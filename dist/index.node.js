(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fhenixjs"] = factory();
	else
		root["fhenixjs"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/extensions/access_control/EIP712.ts":
/*!*************************************************!*\
  !*** ./src/extensions/access_control/EIP712.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/extensions/access_control/index.ts":
/*!************************************************!*\
  !*** ./src/extensions/access_control/index.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./permit */ "./src/extensions/access_control/permit/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./EIP712 */ "./src/extensions/access_control/EIP712.ts"), exports);


/***/ }),

/***/ "./src/extensions/access_control/permit/index.ts":
/*!*******************************************************!*\
  !*** ./src/extensions/access_control/permit/index.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPermitFromLocalstorage = exports.removePermit = exports.generatePermit = exports.getAllPermits = exports.getPermit = void 0;
const utils_1 = __webpack_require__(/*! ../../../sdk/utils */ "./src/sdk/utils.ts");
const types_1 = __webpack_require__(/*! ../../../sdk/types */ "./src/sdk/types.ts");
const sealing_1 = __webpack_require__(/*! ../../../sdk/sealing */ "./src/sdk/sealing.ts");
const PERMIT_PREFIX = "Fhenix_saved_permit_";
const parsePermit = (savedPermit) => {
    const o = JSON.parse(savedPermit);
    if (o) {
        return {
            contractAddress: o.contractAddress,
            sealingKey: new sealing_1.SealingKey(o.sealingKey.privateKey, o.sealingKey.publicKey),
            signature: o.signature,
            publicKey: `0x${o.sealingKey.publicKey}`,
        };
    }
    throw new Error(`Cannot parse permit`);
};
const getPermit = (contract, provider, autoGenerate = true) => __awaiter(void 0, void 0, void 0, function* () {
    (0, utils_1.isAddress)(contract);
    if (!provider) {
        throw new Error(`Missing provider`);
    }
    const getSigner = (0, types_1.determineRequestSigner)(provider);
    const signer = yield getSigner(provider);
    let savedPermit = null;
    if (typeof window !== "undefined" && window.localStorage) {
        savedPermit = window.localStorage.getItem(`${PERMIT_PREFIX}${contract}_${yield signer.getAddress()}`);
        if (!savedPermit) {
            // Backward compatibility
            savedPermit = window.localStorage.getItem(`${PERMIT_PREFIX}${contract}`);
        }
    }
    if (savedPermit) {
        try {
            return parsePermit(savedPermit);
        }
        catch (err) {
            console.warn(err);
        }
    }
    return autoGenerate ? (0, exports.generatePermit)(contract, provider) : null;
});
exports.getPermit = getPermit;
const getAllPermits = () => {
    const permits = new Map();
    for (let i = 0; i < window.localStorage.length; i++) {
        const key = window.localStorage.key(i);
        if (key && key.includes(PERMIT_PREFIX)) {
            const contract = key.replace(PERMIT_PREFIX, "");
            // Not sure if needed, code placeholder:
            // const noPrefixPermit = key.replace(PERMIT_PREFIX, "");
            // let contract = "";
            // if (noPrefixPermit.includes("_")) {
            //   const tmp = noPrefixPermit.split("_");
            //   contract = tmp[0];
            // } else {
            //   contract = noPrefixPermit;
            // }
            try {
                const permit = parsePermit(window.localStorage.getItem(key));
                permits.set(contract, permit);
            }
            catch (err) {
                console.warn(err);
            }
        }
    }
    return permits;
};
exports.getAllPermits = getAllPermits;
const sign = (signer, domain, types, value) => __awaiter(void 0, void 0, void 0, function* () {
    if ("_signTypedData" in signer &&
        typeof signer._signTypedData == "function") {
        return yield signer._signTypedData(domain, types, value);
    }
    else if ("signTypedData" in signer &&
        typeof signer.signTypedData == "function") {
        return yield signer.signTypedData(domain, types, value);
    }
    throw new Error("Unsupported signer");
});
const generatePermit = (contract, provider, customSigner) => __awaiter(void 0, void 0, void 0, function* () {
    if (!provider) {
        throw new Error("Provider is undefined");
    }
    const requestMethod = (0, types_1.determineRequestMethod)(provider);
    let signer;
    if (!customSigner) {
        const getSigner = (0, types_1.determineRequestSigner)(provider);
        signer = yield getSigner(provider);
    }
    else {
        signer = customSigner;
    }
    const chainId = yield requestMethod(provider, "eth_chainId", []);
    const keypair = yield (0, sealing_1.GenerateSealingKey)();
    const msgParams = {
        types: {
            // This refers to the domain the contract is hosted on.
            EIP712Domain: [
                { name: "name", type: "string" },
                { name: "version", type: "string" },
                { name: "chainId", type: "uint256" },
                { name: "verifyingContract", type: "address" },
            ],
            // Refer to primaryType.
            Permissioned: [{ name: "publicKey", type: "bytes32" }],
        },
        // This defines the message you're proposing the user to sign, is dapp-specific, and contains
        // anything you want. There are no required fields. Be as explicit as possible when building out
        // the message schema.
        // This refers to the keys of the following types object.
        primaryType: "Permissioned",
        domain: {
            // Give a user-friendly name to the specific contract you're signing for.
            name: "Fhenix Permission", // params.name
            // This identifies the latest version.
            version: "1.0", //params.version ||
            // This defines the network, in this case, Mainnet.
            chainId: chainId,
            // // Add a verifying contract to make sure you're establishing contracts with the proper entity.
            verifyingContract: contract, //params.verifyingContract,
        },
        message: {
            publicKey: `0x${keypair.publicKey}`,
        },
    };
    const msgSig = yield sign(signer, msgParams.domain, { Permissioned: msgParams.types.Permissioned }, msgParams.message);
    const permit = {
        contractAddress: contract,
        sealingKey: keypair,
        signature: msgSig,
        publicKey: `0x${keypair.publicKey}`,
        //permit: msgParams,
        //msgSig
    };
    if (typeof window !== "undefined" && window.localStorage) {
        // Sealing key is a class, and will include methods in the JSON
        const serialized = {
            contractAddress: permit.contractAddress,
            sealingKey: {
                publicKey: permit.sealingKey.publicKey,
                privateKey: permit.sealingKey.privateKey,
            },
            signature: permit.signature,
        };
        window.localStorage.setItem(`${PERMIT_PREFIX}${contract}_${yield signer.getAddress()}`, JSON.stringify(serialized));
    }
    return permit;
});
exports.generatePermit = generatePermit;
const removePermit = (contract, account) => {
    if (!account) {
        // Backward compatibility
        window.localStorage.removeItem(`${PERMIT_PREFIX}${contract}`);
    }
    else {
        window.localStorage.removeItem(`${PERMIT_PREFIX}${contract}_${account}`);
    }
};
exports.removePermit = removePermit;
const getPermitFromLocalstorage = (contract, account) => {
    let savedPermit = undefined;
    if (typeof window !== "undefined" && window.localStorage) {
        savedPermit = window.localStorage.getItem(`${PERMIT_PREFIX}${contract}_${account}`);
        if (!account) {
            // Backward compatibility
            savedPermit = window.localStorage.getItem(`${PERMIT_PREFIX}${contract}`);
        }
        else {
            savedPermit = window.localStorage.getItem(`${PERMIT_PREFIX}${contract}_${account}`);
        }
    }
    if (!savedPermit) {
        return undefined;
    }
    return parsePermit(savedPermit);
};
exports.getPermitFromLocalstorage = getPermitFromLocalstorage;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// for mobile
// if (typeof BigInt === "undefined") {
//   global.BigInt = require("big-integer");
// }
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateSealingKey = exports.SealingKey = exports.EncryptionTypes = exports.FhenixClient = void 0;
var index_1 = __webpack_require__(/*! ./sdk/index */ "./src/sdk/index.ts");
Object.defineProperty(exports, "FhenixClient", ({ enumerable: true, get: function () { return index_1.FhenixClient; } }));
var types_1 = __webpack_require__(/*! ./sdk/types */ "./src/sdk/types.ts");
Object.defineProperty(exports, "EncryptionTypes", ({ enumerable: true, get: function () { return types_1.EncryptionTypes; } }));
__exportStar(__webpack_require__(/*! ./extensions/access_control */ "./src/extensions/access_control/index.ts"), exports);
var sealing_1 = __webpack_require__(/*! ./sdk/sealing */ "./src/sdk/sealing.ts");
Object.defineProperty(exports, "SealingKey", ({ enumerable: true, get: function () { return sealing_1.SealingKey; } }));
Object.defineProperty(exports, "GenerateSealingKey", ({ enumerable: true, get: function () { return sealing_1.GenerateSealingKey; } }));


/***/ }),

/***/ "./src/sdk/consts.ts":
/*!***************************!*\
  !*** ./src/sdk/consts.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUBLIC_KEY_LENGTH_MIN = exports.FheOpsAddress = exports.MAX_UINT32 = exports.MAX_UINT16 = exports.MAX_UINT8 = void 0;
exports.MAX_UINT8 = 255;
exports.MAX_UINT16 = 65535;
exports.MAX_UINT32 = 4294967295;
exports.FheOpsAddress = "0x0000000000000000000000000000000000000080";
exports.PUBLIC_KEY_LENGTH_MIN = 15000;


/***/ }),

/***/ "./src/sdk/encrypt.ts":
/*!****************************!*\
  !*** ./src/sdk/encrypt.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encrypt = exports.encrypt_address = exports.encrypt_uint256 = exports.encrypt_uint128 = exports.encrypt_uint64 = exports.encrypt_uint32 = exports.encrypt_uint16 = exports.encrypt_uint8 = exports.encrypt_bool = void 0;
const node_tfhe_1 = __webpack_require__(/*! node-tfhe */ "node-tfhe");
const types_1 = __webpack_require__(/*! ./types */ "./src/sdk/types.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/sdk/utils.ts");
/**
 * Encrypts a Uint8 value using TFHE (Fast Fully Homomorphic Encryption over the Torus).
 * @param {boolean} value - The Boolean value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedBool} - The encrypted value serialized as Uint8Array.
 */
const encrypt_bool = (value, publicKey, securityZone = 0) => {
    const encrypted = node_tfhe_1.CompactFheBoolList.encrypt_with_compact_public_key([value], publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_bool = encrypt_bool;
/**
 * Encrypts a Uint8 value using TFHE (Fast Fully Homomorphic Encryption over the Torus).
 * @param {number} value - The Uint8 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint8} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint8 = (value, publicKey, securityZone = 0) => {
    const uint8Array = new Uint8Array([value]);
    const encrypted = node_tfhe_1.CompactFheUint8List.encrypt_with_compact_public_key(uint8Array, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint8 = encrypt_uint8;
/**
 * Encrypts a Uint16 value using TFHE.
 * @param {number} value - The Uint16 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint16} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint16 = (value, publicKey, securityZone = 0) => {
    const uint16Array = new Uint16Array([value]);
    const encrypted = node_tfhe_1.CompactFheUint16List.encrypt_with_compact_public_key(uint16Array, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint16 = encrypt_uint16;
/**
 * Encrypts a Uint32 value using TFHE.
 * @param {number} value - The Uint32 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint32} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint32 = (value, publicKey, securityZone = 0) => {
    const uint32Array = new Uint32Array([value]);
    const encrypted = node_tfhe_1.CompactFheUint32List.encrypt_with_compact_public_key(uint32Array, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint32 = encrypt_uint32;
/**
 * Encrypts a Uint64 value using TFHE.
 * @param {number} value - The Uint64 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint64} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint64 = (value, publicKey, securityZone = 0) => {
    if (typeof value === "string") {
        value = (0, utils_1.toBigInt)((0, utils_1.fromHexString)(value));
    }
    else {
        value = value;
    }
    const uint32Array = new BigUint64Array([value]);
    const encrypted = node_tfhe_1.CompactFheUint64List.encrypt_with_compact_public_key(uint32Array, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint64 = encrypt_uint64;
/**
 * Encrypts a Uint128 value using TFHE.
 * @param {bigint} value - The Uint128 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint128} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint128 = (value, publicKey, securityZone = 0) => {
    if (typeof value === "string") {
        value = (0, utils_1.toBigInt)((0, utils_1.fromHexString)(value));
    }
    else {
        value = value;
    }
    const encrypted = node_tfhe_1.CompactFheUint128.encrypt_with_compact_public_key(value, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint128 = encrypt_uint128;
/**
 * Encrypts a Uint256 value using TFHE.
 * @param {bigint} value - The Uint256 value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {EncryptedUint256} - The encrypted value serialized as Uint8Array.
 */
const encrypt_uint256 = (value, publicKey, securityZone = 0) => {
    if (typeof value === "string") {
        value = (0, utils_1.toBigInt)((0, utils_1.fromHexString)(value));
    }
    else {
        value = value;
    }
    const encrypted = node_tfhe_1.CompactFheUint256.encrypt_with_compact_public_key(value, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_uint256 = encrypt_uint256;
/**
 * Encrypts a Address value using TFHE.
 * @param {bigint} value - The Address (Uint160) value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param securityZone - The security zone to encrypt the address on.
 * @returns {EncryptedAddress} - The encrypted value serialized as Uint8Array.
 */
const encrypt_address = (value, publicKey, securityZone = 0) => {
    if (typeof value === "string") {
        value = (0, utils_1.toBigInt)((0, utils_1.fromHexString)(value));
    }
    else {
        value = value;
    }
    const encrypted = node_tfhe_1.CompactFheUint160.encrypt_with_compact_public_key(value, publicKey);
    return {
        data: encrypted.serialize(),
        securityZone,
    };
};
exports.encrypt_address = encrypt_address;
/**
 * Encrypts a numeric value using TFHE according to the specified encryption type.
 * @param {number} value - The numeric value to encrypt.
 * @param {TfheCompactPublicKey} publicKey - The public key used for encryption.
 * @param {EncryptionTypes} type - The encryption type (uint8, uint16, uint32).
 * @param securityZone - The security zone to encrypt the value on.
 * @returns {Uint8Array} - The encrypted value serialized as Uint8Array.
 * @throws {Error} - Throws an error if an invalid type is specified.
 */
const encrypt = (value, publicKey, type = types_1.EncryptionTypes.uint8, securityZone = 0) => {
    switch (type) {
        case types_1.EncryptionTypes.bool:
            return (0, exports.encrypt_bool)(!!value, publicKey, securityZone);
        case types_1.EncryptionTypes.uint8:
            return (0, exports.encrypt_uint8)(value, publicKey, securityZone);
        case types_1.EncryptionTypes.uint16:
            return (0, exports.encrypt_uint16)(value, publicKey, securityZone);
        case types_1.EncryptionTypes.uint32:
            return (0, exports.encrypt_uint32)(value, publicKey, securityZone);
        case types_1.EncryptionTypes.uint64:
            return (0, exports.encrypt_uint64)(value.toString(16), publicKey, securityZone);
        case types_1.EncryptionTypes.uint128:
            return (0, exports.encrypt_uint128)(value.toString(16), publicKey, securityZone);
        case types_1.EncryptionTypes.uint256:
            return (0, exports.encrypt_uint256)(value.toString(16), publicKey, securityZone);
        case types_1.EncryptionTypes.address:
            return (0, exports.encrypt_address)(value.toString(16), publicKey, securityZone);
        default:
            throw new Error("Invalid type");
    }
};
exports.encrypt = encrypt;


/***/ }),

/***/ "./src/sdk/index.ts":
/*!**************************!*\
  !*** ./src/sdk/index.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FhenixClient = void 0;
const node_tfhe_1 = __webpack_require__(/*! node-tfhe */ "node-tfhe");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/sdk/utils.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/sdk/types.ts");
const access_control_1 = __webpack_require__(/*! ../extensions/access_control */ "./src/extensions/access_control/index.ts");
const consts_1 = __webpack_require__(/*! ./consts */ "./src/sdk/consts.ts");
const tfheEncrypt = __importStar(__webpack_require__(/*! ./encrypt */ "./src/sdk/encrypt.ts"));
const validation_1 = __webpack_require__(/*! ./validation */ "./src/sdk/validation.ts");
/**
 * The FhenixClient class provides functionalities to interact with a FHE (Fully Homomorphic Encryption) system.
 * It includes methods for encryption, unsealing, and managing permits.
 */
class FhenixClient {
    /**
     * Creates an instance of FhenixClient.
     * Initializes the fhevm library if needed and retrieves the public key for encryption from the provider.
     * @param {InstanceParams} params - Parameters to initialize the client.
     */
    constructor(params) {
        this.permits = {};
        this.defaultSecurityZone = 0;
        this.fhePublicKeys = [];
        (0, validation_1.isPlainObject)(params);
        // if (params?.provider === undefined) {
        //   params.provider = new JsonRpcProvider("http://localhost:8545");
        // }
        const { provider, ignoreErrors } = params;
        this.provider = provider;
        // in most cases we will want to init the fhevm library - except if this is used outside of the browser, in which
        // case this should be called with initSdk = false (tests, for instance)
        /////////////////
        this.fhePublicKeys[this.defaultSecurityZone] = FhenixClient.getFheKeyFromProvider(this.provider).catch((err) => {
            if (ignoreErrors) {
                return undefined;
            }
            else {
                throw new Error(`Failed to initialize fhenixjs - is the network FHE-enabled? ${err}`);
            }
        });
        /////////////
        /////////////////////////////////////////////////////////////
        ///////////
        /////////////////////////////////////////////////////
        //////////////////////////
        /////////////////////
        ////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////
        //////////
        ///////
        //////
        ////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////
        ////////
        /////
        //////////////
    }
    // Encryption Methods
    /**
     * Encrypts a Uint8 value using the stored public key.
     * @param {number} value - The Uint8 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedBool} - The encrypted value serialized as EncryptedUint8. Use the .data property to access the Uint8Array.
     */
    encrypt_bool(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const fhePublicKey = yield this._getPublicKey(securityZone);
            return tfheEncrypt.encrypt_bool(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a Uint8 value using the stored public key.
     * @param {number} value - The Uint8 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint8} - The encrypted value serialized as EncryptedUint8. Use the .data property to access the Uint8Array.
     */
    encrypt_uint8(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isNumber)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT8, 0);
            return tfheEncrypt.encrypt_uint8(value, fhePublicKey, securityZone);
        });
    }
    _getPublicKey(securityZone) {
        return __awaiter(this, void 0, void 0, function* () {
            let fhePublicKey = yield this.fhePublicKeys[securityZone];
            if (!fhePublicKey) {
                this.fhePublicKeys[securityZone] = FhenixClient.getFheKeyFromProvider(this.provider, securityZone);
                fhePublicKey = yield this.fhePublicKeys[securityZone];
                if (!fhePublicKey) {
                    throw new Error(`Public key for security zone ${securityZone} somehow not initialized`);
                }
            }
            return fhePublicKey;
        });
    }
    /**
     * Encrypts a Uint16 value using the stored public key.
     * @param {number} value - The Uint16 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint16} - The encrypted value serialized as EncryptedUint16. Use the .data property to access the Uint8Array.
     */
    encrypt_uint16(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isNumber)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT16, 0);
            return tfheEncrypt.encrypt_uint16(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a Uint32 value using the stored public key.
     * @param {number} value - The Uint32 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint32} - The encrypted value serialized as EncryptedUint32. Use the .data property to access the Uint8Array.
     */
    encrypt_uint32(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isNumber)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT32, 0);
            return tfheEncrypt.encrypt_uint32(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a Uint64 value using the stored public key.
     * @param {bigint | string} value - The Uint32 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint64} - The encrypted value serialized as EncryptedUint64. Use the .data property to access the Uint8Array.
     */
    encrypt_uint64(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isBigIntOrHexString)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            // ValidateUintInRange(value, MAX_UINT64, 0);
            return tfheEncrypt.encrypt_uint64(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a Uint128 value using the stored public key.
     * @param {bigint | string} value - The Uint128 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint128} - The encrypted value serialized as EncryptedUint128. Use the .data property to access the Uint8Array.
     */
    encrypt_uint128(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isBigIntOrHexString)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            // ValidateUintInRange(value, MAX_UINT64, 0);
            return tfheEncrypt.encrypt_uint128(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a Uint256 value using the stored public key.
     * @param {bigint | string} value - The Uint256 value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedUint256} - The encrypted value serialized as EncryptedUint256. Use the .data property to access the Uint8Array.
     */
    encrypt_uint256(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isBigIntOrHexString)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            // ValidateUintInRange(value, MAX_UINT64, 0);
            return tfheEncrypt.encrypt_uint256(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts an Address (Uint160) value using the stored public key.
     * @param {bigint | string} value - The Address (Uint160) value to encrypt.
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedAddress} - The encrypted value serialized as EncryptedAddress. Use the .data property to access the Uint8Array.
     */
    encrypt_address(value, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isBigIntOrHexString)(value);
            const fhePublicKey = yield this._getPublicKey(securityZone);
            // ValidateUintInRange(value, MAX_UINT64, 0);
            return tfheEncrypt.encrypt_address(value, fhePublicKey, securityZone);
        });
    }
    /**
     * Encrypts a numeric value according to the specified encryption type or the most efficient one based on the value.
     * @param {number} value - The numeric value to encrypt.
     * @param {EncryptionTypes} type - Optional. The encryption type (uint8, uint16, uint32).
     * @param securityZone - The security zone for which to encrypt the value (default 0).
     * @returns {EncryptedNumber} - The encrypted value serialized as Uint8Array. Use the .data property to access the Uint8Array.
     */
    encrypt(value, type, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.isNumber)(value);
            let outputSize = type;
            const fhePublicKey = yield this._getPublicKey(securityZone);
            // choose the most efficient ciphertext size if not selected
            if (!outputSize) {
                if (value < consts_1.MAX_UINT8) {
                    outputSize = types_1.EncryptionTypes.uint8;
                }
                else if (value < consts_1.MAX_UINT16) {
                    outputSize = types_1.EncryptionTypes.uint16;
                }
                else if (value < consts_1.MAX_UINT32) {
                    outputSize = types_1.EncryptionTypes.uint32;
                }
                else {
                    throw new Error(`Encryption input must be smaller than ${consts_1.MAX_UINT32}`);
                }
            }
            switch (outputSize) {
                case types_1.EncryptionTypes.uint8:
                    (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT8, 0);
                    break;
                case types_1.EncryptionTypes.uint16:
                    (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT16, 0);
                    break;
                case types_1.EncryptionTypes.uint32:
                    (0, utils_1.ValidateUintInRange)(value, consts_1.MAX_UINT32, 0);
                    break;
                default:
            }
            return tfheEncrypt.encrypt(value, fhePublicKey, type, securityZone);
        });
    }
    // Unsealing Method
    /**
     * Unseals an encrypted message using the stored permit for a specific contract address.
     * @param {string} contractAddress - The address of the contract.
     * @param {string} ciphertext - The encrypted message to unseal.
     * @returns bigint - The unsealed message.
     */
    unseal(contractAddress, ciphertext) {
        (0, utils_1.isAddress)(contractAddress);
        (0, validation_1.isString)(ciphertext);
        if (!this.hasPermit(contractAddress)) {
            throw new Error(`Missing keypair for ${contractAddress}`);
        }
        return this.permits[contractAddress].sealingKey.unseal(ciphertext);
    }
    // Permit Management Methods
    /**
     * Creates a new permit for a specific contract address. Also saves the permit to localstorage (if available)
     * @param {string} contractAddress - The address of the contract.
     * @param {SupportedProvider} provider - The provider from which to sign the permit - must container a signer.
     * @param signer - the signer to use to sign the permit if provider does not support signing (e.g. hardhat)
     * @returns Permit - The permit associated with the contract address.
     *
     * @throws {Error} - If the provider does not contain a signer, or if a provider is not set
     */
    generatePermit(contractAddress, provider, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!provider && this.provider === undefined) {
                throw new Error("error getting provider");
            }
            const permit = yield (0, access_control_1.generatePermit)(contractAddress, provider || this.provider, signer);
            this.storePermit(permit);
            return permit;
        });
    }
    /**
     * Retrieves the stored permit for a specific contract address.
     * @param {string} contractAddress - The address of the contract.
     * @param {string} account - The address of the user account.
     * @returns {Permit} - The permit associated with the contract address.
     */
    getPermit(contractAddress, account) {
        const fromLs = (0, access_control_1.getPermitFromLocalstorage)(contractAddress, account);
        if (fromLs) {
            this.permits[contractAddress] = fromLs;
            return fromLs;
        }
        if (!this.hasPermit(contractAddress)) {
            return undefined;
        }
        return this.permits[contractAddress];
    }
    /**
     * Stores a permit for a specific contract address. Will overwrite any existing permit for the same contract address.
     * Does not store the permit in localstorage (should it?)
     * @param {Permit} permit - The permit to store.
     */
    storePermit(permit) {
        this.permits[permit.contractAddress] = permit;
    }
    /**
     * Removes a stored permit for a specific contract address.
     * @param {string} contractAddress - The address of the contract.
     */
    removePermit(contractAddress) {
        if (this.hasPermit(contractAddress)) {
            delete this.permits[contractAddress];
        }
    }
    /**
     * Checks if a permit exists for a specific contract address.
     * @param {string} contractAddress - The address of the contract.
     * @returns {boolean} - True if a permit exists, false otherwise.
     */
    hasPermit(contractAddress) {
        return this.permits[contractAddress] !== null;
    }
    /**
     * Exports all stored permits.
     * @returns {ContractPermits} - All stored permits.
     */
    exportPermits() {
        return this.permits;
    }
    extractPermitPermission(permit) {
        return {
            signature: permit.signature,
            publicKey: permit.publicKey,
        };
    }
    // Private helper methods
    /**
     * Retrieves the FHE public key from the provider.
     * @param {SupportedProvider} provider - The provider from which to retrieve the key.
     * @param securityZone - The security zone for which to retrieve the key (default 0).
     * @returns {Promise<TfheCompactPublicKey>} - The retrieved public key.
     */
    static getFheKeyFromProvider(provider, securityZone = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestMethod = (0, types_1.determineRequestMethod)(provider);
            const chainIdP = requestMethod(provider, "eth_chainId").catch((err) => {
                throw Error(`Error while requesting chainId from provider: ${err}`);
            });
            const funcSig = "0x1b1b484e"; // cast sig "getNetworkPublicKey(int32)"
            const callData = funcSig + (0, utils_1.toABIEncodedUint32)(securityZone);
            const callParams = [{ to: consts_1.FheOpsAddress, data: callData }, "latest"];
            const publicKeyP = requestMethod(provider, "eth_call", callParams).catch((err) => {
                throw Error(`Error while requesting network public key from provider for security zone ${securityZone}: ${JSON.stringify(err)}`);
            });
            const [chainId, publicKey] = yield Promise.all([chainIdP, publicKeyP]);
            const chainIdNum = parseInt(chainId, 16);
            if (isNaN(chainIdNum)) {
                throw new Error(`received non-hex number from chainId request: "${chainId}"`);
            }
            if (typeof publicKey !== "string") {
                throw new Error("Error using publicKey from provider: expected string");
            }
            if (publicKey.length < consts_1.PUBLIC_KEY_LENGTH_MIN) {
                throw new Error(`Error initializing fhenixjs; got shorter than expected public key: ${publicKey.length}`);
            }
            const buff = (0, utils_1.fromHexString)(publicKey.slice(130));
            try {
                return node_tfhe_1.TfheCompactPublicKey.deserialize(buff);
            }
            catch (err) {
                throw new Error(`Error deserializing public key: did you initialize fhenix.js with "initFhevm()"? ${err}`);
            }
        });
    }
}
exports.FhenixClient = FhenixClient;


/***/ }),

/***/ "./src/sdk/sealing.ts":
/*!****************************!*\
  !*** ./src/sdk/sealing.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateSealingKey = exports.SealingKey = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "./src/sdk/utils.ts");
const nacl = __importStar(__webpack_require__(/*! tweetnacl */ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"));
const naclUtil = __importStar(__webpack_require__(/*! tweetnacl-util */ "./node_modules/.pnpm/tweetnacl-util@0.15.1/node_modules/tweetnacl-util/nacl-util.js"));
const validation_1 = __webpack_require__(/*! ./validation */ "./src/sdk/validation.ts");
const PRIVATE_KEY_LENGTH = 64;
const PUBLIC_KEY_LENGTH = 64;
/**
 * A class representing a SealingKey which provides cryptographic sealing (encryption)
 * and unsealing (decryption) capabilities.
 */
class SealingKey {
    /**
     * Constructs a SealingKey instance with the given private and public keys.
     *
     * @param {string} privateKey - The private key used for decryption.
     * @param {string} publicKey - The public key used for encryption.
     * @throws Will throw an error if the provided keys lengths do not match
     *         the required lengths for private and public keys.
     */
    constructor(privateKey, publicKey) {
        /**
         * Unseals (decrypts) the provided ciphertext using the instance's private key.
         *
         * @param {string | Uint8Array} ciphertext - The encrypted data to be decrypted.
         * @returns BigInt - The decrypted message as a bigint.
         * @throws Will throw an error if the decryption process fails.
         */
        this.unseal = (ciphertext) => {
            let parsedData = undefined;
            try {
                if (typeof ciphertext === "string") {
                    parsedData = JSON.parse(ciphertext);
                }
            }
            catch (_a) {
                // ignore errors
            }
            if (!parsedData) {
                const toDecrypt = typeof ciphertext === "string" ? (0, utils_1.fromHexString)(ciphertext) : ciphertext;
                // decode json structure that gets returned from the chain
                const jsonString = Buffer.from(toDecrypt).toString("utf8");
                parsedData = JSON.parse(jsonString);
            }
            if (!parsedData) {
                throw new Error("Failed to parse sealed data");
            }
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(parsedData.nonce);
            const ephemPublicKey = naclUtil.decodeBase64(parsedData.ephemPublicKey);
            const dataToDecrypt = naclUtil.decodeBase64(parsedData.ciphertext);
            // call the nacl box function to decrypt the data
            const decryptedMessage = nacl.box.open(dataToDecrypt, nonce, ephemPublicKey, (0, utils_1.fromHexString)(this.privateKey));
            if (!decryptedMessage) {
                throw new Error("Failed to decrypt message");
            }
            return (0, utils_1.toBigInt)(decryptedMessage);
        };
        if (privateKey.length !== PRIVATE_KEY_LENGTH) {
            throw new Error(`Private key must be of length ${PRIVATE_KEY_LENGTH}`);
        }
        if (publicKey.length !== PUBLIC_KEY_LENGTH) {
            throw new Error(`Private key must be of length ${PUBLIC_KEY_LENGTH}`);
        }
        this.privateKey = privateKey;
        this.publicKey = publicKey;
    }
}
exports.SealingKey = SealingKey;
/**
 * Seals (encrypts) the provided message for a receiver with the specified public key.
 *
 * @param {bigint | number} value - The message to be encrypted.
 * @param {string} publicKey - The public key of the intended recipient.
 * @returns string - The encrypted message in hexadecimal format.
 * @static
 * @throws Will throw if the provided publicKey or value do not meet defined preconditions.
 */
SealingKey.seal = (value, publicKey) => {
    (0, validation_1.isString)(publicKey);
    (0, validation_1.isBigIntOrNumber)(value);
    // generate ephemeral keypair
    const ephemeralKeyPair = nacl.box.keyPair();
    const nonce = nacl.randomBytes(nacl.box.nonceLength);
    const encryptedMessage = nacl.box((0, utils_1.toBeArray)(value), nonce, (0, utils_1.fromHexString)(publicKey), ephemeralKeyPair.secretKey);
    // handle encrypted data
    const output = {
        version: "x25519-xsalsa20-poly1305",
        nonce: naclUtil.encodeBase64(nonce),
        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
        ciphertext: naclUtil.encodeBase64(encryptedMessage),
    };
    // mimicking encoding from the chain
    return (0, utils_1.toHexString)(Buffer.from(JSON.stringify(output)));
};
/**
 * Asynchronously generates a new SealingKey.
 * This function uses the 'nacl' library to create a new public/private key pair for sealing purposes.
 * A sealing key is used to encrypt data such that it can only be unsealed (decrypted) by the owner of the corresponding private key.
 * @returns {Promise<SealingKey>} - A promise that resolves to a new SealingKey object containing the hexadecimal strings of the public and private keys.
 */
const GenerateSealingKey = () => __awaiter(void 0, void 0, void 0, function* () {
    const sodiumKeypair = nacl.box.keyPair();
    return new SealingKey((0, utils_1.toHexString)(sodiumKeypair.secretKey), (0, utils_1.toHexString)(sodiumKeypair.publicKey));
});
exports.GenerateSealingKey = GenerateSealingKey;


/***/ }),

/***/ "./src/sdk/types.ts":
/*!**************************!*\
  !*** ./src/sdk/types.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.determineRequestSigner = exports.determineRequestMethod = exports.EncryptionTypes = void 0;
/**
 * An enumeration of supported encryption types.
 * uint8, uint16, and uint32 represent the different sizes of integers that can be encrypted.
 */
var EncryptionTypes;
(function (EncryptionTypes) {
    EncryptionTypes["bool"] = "bool";
    EncryptionTypes["uint8"] = "uint8";
    EncryptionTypes["uint16"] = "uint16";
    EncryptionTypes["uint32"] = "uint32";
    EncryptionTypes["uint64"] = "uint64";
    EncryptionTypes["uint128"] = "uint128";
    EncryptionTypes["uint256"] = "uint256";
    EncryptionTypes["address"] = "address";
})(EncryptionTypes || (exports.EncryptionTypes = EncryptionTypes = {}));
/**
 * Determines the request method for a given provider.
 * Checks if the provider has a 'request' method typical for Eip1193Providers, or a 'send' method for others.
 * Throws an error if neither method is found.
 * @param {SupportedProvider} provider - The provider to determine the request method for.
 * @returns {Function} - The determined request function.
 */
// eslint-disable-next-line  @typescript-eslint/ban-types
function determineRequestMethod(provider) {
    // unify provider interface: eip-1193-compatible providers such as metamask's expose "request",
    // while ethers' and hardhat's may expose a slightly different "send", to issue RPC calls.
    // eslint-disable-next-line  @typescript-eslint/ban-types
    if ("request" in provider && typeof provider.request == "function") {
        // eslint-disable-next-line  @typescript-eslint/no-explicit-any
        return (p, method, params) => p.request({ method, params });
    }
    else if ("send" in provider && typeof provider.send == "function") {
        // eslint-disable-next-line  @typescript-eslint/no-explicit-any
        return (p, method, params) => p.send(method, params);
    }
    else {
        throw new Error("Received unsupported provider. 'send' or 'request' method not found");
    }
}
exports.determineRequestMethod = determineRequestMethod;
/**
 * Determines the request signer function for a given provider.
 * Checks if the provider has a 'getSigner' method and returns it if available.
 * Throws an error if no 'getSigner' method is found.
 * @param {SupportedProvider} provider - The provider to determine the request signer for.
 * @returns {Function} - The determined request signer function.
 */
// eslint-disable-next-line  @typescript-eslint/ban-types
function determineRequestSigner(provider) {
    if ("getSigner" in provider && typeof provider.getSigner == "function") {
        return (p) => p.getSigner();
    }
    else {
        throw new Error("The supplied provider cannot get a signer");
    }
}
exports.determineRequestSigner = determineRequestSigner;


/***/ }),

/***/ "./src/sdk/utils.ts":
/*!**************************!*\
  !*** ./src/sdk/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toABIEncodedUint32 = exports.isAddress = exports.toBeArray = exports.toBigInt = exports.bytesToNumber = exports.numberToBytes = exports.toHexString = exports.fromHexString = exports.ValidateUintInRange = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const ethers_1 = __webpack_require__(/*! ethers */ "../node_modules/ethers/lib.commonjs/index.js");
const validation_1 = __webpack_require__(/*! ./validation */ "./src/sdk/validation.ts");
const ValidateUintInRange = (value, max, min) => {
    (0, validation_1.isNumber)(value);
    if (value > max || value < min) {
        throw new Error(`Value out of range: ${max} - ${min}, try a different uint type`);
    }
};
exports.ValidateUintInRange = ValidateUintInRange;
const fromHexString = (hexString) => {
    const cleanString = hexString.length % 2 === 1 ? `0${hexString}` : hexString;
    const arr = cleanString.replace(/^0x/, "").match(/.{1,2}/g);
    if (!arr)
        return new Uint8Array();
    return new Uint8Array(arr.map((byte) => parseInt(byte, 16)));
};
exports.fromHexString = fromHexString;
const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
exports.toHexString = toHexString;
const numberToBytes = (uint32Value) => {
    const byteArrayLength = Math.ceil(Math.log2(uint32Value + 1) / 8);
    const byteArray = new Uint8Array(byteArrayLength);
    for (let i = byteArrayLength - 1; i >= 0; i--) {
        byteArray[i] = uint32Value & 0xff;
        uint32Value >>= 8;
    }
    return byteArray;
};
exports.numberToBytes = numberToBytes;
const bytesToNumber = function (byteArray) {
    if (!byteArray || (byteArray === null || byteArray === void 0 ? void 0 : byteArray.length) === 0) {
        return 0;
    }
    const length = byteArray.length;
    const buffer = buffer_1.Buffer.from(byteArray);
    const result = buffer.readUIntBE(0, length);
    return result;
};
exports.bytesToNumber = bytesToNumber;
function toBigInt(value) {
    return (0, ethers_1.toBigInt)(value);
}
exports.toBigInt = toBigInt;
function toBeArray(value) {
    return (0, ethers_1.toBeArray)(value);
}
exports.toBeArray = toBeArray;
function isAddress(address) {
    if (!(0, ethers_1.isAddress)(address)) {
        throw new Error(`Address ${address} is not valid EVM address`);
    }
}
exports.isAddress = isAddress;
function toABIEncodedUint32(value) {
    // Ensure the number is a valid unsigned 32-bit integer
    if (value < 0 || value > 0xFFFFFFFF) {
        throw new RangeError('Number must be between 0 and 2^32 - 1.');
    }
    // Convert the number to a hexadecimal string and pad it to 64 characters (32 bytes)
    return value.toString(16).padStart(64, '0');
}
exports.toABIEncodedUint32 = toABIEncodedUint32;


/***/ }),

/***/ "./src/sdk/validation.ts":
/*!*******************************!*\
  !*** ./src/sdk/validation.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBigIntOrNumber = exports.isNumber = exports.isBigIntOrHexString = exports.isPlainObject = exports.isString = void 0;
function assertIs(is, expected, value) {
    if (!is) {
        throw new Error(`Expected value which is \`${expected}\`, received value of type \`${typeof value}\`.`);
    }
}
function isString(value) {
    const is = typeof value === "string";
    assertIs(is, "string", value);
}
exports.isString = isString;
function isPlainObject(value) {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (typeof value !== "object" || value === null) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const prototype = Object.getPrototypeOf(value);
    const is = (prototype === null ||
        prototype === Object.prototype ||
        Object.getPrototypeOf(prototype) === null) &&
        !(Symbol.toStringTag in value) &&
        !(Symbol.iterator in value);
    assertIs(is, "plain object", value);
}
exports.isPlainObject = isPlainObject;
function isBigIntOrHexString(value) {
    const is = typeof value === "bigint" || typeof value === "string";
    assertIs(is, "bigint or hex string", value);
}
exports.isBigIntOrHexString = isBigIntOrHexString;
function isNumber(value) {
    const is = typeof value === "number" && !Number.isNaN(value);
    assertIs(is, "number", value);
}
exports.isNumber = isNumber;
function isBigIntOrNumber(value) {
    const is = typeof value === "bigint";
    if (!is) {
        try {
            isNumber(value);
        }
        catch (e) {
            throw new Error(`Value ${value} is not a number or bigint: ${typeof value}`);
        }
    }
}
exports.isBigIntOrNumber = isBigIntOrNumber;


/***/ }),

/***/ "./node_modules/.pnpm/tweetnacl-util@0.15.1/node_modules/tweetnacl-util/nacl-util.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/tweetnacl-util@0.15.1/node_modules/tweetnacl-util/nacl-util.js ***!
  \*******************************************************************************************/
/***/ (function(module) {

// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
(function(root, f) {
  'use strict';
  if ( true && module.exports) module.exports = f();
  else if (root.nacl) root.nacl.util = f();
  else {
    root.nacl = {};
    root.nacl.util = f();
  }
}(this, function() {
  'use strict';

  var util = {};

  function validateBase64(s) {
    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
      throw new TypeError('invalid encoding');
    }
  }

  util.decodeUTF8 = function(s) {
    if (typeof s !== 'string') throw new TypeError('expected string');
    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
    return b;
  };

  util.encodeUTF8 = function(arr) {
    var i, s = [];
    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
    return decodeURIComponent(escape(s.join('')));
  };

  if (typeof atob === 'undefined') {
    // Node.js

    if (typeof Buffer.from !== 'undefined') {
       // Node v6 and later
      util.encodeBase64 = function (arr) { // v6 and later
          return Buffer.from(arr).toString('base64');
      };

      util.decodeBase64 = function (s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
      };

    } else {
      // Node earlier than v6
      util.encodeBase64 = function (arr) { // v6 and later
        return (new Buffer(arr)).toString('base64');
      };

      util.decodeBase64 = function(s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
      };
    }

  } else {
    // Browsers

    util.encodeBase64 = function(arr) {
      var i, s = [], len = arr.length;
      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
      return btoa(s.join(''));
    };

    util.decodeBase64 = function(s) {
      validateBase64(s);
      var i, d = atob(s), b = new Uint8Array(d.length);
      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
      return b;
    };

  }

  return util;

}));


/***/ }),

/***/ "./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "crypto");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "../node_modules/@noble/curves/_shortw_utils.js":
/*!******************************************************!*\
  !*** ../node_modules/@noble/curves/_shortw_utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "../node_modules/@noble/hashes/hmac.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "../node_modules/@noble/hashes/utils.js");
const weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "../node_modules/@noble/curves/abstract/weierstrass.js");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
exports.createCurve = createCurve;
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/abstract/curve.js":
/*!*******************************************************!*\
  !*** ../node_modules/@noble/curves/abstract/curve.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = __webpack_require__(/*! ./modular.js */ "../node_modules/@noble/curves/abstract/modular.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
exports.validateBasic = validateBasic;
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!***************************************************************!*\
  !*** ../node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
const modular_js_1 = __webpack_require__(/*! ./modular.js */ "../node_modules/@noble/curves/abstract/modular.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
function validateDST(dst) {
    if (dst instanceof Uint8Array)
        return dst;
    if (typeof dst === 'string')
        return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function isBytes(item) {
    if (!(item instanceof Uint8Array))
        throw new Error('Uint8Array expected');
}
function isNum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
exports.createHasher = createHasher;
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/abstract/modular.js":
/*!*********************************************************!*\
  !*** ../node_modules/@noble/curves/abstract/modular.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ≡ 1    if a is a square (mod p)
    // (a | p) ≡ -1   if a is not a square (mod p)
    // (a | p) ≡ 0    if a ≡ 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ≡ 3 (mod 4)
    // √n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P ≡ 9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/abstract/utils.js":
/*!*******************************************************!*\
  !*** ../node_modules/@noble/curves/abstract/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length)
        return false;
    for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
            return false;
    return true;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n : _0n) << BigInt(pos));
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/abstract/weierstrass.js":
/*!*************************************************************!*\
  !*** ../node_modules/@noble/curves/abstract/weierstrass.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y² = x³ + ax + b
const mod = __webpack_require__(/*! ./modular.js */ "../node_modules/@noble/curves/abstract/modular.js");
const ut = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
const curve_js_1 = __webpack_require__(/*! ./curve.js */ "../node_modules/@noble/curves/abstract/curve.js");
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula
     * @returns y²
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (key instanceof Uint8Array)
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y²
            const right = weierstrassEquation(x); // x³ + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1⋅G - U2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || sg instanceof Uint8Array) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ "../node_modules/@noble/curves/secp256k1.js":
/*!**************************************************!*\
  !*** ../node_modules/@noble/curves/secp256k1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "../node_modules/@noble/hashes/sha256.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "../node_modules/@noble/hashes/utils.js");
const modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ "../node_modules/@noble/curves/abstract/modular.js");
const weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "../node_modules/@noble/curves/abstract/weierstrass.js");
const utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ "../node_modules/@noble/curves/abstract/utils.js");
const hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "../node_modules/@noble/curves/abstract/hash-to-curve.js");
const _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ "../node_modules/@noble/curves/_shortw_utils.js");
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!fe(r))
            return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!ge(s))
            return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod,
    },
}))();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/_assert.js":
/*!************************************************!*\
  !*** ../node_modules/@noble/hashes/_assert.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports["default"] = assert;
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/_sha2.js":
/*!**********************************************!*\
  !*** ../node_modules/@noble/hashes/_sha2.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA2 = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../node_modules/@noble/hashes/_assert.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;
//# sourceMappingURL=_sha2.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/_u64.js":
/*!*********************************************!*\
  !*** ../node_modules/@noble/hashes/_u64.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/cryptoNode.js":
/*!***************************************************!*\
  !*** ../node_modules/@noble/hashes/cryptoNode.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// See utils.ts for details.
// The file will throw on node.js 14 and earlier.
// @ts-ignore
const nc = __webpack_require__(/*! node:crypto */ "node:crypto");
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/hmac.js":
/*!*********************************************!*\
  !*** ../node_modules/@noble/hashes/hmac.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../node_modules/@noble/hashes/_assert.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/pbkdf2.js":
/*!***********************************************!*\
  !*** ../node_modules/@noble/hashes/pbkdf2.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../node_modules/@noble/hashes/_assert.js");
const hmac_js_1 = __webpack_require__(/*! ./hmac.js */ "../node_modules/@noble/hashes/hmac.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assert_js_1.hash)(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, _assert_js_1.number)(c);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/ripemd160.js":
/*!**************************************************!*\
  !*** ../node_modules/@noble/hashes/ripemd160.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "../node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/scrypt.js":
/*!***********************************************!*\
  !*** ../node_modules/@noble/hashes/scrypt.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scryptAsync = exports.scrypt = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../node_modules/@noble/hashes/_assert.js");
const sha256_js_1 = __webpack_require__(/*! ./sha256.js */ "../node_modules/@noble/hashes/sha256.js");
const pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ "../node_modules/@noble/hashes/pbkdf2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// RFC 7914 Scrypt KDF
// Left rotate for uint32
const rotl = (a, b) => (a << b) | (a >>> (32 - b));
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    // Main loop (salsa)
    for (let i = 0; i < 8; i += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = (y00 + x00) | 0;
    out[oi++] = (y01 + x01) | 0;
    out[oi++] = (y02 + x02) | 0;
    out[oi++] = (y03 + x03) | 0;
    out[oi++] = (y04 + x04) | 0;
    out[oi++] = (y05 + x05) | 0;
    out[oi++] = (y06 + x06) | 0;
    out[oi++] = (y07 + x07) | 0;
    out[oi++] = (y08 + x08) | 0;
    out[oi++] = (y09 + x09) | 0;
    out[oi++] = (y10 + x10) | 0;
    out[oi++] = (y11 + x11) | 0;
    out[oi++] = (y12 + x12) | 0;
    out[oi++] = (y13 + x13) | 0;
    out[oi++] = (y14 + x14) | 0;
    out[oi++] = (y15 + x15) | 0;
}
function BlockMix(input, ii, out, oi, r) {
    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
        if (i > 0)
            tail += 16; // First iteration overwrites tmp value in tail
        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
    }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
    // Maxmem - 1GB+1KB by default
    const opts = (0, utils_js_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024,
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    (0, _assert_js_1.number)(N);
    (0, _assert_js_1.number)(r);
    (0, _assert_js_1.number)(p);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    (0, _assert_js_1.number)(maxmem);
    if (onProgress !== undefined && typeof onProgress !== 'function')
        throw new Error('progressCb should be function');
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
    }
    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {
        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
    // Since it has only one iteration there is no reason to use async variant
    const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = (0, utils_js_1.u32)(B);
    // Re-used between parallel iterations. Array(iterations) of B
    const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));
    const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
    let blockMixCb = () => { };
    if (onProgress) {
        const totalBlockMix = 2 * N * p;
        // Invoke callback if progress changes from 10.01 to 10.02
        // Allows to draw smooth progress bar on up to 8K screen
        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
            blockMixCnt++;
            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
                onProgress(blockMixCnt / totalBlockMix);
        };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
    const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
}
/**
 * Scrypt KDF from RFC 7914.
 * @param password - pass
 * @param salt - salt
 * @param opts - parameters
 * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
 * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
 * - `p` is parallelization factor (1 is common)
 * - `dkLen` is output key length in bytes e.g. 32.
 * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
 * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
 * - `onProgress` - callback function that would be executed for progress report
 * @returns Derived key
 */
function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++)
            V[i] = B32[Pi + i]; // V[0] = B[i]
        for (let i = 0, pos = 0; i < N - 1; i++) {
            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        }
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        for (let i = 0; i < N; i++) {
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}
exports.scrypt = scrypt;
/**
 * Scrypt KDF from RFC 7914.
 */
async function scryptAsync(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++)
            V[i] = B32[Pi + i]; // V[0] = B[i]
        let pos = 0;
        await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, () => {
            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        });
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        await (0, utils_js_1.asyncLoop)(N, asyncTick, () => {
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        });
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}
exports.scryptAsync = scryptAsync;
//# sourceMappingURL=scrypt.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/sha256.js":
/*!***********************************************!*\
  !*** ../node_modules/@noble/hashes/sha256.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "../node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/sha3.js":
/*!*********************************************!*\
  !*** ../node_modules/@noble/hashes/sha3.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../node_modules/@noble/hashes/_assert.js");
const _u64_js_1 = __webpack_require__(/*! ./_u64.js */ "../node_modules/@noble/hashes/_u64.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/@noble/hashes/utils.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);
//# sourceMappingURL=sha3.js.map

/***/ }),

/***/ "../node_modules/@noble/hashes/utils.js":
/*!**********************************************!*\
  !*** ../node_modules/@noble/hashes/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "../node_modules/@noble/hashes/cryptoNode.js");
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/tslib/tslib.es6.js":
/*!******************************************!*\
  !*** ../node_modules/tslib/tslib.es6.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ "../node_modules/ws/index.js":
/*!***********************************!*\
  !*** ../node_modules/ws/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "../node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "../node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "../node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "../node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "../node_modules/ws/lib/sender.js");

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ "../node_modules/ws/lib/buffer-util.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/buffer-util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(/*! bufferutil */ "bufferutil");

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ "../node_modules/ws/lib/constants.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/constants.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "../node_modules/ws/lib/event-target.js":
/*!**********************************************!*\
  !*** ../node_modules/ws/lib/event-target.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options = {}) {
    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = listener;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};


/***/ }),

/***/ "../node_modules/ws/lib/extension.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/extension.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "../node_modules/ws/lib/limiter.js":
/*!*****************************************!*\
  !*** ../node_modules/ws/lib/limiter.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "../node_modules/ws/lib/permessage-deflate.js":
/*!****************************************************!*\
  !*** ../node_modules/ws/lib/permessage-deflate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "../node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "../node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "../node_modules/ws/lib/receiver.js":
/*!******************************************!*\
  !*** ../node_modules/ws/lib/receiver.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "../node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "../node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );
      }

      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      }
    } else {
      this._loop = false;
      return error(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
            )
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data, true);
      } else {
        const buf = concat(fragments, messageLength);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('message', buf, false);
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else if (data.length === 1) {
        return error(
          RangeError,
          'invalid payload length 1',
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );
        }

        const buf = data.slice(2);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('conclude', code, buf);
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "../node_modules/ws/lib/sender.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/sender.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */



const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "../node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "../node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "../node_modules/ws/lib/stream.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/stream.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "../node_modules/ws/lib/subprotocol.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/subprotocol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "../node_modules/ws/lib/validation.js":
/*!********************************************!*\
  !*** ../node_modules/ws/lib/validation.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "utf-8-validate");

  module.exports = {
    isValidStatusCode,
    isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    },
    tokenChars
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
}


/***/ }),

/***/ "../node_modules/ws/lib/websocket-server.js":
/*!**************************************************!*\
  !*** ../node_modules/ws/lib/websocket-server.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");

const extension = __webpack_require__(/*! ./extension */ "../node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "../node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "../node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key']
        : false;
    const version = +req.headers['sec-websocket-version'];

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ "../node_modules/ws/lib/websocket.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/websocket.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { Readable } = __webpack_require__(/*! stream */ "stream");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "../node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "../node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "../node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "../node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "../node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "../node_modules/ws/lib/buffer-util.js");

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }

    websocket._url = address;
  }

  const isSecure = parsedUrl.protocol === 'wss:';
  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';
  let invalidURLMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {
    invalidURLMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
  } else if (isUnixSocket && !parsedUrl.pathname) {
    invalidURLMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidURLMessage = 'The URL contains a fragment identifier';
  }

  if (invalidURLMessage) {
    const err = new SyntaxError(invalidURLMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalHost = parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (parsedUrl.host !== websocket._originalHost) {
      //
      // Match curl 7.77.0 behavior and drop the following headers. These
      // headers are also dropped when following a redirect to a subdomain.
      //
      delete opts.headers.authorization;
      delete opts.headers.cookie;
      delete opts.headers.host;
      opts.auth = undefined;
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
}

/**
 * Emit the `'error'` and `'close'` event.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ "node-tfhe":
/*!****************************!*\
  !*** external "node-tfhe" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-tfhe");

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../node_modules/@adraffy/ens-normalize/dist/index.cjs":
/*!*************************************************************!*\
  !*** ../node_modules/@adraffy/ens-normalize/dist/index.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-ens data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32
var COMPRESSED$1 = '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';
const FENCED = new Map([[8217,"apostrophe"],[8260,"fraction slash"],[12539,"middle dot"]]);
const NSM_MAX = 4;

function decode_arithmetic(bytes) {
	let pos = 0;
	function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
	
	// decode the frequency table
	let symbol_count = u16();
	let total = 1;
	let acc = [0, 1]; // first symbol has frequency 1
	for (let i = 1; i < symbol_count; i++) {
		acc.push(total += u16());
	}

	// skip the sized-payload that the last 3 symbols index into
	let skip = u16();
	let pos_payload = pos;
	pos += skip;

	let read_width = 0;
	let read_buffer = 0; 
	function read_bit() {
		if (read_width == 0) {
			// this will read beyond end of buffer
			// but (undefined|0) => zero pad
			read_buffer = (read_buffer << 8) | bytes[pos++];
			read_width = 8;
		}
		return (read_buffer >> --read_width) & 1;
	}

	const N = 31;
	const FULL = 2**N;
	const HALF = FULL >>> 1;
	const QRTR = HALF >> 1;
	const MASK = FULL - 1;

	// fill register
	let register = 0;
	for (let i = 0; i < N; i++) register = (register << 1) | read_bit();

	let symbols = [];
	let low = 0;
	let range = FULL; // treat like a float
	while (true) {
		let value = Math.floor((((register - low + 1) * total) - 1) / range);
		let start = 0;
		let end = symbol_count;
		while (end - start > 1) { // binary search
			let mid = (start + end) >>> 1;
			if (value < acc[mid]) {
				end = mid;
			} else {
				start = mid;
			}
		}
		if (start == 0) break; // first symbol is end mark
		symbols.push(start);
		let a = low + Math.floor(range * acc[start]   / total);
		let b = low + Math.floor(range * acc[start+1] / total) - 1;
		while (((a ^ b) & HALF) == 0) {
			register = (register << 1) & MASK | read_bit();
			a = (a << 1) & MASK;
			b = (b << 1) & MASK | 1;
		}
		while (a & ~b & QRTR) {
			register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
			a = (a << 1) ^ HALF;
			b = ((b ^ HALF) << 1) | HALF | 1;
		}
		low = a;
		range = 1 + b - a;
	}
	let offset = symbol_count - 4;
	return symbols.map(x => { // index into payload
		switch (x - offset) {
			case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 1: return offset + bytes[pos_payload++];
			default: return x - 1;
		}
	});
}	

// returns an iterator which returns the next symbol
function read_payload(v) {
	let pos = 0;
	return () => v[pos++];
}
function read_compressed_payload(s) {
	return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
function unsafe_atob(s) {
	let lookup = [];
	[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
	let n = s.length;
	let ret = new Uint8Array((6 * n) >> 3);
	for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
		carry = (carry << 6) | lookup[s.charCodeAt(i)];
		width += 6;
		if (width >= 8) {
			ret[pos++] = (carry >> (width -= 8));
		}
	}
	return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) { 
	return (i & 1) ? (~i >> 1) : (i >> 1);
}

function read_deltas(n, next) {
	let v = Array(n);
	for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
	return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next, prev = 0) {
	let ret = [];
	while (true) {
		let x = next();
		let n = next();
		if (!n) break;
		prev += x;
		for (let i = 0; i < n; i++) {
			ret.push(prev + i);
		}
		prev += n + 1;
	}
	return ret;
}

function read_sorted_arrays(next) {
	return read_array_while(() => { 
		let v = read_sorted(next);
		if (v.length) return v;
	});
}

// returns map of x => ys
function read_mapped(next) {
	let ret = [];
	while (true) {
		let w = next();
		if (w == 0) break;
		ret.push(read_linear_table(w, next));
	}
	while (true) {
		let w = next() - 1;
		if (w < 0) break;
		ret.push(read_replacement_table(w, next));
	}
	return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
	let v = [];
	while (true) {
		let x = next(v.length);
		if (!x) break;
		v.push(x);
	}
	return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
	let m = Array(n).fill().map(() => []);
	for (let i = 0; i < w; i++) {
		read_deltas(n, next).forEach((x, j) => m[j].push(x));
	}
	return m;
}
 
// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
	let dx = 1 + next();
	let dy = next();
	let vN = read_array_while(next);
	let m = read_transposed(vN.length, 1+w, next);
	return m.flatMap((v, i) => {
		let [x, ...ys] = v;
		return Array(vN[i]).fill().map((_, j) => {
			let j_dy = j * dy;
			return [x + j * dx, ys.map(y => y + j_dy)];
		});
	});
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) { 
	let n = 1 + next();
	let m = read_transposed(n, 1+w, next);
	return m.map(v => [v[0], v.slice(1)]);
}


function read_trie(next) {
	let ret = [];
	let sorted = read_sorted(next); 
	expand(decode([]), []);
	return ret; // not sorted
	function decode(Q) { // characters that lead into this node
		let S = next(); // state: valid, save, check
		let B = read_array_while(() => { // buckets leading to new nodes
			let cps = read_sorted(next).map(i => sorted[i]);
			if (cps.length) return decode(cps);
		});
		return {S, B, Q};
	}
	function expand({S, B}, cps, saved) {
		if (S & 4 && saved === cps[cps.length-1]) return;
		if (S & 2) saved = cps[cps.length-1];
		if (S & 1) ret.push(cps); 
		for (let br of B) {
			for (let cp of br.Q) {
				expand(br, [...cps, cp], saved);
			}
		}
	}
}

function hex_cp(cp) {
	return cp.toString(16).toUpperCase().padStart(2, '0');
}

function quote_cp(cp) {
	return `{${hex_cp(cp)}}`; // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) { // this is about 2x faster
	let cps = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos);
		pos += cp < 0x10000 ? 1 : 2;
		cps.push(cp);
	}
	return cps;
}

function str_from_cps(cps) {
	const chunk = 4096;
	let len = cps.length;
	if (len < chunk) return String.fromCodePoint(...cps);
	let buf = [];
	for (let i = 0; i < len; ) {
		buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
	}
	return buf.join('');
}

function compare_arrays(a, b) {
	let n = a.length;
	let c = n - b.length;
	for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
	return c;
}

// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-nf data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e
var COMPRESSED = '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';

// https://unicode.org/reports/tr15/
// for reference implementation
// see: /derive/nf.js


// algorithmic hangul
// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
const S0 = 0xAC00;
const L0 = 0x1100;
const V0 = 0x1161;
const T0 = 0x11A7;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;

function unpack_cc(packed) {
	return (packed >> 24) & 0xFF;
}
function unpack_cp(packed) {
	return packed & 0xFFFFFF;
}

let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;

function init$1() {
	//console.time('nf');
	let r = read_compressed_payload(COMPRESSED);
	SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted
	EXCLUSIONS = new Set(read_sorted(r));
	DECOMP = new Map();
	RECOMP = new Map();
	for (let [cp, cps] of read_mapped(r)) {
		if (!EXCLUSIONS.has(cp) && cps.length == 2) {
			let [a, b] = cps;
			let bucket = RECOMP.get(a);
			if (!bucket) {
				bucket = new Map();
				RECOMP.set(a, bucket);
			}
			bucket.set(b, cp);
		}
		DECOMP.set(cp, cps.reverse()); // stored reversed
	}
	//console.timeEnd('nf');
	// 20230905: 11ms
}

function is_hangul(cp) {
	return cp >= S0 && cp < S1;
}

function compose_pair(a, b) {
	if (a >= L0 && a < L1 && b >= V0 && b < V1) {
		return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
	} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
		return a + (b - T0);
	} else {
		let recomp = RECOMP.get(a);
		if (recomp) {
			recomp = recomp.get(b);
			if (recomp) {
				return recomp;
			}
		}
		return -1;
	}
}

function decomposed(cps) {
	if (!SHIFTED_RANK) init$1();
	let ret = [];
	let buf = [];
	let check_order = false;
	function add(cp) {
		let cc = SHIFTED_RANK.get(cp);
		if (cc) {
			check_order = true;
			cp |= cc;
		}
		ret.push(cp);
	}
	for (let cp of cps) {
		while (true) {
			if (cp < 0x80) {
				ret.push(cp);
			} else if (is_hangul(cp)) {
				let s_index = cp - S0;
				let l_index = s_index / N_COUNT | 0;
				let v_index = (s_index % N_COUNT) / T_COUNT | 0;
				let t_index = s_index % T_COUNT;
				add(L0 + l_index);
				add(V0 + v_index);
				if (t_index > 0) add(T0 + t_index);
			} else {
				let mapped = DECOMP.get(cp);
				if (mapped) {
					buf.push(...mapped);
				} else {
					add(cp);
				}
			}
			if (!buf.length) break;
			cp = buf.pop();
		}
	}
	if (check_order && ret.length > 1) {
		let prev_cc = unpack_cc(ret[0]);
		for (let i = 1; i < ret.length; i++) {
			let cc = unpack_cc(ret[i]);
			if (cc == 0 || prev_cc <= cc) {
				prev_cc = cc;
				continue;
			}
			let j = i-1;
			while (true) {
				let tmp = ret[j+1];
				ret[j+1] = ret[j];
				ret[j] = tmp;
				if (!j) break;
				prev_cc = unpack_cc(ret[--j]);
				if (prev_cc <= cc) break;
			}
			prev_cc = unpack_cc(ret[i]);
		}
	}
	return ret;
}

function composed_from_decomposed(v) {
	let ret = [];
	let stack = [];
	let prev_cp = -1;
	let prev_cc = 0;
	for (let packed of v) {
		let cc = unpack_cc(packed);
		let cp = unpack_cp(packed);
		if (prev_cp == -1) {
			if (cc == 0) {
				prev_cp = cp;
			} else {
				ret.push(cp);
			}
		} else if (prev_cc > 0 && prev_cc >= cc) {
			if (cc == 0) {
				ret.push(prev_cp, ...stack);
				stack.length = 0;
				prev_cp = cp;
			} else {
				stack.push(cp);
			}
			prev_cc = cc;
		} else {
			let composed = compose_pair(prev_cp, cp);
			if (composed >= 0) {
				prev_cp = composed;
			} else if (prev_cc == 0 && cc == 0) {
				ret.push(prev_cp);
				prev_cp = cp;
			} else {
				stack.push(cp);
				prev_cc = cc;
			}
		}
	}
	if (prev_cp >= 0) {
		ret.push(prev_cp, ...stack);	
	}
	return ret;
}

// note: cps can be iterable
function nfd(cps) {
	return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
	return composed_from_decomposed(decomposed(cps));
}

const HYPHEN = 0x2D;
const STOP = 0x2E;
const STOP_CH = '.';
const FE0F = 0xFE0F;
const UNIQUE_PH = 1;

// 20230913: replace [...v] with Array_from(v) to avoid large spreads
const Array_from = x => Array.from(x); // Array.from.bind(Array);

function group_has_cp(g, cp) {
	// 20230913: keep primary and secondary distinct instead of creating valid union
	return g.P.has(cp) || g.Q.has(cp);
}

class Emoji extends Array {
	get is_emoji() { return true; } // free tagging system
}

let MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;

function init() {
	if (MAPPED) return;
	
	let r = read_compressed_payload(COMPRESSED$1);
	const read_sorted_array = () => read_sorted(r);
	const read_sorted_set = () => new Set(read_sorted_array());
	const set_add_many = (set, v) => v.forEach(x => set.add(x));

	MAPPED = new Map(read_mapped(r)); 
	IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

	/*
	// direct include from payload is smaller than the decompression code
	const FENCED = new Map(read_array_while(() => {
		let cp = r();
		if (cp) return [cp, read_str(r())];
	}));
	*/
	// 20230217: we still need all CM for proper error formatting
	// but norm only needs NSM subset that are potentially-valid
	CM = read_sorted_array();
	NSM = new Set(read_sorted_array().map(i => CM[i]));
	CM = new Set(CM);
	
	ESCAPE = read_sorted_set(); // characters that should not be printed
	NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

	let chunks = read_sorted_arrays(r);
	let unrestricted = r();
	//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
	const read_chunked = () => {
		// 20230921: build set in parts, 2x faster
		let set = new Set();
		read_sorted_array().forEach(i => set_add_many(set, chunks[i]));
		set_add_many(set, read_sorted_array());
		return set; 
	};
	GROUPS = read_array_while(i => {
		// minifier property mangling seems unsafe
		// so these are manually renamed to single chars
		let N = read_array_while(r).map(x => x+0x60);
		if (N.length) {
			let R = i >= unrestricted; // unrestricted then restricted
			N[0] -= 32; // capitalize
			N = str_from_cps(N);
			if (R) N=`Restricted[${N}]`;
			let P = read_chunked(); // primary
			let Q = read_chunked(); // secondary
			let M = !r(); // not-whitelisted, check for NSM
			// *** this code currently isn't needed ***
			/*
			let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
			let M = r()-1; // number of combining mark
			if (M < 0) { // whitelisted
				M = new Map(read_array_while(() => {
					let i = r();
					if (i) return [V[i-1], read_array_while(() => {
						let v = read_array_while(r);
						if (v.length) return v.map(x => x-1);
					})];
				}));
			}*/
			return {N, P, Q, M, R};
		}
	});

	// decode compressed wholes
	WHOLE_VALID = read_sorted_set();
	WHOLE_MAP = new Map();
	let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted
	wholes.forEach((cp, i) => {
		let d = r(); 
		let w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};
		w.V.push(cp); // add to member set
		if (!WHOLE_VALID.has(cp)) {
			WHOLE_MAP.set(cp, w);  // register with whole map
		}
	});

	// compute confusable-extent complements
	// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
	for (let {V, M} of new Set(WHOLE_MAP.values())) {
		// connect all groups that have each whole character
		let recs = [];
		for (let cp of V) {
			let gs = GROUPS.filter(g => group_has_cp(g, cp));
			let rec = recs.find(({G}) => gs.some(g => G.has(g)));
			if (!rec) {
				rec = {G: new Set(), V: []};
				recs.push(rec);
			}
			rec.V.push(cp);
			set_add_many(rec.G, gs);
		}
		// per character cache groups which are not a member of the extent
		let union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole
		for (let {G, V} of recs) {
			let complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent
			for (let cp of V) {
				M.set(cp, complement); // this is the same reference
			}
		}
	}

	// compute valid set
	// 20230924: VALID was union but can be re-used
	VALID = new Set(); // exists in 1+ groups
	let multi = new Set(); // exists in 2+ groups
	const add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
	for (let g of GROUPS) {
		for (let cp of g.P) add_to_union(cp);
		for (let cp of g.Q) add_to_union(cp);
	}
	// dual purpose WHOLE_MAP: return placeholder if unique non-confusable
	for (let cp of VALID) {
		if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
			WHOLE_MAP.set(cp, UNIQUE_PH);
		}
	}
	// add all decomposed parts
	// see derive: "Valid is Closed (via Brute-force)"
	set_add_many(VALID, nfd(VALID));
	
	// decode emoji
	// 20230719: emoji are now fully-expanded to avoid quirk logic 
	EMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);
	EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
	for (let cps of EMOJI_LIST) {
		// 20230719: change to *slightly* stricter algorithm which disallows 
		// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
		// example: beautified [A B] (eg. flag emoji) 
		//  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
		//   after: error: both
		// note: this code now matches ENSNormalize.{cs,java} logic
		let prev = [EMOJI_ROOT];
		for (let cp of cps) {
			let next = prev.map(node => {
				let child = node.get(cp);
				if (!child) {
					// should this be object? 
					// (most have 1-2 items, few have many)
					// 20230719: no, v8 default map is 4?
					child = new Map();
					node.set(cp, child);
				}
				return child;
			});
			if (cp === FE0F) {
				prev.push(...next); // less than 20 elements
			} else {
				prev = next;
			}
		}
		for (let x of prev) {
			x.V = cps;
		}
	}
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
	return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}

// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
	return `"${s}"\u200E`; // strong LTR
}

function check_label_extension(cps) {
	if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
		throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`); // this can only be ascii so cant be bidi
	}
}
function check_leading_underscore(cps) {
	const UNDERSCORE = 0x5F;
	for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
		if (cps[--i] !== UNDERSCORE) {
			throw new Error('underscore allowed only at start');
		}
	}
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
	let cp = cps[0];
	let prev = FENCED.get(cp);
	if (prev) throw error_placement(`leading ${prev}`);
	let n = cps.length;
	let last = -1; // prevents trailing from throwing
	for (let i = 1; i < n; i++) {
		cp = cps[i];
		let match = FENCED.get(cp);
		if (match) {
			// since cps[0] isn't fenced, cps[1] cannot throw
			if (last == i) throw error_placement(`${prev} + ${match}`);
			last = i + 1;
			prev = match;
		}
	}
	if (last == n) throw error_placement(`trailing ${prev}`);
}

// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// if cps exceed max, middle truncate with ellipsis
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
	//if (Number.isInteger(cps)) cps = [cps];
	//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
	let buf = [];
	if (is_combining_mark(cps[0])) buf.push('◌');
	if (cps.length > max) {
		max >>= 1;
		cps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];
	}
	let prev = 0;
	let n = cps.length;
	for (let i = 0; i < n; i++) {
		let cp = cps[i];
		if (should_escape(cp)) {
			buf.push(str_from_cps(cps.slice(prev, i)));
			buf.push(quoter(cp));
			prev = i + 1;
		}
	}
	buf.push(str_from_cps(cps.slice(prev, n)));
	return buf.join('');
}

// note: set(s) cannot be exposed because they can be modified
// note: Object.freeze() doesn't work
function is_combining_mark(cp) {
	init();
	return CM.has(cp);
}
function should_escape(cp) {
	init();
	return ESCAPE.has(cp);
}

// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
	init();
	return EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy
}

function ens_normalize_fragment(frag, decompose) {
	init();
	let nf = decompose ? nfd : nfc;
	return frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);
}

function ens_normalize(name) {
	return flatten(split(name, nfc, filter_fe0f));
}

function ens_beautify(name) {
	let labels = split(name, nfc, x => x); // emoji not exposed
	for (let {type, output, error} of labels) {
		if (error) break; // flatten will throw

		// replace leading/trailing hyphen
		// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
		// not exactly the same in every font, but very similar: "-" vs "‐"
		/*
		const UNICODE_HYPHEN = 0x2010;
		// maybe this should replace all for visual consistancy?
		// `node tools/reg-count.js regex ^-\{2,\}` => 592
		//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
		if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
		let end = output.length-1;
		if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
		*/
		// 20230123: WHATWG URL uses "CheckHyphens" false
		// https://url.spec.whatwg.org/#idna

		// update ethereum symbol
		// ξ => Ξ if not greek
		if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);

		// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
		// could be fixed with special case for: 2D (.) + 200E (LTR)
		// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824
		//output.splice(0, 0, 0x200E);
	}
	return flatten(labels);
}

function array_replace(v, a, b) {
	let prev = 0;
	while (true) {
		let next = v.indexOf(a, prev);
		if (next < 0) break;
		v[next] = b; 
		prev = next + 1;
	}
}

function ens_split(name, preserve_emoji) {
	return split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy
}

function split(name, nf, ef) {
	if (!name) return []; // 20230719: empty name allowance
	init();
	let offset = 0;
	// https://unicode.org/reports/tr46/#Validity_Criteria
	// 4.) "The label must not contain a U+002E ( . ) FULL STOP."
	return name.split(STOP_CH).map(label => {
		let input = explode_cp(label);
		let info = {
			input,
			offset, // codepoint, not substring!
		};
		offset += input.length + 1; // + stop
		try {
			// 1.) "The label must be in Unicode Normalization Form NFC"
			let tokens = info.tokens = tokens_from_str(input, nf, ef);
			let token_count = tokens.length;
			let type;
			if (!token_count) { // the label was effectively empty (could of had ignored characters)
				//norm = [];
				//type = 'None'; // use this instead of next match, "ASCII"
				// 20230120: change to strict
				// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
				throw new Error(`empty label`);
			} 
			let norm = info.output = tokens.flat();
			check_leading_underscore(norm);
			let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
			if (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii
				// 20230123: matches matches WHATWG, see note 3.3
				check_label_extension(norm); // only needed for ascii
				// cant have fenced
				// cant have cm
				// cant have wholes
				// see derive: "Fastpath ASCII"
				type = 'ASCII';
			} else {
				let chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together
				if (!chars.length) { // theres no text, just emoji
					type = 'Emoji';
				} else {
					// 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
					if (CM.has(norm[0])) throw error_placement('leading combining mark');
					for (let i = 1; i < token_count; i++) { // we've already checked the first token
						let cps = tokens[i];
						if (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...
							// bidi_qq() not needed since emoji is LTR and cps is a CM
							throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}"`); 
						}
					}
					check_fenced(norm);
					let unique = Array_from(new Set(chars));
					let [g] = determine_group(unique); // take the first match
					// see derive: "Matching Groups have Same CM Style"
					// alternative: could form a hybrid type: Latin/Japanese/...	
					check_group(g, chars); // need text in order
					check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
					type = g.N;
					// 20230121: consider exposing restricted flag
					// it's simpler to just check for 'Restricted'
					// or even better: type.endsWith(']')
					//if (g.R) info.restricted = true;
				}
			}
			info.type = type;
		} catch (err) {
			info.error = err; // use full error object
		}
		return info;
	});
}

function check_whole(group, unique) {
	let maker;
	let shared = [];
	for (let cp of unique) {
		let whole = WHOLE_MAP.get(cp);
		if (whole === UNIQUE_PH) return; // unique, non-confusable
		if (whole) {
			let set = whole.M.get(cp); // groups which have a character that look-like this character
			maker = maker ? maker.filter(g => set.has(g)) : Array_from(set);
			if (!maker.length) return; // confusable intersection is empty
		} else {
			shared.push(cp); 
		}
	}
	if (maker) {
		// we have 1+ confusable
		// check if any of the remaining groups
		// contain the shared characters too
		for (let g of maker) {
			if (shared.every(cp => group_has_cp(g, cp))) {
				throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
			}
		}
	}
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
	let groups = GROUPS;
	for (let cp of unique) {
		// note: we need to dodge CM that are whitelisted
		// but that code isn't currently necessary
		let gs = groups.filter(g => group_has_cp(g, cp));
		if (!gs.length) {
			if (!GROUPS.some(g => group_has_cp(g, cp))) { 
				// the character was composed of valid parts
				// but it's NFC form is invalid
				// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
				// note: this doesn't have to be a composition
				// 20230720: change to full check
				throw error_disallowed(cp); // this should be rare
			} else {
				// there is no group that contains all these characters
				// throw using the highest priority group that matched
				// https://www.unicode.org/reports/tr39/#mixed_script_confusables
				throw error_group_member(groups[0], cp);
			}
		}
		groups = gs;
		if (gs.length == 1) break; // there is only one group left
	}
	// there are at least 1 group(s) with all of these characters
	return groups;
}

// throw on first error
function flatten(split) {
	return split.map(({input, error, output}) => {
		if (error) {
			// don't print label again if just a single label
			let msg = error.message;
			// bidi_qq() only necessary if msg is digits
			throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); 
		}
		return str_from_cps(output);
	}).join(STOP_CH);
}

function error_disallowed(cp) {
	// TODO: add cp to error?
	return new Error(`disallowed character: ${quoted_cp(cp)}`); 
}
function error_group_member(g, cp) {
	let quoted = quoted_cp(cp);
	let gg = GROUPS.find(g => g.P.has(cp)); // only check primary
	if (gg) {
		quoted = `${gg.N} ${quoted}`;
	}
	return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
	return new Error(`illegal placement: ${where}`);
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
	for (let cp of cps) {
		if (!group_has_cp(g, cp)) {
			// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
			// at the moment, it's unnecessary to introduce an extra error type
			// until there exists a whitelisted multi-character
			//   eg. if (M < 0 && is_combining_mark(cp)) { ... }
			// there are 3 cases:
			//   1. illegal cm for wrong group => mixture error
			//   2. illegal cm for same group => cm error
			//       requires set of whitelist cm per group: 
			//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
			//   3. wrong group => mixture error
			throw error_group_member(g, cp);
		}
	}
	//if (M >= 0) { // we have a known fixed cm count
	if (g.M) { // we need to check for NSM
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption
			// 20230210: bugfix: using cps instead of decomposed h/t Carbon225
			/*
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
				}
				i = j;
			}
			*/
			// 20230217: switch to NSM counting
			// https://www.unicode.org/reports/tr39/#Optional_Detection
			if (NSM.has(decomposed[i])) {
				let j = i + 1;
				for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {
					// a. Forbid sequences of the same nonspacing mark.
					for (let k = i; k < j; k++) { // O(n^2) but n < 100
						if (decomposed[k] == cp) {
							throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
						}
					}
				}
				// parse to end so we have full nsm count
				// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
				if (j - i > NSM_MAX) {
					// note: this slice starts with a base char or spacing-mark cm
					throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);
				}
				i = j;
			}
		}
	}
	// *** this code currently isn't needed ***
	/*
	let cm_whitelist = M instanceof Map;
	for (let i = 0, e = cps.length; i < e; ) {
		let cp = cps[i++];
		let seqs = cm_whitelist && M.get(cp);
		if (seqs) { 
			// list of codepoints that can follow
			// if this exists, this will always be 1+
			let j = i;
			while (j < e && CM.has(cps[j])) j++;
			let cms = cps.slice(i, j);
			let match = seqs.find(seq => !compare_arrays(seq, cms));
			if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
			i = j;
		} else if (!V.has(cp)) {
			// https://www.unicode.org/reports/tr39/#mixed_script_confusables
			let quoted = quoted_cp(cp);
			for (let cp of cps) {
				let u = UNIQUE.get(cp);
				if (u && u !== g) {
					// if both scripts are restricted this error is confusing
					// because we don't differentiate RestrictedA from RestrictedB 
					if (!u.R) quoted = `${quoted} is ${u.N}`;
					break;
				}
			}
			throw new Error(`disallowed ${g.N} character: ${quoted}`);
			//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
			//throw new Error(`${g.N} does not allow: ${quoted}`);
		}
	}
	if (!cm_whitelist) {
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
				}
				i = j;
			}
		}
	}
	*/
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abc💩d") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
// 20230818: rename for 'process' name collision h/t Javarome
// https://github.com/adraffy/ens-normalize.js/issues/23
function tokens_from_str(input, nf, ef) {
	let ret = [];
	let chars = [];
	input = input.slice().reverse(); // flip so we can pop
	while (input.length) {
		let emoji = consume_emoji_reversed(input);
		if (emoji) {
			if (chars.length) {
				ret.push(nf(chars));
				chars = [];
			}
			ret.push(ef(emoji));
		} else {
			let cp = input.pop();
			if (VALID.has(cp)) {
				chars.push(cp);
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					chars.push(...cps); // less than 10 elements
				} else if (!IGNORED.has(cp)) {
					// 20230912: unicode 15.1 changed the order of processing such that
					// disallowed parts are only rejected after NFC
					// https://unicode.org/reports/tr46/#Validity_Criteria
					// this doesn't impact normalization as of today
					// technically, this error can be removed as the group logic will apply similar logic
					// however the error type might be less clear
					throw error_disallowed(cp);
				}
			}
		}
	}
	if (chars.length) {
		ret.push(nf(chars));
	}
	return ret;
}

function filter_fe0f(cps) {
	return cps.filter(cp => cp != FE0F);
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
	let node = EMOJI_ROOT;
	let emoji;
	let pos = cps.length;
	while (pos) {
		node = node.get(cps[--pos]);
		if (!node) break;
		let {V} = node;
		if (V) { // this is a valid emoji (so far)
			emoji = V;
			if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()
			cps.length = pos; // truncate
		}
	}
	return emoji;
}

// ************************************************************
// tokenizer 

const TY_VALID = 'valid';
const TY_MAPPED = 'mapped';
const TY_IGNORED = 'ignored';
const TY_DISALLOWED = 'disallowed';
const TY_EMOJI = 'emoji';
const TY_NFC = 'nfc';
const TY_STOP = 'stop';

function ens_tokenize(name, {
	nf = true, // collapse unnormalized runs into a single token
} = {}) {
	init();
	let input = explode_cp(name).reverse();
	let eaten = [];
	let tokens = [];
	while (input.length) {
		let emoji = consume_emoji_reversed(input, eaten);
		if (emoji) {
			tokens.push({
				type: TY_EMOJI,
				emoji: emoji.slice(), // copy emoji
				input: eaten,
				cps: filter_fe0f(emoji)
			});
			eaten = []; // reset buffer
		} else {
			let cp = input.pop();
			if (cp == STOP) {
				tokens.push({type: TY_STOP, cp});
			} else if (VALID.has(cp)) {
				tokens.push({type: TY_VALID, cps: [cp]});
			} else if (IGNORED.has(cp)) {
				tokens.push({type: TY_IGNORED, cp});
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					tokens.push({type: TY_MAPPED, cp, cps: cps.slice()});
				} else {
					tokens.push({type: TY_DISALLOWED, cp});
				}
			}
		}
	}
	if (nf) {
		for (let i = 0, start = -1; i < tokens.length; i++) {
			let token = tokens[i];
			if (is_valid_or_mapped(token.type)) {
				if (requires_check(token.cps)) { // normalization might be needed
					let end = i + 1;
					for (let pos = end; pos < tokens.length; pos++) { // find adjacent text
						let {type, cps} = tokens[pos];
						if (is_valid_or_mapped(type)) {
							if (!requires_check(cps)) break;
							end = pos + 1;
						} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { 
							break;
						}
					}
					if (start < 0) start = i;
					let slice = tokens.slice(start, end);
					let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens
					let cps = nfc(cps0);
					if (compare_arrays(cps, cps0)) { // bundle into an nfc token
						tokens.splice(start, end - start, {
							type: TY_NFC, 
							input: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
							cps, 
							tokens0: collapse_valid_tokens(slice),
							tokens: ens_tokenize(str_from_cps(cps), {nf: false})
						});
						i = start;
					} else { 
						i = end - 1; // skip to end of slice
					}
					start = -1; // reset
				} else {
					start = i; // remember last
				}
			} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?
				start = -1; // reset
			}
		}
	}
	return collapse_valid_tokens(tokens);
}

function is_valid_or_mapped(type) {
	return type == TY_VALID || type == TY_MAPPED;
}

function requires_check(cps) {
	return cps.some(cp => NFC_CHECK.has(cp));
}

function collapse_valid_tokens(tokens) {
	for (let i = 0; i < tokens.length; i++) {
		if (tokens[i].type == TY_VALID) {
			let j = i + 1;
			while (j < tokens.length && tokens[j].type == TY_VALID) j++;
			tokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});
		}
	}
	return tokens;
}

exports.ens_beautify = ens_beautify;
exports.ens_emoji = ens_emoji;
exports.ens_normalize = ens_normalize;
exports.ens_normalize_fragment = ens_normalize_fragment;
exports.ens_split = ens_split;
exports.ens_tokenize = ens_tokenize;
exports.is_combining_mark = is_combining_mark;
exports.nfc = nfc;
exports.nfd = nfd;
exports.safe_str_from_cps = safe_str_from_cps;
exports.should_escape = should_escape;


/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/aes.js":
/*!**************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/aes.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AES = void 0;
// Number of rounds by keysize
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
// Round constant words
const rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
// S-box and Inverse S-box (S is for Substitution)
const S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
const Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
// Transformations for encryption
const T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
const T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
const T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
const T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
// Transformations for decryption
const T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
const T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
const T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
const T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
// Transformations for decryption key expansion
const U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
const U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
const U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
const U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
function convertToInt32(bytes) {
    const result = [];
    for (let i = 0; i < bytes.length; i += 4) {
        result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);
    }
    return result;
}
class AES {
    get key() { return __classPrivateFieldGet(this, _AES_key, "f").slice(); }
    constructor(key) {
        _AES_key.set(this, void 0);
        _AES_Kd.set(this, void 0);
        _AES_Ke.set(this, void 0);
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }
        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
        const rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
        }
        // encryption round keys
        __classPrivateFieldSet(this, _AES_Ke, [], "f");
        // decryption round keys
        __classPrivateFieldSet(this, _AES_Kd, [], "f");
        for (let i = 0; i <= rounds; i++) {
            __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
            __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
        }
        const roundKeyCount = (rounds + 1) * 4;
        const KC = this.key.length / 4;
        // convert the key into ints
        const tk = convertToInt32(this.key);
        // copy values into round key arrays
        let index;
        for (let i = 0; i < KC; i++) {
            index = i >> 2;
            __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
            __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
        }
        // key expansion (fips-197 section 5.2)
        let rconpointer = 0;
        let t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                (S[(tt >> 8) & 0xFF] << 16) ^
                (S[tt & 0xFF] << 8) ^
                S[(tt >> 24) & 0xFF] ^
                (rcon[rconpointer] << 24));
            rconpointer += 1;
            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (let i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
                // key expansion for 256-bit keys is "slightly different" (fips-197)
            }
            else {
                for (let i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];
                tk[KC / 2] ^= (S[tt & 0xFF] ^
                    (S[(tt >> 8) & 0xFF] << 8) ^
                    (S[(tt >> 16) & 0xFF] << 16) ^
                    (S[(tt >> 24) & 0xFF] << 24));
                for (let i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }
            // copy values into round key arrays
            let i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[i];
                __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
                t++;
            }
        }
        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (let r = 1; r < rounds; r++) {
            for (let c = 0; c < 4; c++) {
                tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r][c];
                __classPrivateFieldGet(this, _AES_Kd, "f")[r][c] = (U1[(tt >> 24) & 0xFF] ^
                    U2[(tt >> 16) & 0xFF] ^
                    U3[(tt >> 8) & 0xFF] ^
                    U4[tt & 0xFF]);
            }
        }
    }
    encrypt(plaintext) {
        if (plaintext.length != 16) {
            throw new TypeError('invalid plaintext size (must be 16 bytes)');
        }
        const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
        const a = [0, 0, 0, 0];
        // convert plaintext to (ints ^ key)
        let t = convertToInt32(plaintext);
        for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
        }
        // apply round transforms
        for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
                a[i] = (T1[(t[i] >> 24) & 0xff] ^
                    T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                    T3[(t[(i + 2) % 4] >> 8) & 0xff] ^
                    T4[t[(i + 3) % 4] & 0xff] ^
                    __classPrivateFieldGet(this, _AES_Ke, "f")[r][i]);
            }
            t = a.slice();
        }
        // the last round is special
        const result = new Uint8Array(16);
        let tt = 0;
        for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    }
    decrypt(ciphertext) {
        if (ciphertext.length != 16) {
            throw new TypeError('invalid ciphertext size (must be 16 bytes)');
        }
        const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
        const a = [0, 0, 0, 0];
        // convert plaintext to (ints ^ key)
        let t = convertToInt32(ciphertext);
        for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
        }
        // apply round transforms
        for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
                a[i] = (T5[(t[i] >> 24) & 0xff] ^
                    T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                    T7[(t[(i + 2) % 4] >> 8) & 0xff] ^
                    T8[t[(i + 1) % 4] & 0xff] ^
                    __classPrivateFieldGet(this, _AES_Kd, "f")[r][i]);
            }
            t = a.slice();
        }
        // the last round is special
        const result = new Uint8Array(16);
        let tt = 0;
        for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    }
}
exports.AES = AES;
_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();
//# sourceMappingURL=aes.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/index.js":
/*!****************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;
var aes_js_1 = __webpack_require__(/*! ./aes.js */ "../node_modules/aes-js/lib.commonjs/aes.js");
Object.defineProperty(exports, "AES", ({ enumerable: true, get: function () { return aes_js_1.AES; } }));
var mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
Object.defineProperty(exports, "ModeOfOperation", ({ enumerable: true, get: function () { return mode_js_1.ModeOfOperation; } }));
var mode_cbc_js_1 = __webpack_require__(/*! ./mode-cbc.js */ "../node_modules/aes-js/lib.commonjs/mode-cbc.js");
Object.defineProperty(exports, "CBC", ({ enumerable: true, get: function () { return mode_cbc_js_1.CBC; } }));
var mode_cfb_js_1 = __webpack_require__(/*! ./mode-cfb.js */ "../node_modules/aes-js/lib.commonjs/mode-cfb.js");
Object.defineProperty(exports, "CFB", ({ enumerable: true, get: function () { return mode_cfb_js_1.CFB; } }));
var mode_ctr_js_1 = __webpack_require__(/*! ./mode-ctr.js */ "../node_modules/aes-js/lib.commonjs/mode-ctr.js");
Object.defineProperty(exports, "CTR", ({ enumerable: true, get: function () { return mode_ctr_js_1.CTR; } }));
var mode_ecb_js_1 = __webpack_require__(/*! ./mode-ecb.js */ "../node_modules/aes-js/lib.commonjs/mode-ecb.js");
Object.defineProperty(exports, "ECB", ({ enumerable: true, get: function () { return mode_ecb_js_1.ECB; } }));
var mode_ofb_js_1 = __webpack_require__(/*! ./mode-ofb.js */ "../node_modules/aes-js/lib.commonjs/mode-ofb.js");
Object.defineProperty(exports, "OFB", ({ enumerable: true, get: function () { return mode_ofb_js_1.OFB; } }));
var padding_js_1 = __webpack_require__(/*! ./padding.js */ "../node_modules/aes-js/lib.commonjs/padding.js");
Object.defineProperty(exports, "pkcs7Pad", ({ enumerable: true, get: function () { return padding_js_1.pkcs7Pad; } }));
Object.defineProperty(exports, "pkcs7Strip", ({ enumerable: true, get: function () { return padding_js_1.pkcs7Strip; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode-cbc.js":
/*!*******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode-cbc.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Cipher Block Chaining
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CBC = void 0;
const mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
class CBC extends mode_js_1.ModeOfOperation {
    constructor(key, iv) {
        super("ECC", key, CBC);
        _CBC_iv.set(this, void 0);
        _CBC_lastBlock.set(this, void 0);
        if (iv) {
            if (iv.length % 16) {
                throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), "f");
        }
        else {
            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, "f");
    }
    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, "f")); }
    encrypt(plaintext) {
        if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const ciphertext = new Uint8Array(plaintext.length);
        for (let i = 0; i < plaintext.length; i += 16) {
            for (let j = 0; j < 16; j++) {
                __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
            }
            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, "f")), "f");
            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, "f"), i);
        }
        return ciphertext;
    }
    decrypt(ciphertext) {
        if (ciphertext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        const plaintext = new Uint8Array(ciphertext.length);
        for (let i = 0; i < ciphertext.length; i += 16) {
            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
            for (let j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j];
                __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
            }
        }
        return plaintext;
    }
}
exports.CBC = CBC;
_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();
//# sourceMappingURL=mode-cbc.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode-cfb.js":
/*!*******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode-cfb.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Cipher Feedback
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CFB = void 0;
const mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
class CFB extends mode_js_1.ModeOfOperation {
    constructor(key, iv, segmentSize = 8) {
        super("CFB", key, CFB);
        _CFB_instances.add(this);
        _CFB_iv.set(this, void 0);
        _CFB_shiftRegister.set(this, void 0);
        // This library currently only handles byte-aligned segmentSize
        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {
            throw new TypeError("invalid segmentSize");
        }
        Object.defineProperties(this, {
            segmentSize: { enumerable: true, value: segmentSize }
        });
        if (iv) {
            if (iv.length % 16) {
                throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), "f");
        }
        else {
            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, "f");
    }
    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, "f")); }
    encrypt(plaintext) {
        if (8 * plaintext.length % this.segmentSize) {
            throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
        }
        const segmentSize = this.segmentSize / 8;
        const ciphertext = new Uint8Array(plaintext);
        for (let i = 0; i < ciphertext.length; i += segmentSize) {
            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
            for (let j = 0; j < segmentSize; j++) {
                ciphertext[i + j] ^= xorSegment[j];
            }
            __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
        }
        return ciphertext;
    }
    decrypt(ciphertext) {
        if (8 * ciphertext.length % this.segmentSize) {
            throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
        }
        const segmentSize = this.segmentSize / 8;
        const plaintext = new Uint8Array(ciphertext);
        for (let i = 0; i < plaintext.length; i += segmentSize) {
            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
            for (let j = 0; j < segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }
            __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
        }
        return plaintext;
    }
}
exports.CFB = CFB;
_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {
    const segmentSize = this.segmentSize / 8;
    // Shift the register
    __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet(this, _CFB_shiftRegister, "f").subarray(segmentSize));
    __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};
//# sourceMappingURL=mode-cfb.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode-ctr.js":
/*!*******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode-ctr.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Counter Mode
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CTR = void 0;
const mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
class CTR extends mode_js_1.ModeOfOperation {
    constructor(key, initialValue) {
        super("CTR", key, CTR);
        // Remaining bytes for the one-time pad
        _CTR_remaining.set(this, void 0);
        _CTR_remainingIndex.set(this, void 0);
        // The current counter
        _CTR_counter.set(this, void 0);
        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
        __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f"); // This will be discarded immediately
        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
        if (initialValue == null) {
            initialValue = 1;
        }
        if (typeof (initialValue) === "number") {
            this.setCounterValue(initialValue);
        }
        else {
            this.setCounterBytes(initialValue);
        }
    }
    get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f")); }
    setCounterValue(value) {
        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
            throw new TypeError("invalid counter initial integer value");
        }
        for (let index = 15; index >= 0; --index) {
            __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
            value = Math.floor(value / 256);
        }
    }
    setCounterBytes(value) {
        if (value.length !== 16) {
            throw new TypeError("invalid counter initial Uint8Array value length");
        }
        __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
    }
    increment() {
        for (let i = 15; i >= 0; i--) {
            if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
            }
            else {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
                break;
            }
        }
    }
    encrypt(plaintext) {
        var _a, _b;
        const crypttext = new Uint8Array(plaintext);
        for (let i = 0; i < crypttext.length; i++) {
            if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
                this.increment();
            }
            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
        }
        return crypttext;
    }
    decrypt(ciphertext) {
        return this.encrypt(ciphertext);
    }
}
exports.CTR = CTR;
_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();
//# sourceMappingURL=mode-ctr.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode-ecb.js":
/*!*******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode-ecb.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Electronic Code Book
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECB = void 0;
const mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
class ECB extends mode_js_1.ModeOfOperation {
    constructor(key) {
        super("ECB", key, ECB);
    }
    encrypt(plaintext) {
        if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const crypttext = new Uint8Array(plaintext.length);
        for (let i = 0; i < plaintext.length; i += 16) {
            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);
        }
        return crypttext;
    }
    decrypt(crypttext) {
        if (crypttext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        const plaintext = new Uint8Array(crypttext.length);
        for (let i = 0; i < crypttext.length; i += 16) {
            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);
        }
        return plaintext;
    }
}
exports.ECB = ECB;
//# sourceMappingURL=mode-ecb.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode-ofb.js":
/*!*******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode-ofb.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Output Feedback
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OFB = void 0;
const mode_js_1 = __webpack_require__(/*! ./mode.js */ "../node_modules/aes-js/lib.commonjs/mode.js");
class OFB extends mode_js_1.ModeOfOperation {
    constructor(key, iv) {
        super("OFB", key, OFB);
        _OFB_iv.set(this, void 0);
        _OFB_lastPrecipher.set(this, void 0);
        _OFB_lastPrecipherIndex.set(this, void 0);
        if (iv) {
            if (iv.length % 16) {
                throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), "f");
        }
        else {
            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, "f");
        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, "f");
    }
    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, "f")); }
    encrypt(plaintext) {
        var _a, _b;
        if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const ciphertext = new Uint8Array(plaintext);
        for (let i = 0; i < ciphertext.length; i++) {
            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f") === 16) {
                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, "f")), "f");
                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, "f");
            }
            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, "f")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f"), _a = _b++, _b), "f"), _a];
        }
        return ciphertext;
    }
    decrypt(ciphertext) {
        if (ciphertext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        return this.encrypt(ciphertext);
    }
}
exports.OFB = OFB;
_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();
//# sourceMappingURL=mode-ofb.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/mode.js":
/*!***************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/mode.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModeOfOperation = void 0;
const aes_js_1 = __webpack_require__(/*! ./aes.js */ "../node_modules/aes-js/lib.commonjs/aes.js");
class ModeOfOperation {
    constructor(name, key, cls) {
        if (cls && !(this instanceof cls)) {
            throw new Error(`${name} must be instantiated with "new"`);
        }
        Object.defineProperties(this, {
            aes: { enumerable: true, value: new aes_js_1.AES(key) },
            name: { enumerable: true, value: name }
        });
    }
}
exports.ModeOfOperation = ModeOfOperation;
//# sourceMappingURL=mode.js.map

/***/ }),

/***/ "../node_modules/aes-js/lib.commonjs/padding.js":
/*!******************************************************!*\
  !*** ../node_modules/aes-js/lib.commonjs/padding.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pkcs7Strip = exports.pkcs7Pad = void 0;
function pkcs7Pad(data) {
    const padder = 16 - (data.length % 16);
    const result = new Uint8Array(data.length + padder);
    result.set(data);
    for (let i = data.length; i < result.length; i++) {
        result[i] = padder;
    }
    return result;
}
exports.pkcs7Pad = pkcs7Pad;
function pkcs7Strip(data) {
    if (data.length < 16) {
        throw new TypeError('PKCS#7 invalid length');
    }
    const padder = data[data.length - 1];
    if (padder > 16) {
        throw new TypeError('PKCS#7 padding byte out of range');
    }
    const length = data.length - padder;
    for (let i = 0; i < padder; i++) {
        if (data[length + i] !== padder) {
            throw new TypeError('PKCS#7 invalid padding byte');
        }
    }
    return new Uint8Array(data.subarray(0, length));
}
exports.pkcs7Strip = pkcs7Strip;
//# sourceMappingURL=padding.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/_version.js":
/*!*******************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/_version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
/**
 *  The current version of Ethers.
 */
exports.version = "6.12.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/abi-coder.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/abi-coder.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbiCoder = void 0;
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
const address_js_1 = __webpack_require__(/*! ./coders/address.js */ "../node_modules/ethers/lib.commonjs/abi/coders/address.js");
const array_js_1 = __webpack_require__(/*! ./coders/array.js */ "../node_modules/ethers/lib.commonjs/abi/coders/array.js");
const boolean_js_1 = __webpack_require__(/*! ./coders/boolean.js */ "../node_modules/ethers/lib.commonjs/abi/coders/boolean.js");
const bytes_js_1 = __webpack_require__(/*! ./coders/bytes.js */ "../node_modules/ethers/lib.commonjs/abi/coders/bytes.js");
const fixed_bytes_js_1 = __webpack_require__(/*! ./coders/fixed-bytes.js */ "../node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js");
const null_js_1 = __webpack_require__(/*! ./coders/null.js */ "../node_modules/ethers/lib.commonjs/abi/coders/null.js");
const number_js_1 = __webpack_require__(/*! ./coders/number.js */ "../node_modules/ethers/lib.commonjs/abi/coders/number.js");
const string_js_1 = __webpack_require__(/*! ./coders/string.js */ "../node_modules/ethers/lib.commonjs/abi/coders/string.js");
const tuple_js_1 = __webpack_require__(/*! ./coders/tuple.js */ "../node_modules/ethers/lib.commonjs/abi/coders/tuple.js");
const fragments_js_1 = __webpack_require__(/*! ./fragments.js */ "../node_modules/ethers/lib.commonjs/abi/fragments.js");
const index_js_2 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
const PanicReasons = new Map();
PanicReasons.set(0x00, "GENERIC_PANIC");
PanicReasons.set(0x01, "ASSERT_FALSE");
PanicReasons.set(0x11, "OVERFLOW");
PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons.set(0x22, "BAD_STORAGE_DATA");
PanicReasons.set(0x31, "STACK_UNDERFLOW");
PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons.set(0x41, "OUT_OF_MEMORY");
PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
    let message = "missing revert data";
    let reason = null;
    const invocation = null;
    let revert = null;
    if (data) {
        message = "execution reverted";
        const bytes = (0, index_js_3.getBytes)(data);
        data = (0, index_js_3.hexlify)(data);
        if (bytes.length === 0) {
            message += " (no data present; likely require(false) occurred";
            reason = "require(false)";
        }
        else if (bytes.length % 32 !== 4) {
            message += " (could not decode reason; invalid data length)";
        }
        else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x08c379a0") {
            // Error(string)
            try {
                reason = abiCoder.decode(["string"], bytes.slice(4))[0];
                revert = {
                    signature: "Error(string)",
                    name: "Error",
                    args: [reason]
                };
                message += `: ${JSON.stringify(reason)}`;
            }
            catch (error) {
                message += " (could not decode reason; invalid string data)";
            }
        }
        else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x4e487b71") {
            // Panic(uint256)
            try {
                const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
                revert = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [code]
                };
                reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
                message += `: ${reason}`;
            }
            catch (error) {
                message += " (could not decode panic code)";
            }
        }
        else {
            message += " (unknown custom error)";
        }
    }
    const transaction = {
        to: (tx.to ? (0, index_js_2.getAddress)(tx.to) : null),
        data: (tx.data || "0x")
    };
    if (tx.from) {
        transaction.from = (0, index_js_2.getAddress)(tx.from);
    }
    return (0, index_js_3.makeError)(message, "CALL_EXCEPTION", {
        action, data, reason, transaction, invocation, revert
    });
}
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
class AbiCoder {
    #getCoder(param) {
        if (param.isArray()) {
            return new array_js_1.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
        }
        if (param.isTuple()) {
            return new tuple_js_1.TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
        }
        switch (param.baseType) {
            case "address":
                return new address_js_1.AddressCoder(param.name);
            case "bool":
                return new boolean_js_1.BooleanCoder(param.name);
            case "string":
                return new string_js_1.StringCoder(param.name);
            case "bytes":
                return new bytes_js_1.BytesCoder(param.name);
            case "":
                return new null_js_1.NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, "invalid " + match[1] + " bit length", "param", param);
            return new number_js_1.NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            (0, index_js_1.assertArgument)(size !== 0 && size <= 32, "invalid bytes length", "param", param);
            return new fixed_bytes_js_1.FixedBytesCoder(size, param.name);
        }
        (0, index_js_1.assertArgument)(false, "invalid type", "type", param.type);
    }
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types) {
        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));
        const coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(types, values) {
        (0, index_js_1.assertArgumentCount)(values.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));
        const coder = (new tuple_js_1.TupleCoder(coders, "_"));
        const writer = new abstract_coder_js_1.Writer();
        coder.encode(writer, values);
        return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(types, data, loose) {
        const coders = types.map((type) => this.#getCoder(fragments_js_1.ParamType.from(type)));
        const coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.decode(new abstract_coder_js_1.Reader(data, loose, defaultMaxInflation));
    }
    static _setDefaultMaxInflation(value) {
        (0, index_js_1.assertArgument)(typeof (value) === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
        defaultMaxInflation = value;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder() {
        if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
        }
        return defaultCoder;
    }
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
    static getBuiltinCallException(action, tx, data) {
        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
}
exports.AbiCoder = AbiCoder;
//# sourceMappingURL=abi-coder.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/bytes32.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/bytes32.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  About bytes32 strings...
 *
 *  @_docloc: api/utils:Bytes32 Strings
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeBytes32String = exports.encodeBytes32String = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  Encodes %%text%% as a Bytes32 string.
 */
function encodeBytes32String(text) {
    // Get the bytes
    const bytes = (0, index_js_1.toUtf8Bytes)(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return (0, index_js_1.zeroPadBytes)(bytes, 32);
}
exports.encodeBytes32String = encodeBytes32String;
/**
 *  Encodes the Bytes32-encoded %%bytes%% into a string.
 */
function decodeBytes32String(_bytes) {
    const data = (0, index_js_1.getBytes)(_bytes, "bytes");
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    let length = 31;
    while (data[length - 1] === 0) {
        length--;
    }
    // Determine the string value
    return (0, index_js_1.toUtf8String)(data.slice(0, length));
}
exports.decodeBytes32String = decodeBytes32String;
//# sourceMappingURL=bytes32.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 * @_ignore:
 */
exports.WordSize = 32;
const Padding = new Uint8Array(exports.WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
const passProperties = ["then"];
const _guard = {};
function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
class Result extends Array {
    #names;
    /**
     *  @private
     */
    constructor(...args) {
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        const guard = args[0];
        let items = args[1];
        let names = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard) {
            items = args;
            names = [];
            wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        super(items.length);
        items.forEach((item, index) => { this[index] = item; });
        // Find all unique keys
        const nameCounts = names.reduce((accum, name) => {
            if (typeof (name) === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
        }, (new Map()));
        // Remove any key thats not unique
        this.#names = Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
                return name;
            }
            return null;
        }));
        if (!wrap) {
            return;
        }
        // A wrapped Result is immutable
        Object.freeze(this);
        // Proxy indices and names so we can trap deferred errors
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "string") {
                    // Index accessor
                    if (prop.match(/^[0-9]+$/)) {
                        const index = (0, index_js_1.getNumber)(prop, "%index");
                        if (index < 0 || index >= this.length) {
                            throw new RangeError("out of result range");
                        }
                        const item = target[index];
                        if (item instanceof Error) {
                            throwError(`index ${index}`, item);
                        }
                        return item;
                    }
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    const value = target[prop];
                    if (value instanceof Function) {
                        // Make sure functions work with private variables
                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                        return function (...args) {
                            return value.apply((this === receiver) ? target : this, args);
                        };
                    }
                    else if (!(prop in target)) {
                        // Possible name accessor
                        return target.getValue.apply((this === receiver) ? target : this, [prop]);
                    }
                }
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    /**
     *  Returns the Result as a normal Array. If %%deep%%, any children
     *  which are Result objects are also converted to a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray(deep) {
        const result = [];
        this.forEach((item, index) => {
            if (item instanceof Error) {
                throwError(`index ${index}`, item);
            }
            if (deep && item instanceof Result) {
                item = item.toArray(deep);
            }
            result.push(item);
        });
        return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair. If
     *  %%deep%%, any children which are Result objects are also
     *  converted to an Object.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject(deep) {
        return this.#names.reduce((accum, name, index) => {
            (0, index_js_1.assert)(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
                operation: "toObject()"
            });
            // Add values for names that don't conflict
            if (!(name in accum)) {
                let child = this.getValue(name);
                if (deep && child instanceof Result) {
                    child = child.toObject(deep);
                }
                accum[name] = child;
            }
            return accum;
        }, {});
    }
    /**
     *  @_ignore
     */
    slice(start, end) {
        if (start == null) {
            start = 0;
        }
        if (start < 0) {
            start += this.length;
            if (start < 0) {
                start = 0;
            }
        }
        if (end == null) {
            end = this.length;
        }
        if (end < 0) {
            end += this.length;
            if (end < 0) {
                end = 0;
            }
        }
        if (end > this.length) {
            end = this.length;
        }
        const result = [], names = [];
        for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(this.#names[i]);
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    filter(callback, thisArg) {
        const result = [], names = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(this.#names[i]);
            }
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
        }
        return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name) {
        const index = this.#names.indexOf(name);
        if (index === -1) {
            return undefined;
        }
        const value = this[index];
        if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items, keys) {
        return new Result(_guard, items, keys);
    }
}
exports.Result = Result;
/**
 *  Returns all errors found in a [[Result]].
 *
 *  Since certain errors encountered when creating a [[Result]] do
 *  not impact the ability to continue parsing data, they are
 *  deferred until they are actually accessed. Hence a faulty string
 *  in an Event that is never used does not impact the program flow.
 *
 *  However, sometimes it may be useful to access, identify or
 *  validate correctness of a [[Result]].
 *
 *  @_docloc api/abi
 */
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
exports.checkResultErrors = checkResultErrors;
function getValue(value) {
    let bytes = (0, index_js_1.toBeArray)(value);
    (0, index_js_1.assert)(bytes.length <= exports.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: exports.WordSize, offset: bytes.length });
    if (bytes.length !== exports.WordSize) {
        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));
    }
    return bytes;
}
/**
 *  @_ignore
 */
class Coder {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    name;
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    type;
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    localName;
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    dynamic;
    constructor(name, type, localName, dynamic) {
        (0, index_js_1.defineProperties)(this, { name, type, localName, dynamic }, {
            name: "string", type: "string", localName: "string", dynamic: "boolean"
        });
    }
    _throwError(message, value) {
        (0, index_js_1.assertArgument)(false, message, this.localName, value);
    }
}
exports.Coder = Coder;
/**
 *  @_ignore
 */
class Writer {
    // An array of WordSize lengthed objects to concatenation
    #data;
    #dataLength;
    constructor() {
        this.#data = [];
        this.#dataLength = 0;
    }
    get data() {
        return (0, index_js_1.concat)(this.#data);
    }
    get length() { return this.#dataLength; }
    #writeData(data) {
        this.#data.push(data);
        this.#dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
    writeBytes(value) {
        let bytes = (0, index_js_1.getBytesCopy)(value);
        const paddingOffset = bytes.length % exports.WordSize;
        if (paddingOffset) {
            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));
        }
        return this.#writeData(bytes);
    }
    // Numeric item; pad on the left *to* WordSize
    writeValue(value) {
        return this.#writeData(getValue(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
    writeUpdatableValue() {
        const offset = this.#data.length;
        this.#data.push(Padding);
        this.#dataLength += exports.WordSize;
        return (value) => {
            this.#data[offset] = getValue(value);
        };
    }
}
exports.Writer = Writer;
/**
 *  @_ignore
 */
class Reader {
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    allowLoose;
    #data;
    #offset;
    #bytesRead;
    #parent;
    #maxInflation;
    constructor(data, allowLoose, maxInflation) {
        (0, index_js_1.defineProperties)(this, { allowLoose: !!allowLoose });
        this.#data = (0, index_js_1.getBytesCopy)(data);
        this.#bytesRead = 0;
        this.#parent = null;
        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;
        this.#offset = 0;
    }
    get data() { return (0, index_js_1.hexlify)(this.#data); }
    get dataLength() { return this.#data.length; }
    get consumed() { return this.#offset; }
    get bytes() { return new Uint8Array(this.#data); }
    #incrementBytesRead(count) {
        if (this.#parent) {
            return this.#parent.#incrementBytesRead(count);
        }
        this.#bytesRead += count;
        // Check for excessive inflation (see: #4537)
        (0, index_js_1.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
            buffer: (0, index_js_1.getBytesCopy)(this.#data), offset: this.#offset,
            length: count, info: {
                bytesRead: this.#bytesRead,
                dataLength: this.dataLength
            }
        });
    }
    #peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
        if (this.#offset + alignedLength > this.#data.length) {
            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
                alignedLength = length;
            }
            else {
                (0, index_js_1.assert)(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: (0, index_js_1.getBytesCopy)(this.#data),
                    length: this.#data.length,
                    offset: this.#offset + alignedLength
                });
            }
        }
        return this.#data.slice(this.#offset, this.#offset + alignedLength);
    }
    // Create a sub-reader with the same underlying data, but offset
    subReader(offset) {
        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
        reader.#parent = this;
        return reader;
    }
    // Read bytes
    readBytes(length, loose) {
        let bytes = this.#peekBytes(0, length, !!loose);
        this.#incrementBytesRead(length);
        this.#offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    // Read a numeric values
    readValue() {
        return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));
    }
    readIndex() {
        return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));
    }
}
exports.Reader = Reader;
//# sourceMappingURL=abstract-coder.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/address.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressCoder = void 0;
const index_js_1 = __webpack_require__(/*! ../../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const maths_js_1 = __webpack_require__(/*! ../../utils/maths.js */ "../node_modules/ethers/lib.commonjs/utils/maths.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
/**
 *  @_ignore
 */
class AddressCoder extends abstract_coder_js_1.Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, _value) {
        let value = typed_js_1.Typed.dereference(_value, "string");
        try {
            value = (0, index_js_1.getAddress)(value);
        }
        catch (error) {
            return this._throwError(error.message, _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));
    }
}
exports.AddressCoder = AddressCoder;
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/anonymous.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/anonymous.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnonymousCoder = void 0;
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
class AnonymousCoder extends abstract_coder_js_1.Coder {
    coder;
    constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
exports.AnonymousCoder = AnonymousCoder;
//# sourceMappingURL=anonymous.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/array.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/array.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayCoder = exports.unpack = exports.pack = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
const anonymous_js_1 = __webpack_require__(/*! ./anonymous.js */ "../node_modules/ethers/lib.commonjs/abi/coders/anonymous.js");
/**
 *  @_ignore
 */
function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            (0, index_js_1.assert)(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            (0, index_js_1.assert)(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
            unique[name] = true;
            return values[name];
        });
    }
    else {
        (0, index_js_1.assertArgument)(false, "invalid tuple value", "tuple", values);
    }
    (0, index_js_1.assertArgument)(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    let staticWriter = new abstract_coder_js_1.Writer();
    let dynamicWriter = new abstract_coder_js_1.Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
exports.pack = pack;
/**
 *  @_ignore
 */
function unpack(reader, coders) {
    let values = [];
    let keys = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value == undefined) {
            throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
    });
    return abstract_coder_js_1.Result.fromItems(values, keys);
}
exports.unpack = unpack;
/**
 *  @_ignore
 */
class ArrayCoder extends abstract_coder_js_1.Coder {
    coder;
    length;
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        (0, index_js_1.defineProperties)(this, { coder, length });
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "array");
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        (0, index_js_1.assertArgumentCount)(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readIndex();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * abstract_coder_js_1.WordSize, length: reader.dataLength });
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new anonymous_js_1.AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
    }
}
exports.ArrayCoder = ArrayCoder;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/boolean.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/boolean.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BooleanCoder = void 0;
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
/**
 *  @_ignore
 */
class BooleanCoder extends abstract_coder_js_1.Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "bool");
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return !!reader.readValue();
    }
}
exports.BooleanCoder = BooleanCoder;
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/bytes.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BytesCoder = exports.DynamicBytesCoder = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
/**
 *  @_ignore
 */
class DynamicBytesCoder extends abstract_coder_js_1.Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = (0, index_js_1.getBytesCopy)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
    }
}
exports.DynamicBytesCoder = DynamicBytesCoder;
/**
 *  @_ignore
 */
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return (0, index_js_1.hexlify)(super.decode(reader));
    }
}
exports.BytesCoder = BytesCoder;
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js":
/*!*********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedBytesCoder = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
/**
 *  @_ignore
 */
class FixedBytesCoder extends abstract_coder_js_1.Coder {
    size;
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        (0, index_js_1.defineProperties)(this, { size }, { size: "number" });
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, _value) {
        let data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));
        if (data.length !== this.size) {
            this._throwError("incorrect data length", _value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return (0, index_js_1.hexlify)(reader.readBytes(this.size));
    }
}
exports.FixedBytesCoder = FixedBytesCoder;
//# sourceMappingURL=fixed-bytes.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/null.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/null.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullCoder = void 0;
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
const Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
class NullCoder extends abstract_coder_js_1.Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
    }
    decode(reader) {
        reader.readBytes(0);
        return null;
    }
}
exports.NullCoder = NullCoder;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/number.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/number.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberCoder = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  @_ignore
 */
class NumberCoder extends abstract_coder_js_1.Coder {
    size;
    signed;
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        (0, index_js_1.defineProperties)(this, { size, signed }, { size: "number", signed: "boolean" });
    }
    defaultValue() {
        return 0;
    }
    encode(writer, _value) {
        let value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));
        // Check bounds are safe for encoding
        let maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);
        if (this.signed) {
            let bounds = (0, index_js_1.mask)(maxUintValue, (this.size * 8) - 1);
            if (value > bounds || value < -(bounds + BN_1)) {
                this._throwError("value out-of-bounds", _value);
            }
            value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);
        }
        else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        let value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);
        if (this.signed) {
            value = (0, index_js_1.fromTwos)(value, this.size * 8);
        }
        return value;
    }
}
exports.NumberCoder = NumberCoder;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/string.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/string.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringCoder = void 0;
const utf8_js_1 = __webpack_require__(/*! ../../utils/utf8.js */ "../node_modules/ethers/lib.commonjs/utils/utf8.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const bytes_js_1 = __webpack_require__(/*! ./bytes.js */ "../node_modules/ethers/lib.commonjs/abi/coders/bytes.js");
/**
 *  @_ignore
 */
class StringCoder extends bytes_js_1.DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, _value) {
        return super.encode(writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, "string")));
    }
    decode(reader) {
        return (0, utf8_js_1.toUtf8String)(super.decode(reader));
    }
}
exports.StringCoder = StringCoder;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/coders/tuple.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/coders/tuple.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleCoder = void 0;
const properties_js_1 = __webpack_require__(/*! ../../utils/properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
const typed_js_1 = __webpack_require__(/*! ../typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
const array_js_1 = __webpack_require__(/*! ./array.js */ "../node_modules/ethers/lib.commonjs/abi/coders/array.js");
/**
 *  @_ignore
 */
class TupleCoder extends abstract_coder_js_1.Coder {
    coders;
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        (0, properties_js_1.defineProperties)(this, { coders: Object.freeze(coders.slice()) });
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "tuple");
        return (0, array_js_1.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return (0, array_js_1.unpack)(reader, this.coders);
    }
}
exports.TupleCoder = TupleCoder;
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/fragments.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/fragments.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const index_js_2 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
;
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
    const result = new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
// All Keywords
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
// Single character tokens
const SimpleTokens = {
    "(": "OPEN_PAREN", ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET", "]": "CLOSE_BRACKET",
    ",": "COMMA", "@": "AT"
};
// Parser regexes to consume the next token
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
    #offset;
    #tokens;
    get offset() { return this.#offset; }
    get length() { return this.#tokens.length - this.#offset; }
    constructor(tokens) {
        this.#offset = 0;
        this.#tokens = tokens.slice();
    }
    clone() { return new TokenString(this.#tokens); }
    reset() { this.#offset = 0; }
    #subTokenString(from = 0, to = 0) {
        return new TokenString(this.#tokens.slice(from, to).map((t) => {
            return Object.freeze(Object.assign({}, t, {
                match: (t.match - from),
                linkBack: (t.linkBack - from),
                linkNext: (t.linkNext - from),
            }));
        }));
    }
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    popType(type) {
        if (this.peek().type !== type) {
            const top = this.peek();
            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
        }
        return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
    popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = this.#subTokenString(this.#offset + 1, top.match + 1);
        this.#offset = top.match + 1;
        return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = [];
        while (this.#offset < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(this.#subTokenString(this.#offset + 1, link));
            this.#offset = link;
        }
        this.#offset = top.match + 1;
        return result;
    }
    // Returns the top Token, throwing if out of tokens
    peek() {
        if (this.#offset >= this.#tokens.length) {
            throw new Error("out-of-bounds");
        }
        return this.#tokens[this.#offset];
    }
    // Returns the next value, if it is a keyword in `allowed`
    peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return (top != null && allowed.has(top)) ? top : null;
    }
    // Returns the value of the next token if it is `type`
    peekType(type) {
        if (this.length === 0) {
            return null;
        }
        const top = this.peek();
        return (top.type === type) ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
    pop() {
        const result = this.peek();
        this.#offset++;
        return result;
    }
    toString() {
        const tokens = [];
        for (let i = this.#offset; i < this.#tokens.length; i++) {
            const token = this.#tokens[i];
            tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
    }
}
function lex(text) {
    const tokens = [];
    const throwError = (message) => {
        const token = (offset < text.length) ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
        // Strip off any leading whitespace
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type = (SimpleTokens[cur[0]] || "");
        if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
            }
            else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                    throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                (tokens[token.match]).match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
            }
            else if (type === "COMMA") {
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
            }
            else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
            }
            else if (type === "CLOSE_BRACKET") {
                // Remove the CLOSE_BRACKET
                let suffix = tokens.pop().text;
                if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                    const value = tokens.pop().text;
                    suffix = value + suffix;
                    (tokens[tokens.length - 1]).value = (0, index_js_1.getNumber)(value);
                }
                if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                    throw new Error("missing opening bracket");
                }
                (tokens[tokens.length - 1]).text += suffix;
            }
            continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
            }
            if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
            }
            token.type = "ID";
            continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
        if (set.has(key)) {
            included.push(key);
        }
    }
    if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
    }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
        }
    }
    return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
    const keywords = new Set();
    while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || (allowed && !allowed.has(keyword))) {
            break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
    }
    return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
        return "view";
    }
    if (modifiers.has("pure")) {
        return "pure";
    }
    if (modifiers.has("payable")) {
        return "payable";
    }
    if (modifiers.has("nonpayable")) {
        return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
        return "view";
    }
    return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
            return (0, index_js_1.getBigInt)(tokens.pop().text);
        }
        throw new Error("invalid gas");
    }
    return null;
}
function consumeEoi(tokens) {
    if (tokens.length) {
        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
    }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
    const match = type.match(regexType);
    (0, index_js_1.assertArgument)(match, "invalid type", "type", type);
    if (type === "uint") {
        return "uint256";
    }
    if (type === "int") {
        return "int256";
    }
    if (match[2]) {
        // bytesXX
        const length = parseInt(match[2]);
        (0, index_js_1.assertArgument)(length !== 0 && length <= 32, "invalid bytes length", "type", type);
    }
    else if (match[3]) {
        // intXX or uintXX
        const size = parseInt(match[3]);
        (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, "invalid numeric width", "type", type);
    }
    return type;
}
// Make the Fragment constructors effectively private
const _guard = {};
const internal = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
class ParamType {
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    name;
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    type;
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    baseType;
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    indexed;
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    components;
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    arrayLength;
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    arrayChildren;
    /**
     *  @private
     */
    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        (0, index_js_1.assertPrivate)(guard, _guard, "ParamType");
        Object.defineProperty(this, internal, { value: ParamTypeInternal });
        if (components) {
            components = Object.freeze(components.slice());
        }
        if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
            }
        }
        else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
        }
        if (baseType === "tuple") {
            if (components == null) {
                throw new Error("");
            }
        }
        else if (components != null) {
            throw new Error("");
        }
        (0, index_js_1.defineProperties)(this, {
            name, type, baseType, indexed, components, arrayLength, arrayChildren
        });
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            const name = this.name || "";
            if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
                return JSON.stringify(result);
            }
            const result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.isTuple()) {
                result.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
        }
        else {
            if (this.isTuple()) {
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === "full") ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== "sighash") {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === "full" && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray() {
        return (this.baseType === "array");
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple() {
        return (this.baseType === "tuple");
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable() {
        return (this.indexed != null);
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value, process) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => (_this.arrayChildren.walk(v, process)));
        }
        if (this.isTuple()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => (_this.components[i].walk(v, process)));
        }
        return process(this.type, value);
    }
    #walkAsync(promises, value, process, setValue) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const childType = this.arrayChildren;
            const result = value.slice();
            result.forEach((value, index) => {
                childType.#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        if (this.isTuple()) {
            const components = this.components;
            // Convert the object into an array
            let result;
            if (Array.isArray(value)) {
                result = value.slice();
            }
            else {
                if (value == null || typeof (value) !== "object") {
                    throw new Error("invalid tuple value");
                }
                result = components.map((param) => {
                    if (!param.name) {
                        throw new Error("cannot use object value with unnamed components");
                    }
                    if (!(param.name in value)) {
                        throw new Error(`missing value for component ${param.name}`);
                    }
                    return value[param.name];
                });
            }
            if (result.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            result.forEach((value, index) => {
                components[index].#walkAsync(promises, value, process, (value) => {
                    result[index] = value;
                });
            });
            setValue(result);
            return;
        }
        const result = process(this.type, value);
        if (result.then) {
            promises.push((async function () { setValue(await result); })());
        }
        else {
            setValue(result);
        }
    }
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS naes by walking and resolving each
     *  ``"address"`` type.
     */
    async walkAsync(value, process) {
        const promises = [];
        const result = [value];
        this.#walkAsync(promises, value, process, (value) => {
            result[0] = value;
        });
        if (promises.length) {
            await Promise.all(promises);
        }
        return result[0];
    }
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ParamType.from(lex(obj), allowIndexed);
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid param type", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            let type = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
                // Tuple
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
            }
            else {
                // Normal
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
            }
            // Check for Array
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop(); //arrays[i];
                arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
                if (!allowIndexed) {
                    throw new Error("");
                }
                indexed = true;
            }
            const name = (obj.peekType("ID") ? obj.pop().text : "");
            if (obj.length) {
                throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        (0, index_js_1.assertArgument)(!name || (typeof (name) === "string" && name.match(regexId)), "invalid name", "obj.name", name);
        let indexed = obj.indexed;
        if (indexed != null) {
            (0, index_js_1.assertArgument)(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
            indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            // @TODO: use lexer to validate and normalize type
            return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value) {
        return (value && value[internal] === ParamTypeInternal);
    }
}
exports.ParamType = ParamType;
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
class Fragment {
    /**
     *  The type of the fragment.
     */
    type;
    /**
     *  The inputs for the fragment.
     */
    inputs;
    /**
     *  @private
     */
    constructor(guard, type, inputs) {
        (0, index_js_1.assertPrivate)(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        (0, index_js_1.defineProperties)(this, { type, inputs });
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            // Try parsing JSON...
            try {
                Fragment.from(JSON.parse(obj));
            }
            catch (e) { }
            // ...otherwise, use the human-readable lexer
            return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
            // Human-readable ABI (already lexed)
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
        }
        else if (typeof (obj) === "object") {
            // JSON ABI
            switch (obj.type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
            (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            });
        }
        (0, index_js_1.assertArgument)(false, "unsupported frgament object", "obj", obj);
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value) {
        return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value) {
        return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value) {
        return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value) {
        return StructFragment.isFragment(value);
    }
}
exports.Fragment = Fragment;
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
class NamedFragment extends Fragment {
    /**
     *  The name of the fragment.
     */
    name;
    /**
     *  @private
     */
    constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        (0, index_js_1.assertArgument)(typeof (name) === "string" && name.match(regexId), "invalid identifier", "name", name);
        inputs = Object.freeze(inputs.slice());
        (0, index_js_1.defineProperties)(this, { name });
    }
}
exports.NamedFragment = NamedFragment;
function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join((format === "full") ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
    }
    /**
     *  The Custom Error selector.
     */
    get selector() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ErrorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            return ErrorFragment.from(lex(obj));
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === ErrorFragmentInternal);
    }
}
exports.ErrorFragment = ErrorFragment;
/**
 *  A Fragment which represents an Event.
 */
class EventFragment extends NamedFragment {
    /**
     *  Whether this event is anonymous.
     */
    anonymous;
    /**
     *  @private
     */
    constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        Object.defineProperty(this, internal, { value: EventFragmentInternal });
        (0, index_js_1.defineProperties)(this, { anonymous });
    }
    /**
     *  The Event topic hash.
     */
    get topicHash() {
        return (0, index_js_2.id)(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
        }
        return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj) {
        if (EventFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return EventFragment.from(lex(obj));
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid event fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === EventFragmentInternal);
    }
}
exports.EventFragment = EventFragment;
/**
 *  A Fragment which represents a constructor.
 */
class ConstructorFragment extends Fragment {
    /**
     *  Whether the constructor can receive an endowment.
     */
    payable;
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
        (0, index_js_1.defineProperties)(this, { payable, gas });
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format) {
        (0, index_js_1.assert)(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
        if (format === "json") {
            return JSON.stringify({
                type: "constructor",
                stateMutability: (this.payable ? "payable" : "undefined"),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        if (this.payable) {
            result.push("payable");
        }
        if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ConstructorFragment.from(lex(obj));
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid constuctor fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === ConstructorFragmentInternal);
    }
}
exports.ConstructorFragment = ConstructorFragment;
/**
 *  A Fragment which represents a method.
 */
class FallbackFragment extends Fragment {
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
        (0, index_js_1.defineProperties)(this, { payable });
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format) {
        const type = ((this.inputs.length === 0) ? "receive" : "fallback");
        if (format === "json") {
            const stateMutability = (this.payable ? "payable" : "nonpayable");
            return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FallbackFragment.from(lex(obj));
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid fallback fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            (0, index_js_1.assertArgument)(topIsValid, "type must be fallback or receive", "obj", errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            // receive()
            if (type === "receive") {
                const inputs = consumeParams(obj);
                (0, index_js_1.assertArgument)(inputs.length === 0, `receive cannot have arguments`, "obj.inputs", inputs);
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard, [], true);
            }
            // fallback() [payable]
            // fallback(bytes) [payable] returns (bytes)
            let inputs = consumeParams(obj);
            if (inputs.length) {
                (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
            }
            else {
                inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            (0, index_js_1.assertArgument)(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = (obj.stateMutability === "payable");
            return new FallbackFragment(_guard, inputs, payable);
        }
        (0, index_js_1.assertArgument)(false, "invalid fallback description", "obj", obj);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === FallbackFragmentInternal);
    }
}
exports.FallbackFragment = FallbackFragment;
/**
 *  A Fragment which represents a method.
 */
class FunctionFragment extends NamedFragment {
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    constant;
    /**
     *  The returned types for the result of calling this function.
     */
    outputs;
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    stateMutability;
    /**
     *  If the function can be sent value during invocation.
     */
    payable;
    /**
     *  The recommended gas limit to send when calling this function.
     */
    gas;
    /**
     *  @private
     */
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = (stateMutability === "view" || stateMutability === "pure");
        const payable = (stateMutability === "payable");
        (0, index_js_1.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });
    }
    /**
     *  The Function selector.
     */
    get selector() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
        }
        return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj) {
        if (FunctionFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FunctionFragment.from(lex(obj));
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid function fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof (obj.constant) === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                    stateMutability = "payable";
                    if (typeof (obj.payable) === "boolean" && !obj.payable) {
                        stateMutability = "nonpayable";
                    }
                }
            }
            else if (typeof (obj.payable) === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
            }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === FunctionFragmentInternal);
    }
}
exports.FunctionFragment = FunctionFragment;
/**
 *  A Fragment which represents a structure.
 */
class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        Object.defineProperty(this, internal, { value: StructFragmentInternal });
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format() {
        throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            try {
                return StructFragment.from(lex(obj));
            }
            catch (error) {
                (0, index_js_1.assertArgument)(false, "invalid struct fragment", "obj", obj);
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value) {
        return (value && value[internal] === StructFragmentInternal);
    }
}
exports.StructFragment = StructFragment;
//# sourceMappingURL=fragments.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/index.js":
/*!********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  The Application Binary Interface (ABI) describes how method input
 *  parameters should be encoded, their results decoded, and how to
 *  decode events and errors.
 *
 *  See [About ABIs](docs-abi) for more details how they are used.
 *
 *  @_section api/abi:Application Binary Interface  [about-abi]
 *  @_navTitle: ABI
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;
//////
var abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ "../node_modules/ethers/lib.commonjs/abi/abi-coder.js");
Object.defineProperty(exports, "AbiCoder", ({ enumerable: true, get: function () { return abi_coder_js_1.AbiCoder; } }));
var bytes32_js_1 = __webpack_require__(/*! ./bytes32.js */ "../node_modules/ethers/lib.commonjs/abi/bytes32.js");
Object.defineProperty(exports, "decodeBytes32String", ({ enumerable: true, get: function () { return bytes32_js_1.decodeBytes32String; } }));
Object.defineProperty(exports, "encodeBytes32String", ({ enumerable: true, get: function () { return bytes32_js_1.encodeBytes32String; } }));
var fragments_js_1 = __webpack_require__(/*! ./fragments.js */ "../node_modules/ethers/lib.commonjs/abi/fragments.js");
Object.defineProperty(exports, "ConstructorFragment", ({ enumerable: true, get: function () { return fragments_js_1.ConstructorFragment; } }));
Object.defineProperty(exports, "ErrorFragment", ({ enumerable: true, get: function () { return fragments_js_1.ErrorFragment; } }));
Object.defineProperty(exports, "EventFragment", ({ enumerable: true, get: function () { return fragments_js_1.EventFragment; } }));
Object.defineProperty(exports, "FallbackFragment", ({ enumerable: true, get: function () { return fragments_js_1.FallbackFragment; } }));
Object.defineProperty(exports, "Fragment", ({ enumerable: true, get: function () { return fragments_js_1.Fragment; } }));
Object.defineProperty(exports, "FunctionFragment", ({ enumerable: true, get: function () { return fragments_js_1.FunctionFragment; } }));
Object.defineProperty(exports, "NamedFragment", ({ enumerable: true, get: function () { return fragments_js_1.NamedFragment; } }));
Object.defineProperty(exports, "ParamType", ({ enumerable: true, get: function () { return fragments_js_1.ParamType; } }));
Object.defineProperty(exports, "StructFragment", ({ enumerable: true, get: function () { return fragments_js_1.StructFragment; } }));
var interface_js_1 = __webpack_require__(/*! ./interface.js */ "../node_modules/ethers/lib.commonjs/abi/interface.js");
Object.defineProperty(exports, "checkResultErrors", ({ enumerable: true, get: function () { return interface_js_1.checkResultErrors; } }));
Object.defineProperty(exports, "Indexed", ({ enumerable: true, get: function () { return interface_js_1.Indexed; } }));
Object.defineProperty(exports, "Interface", ({ enumerable: true, get: function () { return interface_js_1.Interface; } }));
Object.defineProperty(exports, "ErrorDescription", ({ enumerable: true, get: function () { return interface_js_1.ErrorDescription; } }));
Object.defineProperty(exports, "LogDescription", ({ enumerable: true, get: function () { return interface_js_1.LogDescription; } }));
Object.defineProperty(exports, "TransactionDescription", ({ enumerable: true, get: function () { return interface_js_1.TransactionDescription; } }));
Object.defineProperty(exports, "Result", ({ enumerable: true, get: function () { return interface_js_1.Result; } }));
var typed_js_1 = __webpack_require__(/*! ./typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
Object.defineProperty(exports, "Typed", ({ enumerable: true, get: function () { return typed_js_1.Typed; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/interface.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/interface.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  The Interface class is a low-level class that accepts an
 *  ABI and provides all the necessary functionality to encode
 *  and decode paramaters to and results from methods, events
 *  and errors.
 *
 *  It also provides several convenience methods to automatically
 *  search and find matching transactions and events to parse them.
 *
 *  @_subsection api/abi:Interfaces  [interfaces]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ "../node_modules/ethers/lib.commonjs/abi/abi-coder.js");
const abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ "../node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js");
Object.defineProperty(exports, "checkResultErrors", ({ enumerable: true, get: function () { return abstract_coder_js_1.checkResultErrors; } }));
Object.defineProperty(exports, "Result", ({ enumerable: true, get: function () { return abstract_coder_js_1.Result; } }));
const fragments_js_1 = __webpack_require__(/*! ./fragments.js */ "../node_modules/ethers/lib.commonjs/abi/fragments.js");
const typed_js_1 = __webpack_require__(/*! ./typed.js */ "../node_modules/ethers/lib.commonjs/abi/typed.js");
/**
 *  When using the [[Interface-parseLog]] to automatically match a Log to its event
 *  for parsing, a **LogDescription** is returned.
 */
class LogDescription {
    /**
     *  The matching fragment for the ``topic0``.
     */
    fragment;
    /**
     *  The name of the Event.
     */
    name;
    /**
     *  The full Event signature.
     */
    signature;
    /**
     *  The topic hash for the Event.
     */
    topic;
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    args;
    /**
     *  @_ignore:
     */
    constructor(fragment, topic, args) {
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
            fragment, name, signature, topic, args
        });
    }
}
exports.LogDescription = LogDescription;
/**
 *  When using the [[Interface-parseTransaction]] to automatically match
 *  a transaction data to its function for parsing,
 *  a **TransactionDescription** is returned.
 */
class TransactionDescription {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    fragment;
    /**
     *  The name of the Function from the transaction ``data``.
     */
    name;
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    args;
    /**
     *  The full Function signature from the transaction ``data``.
     */
    signature;
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    selector;
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    value;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args, value) {
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
            fragment, name, args, signature, selector, value
        });
    }
}
exports.TransactionDescription = TransactionDescription;
/**
 *  When using the [[Interface-parseError]] to automatically match an
 *  error for a call result for parsing, an **ErrorDescription** is returned.
 */
class ErrorDescription {
    /**
     *  The matching fragment.
     */
    fragment;
    /**
     *  The name of the Error.
     */
    name;
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    args;
    /**
     *  The full Error signature.
     */
    signature;
    /**
     *  The selector for the Error.
     */
    selector;
    /**
     *  @_ignore:
     */
    constructor(fragment, selector, args) {
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
            fragment, name, args, signature, selector
        });
    }
}
exports.ErrorDescription = ErrorDescription;
/**
 *  An **Indexed** is used as a value when a value that does not
 *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
 *  is the ``keccak256`` of the value, and used for types such as
 *  arrays, tuples, bytes and strings.
 */
class Indexed {
    /**
     *  The ``keccak256`` of the value logged.
     */
    hash;
    /**
     *  @_ignore:
     */
    _isIndexed;
    /**
     *  Returns ``true`` if %%value%% is an **Indexed**.
     *
     *  This provides a Type Guard for property access.
     */
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
    /**
     *  @_ignore:
     */
    constructor(hash) {
        (0, index_js_3.defineProperties)(this, { hash, _isIndexed: true });
    }
}
exports.Indexed = Indexed;
// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
const PanicReasons = {
    "0": "generic panic",
    "1": "assert(false)",
    "17": "arithmetic overflow",
    "18": "division or modulo by zero",
    "33": "enum overflow",
    "34": "invalid encoded storage byte array accessed",
    "49": "out-of-bounds array access; popping on an empty array",
    "50": "out-of-bounds access of an array or bytesN",
    "65": "out of memory",
    "81": "uninitialized function",
};
const BuiltinErrors = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: (message) => {
            return `reverted with reason string ${JSON.stringify(message)}`;
        }
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: (code) => {
            let reason = "unknown panic code";
            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
                reason = PanicReasons[code.toString()];
            }
            return `reverted with panic code 0x${code.toString(16)} (${reason})`;
        }
    }
};
/**
 *  An Interface abstracts many of the low-level details for
 *  encoding and decoding the data on the blockchain.
 *
 *  An ABI provides information on how to encode data to send to
 *  a Contract, how to decode the results and events and how to
 *  interpret revert errors.
 *
 *  The ABI can be specified by [any supported format](InterfaceAbi).
 */
class Interface {
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    fragments;
    /**
     *  The Contract constructor.
     */
    deploy;
    /**
     *  The Fallback method, if any.
     */
    fallback;
    /**
     *  If receiving ether is supported.
     */
    receive;
    #errors;
    #events;
    #functions;
    //    #structs: Map<string, StructFragment>;
    #abiCoder;
    /**
     *  Create a new Interface for the %%fragments%%.
     */
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        this.#functions = new Map();
        this.#errors = new Map();
        this.#events = new Map();
        //        this.#structs = new Map();
        const frags = [];
        for (const a of abi) {
            try {
                frags.push(fragments_js_1.Fragment.from(a));
            }
            catch (error) {
                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
            }
        }
        (0, index_js_3.defineProperties)(this, {
            fragments: Object.freeze(frags)
        });
        let fallback = null;
        let receive = false;
        this.#abiCoder = this.getAbiCoder();
        // Add all fragments by their signature
        this.fragments.forEach((fragment, index) => {
            let bucket;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        console.log("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    (0, index_js_3.defineProperties)(this, { deploy: fragment });
                    return;
                case "fallback":
                    if (fragment.inputs.length === 0) {
                        receive = true;
                    }
                    else {
                        (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
                        fallback = fragment;
                        receive = fallback.payable;
                    }
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.#functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.#events;
                    break;
                case "error":
                    bucket = this.#errors;
                    break;
                default:
                    return;
            }
            // Two identical entries; ignore it
            const signature = fragment.format();
            if (bucket.has(signature)) {
                return;
            }
            bucket.set(signature, fragment);
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            (0, index_js_3.defineProperties)(this, {
                deploy: fragments_js_1.ConstructorFragment.from("constructor()")
            });
        }
        (0, index_js_3.defineProperties)(this, { fallback, receive });
    }
    /**
     *  Returns the entire Human-Readable ABI, as an array of
     *  signatures, optionally as %%minimal%% strings, which
     *  removes parameter names and unneceesary spaces.
     */
    format(minimal) {
        const format = (minimal ? "minimal" : "full");
        const abi = this.fragments.map((f) => f.format(format));
        return abi;
    }
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
    formatJson() {
        const abi = this.fragments.map((f) => f.format("json"));
        // We need to re-bundle the JSON fragments a bit
        return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
    getAbiCoder() {
        return abi_coder_js_1.AbiCoder.defaultAbiCoder();
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    #getFunction(key, values, forceUnique) {
        // Selector
        if ((0, index_js_3.isHexString)(key)) {
            const selector = key.toLowerCase();
            for (const fragment of this.#functions.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#functions) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                const lastValue = (values.length > 0) ? values[values.length - 1] : null;
                let valueLength = values.length;
                let allowOptions = true;
                if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === "overrides") {
                    allowOptions = false;
                    valueLength--;
                }
                // Remove all matches that don't have a compatible length. The args
                // may contain an overrides, so the match may have n or n - 1 parameters
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs.length;
                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!typed_js_1.Typed.isTyped(values[j])) {
                            continue;
                        }
                        // We are past the inputs
                        if (j >= inputs.length) {
                            if (values[j].type === "overrides") {
                                continue;
                            }
                            matching.splice(i, 1);
                            break;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            // We found a single matching signature with an overrides, but the
            // last value is something that cannot possibly be an options
            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
                const lastArg = values[values.length - 1];
                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== "object") {
                    matching.splice(0, 1);
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#functions.get(fragments_js_1.FunctionFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    getFunctionName(key) {
        const fragment = this.#getFunction(key, null, false);
        (0, index_js_3.assertArgument)(fragment, "no matching function", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (a function selector, function name or
     *  function signature) is present in the ABI.
     *
     *  In the case of a function name, the name may be ambiguous, so
     *  accessing the [[FunctionFragment]] may require refinement.
     */
    hasFunction(key) {
        return !!this.#getFunction(key, null, false);
    }
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
    getFunction(key, values) {
        return this.#getFunction(key, values || null, true);
    }
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
    forEachFunction(callback) {
        const names = Array.from(this.#functions.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#functions.get(name)), i);
        }
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    #getEvent(key, values, forceUnique) {
        // EventTopic
        if ((0, index_js_3.isHexString)(key)) {
            const eventTopic = key.toLowerCase();
            for (const fragment of this.#events.values()) {
                if (eventTopic === fragment.topicHash) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#events) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (values) {
                // Remove all matches that don't have a compatible length.
                for (let i = matching.length - 1; i >= 0; i--) {
                    if (matching[i].inputs.length < values.length) {
                        matching.splice(i, 1);
                    }
                }
                // Remove all matches that don't match the Typed signature
                for (let i = matching.length - 1; i >= 0; i--) {
                    const inputs = matching[i].inputs;
                    for (let j = 0; j < values.length; j++) {
                        // Not a typed value
                        if (!typed_js_1.Typed.isTyped(values[j])) {
                            continue;
                        }
                        // Make sure the value type matches the input type
                        if (values[j].type !== inputs[j].baseType) {
                            matching.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            if (matching.length === 0) {
                return null;
            }
            if (matching.length > 1 && forceUnique) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        const result = this.#events.get(fragments_js_1.EventFragment.from(key).format());
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    getEventName(key) {
        const fragment = this.#getEvent(key, null, false);
        (0, index_js_3.assertArgument)(fragment, "no matching event", "key", key);
        return fragment.name;
    }
    /**
     *  Returns true if %%key%% (an event topic hash, event name or
     *  event signature) is present in the ABI.
     *
     *  In the case of an event name, the name may be ambiguous, so
     *  accessing the [[EventFragment]] may require refinement.
     */
    hasEvent(key) {
        return !!this.#getEvent(key, null, false);
    }
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
    getEvent(key, values) {
        return this.#getEvent(key, values || null, true);
    }
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
    forEachEvent(callback) {
        const names = Array.from(this.#events.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#events.get(name)), i);
        }
    }
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
    getError(key, values) {
        if ((0, index_js_3.isHexString)(key)) {
            const selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
                return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            for (const fragment of this.#errors.values()) {
                if (selector === fragment.selector) {
                    return fragment;
                }
            }
            return null;
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#errors) {
                if (name.split("(" /* fix:) */)[0] === key) {
                    matching.push(fragment);
                }
            }
            if (matching.length === 0) {
                if (key === "Error") {
                    return fragments_js_1.ErrorFragment.from("error Error(string)");
                }
                if (key === "Panic") {
                    return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
                }
                return null;
            }
            else if (matching.length > 1) {
                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
                (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
            }
            return matching[0];
        }
        // Normalize the signature and lookup the function
        key = fragments_js_1.ErrorFragment.from(key).format();
        if (key === "Error(string)") {
            return fragments_js_1.ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic(uint256)") {
            return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
        }
        const result = this.#errors.get(key);
        if (result) {
            return result;
        }
        return null;
    }
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
    forEachError(callback) {
        const names = Array.from(this.#errors.keys());
        names.sort((a, b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback((this.#errors.get(name)), i);
        }
    }
    // Get the 4-byte selector used by Solidity to identify a function
    /*
getSelector(fragment: ErrorFragment | FunctionFragment): string {
    if (typeof(fragment) === "string") {
        const matches: Array<Fragment> = [ ];

        try { matches.push(this.getFunction(fragment)); } catch (error) { }
        try { matches.push(this.getError(<string>fragment)); } catch (_) { }

        if (matches.length === 0) {
            logger.throwArgumentError("unknown fragment", "key", fragment);
        } else if (matches.length > 1) {
            logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
        }

        fragment = matches[0];
    }

    return dataSlice(id(fragment.format()), 0, 4);
}
    */
    // Get the 32-byte topic hash used by Solidity to identify an event
    /*
    getEventTopic(fragment: EventFragment): string {
        //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
        return id(fragment.format());
    }
    */
    _decodeParams(params, data) {
        return this.#abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this.#abiCoder.encode(params, values);
    }
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
    }
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
        }
        return (0, index_js_3.concat)([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
    decodeFunctionData(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
    }
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
    encodeFunctionData(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return (0, index_js_3.concat)([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
        ]);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeFunctionResult(fragment, data) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        let message = "invalid length for result data";
        const bytes = (0, index_js_3.getBytesCopy)(data);
        if ((bytes.length % 32) === 0) {
            try {
                return this.#abiCoder.decode(fragment.outputs, bytes);
            }
            catch (error) {
                message = "could not decode result data";
            }
        }
        // Call returned data with no error, but the data is junk
        (0, index_js_3.assert)(false, message, "BAD_DATA", {
            value: (0, index_js_3.hexlify)(bytes),
            info: { method: fragment.name, signature: fragment.format() }
        });
    }
    makeError(_data, tx) {
        const data = (0, index_js_3.getBytes)(_data, "data");
        const error = abi_coder_js_1.AbiCoder.getBuiltinCallException("call", tx, data);
        // Not a built-in error; try finding a custom error
        const customPrefix = "execution reverted (unknown custom error)";
        if (error.message.startsWith(customPrefix)) {
            const selector = (0, index_js_3.hexlify)(data.slice(0, 4));
            const ef = this.getError(selector);
            if (ef) {
                try {
                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                    error.revert = {
                        name: ef.name, signature: ef.format(), args
                    };
                    error.reason = error.revert.signature;
                    error.message = `execution reverted: ${error.reason}`;
                }
                catch (e) {
                    error.message = `execution reverted (coult not decode custom error)`;
                }
            }
        }
        // Add the invocation, if available
        const parsed = this.parseTransaction(tx);
        if (parsed) {
            error.invocation = {
                method: parsed.name,
                signature: parsed.signature,
                args: parsed.args
            };
        }
        return error;
    }
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeFunctionResult(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
        }
        return (0, index_js_3.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));
    }
    /*
        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
            const promises: Array<Promise<>> = [ ];
            const process = function(type: ParamType, value: any): any {
                if (type.baseType === "array") {
                    return descend(type.child
                }
                if (type. === "address") {
                }
            };
    
            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                
            };
    
            const result: Array<any> = [ ];
            values.forEach((value, index) => {
                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            });
        }
    */
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
        const topics = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        // @TODO: Use the coders for this; to properly support tuples, etc.
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return (0, index_js_2.id)(value);
            }
            else if (param.type === "bytes") {
                return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            else if (param.type.match(/^u?int/)) {
                value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??
            }
            else if (param.type.match(/^bytes/)) {
                value = (0, index_js_3.zeroPadBytes)(value, 32);
            }
            else if (param.type === "address") {
                // Check addresses are valid
                this.#abiCoder.encode(["address"], [value]);
            }
            return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);
        };
        values.forEach((value, index) => {
            const param = fragment.inputs[index];
            if (!param.indexed) {
                (0, index_js_3.assertArgument)(value == null, "cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                (0, index_js_3.assertArgument)(false, "filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(fragment, values) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
        }
        (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
        fragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push((0, index_js_2.id)(value));
                }
                else if (param.type === "bytes") {
                    topics.push((0, index_js_1.keccak256)(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this.#abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this.#abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(fragment, data, topics) {
        if (typeof (fragment) === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
        }
        if (topics != null && !fragment.anonymous) {
            const eventTopic = fragment.topicHash;
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
        }
        const indexed = [];
        const nonIndexed = [];
        const dynamic = [];
        fragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(fragments_js_1.ParamType.from({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, (0, index_js_3.concat)(topics)) : null;
        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
        //const result: (Array<any> & { [ key: string ]: any }) = [ ];
        const values = [];
        const keys = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        fragment.inputs.forEach((param, index) => {
            let value = null;
            if (param.indexed) {
                if (resultIndexed == null) {
                    value = new Indexed(null);
                }
                else if (dynamic[index]) {
                    value = new Indexed(resultIndexed[indexedIndex++]);
                }
                else {
                    try {
                        value = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        value = error;
                    }
                }
            }
            else {
                try {
                    value = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    value = error;
                }
            }
            values.push(value);
            keys.push(param.name || null);
        });
        return abstract_coder_js_1.Result.fromItems(values, keys);
    }
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
    parseTransaction(tx) {
        const data = (0, index_js_3.getBytes)(tx.data, "tx.data");
        const value = (0, index_js_3.getBigInt)((tx.value != null) ? tx.value : 0, "tx.value");
        const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
        return new TransactionDescription(fragment, fragment.selector, args, value);
    }
    parseCallResult(data) {
        throw new Error("@TODO");
    }
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
    parseLog(log) {
        const fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching error cannot be found, returns null.
     */
    parseError(data) {
        const hexData = (0, index_js_3.hexlify)(data);
        const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));
        if (!fragment) {
            return null;
        }
        const args = this.#abiCoder.decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));
        return new ErrorDescription(fragment, fragment.selector, args);
    }
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
    static from(value) {
        // Already an Interface, which is immutable
        if (value instanceof Interface) {
            return value;
        }
        // JSON
        if (typeof (value) === "string") {
            return new Interface(JSON.parse(value));
        }
        // An Interface; possibly from another v6 instance
        if (typeof (value.formatJson) === "function") {
            return new Interface(value.formatJson());
        }
        // A legacy Interface; from an older version
        if (typeof (value.format) === "function") {
            return new Interface(value.format("json"));
        }
        // Array of fragments
        return new Interface(value);
    }
}
exports.Interface = Interface;
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/abi/typed.js":
/*!********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/abi/typed.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A Typed object allows a value to have its type explicitly
 *  specified.
 *
 *  For example, in Solidity, the value ``45`` could represent a
 *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent
 *  a ``bytes2`` or ``bytes``.
 *
 *  Since JavaScript has no meaningful way to explicitly inform any
 *  APIs which what the type is, this allows transparent interoperation
 *  with Soldity.
 *
 *  @_subsection: api/abi:Typed Values
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Typed = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const _gaurd = {};
function n(value, width) {
    let signed = false;
    if (width < 0) {
        signed = true;
        width *= -1;
    }
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size) {
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, `bytes${(size) ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
/**
 *  The **Typed** class to wrap values providing explicit type information.
 */
class Typed {
    /**
     *  The type, as a Solidity-compatible type.
     */
    type;
    /**
     *  The actual value.
     */
    value;
    #options;
    /**
     *  @_ignore:
     */
    _typedSymbol;
    /**
     *  @_ignore:
     */
    constructor(gaurd, type, value, options) {
        if (options == null) {
            options = null;
        }
        (0, index_js_1.assertPrivate)(_gaurd, gaurd, "Typed");
        (0, index_js_1.defineProperties)(this, { _typedSymbol, type, value });
        this.#options = options;
        // Check the value is valid
        this.format();
    }
    /**
     *  Format the type as a Human-Readable type.
     */
    format() {
        if (this.type === "array") {
            throw new Error("");
        }
        else if (this.type === "dynamicArray") {
            throw new Error("");
        }
        else if (this.type === "tuple") {
            return `tuple(${this.value.map((v) => v.format()).join(",")})`;
        }
        return this.type;
    }
    /**
     *  The default value returned by this type.
     */
    defaultValue() {
        return 0;
    }
    /**
     *  The minimum value for numeric types.
     */
    minValue() {
        return 0;
    }
    /**
     *  The maximum value for numeric types.
     */
    maxValue() {
        return 0;
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
     */
    isBigInt() {
        return !!(this.type.match(/^u?int[0-9]+$/));
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
     */
    isData() {
        return this.type.startsWith("bytes");
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
     */
    isString() {
        return (this.type === "string");
    }
    /**
     *  Returns the tuple name, if this is a tuple. Throws otherwise.
     */
    get tupleName() {
        if (this.type !== "tuple") {
            throw TypeError("not a tuple");
        }
        return this.#options;
    }
    // Returns the length of this type as an array
    // - `null` indicates the length is unforced, it could be dynamic
    // - `-1` indicates the length is dynamic
    // - any other value indicates it is a static array and is its length
    /**
     *  Returns the length of the array type or ``-1`` if it is dynamic.
     *
     *  Throws if the type is not an array.
     */
    get arrayLength() {
        if (this.type !== "array") {
            throw TypeError("not an array");
        }
        if (this.#options === true) {
            return -1;
        }
        if (this.#options === false) {
            return (this.value).length;
        }
        return null;
    }
    /**
     *  Returns a new **Typed** of %%type%% with the %%value%%.
     */
    static from(type, value) {
        return new Typed(_gaurd, type, value);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static uint8(v) { return n(v, 8); }
    /**
     *  Return a new ``uint16`` type for %%v%%.
     */
    static uint16(v) { return n(v, 16); }
    /**
     *  Return a new ``uint24`` type for %%v%%.
     */
    static uint24(v) { return n(v, 24); }
    /**
     *  Return a new ``uint32`` type for %%v%%.
     */
    static uint32(v) { return n(v, 32); }
    /**
     *  Return a new ``uint40`` type for %%v%%.
     */
    static uint40(v) { return n(v, 40); }
    /**
     *  Return a new ``uint48`` type for %%v%%.
     */
    static uint48(v) { return n(v, 48); }
    /**
     *  Return a new ``uint56`` type for %%v%%.
     */
    static uint56(v) { return n(v, 56); }
    /**
     *  Return a new ``uint64`` type for %%v%%.
     */
    static uint64(v) { return n(v, 64); }
    /**
     *  Return a new ``uint72`` type for %%v%%.
     */
    static uint72(v) { return n(v, 72); }
    /**
     *  Return a new ``uint80`` type for %%v%%.
     */
    static uint80(v) { return n(v, 80); }
    /**
     *  Return a new ``uint88`` type for %%v%%.
     */
    static uint88(v) { return n(v, 88); }
    /**
     *  Return a new ``uint96`` type for %%v%%.
     */
    static uint96(v) { return n(v, 96); }
    /**
     *  Return a new ``uint104`` type for %%v%%.
     */
    static uint104(v) { return n(v, 104); }
    /**
     *  Return a new ``uint112`` type for %%v%%.
     */
    static uint112(v) { return n(v, 112); }
    /**
     *  Return a new ``uint120`` type for %%v%%.
     */
    static uint120(v) { return n(v, 120); }
    /**
     *  Return a new ``uint128`` type for %%v%%.
     */
    static uint128(v) { return n(v, 128); }
    /**
     *  Return a new ``uint136`` type for %%v%%.
     */
    static uint136(v) { return n(v, 136); }
    /**
     *  Return a new ``uint144`` type for %%v%%.
     */
    static uint144(v) { return n(v, 144); }
    /**
     *  Return a new ``uint152`` type for %%v%%.
     */
    static uint152(v) { return n(v, 152); }
    /**
     *  Return a new ``uint160`` type for %%v%%.
     */
    static uint160(v) { return n(v, 160); }
    /**
     *  Return a new ``uint168`` type for %%v%%.
     */
    static uint168(v) { return n(v, 168); }
    /**
     *  Return a new ``uint176`` type for %%v%%.
     */
    static uint176(v) { return n(v, 176); }
    /**
     *  Return a new ``uint184`` type for %%v%%.
     */
    static uint184(v) { return n(v, 184); }
    /**
     *  Return a new ``uint192`` type for %%v%%.
     */
    static uint192(v) { return n(v, 192); }
    /**
     *  Return a new ``uint200`` type for %%v%%.
     */
    static uint200(v) { return n(v, 200); }
    /**
     *  Return a new ``uint208`` type for %%v%%.
     */
    static uint208(v) { return n(v, 208); }
    /**
     *  Return a new ``uint216`` type for %%v%%.
     */
    static uint216(v) { return n(v, 216); }
    /**
     *  Return a new ``uint224`` type for %%v%%.
     */
    static uint224(v) { return n(v, 224); }
    /**
     *  Return a new ``uint232`` type for %%v%%.
     */
    static uint232(v) { return n(v, 232); }
    /**
     *  Return a new ``uint240`` type for %%v%%.
     */
    static uint240(v) { return n(v, 240); }
    /**
     *  Return a new ``uint248`` type for %%v%%.
     */
    static uint248(v) { return n(v, 248); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint256(v) { return n(v, 256); }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint(v) { return n(v, 256); }
    /**
     *  Return a new ``int8`` type for %%v%%.
     */
    static int8(v) { return n(v, -8); }
    /**
     *  Return a new ``int16`` type for %%v%%.
     */
    static int16(v) { return n(v, -16); }
    /**
     *  Return a new ``int24`` type for %%v%%.
     */
    static int24(v) { return n(v, -24); }
    /**
     *  Return a new ``int32`` type for %%v%%.
     */
    static int32(v) { return n(v, -32); }
    /**
     *  Return a new ``int40`` type for %%v%%.
     */
    static int40(v) { return n(v, -40); }
    /**
     *  Return a new ``int48`` type for %%v%%.
     */
    static int48(v) { return n(v, -48); }
    /**
     *  Return a new ``int56`` type for %%v%%.
     */
    static int56(v) { return n(v, -56); }
    /**
     *  Return a new ``int64`` type for %%v%%.
     */
    static int64(v) { return n(v, -64); }
    /**
     *  Return a new ``int72`` type for %%v%%.
     */
    static int72(v) { return n(v, -72); }
    /**
     *  Return a new ``int80`` type for %%v%%.
     */
    static int80(v) { return n(v, -80); }
    /**
     *  Return a new ``int88`` type for %%v%%.
     */
    static int88(v) { return n(v, -88); }
    /**
     *  Return a new ``int96`` type for %%v%%.
     */
    static int96(v) { return n(v, -96); }
    /**
     *  Return a new ``int104`` type for %%v%%.
     */
    static int104(v) { return n(v, -104); }
    /**
     *  Return a new ``int112`` type for %%v%%.
     */
    static int112(v) { return n(v, -112); }
    /**
     *  Return a new ``int120`` type for %%v%%.
     */
    static int120(v) { return n(v, -120); }
    /**
     *  Return a new ``int128`` type for %%v%%.
     */
    static int128(v) { return n(v, -128); }
    /**
     *  Return a new ``int136`` type for %%v%%.
     */
    static int136(v) { return n(v, -136); }
    /**
     *  Return a new ``int144`` type for %%v%%.
     */
    static int144(v) { return n(v, -144); }
    /**
     *  Return a new ``int52`` type for %%v%%.
     */
    static int152(v) { return n(v, -152); }
    /**
     *  Return a new ``int160`` type for %%v%%.
     */
    static int160(v) { return n(v, -160); }
    /**
     *  Return a new ``int168`` type for %%v%%.
     */
    static int168(v) { return n(v, -168); }
    /**
     *  Return a new ``int176`` type for %%v%%.
     */
    static int176(v) { return n(v, -176); }
    /**
     *  Return a new ``int184`` type for %%v%%.
     */
    static int184(v) { return n(v, -184); }
    /**
     *  Return a new ``int92`` type for %%v%%.
     */
    static int192(v) { return n(v, -192); }
    /**
     *  Return a new ``int200`` type for %%v%%.
     */
    static int200(v) { return n(v, -200); }
    /**
     *  Return a new ``int208`` type for %%v%%.
     */
    static int208(v) { return n(v, -208); }
    /**
     *  Return a new ``int216`` type for %%v%%.
     */
    static int216(v) { return n(v, -216); }
    /**
     *  Return a new ``int224`` type for %%v%%.
     */
    static int224(v) { return n(v, -224); }
    /**
     *  Return a new ``int232`` type for %%v%%.
     */
    static int232(v) { return n(v, -232); }
    /**
     *  Return a new ``int240`` type for %%v%%.
     */
    static int240(v) { return n(v, -240); }
    /**
     *  Return a new ``int248`` type for %%v%%.
     */
    static int248(v) { return n(v, -248); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int256(v) { return n(v, -256); }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int(v) { return n(v, -256); }
    /**
     *  Return a new ``bytes1`` type for %%v%%.
     */
    static bytes1(v) { return b(v, 1); }
    /**
     *  Return a new ``bytes2`` type for %%v%%.
     */
    static bytes2(v) { return b(v, 2); }
    /**
     *  Return a new ``bytes3`` type for %%v%%.
     */
    static bytes3(v) { return b(v, 3); }
    /**
     *  Return a new ``bytes4`` type for %%v%%.
     */
    static bytes4(v) { return b(v, 4); }
    /**
     *  Return a new ``bytes5`` type for %%v%%.
     */
    static bytes5(v) { return b(v, 5); }
    /**
     *  Return a new ``bytes6`` type for %%v%%.
     */
    static bytes6(v) { return b(v, 6); }
    /**
     *  Return a new ``bytes7`` type for %%v%%.
     */
    static bytes7(v) { return b(v, 7); }
    /**
     *  Return a new ``bytes8`` type for %%v%%.
     */
    static bytes8(v) { return b(v, 8); }
    /**
     *  Return a new ``bytes9`` type for %%v%%.
     */
    static bytes9(v) { return b(v, 9); }
    /**
     *  Return a new ``bytes10`` type for %%v%%.
     */
    static bytes10(v) { return b(v, 10); }
    /**
     *  Return a new ``bytes11`` type for %%v%%.
     */
    static bytes11(v) { return b(v, 11); }
    /**
     *  Return a new ``bytes12`` type for %%v%%.
     */
    static bytes12(v) { return b(v, 12); }
    /**
     *  Return a new ``bytes13`` type for %%v%%.
     */
    static bytes13(v) { return b(v, 13); }
    /**
     *  Return a new ``bytes14`` type for %%v%%.
     */
    static bytes14(v) { return b(v, 14); }
    /**
     *  Return a new ``bytes15`` type for %%v%%.
     */
    static bytes15(v) { return b(v, 15); }
    /**
     *  Return a new ``bytes16`` type for %%v%%.
     */
    static bytes16(v) { return b(v, 16); }
    /**
     *  Return a new ``bytes17`` type for %%v%%.
     */
    static bytes17(v) { return b(v, 17); }
    /**
     *  Return a new ``bytes18`` type for %%v%%.
     */
    static bytes18(v) { return b(v, 18); }
    /**
     *  Return a new ``bytes19`` type for %%v%%.
     */
    static bytes19(v) { return b(v, 19); }
    /**
     *  Return a new ``bytes20`` type for %%v%%.
     */
    static bytes20(v) { return b(v, 20); }
    /**
     *  Return a new ``bytes21`` type for %%v%%.
     */
    static bytes21(v) { return b(v, 21); }
    /**
     *  Return a new ``bytes22`` type for %%v%%.
     */
    static bytes22(v) { return b(v, 22); }
    /**
     *  Return a new ``bytes23`` type for %%v%%.
     */
    static bytes23(v) { return b(v, 23); }
    /**
     *  Return a new ``bytes24`` type for %%v%%.
     */
    static bytes24(v) { return b(v, 24); }
    /**
     *  Return a new ``bytes25`` type for %%v%%.
     */
    static bytes25(v) { return b(v, 25); }
    /**
     *  Return a new ``bytes26`` type for %%v%%.
     */
    static bytes26(v) { return b(v, 26); }
    /**
     *  Return a new ``bytes27`` type for %%v%%.
     */
    static bytes27(v) { return b(v, 27); }
    /**
     *  Return a new ``bytes28`` type for %%v%%.
     */
    static bytes28(v) { return b(v, 28); }
    /**
     *  Return a new ``bytes29`` type for %%v%%.
     */
    static bytes29(v) { return b(v, 29); }
    /**
     *  Return a new ``bytes30`` type for %%v%%.
     */
    static bytes30(v) { return b(v, 30); }
    /**
     *  Return a new ``bytes31`` type for %%v%%.
     */
    static bytes31(v) { return b(v, 31); }
    /**
     *  Return a new ``bytes32`` type for %%v%%.
     */
    static bytes32(v) { return b(v, 32); }
    /**
     *  Return a new ``address`` type for %%v%%.
     */
    static address(v) { return new Typed(_gaurd, "address", v); }
    /**
     *  Return a new ``bool`` type for %%v%%.
     */
    static bool(v) { return new Typed(_gaurd, "bool", !!v); }
    /**
     *  Return a new ``bytes`` type for %%v%%.
     */
    static bytes(v) { return new Typed(_gaurd, "bytes", v); }
    /**
     *  Return a new ``string`` type for %%v%%.
     */
    static string(v) { return new Typed(_gaurd, "string", v); }
    /**
     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
     */
    static array(v, dynamic) {
        throw new Error("not implemented yet");
        return new Typed(_gaurd, "array", v, dynamic);
    }
    /**
     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
     */
    static tuple(v, name) {
        throw new Error("not implemented yet");
        return new Typed(_gaurd, "tuple", v, name);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static overrides(v) {
        return new Typed(_gaurd, "overrides", Object.assign({}, v));
    }
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
    static isTyped(value) {
        return (value
            && typeof (value) === "object"
            && "_typedSymbol" in value
            && value._typedSymbol === _typedSymbol);
    }
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
    static dereference(value, type) {
        if (Typed.isTyped(value)) {
            if (value.type !== type) {
                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
            }
            return value.value;
        }
        return value;
    }
}
exports.Typed = Typed;
//# sourceMappingURL=typed.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/address/address.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/address/address.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIcapAddress = exports.getAddress = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const BN_0 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
    //    if (!isHexString(address, 20)) {
    //        logger.throwArgumentError("invalid address", "address", address);
    //    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
const safeDigits = 15;
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
const Base36 = (function () {
    ;
    const result = {};
    for (let i = 0; i < 36; i++) {
        const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
        result[key] = BigInt(i);
    }
    return result;
})();
function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_0;
    for (let i = 0; i < value.length; i++) {
        result = result * BN_36 + Base36[value[i]];
    }
    return result;
}
/**
 *  Returns a normalized and checksumed address for %%address%%.
 *  This accepts non-checksum addresses, checksum addresses and
 *  [[getIcapAddress]] formats.
 *
 *  The checksum in Ethereum uses the capitalization (upper-case
 *  vs lower-case) of the characters within an address to encode
 *  its checksum, which offers, on average, a checksum of 15-bits.
 *
 *  If %%address%% contains both upper-case and lower-case, it is
 *  assumed to already be a checksum address and its checksum is
 *  validated, and if the address fails its expected checksum an
 *  error is thrown.
 *
 *  If you wish the checksum of %%address%% to be ignore, it should
 *  be converted to lower-case (i.e. ``.toLowercase()``) before
 *  being passed in. This should be a very rare situation though,
 *  that you wish to bypass the safegaurds in place to protect
 *  against an address that has been incorrectly copied from another
 *  source.
 *
 *  @example:
 *    // Adds the checksum (via upper-casing specific letters)
 *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
 *    //_result:
 *
 *    // Converts ICAP address and adds checksum
 *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if an address contains mixed case,
 *    // but the checksum fails
 *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_error:
 */
function getAddress(address) {
    (0, index_js_2.assertArgument)(typeof (address) === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (!address.startsWith("0x")) {
            address = "0x" + address;
        }
        const result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
        return result;
    }
    // Maybe ICAP? (we only support direct mode)
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
        let result = fromBase36(address.substring(4)).toString(16);
        while (result.length < 40) {
            result = "0" + result;
        }
        return getChecksumAddress("0x" + result);
    }
    (0, index_js_2.assertArgument)(false, "invalid address", "address", address);
}
exports.getAddress = getAddress;
/**
 *  The [ICAP Address format](link-icap) format is an early checksum
 *  format which attempts to be compatible with the banking
 *  industry [IBAN format](link-wiki-iban) for bank accounts.
 *
 *  It is no longer common or a recommended format.
 *
 *  @example:
 *    getIcapAddress("0x8ba1f109551bd432803012645ac136ddd64dba72");
 *    //_result:
 *
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if the ICAP checksum is wrong
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37");
 *    //_error:
 */
function getIcapAddress(address) {
    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
exports.getIcapAddress = getIcapAddress;
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/address/checks.js":
/*!*************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/address/checks.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const address_js_1 = __webpack_require__(/*! ./address.js */ "../node_modules/ethers/lib.commonjs/address/address.js");
/**
 *  Returns true if %%value%% is an object which implements the
 *  [[Addressable]] interface.
 *
 *  @example:
 *    // Wallets and AbstractSigner sub-classes
 *    isAddressable(Wallet.createRandom())
 *    //_result:
 *
 *    // Contracts
 *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
 *    isAddressable(contract)
 *    //_result:
 */
function isAddressable(value) {
    return (value && typeof (value.getAddress) === "function");
}
exports.isAddressable = isAddressable;
/**
 *  Returns true if %%value%% is a valid address.
 *
 *  @example:
 *    // Valid address
 *    isAddress("0x8ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Valid ICAP address
 *    isAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36")
 *    //_result:
 *
 *    // Invalid checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBa72")
 *    //_result:
 *
 *    // Invalid ICAP checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Not an address (an ENS name requires a provided and an
 *    // asynchronous API to access)
 *    isAddress("ricmoo.eth")
 *    //_result:
 */
function isAddress(value) {
    try {
        (0, address_js_1.getAddress)(value);
        return true;
    }
    catch (error) { }
    return false;
}
exports.isAddress = isAddress;
async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === "0x0000000000000000000000000000000000000000") {
        (0, index_js_1.assert)(typeof (target) !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
        (0, index_js_1.assertArgument)(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
    }
    return (0, address_js_1.getAddress)(result);
}
/**
 *  Resolves to an address for the %%target%%, which may be any
 *  supported address type, an [[Addressable]] or a Promise which
 *  resolves to an address.
 *
 *  If an ENS name is provided, but that name has not been correctly
 *  configured a [[UnconfiguredNameError]] is thrown.
 *
 *  @example:
 *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
 *
 *    // Addresses are return synchronously
 *    resolveAddress(addr, provider)
 *    //_result:
 *
 *    // Address promises are resolved asynchronously
 *    resolveAddress(Promise.resolve(addr))
 *    //_result:
 *
 *    // ENS names are resolved asynchronously
 *    resolveAddress("dai.tokens.ethers.eth", provider)
 *    //_result:
 *
 *    // Addressable objects are resolved asynchronously
 *    contract = new Contract(addr, [ ])
 *    resolveAddress(contract, provider)
 *    //_result:
 *
 *    // Unconfigured ENS names reject
 *    resolveAddress("nothing-here.ricmoo.eth", provider)
 *    //_error:
 *
 *    // ENS names require a NameResolver object passed in
 *    // (notice the provider was omitted)
 *    resolveAddress("nothing-here.ricmoo.eth")
 *    //_error:
 */
function resolveAddress(target, resolver) {
    if (typeof (target) === "string") {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return (0, address_js_1.getAddress)(target);
        }
        (0, index_js_1.assert)(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
        return checkAddress(target, resolver.resolveName(target));
    }
    else if (isAddressable(target)) {
        return checkAddress(target, target.getAddress());
    }
    else if (target && typeof (target.then) === "function") {
        return checkAddress(target, target);
    }
    (0, index_js_1.assertArgument)(false, "unsupported addressable value", "target", target);
}
exports.resolveAddress = resolveAddress;
//# sourceMappingURL=checks.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/address/contract-address.js":
/*!***********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/address/contract-address.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCreate2Address = exports.getCreateAddress = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const address_js_1 = __webpack_require__(/*! ./address.js */ "../node_modules/ethers/lib.commonjs/address/address.js");
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
/**
 *  Returns the address that would result from a ``CREATE`` for %%tx%%.
 *
 *  This can be used to compute the address a contract will be
 *  deployed to by an EOA when sending a deployment transaction (i.e.
 *  when the ``to`` address is ``null``).
 *
 *  This can also be used to compute the address a contract will be
 *  deployed to by a contract, by using the contract's address as the
 *  ``to`` and the contract's nonce.
 *
 *  @example
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
 *    nonce = 5;
 *
 *    getCreateAddress({ from, nonce });
 *    //_result:
 */
function getCreateAddress(tx) {
    const from = (0, address_js_1.getAddress)(tx.from);
    const nonce = (0, index_js_2.getBigInt)(tx.nonce, "tx.nonce");
    let nonceHex = nonce.toString(16);
    if (nonceHex === "0") {
        nonceHex = "0x";
    }
    else if (nonceHex.length % 2) {
        nonceHex = "0x0" + nonceHex;
    }
    else {
        nonceHex = "0x" + nonceHex;
    }
    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));
}
exports.getCreateAddress = getCreateAddress;
/**
 *  Returns the address that would result from a ``CREATE2`` operation
 *  with the given %%from%%, %%salt%% and %%initCodeHash%%.
 *
 *  To compute the %%initCodeHash%% from a contract's init code, use
 *  the [[keccak256]] function.
 *
 *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].
 *
 *  @example
 *    // The address of the contract
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72"
 *
 *    // The salt
 *    salt = id("HelloWorld")
 *
 *    // The hash of the initCode
 *    initCode = "0x6394198df16000526103ff60206004601c335afa6040516060f3";
 *    initCodeHash = keccak256(initCode)
 *
 *    getCreate2Address(from, salt, initCodeHash)
 *    //_result:
 */
function getCreate2Address(_from, _salt, _initCodeHash) {
    const from = (0, address_js_1.getAddress)(_from);
    const salt = (0, index_js_2.getBytes)(_salt, "salt");
    const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, "initCodeHash");
    (0, index_js_2.assertArgument)(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
    (0, index_js_2.assertArgument)(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)(["0xff", from, salt, initCodeHash])), 12));
}
exports.getCreate2Address = getCreate2Address;
//# sourceMappingURL=contract-address.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/address/index.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/address/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Addresses are a fundamental part of interacting with Ethereum. They
 *  represent the gloabal identity of Externally Owned Accounts (accounts
 *  backed by a private key) and contracts.
 *
 *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem
 *  of contracts, standards and libraries which enable looking up an
 *  address for an ENS name.
 *
 *  These functions help convert between various formats, validate
 *  addresses and safely resolve ENS names.
 *
 *  @_section: api/address:Addresses  [about-addresses]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;
null;
var address_js_1 = __webpack_require__(/*! ./address.js */ "../node_modules/ethers/lib.commonjs/address/address.js");
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return address_js_1.getAddress; } }));
Object.defineProperty(exports, "getIcapAddress", ({ enumerable: true, get: function () { return address_js_1.getIcapAddress; } }));
var contract_address_js_1 = __webpack_require__(/*! ./contract-address.js */ "../node_modules/ethers/lib.commonjs/address/contract-address.js");
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return contract_address_js_1.getCreateAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return contract_address_js_1.getCreate2Address; } }));
var checks_js_1 = __webpack_require__(/*! ./checks.js */ "../node_modules/ethers/lib.commonjs/address/checks.js");
Object.defineProperty(exports, "isAddressable", ({ enumerable: true, get: function () { return checks_js_1.isAddressable; } }));
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return checks_js_1.isAddress; } }));
Object.defineProperty(exports, "resolveAddress", ({ enumerable: true, get: function () { return checks_js_1.resolveAddress; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/constants/addresses.js":
/*!******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/constants/addresses.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZeroAddress = void 0;
/**
 *  A constant for the zero address.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
 */
exports.ZeroAddress = "0x0000000000000000000000000000000000000000";
//# sourceMappingURL=addresses.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/constants/hashes.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/constants/hashes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZeroHash = void 0;
/**
 *  A constant for the zero hash.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
 */
exports.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/constants/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/constants/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Some common constants useful for Ethereum.
 *
 *  @_section: api/constants: Constants  [about-constants]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;
var addresses_js_1 = __webpack_require__(/*! ./addresses.js */ "../node_modules/ethers/lib.commonjs/constants/addresses.js");
Object.defineProperty(exports, "ZeroAddress", ({ enumerable: true, get: function () { return addresses_js_1.ZeroAddress; } }));
var hashes_js_1 = __webpack_require__(/*! ./hashes.js */ "../node_modules/ethers/lib.commonjs/constants/hashes.js");
Object.defineProperty(exports, "ZeroHash", ({ enumerable: true, get: function () { return hashes_js_1.ZeroHash; } }));
var numbers_js_1 = __webpack_require__(/*! ./numbers.js */ "../node_modules/ethers/lib.commonjs/constants/numbers.js");
Object.defineProperty(exports, "N", ({ enumerable: true, get: function () { return numbers_js_1.N; } }));
Object.defineProperty(exports, "WeiPerEther", ({ enumerable: true, get: function () { return numbers_js_1.WeiPerEther; } }));
Object.defineProperty(exports, "MaxUint256", ({ enumerable: true, get: function () { return numbers_js_1.MaxUint256; } }));
Object.defineProperty(exports, "MinInt256", ({ enumerable: true, get: function () { return numbers_js_1.MinInt256; } }));
Object.defineProperty(exports, "MaxInt256", ({ enumerable: true, get: function () { return numbers_js_1.MaxInt256; } }));
var strings_js_1 = __webpack_require__(/*! ./strings.js */ "../node_modules/ethers/lib.commonjs/constants/strings.js");
Object.defineProperty(exports, "EtherSymbol", ({ enumerable: true, get: function () { return strings_js_1.EtherSymbol; } }));
Object.defineProperty(exports, "MessagePrefix", ({ enumerable: true, get: function () { return strings_js_1.MessagePrefix; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/constants/numbers.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/constants/numbers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;
/**
 *  A constant for the order N for the secp256k1 curve.
 *
 *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
 */
exports.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
/**
 *  A constant for the number of wei in a single ether.
 *
 *  (**i.e.** ``1000000000000000000n``)
 */
exports.WeiPerEther = BigInt("1000000000000000000");
/**
 *  A constant for the maximum value for a ``uint256``.
 *
 *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  A constant for the minimum value for an ``int256``.
 *
 *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
 */
exports.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
/**
 *  A constant for the maximum value for an ``int256``.
 *
 *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
//# sourceMappingURL=numbers.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/constants/strings.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/constants/strings.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// NFKC (composed)             // (decomposed)
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessagePrefix = exports.EtherSymbol = void 0;
/**
 *  A constant for the ether symbol (normalized using NFKC).
 *
 *  (**i.e.** ``"\\u039e"``)
 */
exports.EtherSymbol = "\u039e"; // "\uD835\uDF63";
/**
 *  A constant for the [[link-eip-191]] personal message prefix.
 *
 *  (**i.e.** ``"\\x19Ethereum Signed Message:\\n"``)
 */
exports.MessagePrefix = "\x19Ethereum Signed Message:\n";
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/contract/contract.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/contract/contract.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;
const index_js_1 = __webpack_require__(/*! ../abi/index.js */ "../node_modules/ethers/lib.commonjs/abi/index.js");
const index_js_2 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
const provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ "../node_modules/ethers/lib.commonjs/providers/provider.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ "../node_modules/ethers/lib.commonjs/contract/wrappers.js");
const BN_0 = BigInt(0);
function canCall(value) {
    return (value && typeof (value.call) === "function");
}
function canEstimate(value) {
    return (value && typeof (value.estimateGas) === "function");
}
function canResolve(value) {
    return (value && typeof (value.resolveName) === "function");
}
function canSend(value) {
    return (value && typeof (value.sendTransaction) === "function");
}
function getResolver(value) {
    if (value != null) {
        if (canResolve(value)) {
            return value;
        }
        if (value.provider) {
            return value.provider;
        }
    }
    return undefined;
}
class PreparedTopicFilter {
    #filter;
    fragment;
    constructor(contract, fragment, args) {
        (0, index_js_3.defineProperties)(this, { fragment });
        if (fragment.inputs.length < args.length) {
            throw new Error("too many arguments");
        }
        // Recursively descend into args and resolve any addresses
        const runner = getRunner(contract.runner, "resolveName");
        const resolver = canResolve(runner) ? runner : null;
        this.#filter = (async function () {
            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
                const arg = args[index];
                if (arg == null) {
                    return null;
                }
                return param.walkAsync(args[index], (type, value) => {
                    if (type === "address") {
                        if (Array.isArray(value)) {
                            return Promise.all(value.map((v) => (0, index_js_2.resolveAddress)(v, resolver)));
                        }
                        return (0, index_js_2.resolveAddress)(value, resolver);
                    }
                    return value;
                });
            }));
            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
        })();
    }
    getTopicFilter() {
        return this.#filter;
    }
}
// A = Arguments passed in as a tuple
// R = The result type of the call (i.e. if only one return type,
//     the qualified type, otherwise Result)
// D = The type the default call will return (i.e. R for view/pure,
//     TransactionResponse otherwise)
//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
function getRunner(value, feature) {
    if (value == null) {
        return null;
    }
    if (typeof (value[feature]) === "function") {
        return value;
    }
    if (value.provider && typeof (value.provider[feature]) === "function") {
        return value.provider;
    }
    return null;
}
function getProvider(value) {
    if (value == null) {
        return null;
    }
    return value.provider || null;
}
/**
 *  @_ignore:
 */
async function copyOverrides(arg, allowed) {
    // Make sure the overrides passed in are a valid overrides object
    const _overrides = index_js_1.Typed.dereference(arg, "overrides");
    (0, index_js_3.assertArgument)(typeof (_overrides) === "object", "invalid overrides parameter", "overrides", arg);
    // Create a shallow copy (we'll deep-ify anything needed during normalizing)
    const overrides = (0, provider_js_1.copyRequest)(_overrides);
    (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
    (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
    // Resolve any from
    if (overrides.from) {
        overrides.from = overrides.from;
    }
    return overrides;
}
exports.copyOverrides = copyOverrides;
/**
 *  @_ignore:
 */
async function resolveArgs(_runner, inputs, args) {
    // Recursively descend into args and resolve any addresses
    const runner = getRunner(_runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    return await Promise.all(inputs.map((param, index) => {
        return param.walkAsync(args[index], (type, value) => {
            value = index_js_1.Typed.dereference(value, type);
            if (type === "address") {
                return (0, index_js_2.resolveAddress)(value, resolver);
            }
            return value;
        });
    }));
}
exports.resolveArgs = resolveArgs;
function buildWrappedFallback(contract) {
    const populateTransaction = async function (overrides) {
        // If an overrides was passed in, copy it and normalize the values
        const tx = (await copyOverrides(overrides, ["data"]));
        tx.to = await contract.getAddress();
        if (tx.from) {
            tx.from = await (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));
        }
        const iface = contract.interface;
        const noValue = ((0, index_js_3.getBigInt)((tx.value || BN_0), "overrides.value") === BN_0);
        const noData = ((tx.data || "0x") === "0x");
        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
            (0, index_js_3.assertArgument)(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
        }
        (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        // Only allow payable contracts to set non-zero value
        const payable = iface.receive || (iface.fallback && iface.fallback.payable);
        (0, index_js_3.assertArgument)(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
        // Only allow fallback contracts to set non-empty data
        (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        return tx;
    };
    const staticCall = async function (overrides) {
        const runner = getRunner(contract.runner, "call");
        (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(overrides);
        try {
            return await runner.call(tx);
        }
        catch (error) {
            if ((0, index_js_3.isCallException)(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
    };
    const send = async function (overrides) {
        const runner = contract.runner;
        (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(overrides));
        const provider = getProvider(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (overrides) {
        const runner = getRunner(contract.runner, "estimateGas");
        (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(overrides));
    };
    const method = async (overrides) => {
        return await send(overrides);
    };
    (0, index_js_3.defineProperties)(method, {
        _contract: contract,
        estimateGas,
        populateTransaction,
        send, staticCall
    });
    return method;
}
function buildWrappedMethod(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getFunction(key, args);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const populateTransaction = async function (...args) {
        const fragment = getFragment(...args);
        // If an overrides was passed in, copy it and normalize the values
        let overrides = {};
        if (fragment.inputs.length + 1 === args.length) {
            overrides = await copyOverrides(args.pop());
            if (overrides.from) {
                overrides.from = await (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));
            }
        }
        if (fragment.inputs.length !== args.length) {
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
        }
        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
        return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({
            to: contract.getAddress(),
            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
        }));
    };
    const staticCall = async function (...args) {
        const result = await staticCallResult(...args);
        if (result.length === 1) {
            return result[0];
        }
        return result;
    };
    const send = async function (...args) {
        const runner = contract.runner;
        (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(...args));
        const provider = getProvider(contract.runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function (...args) {
        const runner = getRunner(contract.runner, "estimateGas");
        (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(...args));
    };
    const staticCallResult = async function (...args) {
        const runner = getRunner(contract.runner, "call");
        (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(...args);
        let result = "0x";
        try {
            result = await runner.call(tx);
        }
        catch (error) {
            if ((0, index_js_3.isCallException)(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
            }
            throw error;
        }
        const fragment = getFragment(...args);
        return contract.interface.decodeFunctionResult(fragment, result);
    };
    const method = async (...args) => {
        const fragment = getFragment(...args);
        if (fragment.constant) {
            return await staticCall(...args);
        }
        return await send(...args);
    };
    (0, index_js_3.defineProperties)(method, {
        name: contract.interface.getFunctionName(key),
        _contract: contract, _key: key,
        getFragment,
        estimateGas,
        populateTransaction,
        send, staticCall, staticCallResult,
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getFunction(key);
            (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
function buildWrappedEvent(contract, key) {
    const getFragment = function (...args) {
        const fragment = contract.interface.getEvent(key, args);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key, args }
        });
        return fragment;
    };
    const method = function (...args) {
        return new PreparedTopicFilter(contract, getFragment(...args), args);
    };
    (0, index_js_3.defineProperties)(method, {
        name: contract.interface.getEventName(key),
        _contract: contract, _key: key,
        getFragment
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
            const fragment = contract.interface.getEvent(key);
            (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: { key }
            });
            return fragment;
        }
    });
    return method;
}
// The combination of TypeScrype, Private Fields and Proxies makes
// the world go boom; so we hide variables with some trickery keeping
// a symbol attached to each BaseContract which its sub-class (even
// via a Proxy) can reach and use to look up its internal values.
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = new WeakMap();
function setInternal(contract, values) {
    internalValues.set(contract[internal], values);
}
function getInternal(contract) {
    return internalValues.get(contract[internal]);
}
function isDeferred(value) {
    return (value && typeof (value) === "object" && ("getTopicFilter" in value) &&
        (typeof (value.getTopicFilter) === "function") && value.fragment);
}
async function getSubInfo(contract, event) {
    let topics;
    let fragment = null;
    // Convert named events to topicHash and get the fragment for
    // events which need deconstructing.
    if (Array.isArray(event)) {
        const topicHashify = function (name) {
            if ((0, index_js_3.isHexString)(name, 32)) {
                return name;
            }
            const fragment = contract.interface.getEvent(name);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
        };
        // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
        topics = event.map((e) => {
            if (e == null) {
                return null;
            }
            if (Array.isArray(e)) {
                return e.map(topicHashify);
            }
            return topicHashify(e);
        });
    }
    else if (event === "*") {
        topics = [null];
    }
    else if (typeof (event) === "string") {
        if ((0, index_js_3.isHexString)(event, 32)) {
            // Topic Hash
            topics = [event];
        }
        else {
            // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
            fragment = contract.interface.getEvent(event);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
        }
    }
    else if (isDeferred(event)) {
        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`
        topics = await event.getTopicFilter();
    }
    else if ("fragment" in event) {
        // ContractEvent; e.g. `contract.filter.Transfer`
        fragment = event.fragment;
        topics = [fragment.topicHash];
    }
    else {
        (0, index_js_3.assertArgument)(false, "unknown event name", "event", event);
    }
    // Normalize topics and sort TopicSets
    topics = topics.map((t) => {
        if (t == null) {
            return null;
        }
        if (Array.isArray(t)) {
            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());
            if (items.length === 1) {
                return items[0];
            }
            items.sort();
            return items;
        }
        return t.toLowerCase();
    });
    const tag = topics.map((t) => {
        if (t == null) {
            return "null";
        }
        if (Array.isArray(t)) {
            return t.join("|");
        }
        return t;
    }).join("&");
    return { fragment, tag, topics };
}
async function hasSub(contract, event) {
    const { subs } = getInternal(contract);
    return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
    // Make sure our runner can actually subscribe to events
    const provider = getProvider(contract.runner);
    (0, index_js_3.assert)(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
    const { fragment, tag, topics } = await getSubInfo(contract, event);
    const { addr, subs } = getInternal(contract);
    let sub = subs.get(tag);
    if (!sub) {
        const address = (addr ? addr : contract);
        const filter = { address, topics };
        const listener = (log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = contract.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            // If fragment is null, we do not deconstruct the args to emit
            if (foundFragment) {
                const _foundFragment = foundFragment;
                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
                emit(contract, event, args, (listener) => {
                    return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);
                });
            }
            else {
                emit(contract, event, [], (listener) => {
                    return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);
                });
            }
        };
        let starting = [];
        const start = () => {
            if (starting.length) {
                return;
            }
            starting.push(provider.on(filter, listener));
        };
        const stop = async () => {
            if (starting.length == 0) {
                return;
            }
            let started = starting;
            starting = [];
            await Promise.all(started);
            provider.off(filter, listener);
        };
        sub = { tag, listeners: [], start, stop };
        subs.set(tag, sub);
    }
    return sub;
}
// We use this to ensure one emit resolves before firing the next to
// ensure correct ordering (note this cannot throw and just adds the
// notice to the event queu using setTimeout).
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
    await lastEmit;
    const sub = await hasSub(contract, event);
    if (!sub) {
        return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
        const passArgs = Array.from(args);
        if (payloadFunc) {
            passArgs.push(payloadFunc(once ? null : listener));
        }
        try {
            listener.call(contract, ...passArgs);
        }
        catch (error) { }
        return !once;
    });
    if (sub.listeners.length === 0) {
        sub.stop();
        getInternal(contract).subs.delete(sub.tag);
    }
    return (count > 0);
}
async function emit(contract, event, args, payloadFunc) {
    try {
        await lastEmit;
    }
    catch (error) { }
    const resultPromise = _emit(contract, event, args, payloadFunc);
    lastEmit = resultPromise;
    return await resultPromise;
}
const passProperties = ["then"];
class BaseContract {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    target;
    /**
     *  The contract Interface.
     */
    interface;
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    runner;
    /**
     *  All the Events available on this contract.
     */
    filters;
    /**
     *  @_ignore:
     */
    [internal];
    /**
     *  The fallback or receive function if any.
     */
    fallback;
    /**
     *  Creates a new contract connected to %%target%% with the %%abi%% and
     *  optionally connected to a %%runner%% to perform operations on behalf
     *  of.
     */
    constructor(target, abi, runner, _deployTx) {
        (0, index_js_3.assertArgument)(typeof (target) === "string" || (0, index_js_2.isAddressable)(target), "invalid value for Contract target", "target", target);
        if (runner == null) {
            runner = null;
        }
        const iface = index_js_1.Interface.from(abi);
        (0, index_js_3.defineProperties)(this, { target, runner, interface: iface });
        Object.defineProperty(this, internal, { value: {} });
        let addrPromise;
        let addr = null;
        let deployTx = null;
        if (_deployTx) {
            const provider = getProvider(runner);
            // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);
        }
        let subs = new Map();
        // Resolve the target as the address
        if (typeof (target) === "string") {
            if ((0, index_js_3.isHexString)(target)) {
                addr = target;
                addrPromise = Promise.resolve(target);
            }
            else {
                const resolver = getRunner(runner, "resolveName");
                if (!canResolve(resolver)) {
                    throw (0, index_js_3.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                        operation: "resolveName"
                    });
                }
                addrPromise = resolver.resolveName(target).then((addr) => {
                    if (addr == null) {
                        throw (0, index_js_3.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                            value: target
                        });
                    }
                    getInternal(this).addr = addr;
                    return addr;
                });
            }
        }
        else {
            addrPromise = target.getAddress().then((addr) => {
                if (addr == null) {
                    throw new Error("TODO");
                }
                getInternal(this).addr = addr;
                return addr;
            });
        }
        // Set our private values
        setInternal(this, { addrPromise, addr, deployTx, subs });
        // Add the event filters
        const filters = new Proxy({}, {
            get: (target, prop, receiver) => {
                // Pass important checks (like `then` for Promise) through
                if (typeof (prop) === "symbol" || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                try {
                    return this.getEvent(prop);
                }
                catch (error) {
                    if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                // Pass important checks (like `then` for Promise) through
                if (passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));
            }
        });
        (0, index_js_3.defineProperties)(this, { filters });
        (0, index_js_3.defineProperties)(this, {
            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)
        });
        // Return a Proxy that will respond to functions
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                }
                // Undefined properties should return undefined
                try {
                    return target.getFunction(prop);
                }
                catch (error) {
                    if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                        throw error;
                    }
                }
                return undefined;
            },
            has: (target, prop) => {
                if (typeof (prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                }
                return target.interface.hasFunction(prop);
            }
        });
    }
    /**
     *  Return a new Contract instance with the same target and ABI, but
     *  a different %%runner%%.
     */
    connect(runner) {
        return new BaseContract(this.target, this.interface, runner);
    }
    /**
     *  Return a new Contract instance with the same ABI and runner, but
     *  a different %%target%%.
     */
    attach(target) {
        return new BaseContract(target, this.interface, this.runner);
    }
    /**
     *  Return the resolved address of this Contract.
     */
    async getAddress() { return await getInternal(this).addrPromise; }
    /**
     *  Return the deployed bytecode or null if no bytecode is found.
     */
    async getDeployedCode() {
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
        const code = await provider.getCode(await this.getAddress());
        if (code === "0x") {
            return null;
        }
        return code;
    }
    /**
     *  Resolve to this Contract once the bytecode has been deployed, or
     *  resolve immediately if already deployed.
     */
    async waitForDeployment() {
        // We have the deployement transaction; just use that (throws if deployement fails)
        const deployTx = this.deploymentTransaction();
        if (deployTx) {
            await deployTx.wait();
            return this;
        }
        // Check for code
        const code = await this.getDeployedCode();
        if (code != null) {
            return this;
        }
        // Make sure we can subscribe to a provider event
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
        return new Promise((resolve, reject) => {
            const checkCode = async () => {
                try {
                    const code = await this.getDeployedCode();
                    if (code != null) {
                        return resolve(this);
                    }
                    provider.once("block", checkCode);
                }
                catch (error) {
                    reject(error);
                }
            };
            checkCode();
        });
    }
    /**
     *  Return the transaction used to deploy this contract.
     *
     *  This is only available if this instance was returned from a
     *  [[ContractFactory]].
     */
    deploymentTransaction() {
        return getInternal(this).deployTx;
    }
    /**
     *  Return the function for a given name. This is useful when a contract
     *  method name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getFunction(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        const func = buildWrappedMethod(this, key);
        return func;
    }
    /**
     *  Return the event for a given name. This is useful when a contract
     *  event name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getEvent(key) {
        if (typeof (key) !== "string") {
            key = key.format();
        }
        return buildWrappedEvent(this, key);
    }
    /**
     *  @_ignore:
     */
    async queryTransaction(hash) {
        throw new Error("@TODO");
    }
    /*
    // @TODO: this is a non-backwards compatible change, but will be added
    //        in v7 and in a potential SmartContract class in an upcoming
    //        v6 release
    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
        const provider = getProvider(this.runner);
        assert(provider, "contract runner does not have a provider",
            "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });

        const receipt = await provider.getTransactionReceipt(hash);
        if (receipt == null) { return null; }

        return new ContractTransactionReceipt(this.interface, provider, receipt);
    }
    */
    /**
     *  Provide historic access to event data for %%event%% in the range
     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
     *  inclusive.
     */
    async queryFilter(event, fromBlock, toBlock) {
        if (fromBlock == null) {
            fromBlock = 0;
        }
        if (toBlock == null) {
            toBlock = "latest";
        }
        const { addr, addrPromise } = getInternal(this);
        const address = (addr ? addr : (await addrPromise));
        const { fragment, topics } = await getSubInfo(this, event);
        const filter = { address, topics, fromBlock, toBlock };
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
        return (await provider.getLogs(filter)).map((log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
                try {
                    foundFragment = this.interface.getEvent(log.topics[0]);
                }
                catch (error) { }
            }
            if (foundFragment) {
                try {
                    return new wrappers_js_1.EventLog(log, this.interface, foundFragment);
                }
                catch (error) {
                    return new wrappers_js_1.UndecodedEventLog(log, error);
                }
            }
            return new provider_js_1.Log(log, provider);
        });
    }
    /**
     *  Add an event %%listener%% for the %%event%%.
     */
    async on(event, listener) {
        const sub = await getSub(this, "on", event);
        sub.listeners.push({ listener, once: false });
        sub.start();
        return this;
    }
    /**
     *  Add an event %%listener%% for the %%event%%, but remove the listener
     *  after it is fired once.
     */
    async once(event, listener) {
        const sub = await getSub(this, "once", event);
        sub.listeners.push({ listener, once: true });
        sub.start();
        return this;
    }
    /**
     *  Emit an %%event%% calling all listeners with %%args%%.
     *
     *  Resolves to ``true`` if any listeners were called.
     */
    async emit(event, ...args) {
        return await emit(this, event, args, null);
    }
    /**
     *  Resolves to the number of listeners of %%event%% or the total number
     *  of listeners if unspecified.
     */
    async listenerCount(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return 0;
            }
            return sub.listeners.length;
        }
        const { subs } = getInternal(this);
        let total = 0;
        for (const { listeners } of subs.values()) {
            total += listeners.length;
        }
        return total;
    }
    /**
     *  Resolves to the listeners subscribed to %%event%% or all listeners
     *  if unspecified.
     */
    async listeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return [];
            }
            return sub.listeners.map(({ listener }) => listener);
        }
        const { subs } = getInternal(this);
        let result = [];
        for (const { listeners } of subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
    }
    /**
     *  Remove the %%listener%% from the listeners for %%event%% or remove
     *  all listeners if unspecified.
     */
    async off(event, listener) {
        const sub = await hasSub(this, event);
        if (!sub) {
            return this;
        }
        if (listener) {
            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
            if (index >= 0) {
                sub.listeners.splice(index, 1);
            }
        }
        if (listener == null || sub.listeners.length === 0) {
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        return this;
    }
    /**
     *  Remove all the listeners for %%event%% or remove all listeners if
     *  unspecified.
     */
    async removeAllListeners(event) {
        if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return this;
            }
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
        }
        else {
            const { subs } = getInternal(this);
            for (const { tag, stop } of subs.values()) {
                stop();
                subs.delete(tag);
            }
        }
        return this;
    }
    /**
     *  Alias for [on].
     */
    async addListener(event, listener) {
        return await this.on(event, listener);
    }
    /**
     *  Alias for [off].
     */
    async removeListener(event, listener) {
        return await this.off(event, listener);
    }
    /**
     *  Create a new Class for the %%abi%%.
     */
    static buildClass(abi) {
        class CustomContract extends BaseContract {
            constructor(address, runner = null) {
                super(address, abi, runner);
            }
        }
        return CustomContract;
    }
    ;
    /**
     *  Create a new BaseContract with a specified Interface.
     */
    static from(target, abi, runner) {
        if (runner == null) {
            runner = null;
        }
        const contract = new this(target, abi, runner);
        return contract;
    }
}
exports.BaseContract = BaseContract;
function _ContractBase() {
    return BaseContract;
}
/**
 *  A [[BaseContract]] with no type guards on its methods or events.
 */
class Contract extends _ContractBase() {
}
exports.Contract = Contract;
//# sourceMappingURL=contract.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/contract/factory.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/contract/factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractFactory = void 0;
const index_js_1 = __webpack_require__(/*! ../abi/index.js */ "../node_modules/ethers/lib.commonjs/abi/index.js");
const index_js_2 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const contract_js_1 = __webpack_require__(/*! ./contract.js */ "../node_modules/ethers/lib.commonjs/contract/contract.js");
// A = Arguments to the constructor
// I = Interface of deployed contracts
/**
 *  A **ContractFactory** is used to deploy a Contract to the blockchain.
 */
class ContractFactory {
    /**
     *  The Contract Interface.
     */
    interface;
    /**
     *  The Contract deployment bytecode. Often called the initcode.
     */
    bytecode;
    /**
     *  The ContractRunner to deploy the Contract as.
     */
    runner;
    /**
     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
     *  optionally connected to %%runner%%.
     *
     *  The %%bytecode%% may be the ``bytecode`` property within the
     *  standard Solidity JSON output.
     */
    constructor(abi, bytecode, runner) {
        const iface = index_js_1.Interface.from(abi);
        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
        if (bytecode instanceof Uint8Array) {
            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
        }
        else {
            if (typeof (bytecode) === "object") {
                bytecode = bytecode.object;
            }
            if (!bytecode.startsWith("0x")) {
                bytecode = "0x" + bytecode;
            }
            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
        }
        (0, index_js_3.defineProperties)(this, {
            bytecode, interface: iface, runner: (runner || null)
        });
    }
    attach(target) {
        return new contract_js_1.BaseContract(target, this.interface, this.runner);
    }
    /**
     *  Resolves to the transaction to deploy the contract, passing %%args%%
     *  into the constructor.
     */
    async getDeployTransaction(...args) {
        let overrides = {};
        const fragment = this.interface.deploy;
        if (fragment.inputs.length + 1 === args.length) {
            overrides = await (0, contract_js_1.copyOverrides)(args.pop());
        }
        if (fragment.inputs.length !== args.length) {
            throw new Error("incorrect number of arguments to constructor");
        }
        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
        const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
        return Object.assign({}, overrides, { data });
    }
    /**
     *  Resolves to the Contract deployed by passing %%args%% into the
     *  constructor.
     *
     *  This will resolve to the Contract before it has been deployed to the
     *  network, so the [[BaseContract-waitForDeployment]] should be used before
     *  sending any transactions to it.
     */
    async deploy(...args) {
        const tx = await this.getDeployTransaction(...args);
        (0, index_js_3.assert)(this.runner && typeof (this.runner.sendTransaction) === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
        });
        const sentTx = await this.runner.sendTransaction(tx);
        const address = (0, index_js_2.getCreateAddress)(sentTx);
        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);
    }
    /**
     *  Return a new **ContractFactory** with the same ABI and bytecode,
     *  but connected to %%runner%%.
     */
    connect(runner) {
        return new ContractFactory(this.interface, this.bytecode, runner);
    }
    /**
     *  Create a new **ContractFactory** from the standard Solidity JSON output.
     */
    static fromSolidity(output, runner) {
        (0, index_js_3.assertArgument)(output != null, "bad compiler output", "output", output);
        if (typeof (output) === "string") {
            output = JSON.parse(output);
        }
        const abi = output.abi;
        let bytecode = "";
        if (output.bytecode) {
            bytecode = output.bytecode;
        }
        else if (output.evm && output.evm.bytecode) {
            bytecode = output.evm.bytecode;
        }
        return new this(abi, bytecode, runner);
    }
}
exports.ContractFactory = ContractFactory;
//# sourceMappingURL=factory.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/contract/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/contract/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
/**
 *  A **Contract** object is a meta-class (a class whose definition is
 *  defined at runtime), which communicates with a deployed smart contract
 *  on the blockchain and provides a simple JavaScript interface to call
 *  methods, send transaction, query historic logs and listen for its events.
 *
 *  @_section: api/contract:Contracts  [about-contracts]
 */
var contract_js_1 = __webpack_require__(/*! ./contract.js */ "../node_modules/ethers/lib.commonjs/contract/contract.js");
Object.defineProperty(exports, "BaseContract", ({ enumerable: true, get: function () { return contract_js_1.BaseContract; } }));
Object.defineProperty(exports, "Contract", ({ enumerable: true, get: function () { return contract_js_1.Contract; } }));
var factory_js_1 = __webpack_require__(/*! ./factory.js */ "../node_modules/ethers/lib.commonjs/contract/factory.js");
Object.defineProperty(exports, "ContractFactory", ({ enumerable: true, get: function () { return factory_js_1.ContractFactory; } }));
var wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ "../node_modules/ethers/lib.commonjs/contract/wrappers.js");
Object.defineProperty(exports, "ContractEventPayload", ({ enumerable: true, get: function () { return wrappers_js_1.ContractEventPayload; } }));
Object.defineProperty(exports, "ContractUnknownEventPayload", ({ enumerable: true, get: function () { return wrappers_js_1.ContractUnknownEventPayload; } }));
Object.defineProperty(exports, "ContractTransactionReceipt", ({ enumerable: true, get: function () { return wrappers_js_1.ContractTransactionReceipt; } }));
Object.defineProperty(exports, "ContractTransactionResponse", ({ enumerable: true, get: function () { return wrappers_js_1.ContractTransactionResponse; } }));
Object.defineProperty(exports, "EventLog", ({ enumerable: true, get: function () { return wrappers_js_1.EventLog; } }));
Object.defineProperty(exports, "UndecodedEventLog", ({ enumerable: true, get: function () { return wrappers_js_1.UndecodedEventLog; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/contract/wrappers.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/contract/wrappers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;
// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
const provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ "../node_modules/ethers/lib.commonjs/providers/provider.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class EventLog extends provider_js_1.Log {
    /**
     *  The Contract Interface.
     */
    interface;
    /**
     *  The matching event.
     */
    fragment;
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    args;
    /**
     * @_ignore:
     */
    constructor(log, iface, fragment) {
        super(log, log.provider);
        const args = iface.decodeEventLog(fragment, log.data, log.topics);
        (0, index_js_1.defineProperties)(this, { args, fragment, interface: iface });
    }
    /**
     *  The name of the event.
     */
    get eventName() { return this.fragment.name; }
    /**
     *  The signature of the event.
     */
    get eventSignature() { return this.fragment.format(); }
}
exports.EventLog = EventLog;
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
class UndecodedEventLog extends provider_js_1.Log {
    /**
     *  The error encounted when trying to decode the log.
     */
    error;
    /**
     * @_ignore:
     */
    constructor(log, error) {
        super(log, log.provider);
        (0, index_js_1.defineProperties)(this, { error });
    }
}
exports.UndecodedEventLog = UndecodedEventLog;
/**
 *  A **ContractTransactionReceipt** includes the parsed logs from a
 *  [[TransactionReceipt]].
 */
class ContractTransactionReceipt extends provider_js_1.TransactionReceipt {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  The parsed logs for any [[Log]] which has a matching event in the
     *  Contract ABI.
     */
    get logs() {
        return super.logs.map((log) => {
            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
            if (fragment) {
                try {
                    return new EventLog(log, this.#iface, fragment);
                }
                catch (error) {
                    return new UndecodedEventLog(log, error);
                }
            }
            return log;
        });
    }
}
exports.ContractTransactionReceipt = ContractTransactionReceipt;
/**
 *  A **ContractTransactionResponse** will return a
 *  [[ContractTransactionReceipt]] when waited on.
 */
class ContractTransactionResponse extends provider_js_1.TransactionResponse {
    #iface;
    /**
     *  @_ignore:
     */
    constructor(iface, provider, tx) {
        super(tx, provider);
        this.#iface = iface;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(confirms, timeout) {
        const receipt = await super.wait(confirms, timeout);
        if (receipt == null) {
            return null;
        }
        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
    }
}
exports.ContractTransactionResponse = ContractTransactionResponse;
/**
 *  A **ContractUnknownEventPayload** is included as the last parameter to
 *  Contract Events when the event does not match any events in the ABI.
 */
class ContractUnknownEventPayload extends index_js_1.EventPayload {
    /**
     *  The log with no matching events.
     */
    log;
    /**
     *  @_event:
     */
    constructor(contract, listener, filter, log) {
        super(contract, listener, filter);
        (0, index_js_1.defineProperties)(this, { log });
    }
    /**
     *  Resolves to the block the event occured in.
     */
    async getBlock() {
        return await this.log.getBlock();
    }
    /**
     *  Resolves to the transaction the event occured in.
     */
    async getTransaction() {
        return await this.log.getTransaction();
    }
    /**
     *  Resolves to the transaction receipt the event occured in.
     */
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt();
    }
}
exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
/**
 *  A **ContractEventPayload** is included as the last parameter to
 *  Contract Events when the event is known.
 */
class ContractEventPayload extends ContractUnknownEventPayload {
    /**
     *  @_ignore:
     */
    constructor(contract, listener, filter, fragment, _log) {
        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
        (0, index_js_1.defineProperties)(this, { args, fragment });
    }
    /**
     *  The event name.
     */
    get eventName() {
        return this.fragment.name;
    }
    /**
     *  The event signature.
     */
    get eventSignature() {
        return this.fragment.format();
    }
}
exports.ContractEventPayload = ContractEventPayload;
//# sourceMappingURL=wrappers.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/crypto.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/crypto.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;
var crypto_1 = __webpack_require__(/*! crypto */ "crypto");
Object.defineProperty(exports, "createHash", ({ enumerable: true, get: function () { return crypto_1.createHash; } }));
Object.defineProperty(exports, "createHmac", ({ enumerable: true, get: function () { return crypto_1.createHmac; } }));
Object.defineProperty(exports, "pbkdf2Sync", ({ enumerable: true, get: function () { return crypto_1.pbkdf2Sync; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return crypto_1.randomBytes; } }));
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/hmac.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/hmac.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeHmac = void 0;
/**
 *  An **HMAC** enables verification that a given key was used
 *  to authenticate a payload.
 *
 *  See: [[link-wiki-hmac]]
 *
 *  @_subsection: api/crypto:HMAC  [about-hmac]
 */
const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ "../node_modules/ethers/lib.commonjs/crypto/crypto.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
let locked = false;
const _computeHmac = function (algorithm, key, data) {
    return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
/**
 *  Return the HMAC for %%data%% using the %%key%% key with the underlying
 *  %%algo%% used for compression.
 *
 *  @example:
 *    key = id("some-secret")
 *
 *    // Compute the HMAC
 *    computeHmac("sha256", key, "0x1337")
 *    //_result:
 *
 *    // To compute the HMAC of UTF-8 data, the data must be
 *    // converted to UTF-8 bytes
 *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
 *    //_result:
 *
 */
function computeHmac(algorithm, _key, _data) {
    const key = (0, index_js_1.getBytes)(_key, "key");
    const data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));
}
exports.computeHmac = computeHmac;
computeHmac._ = _computeHmac;
computeHmac.lock = function () { locked = true; };
computeHmac.register = function (func) {
    if (locked) {
        throw new Error("computeHmac is locked");
    }
    __computeHmac = func;
};
Object.freeze(computeHmac);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A fundamental building block of Ethereum is the underlying
 *  cryptographic primitives.
 *
 *  @_section: api/crypto:Cryptographic Functions   [about-crypto]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;
null;
// We import all these so we can export lock()
const hmac_js_1 = __webpack_require__(/*! ./hmac.js */ "../node_modules/ethers/lib.commonjs/crypto/hmac.js");
Object.defineProperty(exports, "computeHmac", ({ enumerable: true, get: function () { return hmac_js_1.computeHmac; } }));
const keccak_js_1 = __webpack_require__(/*! ./keccak.js */ "../node_modules/ethers/lib.commonjs/crypto/keccak.js");
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return keccak_js_1.keccak256; } }));
const ripemd160_js_1 = __webpack_require__(/*! ./ripemd160.js */ "../node_modules/ethers/lib.commonjs/crypto/ripemd160.js");
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));
const pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ "../node_modules/ethers/lib.commonjs/crypto/pbkdf2.js");
Object.defineProperty(exports, "pbkdf2", ({ enumerable: true, get: function () { return pbkdf2_js_1.pbkdf2; } }));
const random_js_1 = __webpack_require__(/*! ./random.js */ "../node_modules/ethers/lib.commonjs/crypto/random.js");
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return random_js_1.randomBytes; } }));
const scrypt_js_1 = __webpack_require__(/*! ./scrypt.js */ "../node_modules/ethers/lib.commonjs/crypto/scrypt.js");
Object.defineProperty(exports, "scrypt", ({ enumerable: true, get: function () { return scrypt_js_1.scrypt; } }));
Object.defineProperty(exports, "scryptSync", ({ enumerable: true, get: function () { return scrypt_js_1.scryptSync; } }));
const sha2_js_1 = __webpack_require__(/*! ./sha2.js */ "../node_modules/ethers/lib.commonjs/crypto/sha2.js");
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha2_js_1.sha256; } }));
Object.defineProperty(exports, "sha512", ({ enumerable: true, get: function () { return sha2_js_1.sha512; } }));
var signing_key_js_1 = __webpack_require__(/*! ./signing-key.js */ "../node_modules/ethers/lib.commonjs/crypto/signing-key.js");
Object.defineProperty(exports, "SigningKey", ({ enumerable: true, get: function () { return signing_key_js_1.SigningKey; } }));
var signature_js_1 = __webpack_require__(/*! ./signature.js */ "../node_modules/ethers/lib.commonjs/crypto/signature.js");
Object.defineProperty(exports, "Signature", ({ enumerable: true, get: function () { return signature_js_1.Signature; } }));
/**
 *  Once called, prevents any future change to the underlying cryptographic
 *  primitives using the ``.register`` feature for hooks.
 */
function lock() {
    hmac_js_1.computeHmac.lock();
    keccak_js_1.keccak256.lock();
    pbkdf2_js_1.pbkdf2.lock();
    random_js_1.randomBytes.lock();
    ripemd160_js_1.ripemd160.lock();
    scrypt_js_1.scrypt.lock();
    scrypt_js_1.scryptSync.lock();
    sha2_js_1.sha256.lock();
    sha2_js_1.sha512.lock();
    random_js_1.randomBytes.lock();
}
exports.lock = lock;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/keccak.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/keccak.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Cryptographic hashing functions
 *
 *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256 = void 0;
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "../node_modules/@noble/hashes/sha3.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
let locked = false;
const _keccak256 = function (data) {
    return (0, sha3_1.keccak_256)(data);
};
let __keccak256 = _keccak256;
/**
 *  Compute the cryptographic KECCAK256 hash of %%data%%.
 *
 *  The %%data%% **must** be a data representation, to compute the
 *  hash of UTF-8 data use the [[id]] function.
 *
 *  @returns DataHexstring
 *  @example:
 *    keccak256("0x")
 *    //_result:
 *
 *    keccak256("0x1337")
 *    //_result:
 *
 *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 *    // Strings are assumed to be DataHexString, otherwise it will
 *    // throw. To hash UTF-8 data, see the note above.
 *    keccak256("Hello World")
 *    //_error:
 */
function keccak256(_data) {
    const data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__keccak256(data));
}
exports.keccak256 = keccak256;
keccak256._ = _keccak256;
keccak256.lock = function () { locked = true; };
keccak256.register = function (func) {
    if (locked) {
        throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
};
Object.freeze(keccak256);
//# sourceMappingURL=keccak.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/pbkdf2.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/pbkdf2.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A **Password-Based Key-Derivation Function** is designed to create
 *  a sequence of bytes suitible as a **key** from a human-rememberable
 *  password.
 *
 *  @_subsection: api/crypto:Passwords  [about-pbkdf]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pbkdf2 = void 0;
const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ "../node_modules/ethers/lib.commonjs/crypto/crypto.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
let locked = false;
const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
    return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
/**
 *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
 *  the %%salt%% and using %%iterations%% of %%algo%%.
 *
 *  This PBKDF is outdated and should not be used in new projects, but is
 *  required to decrypt older files.
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the PBKDF2
 *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
 *    //_result:
 */
function pbkdf2(_password, _salt, iterations, keylen, algo) {
    const password = (0, index_js_1.getBytes)(_password, "password");
    const salt = (0, index_js_1.getBytes)(_salt, "salt");
    return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));
}
exports.pbkdf2 = pbkdf2;
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function () { locked = true; };
pbkdf2.register = function (func) {
    if (locked) {
        throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
};
Object.freeze(pbkdf2);
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/random.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/random.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = void 0;
/**
 *  A **Cryptographically Secure Random Value** is one that has been
 *  generated with additional care take to prevent side-channels
 *  from allowing others to detect it and prevent others from through
 *  coincidence generate the same values.
 *
 *  @_subsection: api/crypto:Random Values  [about-crypto-random]
 */
const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ "../node_modules/ethers/lib.commonjs/crypto/crypto.js");
let locked = false;
const _randomBytes = function (length) {
    return new Uint8Array((0, crypto_js_1.randomBytes)(length));
};
let __randomBytes = _randomBytes;
/**
 *  Return %%length%% bytes of cryptographically secure random data.
 *
 *  @example:
 *    randomBytes(8)
 *    //_result:
 */
function randomBytes(length) {
    return __randomBytes(length);
}
exports.randomBytes = randomBytes;
randomBytes._ = _randomBytes;
randomBytes.lock = function () { locked = true; };
randomBytes.register = function (func) {
    if (locked) {
        throw new Error("randomBytes is locked");
    }
    __randomBytes = func;
};
Object.freeze(randomBytes);
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/ripemd160.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/ripemd160.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = void 0;
const ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "../node_modules/@noble/hashes/ripemd160.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
let locked = false;
const _ripemd160 = function (data) {
    return (0, ripemd160_1.ripemd160)(data);
};
let __ripemd160 = _ripemd160;
/**
 *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    ripemd160("0x")
 *    //_result:
 *
 *    ripemd160("0x1337")
 *    //_result:
 *
 *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function ripemd160(_data) {
    const data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__ripemd160(data));
}
exports.ripemd160 = ripemd160;
ripemd160._ = _ripemd160;
ripemd160.lock = function () { locked = true; };
ripemd160.register = function (func) {
    if (locked) {
        throw new TypeError("ripemd160 is locked");
    }
    __ripemd160 = func;
};
Object.freeze(ripemd160);
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/scrypt.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/scrypt.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scryptSync = exports.scrypt = void 0;
const scrypt_1 = __webpack_require__(/*! @noble/hashes/scrypt */ "../node_modules/@noble/hashes/scrypt.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {
    return await (0, scrypt_1.scryptAsync)(passwd, salt, { N, r, p, dkLen, onProgress });
};
const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
    return (0, scrypt_1.scrypt)(passwd, salt, { N, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
/**
 *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
 *  derivation to increase the resource cost to brute-force a password
 *  for a given key.
 *
 *  This means this algorithm is intentionally slow, and can be tuned to
 *  become slower. As computation and memory speed improve over time,
 *  increasing the difficulty maintains the cost of an attacker.
 *
 *  For example, if a target time of 5 seconds is used, a legitimate user
 *  which knows their password requires only 5 seconds to unlock their
 *  account. A 6 character password has 68 billion possibilities, which
 *  would require an attacker to invest over 10,000 years of CPU time. This
 *  is of course a crude example (as password generally aren't random),
 *  but demonstrates to value of imposing large costs to decryption.
 *
 *  For this reason, if building a UI which involved decrypting or
 *  encrypting datsa using scrypt, it is recommended to use a
 *  [[ProgressCallback]] (as event short periods can seem lik an eternity
 *  if the UI freezes). Including the phrase //"decrypting"// in the UI
 *  can also help, assuring the user their waiting is for a good reason.
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
    const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
    const salt = (0, index_js_1.getBytes)(_salt, "salt");
    return (0, index_js_1.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
}
exports.scrypt = scrypt;
scrypt._ = _scryptAsync;
scrypt.lock = function () { lockedAsync = true; };
scrypt.register = function (func) {
    if (lockedAsync) {
        throw new Error("scrypt is locked");
    }
    __scryptAsync = func;
};
Object.freeze(scrypt);
/**
 *  Provides a synchronous variant of [[scrypt]].
 *
 *  This will completely lock up and freeze the UI in a browser and will
 *  prevent any event loop from progressing. For this reason, it is
 *  preferred to use the [async variant](scrypt).
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
    const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
    const salt = (0, index_js_1.getBytes)(_salt, "salt");
    return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));
}
exports.scryptSync = scryptSync;
scryptSync._ = _scryptSync;
scryptSync.lock = function () { lockedSync = true; };
scryptSync.register = function (func) {
    if (lockedSync) {
        throw new Error("scryptSync is locked");
    }
    __scryptSync = func;
};
Object.freeze(scryptSync);
//# sourceMappingURL=scrypt.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/sha2.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/sha2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512 = exports.sha256 = void 0;
const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ "../node_modules/ethers/lib.commonjs/crypto/crypto.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const _sha256 = function (data) {
    return (0, crypto_js_1.createHash)("sha256").update(data).digest();
};
const _sha512 = function (data) {
    return (0, crypto_js_1.createHash)("sha512").update(data).digest();
};
let __sha256 = _sha256;
let __sha512 = _sha512;
let locked256 = false, locked512 = false;
/**
 *  Compute the cryptographic SHA2-256 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha256("0x")
 *    //_result:
 *
 *    sha256("0x1337")
 *    //_result:
 *
 *    sha256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function sha256(_data) {
    const data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__sha256(data));
}
exports.sha256 = sha256;
sha256._ = _sha256;
sha256.lock = function () { locked256 = true; };
sha256.register = function (func) {
    if (locked256) {
        throw new Error("sha256 is locked");
    }
    __sha256 = func;
};
Object.freeze(sha256);
/**
 *  Compute the cryptographic SHA2-512 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha512("0x")
 *    //_result:
 *
 *    sha512("0x1337")
 *    //_result:
 *
 *    sha512(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 */
function sha512(_data) {
    const data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__sha512(data));
}
exports.sha512 = sha512;
sha512._ = _sha512;
sha512.lock = function () { locked512 = true; };
sha512.register = function (func) {
    if (locked512) {
        throw new Error("sha512 is locked");
    }
    __sha512 = func;
};
Object.freeze(sha256);
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/signature.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/signature.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signature = void 0;
const index_js_1 = __webpack_require__(/*! ../constants/index.js */ "../node_modules/ethers/lib.commonjs/constants/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
// Constants
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_2 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const _guard = {};
function toUint256(value) {
    return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);
}
/**
 *  A Signature  @TODO
 *
 *
 *  @_docloc: api/crypto:Signing
 */
class Signature {
    #r;
    #s;
    #v;
    #networkV;
    /**
     *  The ``r`` value for a signautre.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    get r() { return this.#r; }
    set r(value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, "invalid r", "value", value);
        this.#r = (0, index_js_2.hexlify)(value);
    }
    /**
     *  The ``s`` value for a signature.
     */
    get s() { return this.#s; }
    set s(_value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, "invalid s", "value", _value);
        const value = (0, index_js_2.hexlify)(_value);
        (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
        this.#s = value;
    }
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
    get v() { return this.#v; }
    set v(value) {
        const v = (0, index_js_2.getNumber)(value, "value");
        (0, index_js_2.assertArgument)(v === 27 || v === 28, "invalid v", "v", value);
        this.#v = v;
    }
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get networkV() { return this.#networkV; }
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get legacyChainId() {
        const v = this.networkV;
        if (v == null) {
            return null;
        }
        return Signature.getChainId(v);
    }
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
    get yParity() {
        return (this.v === 27) ? 0 : 1;
    }
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
    get yParityAndS() {
        // The EIP-2098 compact representation
        const yParityAndS = (0, index_js_2.getBytes)(this.s);
        if (this.yParity) {
            yParityAndS[0] |= 0x80;
        }
        return (0, index_js_2.hexlify)(yParityAndS);
    }
    /**
     *  The [[link-eip-2098]] compact representation.
     */
    get compactSerialized() {
        return (0, index_js_2.concat)([this.r, this.yParityAndS]);
    }
    /**
     *  The serialized representation.
     */
    get serialized() {
        return (0, index_js_2.concat)([this.r, this.s, (this.yParity ? "0x1c" : "0x1b")]);
    }
    /**
     *  @private
     */
    constructor(guard, r, s, v) {
        (0, index_js_2.assertPrivate)(guard, _guard, "Signature");
        this.#r = r;
        this.#s = s;
        this.#v = v;
        this.#networkV = null;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
    }
    /**
     *  Returns a new identical [[Signature]].
     */
    clone() {
        const clone = new Signature(_guard, this.r, this.s, this.v);
        if (this.networkV) {
            clone.#networkV = this.networkV;
        }
        return clone;
    }
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
    toJSON() {
        const networkV = this.networkV;
        return {
            _type: "signature",
            networkV: ((networkV != null) ? networkV.toString() : null),
            r: this.r, s: this.s, v: this.v,
        };
    }
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
    static getChainId(v) {
        const bv = (0, index_js_2.getBigInt)(v, "v");
        // The v is not an EIP-155 v, so it is the unspecified chain ID
        if ((bv == BN_27) || (bv == BN_28)) {
            return BN_0;
        }
        // Bad value for an EIP-155 v
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid EIP-155 v", "v", v);
        return (bv - BN_35) / BN_2;
    }
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
    static getChainIdV(chainId, v) {
        return ((0, index_js_2.getBigInt)(chainId) * BN_2) + BigInt(35 + v - 27);
    }
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
    static getNormalizedV(v) {
        const bv = (0, index_js_2.getBigInt)(v);
        if (bv === BN_0 || bv === BN_27) {
            return 27;
        }
        if (bv === BN_1 || bv === BN_28) {
            return 28;
        }
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid v", "v", v);
        // Otherwise, EIP-155 v means odd is 27 and even is 28
        return (bv & BN_1) ? 27 : 28;
    }
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
    static from(sig) {
        function assertError(check, message) {
            (0, index_js_2.assertArgument)(check, message, "signature", sig);
        }
        ;
        if (sig == null) {
            return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);
        }
        if (typeof (sig) === "string") {
            const bytes = (0, index_js_2.getBytes)(sig, "signature");
            if (bytes.length === 64) {
                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                const v = (s[0] & 0x80) ? 28 : 27;
                s[0] &= 0x7f;
                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);
            }
            if (bytes.length === 65) {
                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                assertError((s[0] & 0x80) === 0, "non-canonical s");
                const v = Signature.getNormalizedV(bytes[64]);
                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);
            }
            assertError(false, "invalid raw signature length");
        }
        if (sig instanceof Signature) {
            return sig.clone();
        }
        // Get r
        const _r = sig.r;
        assertError(_r != null, "missing r");
        const r = toUint256(_r);
        // Get s; by any means necessary (we check consistency below)
        const s = (function (s, yParityAndS) {
            if (s != null) {
                return toUint256(s);
            }
            if (yParityAndS != null) {
                assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
                const bytes = (0, index_js_2.getBytes)(yParityAndS);
                bytes[0] &= 0x7f;
                return (0, index_js_2.hexlify)(bytes);
            }
            assertError(false, "missing s");
        })(sig.s, sig.yParityAndS);
        assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, "non-canonical s");
        // Get v; by any means necessary (we check consistency below)
        const { networkV, v } = (function (_v, yParityAndS, yParity) {
            if (_v != null) {
                const v = (0, index_js_2.getBigInt)(_v);
                return {
                    networkV: ((v >= BN_35) ? v : undefined),
                    v: Signature.getNormalizedV(v)
                };
            }
            if (yParityAndS != null) {
                assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
                return { v: (((0, index_js_2.getBytes)(yParityAndS)[0] & 0x80) ? 28 : 27) };
            }
            if (yParity != null) {
                switch ((0, index_js_2.getNumber)(yParity, "sig.yParity")) {
                    case 0: return { v: 27 };
                    case 1: return { v: 28 };
                }
                assertError(false, "invalid yParity");
            }
            assertError(false, "missing v");
        })(sig.v, sig.yParityAndS, sig.yParity);
        const result = new Signature(_guard, r, s, v);
        if (networkV) {
            result.#networkV = networkV;
        }
        // If multiple of v, yParity, yParityAndS we given, check they match
        assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
        return result;
    }
}
exports.Signature = Signature;
//# sourceMappingURL=signature.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/crypto/signing-key.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/crypto/signing-key.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Add details about signing here.
 *
 *  @_subsection: api/crypto:Signing  [about-signing]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SigningKey = void 0;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "../node_modules/@noble/curves/secp256k1.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const signature_js_1 = __webpack_require__(/*! ./signature.js */ "../node_modules/ethers/lib.commonjs/crypto/signature.js");
/**
 *  A **SigningKey** provides high-level access to the elliptic curve
 *  cryptography (ECC) operations and key management.
 */
class SigningKey {
    #privateKey;
    /**
     *  Creates a new **SigningKey** for %%privateKey%%.
     */
    constructor(privateKey) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
        this.#privateKey = (0, index_js_1.hexlify)(privateKey);
    }
    /**
     *  The private key.
     */
    get privateKey() { return this.#privateKey; }
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }
    /**
     *  Return the signature of the signed %%digest%%.
     */
    sign(digest) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        const sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(this.#privateKey), {
            lowS: true
        });
        return signature_js_1.Signature.from({
            r: (0, index_js_1.toBeHex)(sig.r, 32),
            s: (0, index_js_1.toBeHex)(sig.s, 32),
            v: (sig.recovery ? 0x1c : 0x1b)
        });
    }
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
    computeSharedSecret(other) {
        const pubKey = SigningKey.computePublicKey(other);
        return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(this.#privateKey), (0, index_js_1.getBytes)(pubKey), false));
    }
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
    static computePublicKey(key, compressed) {
        let bytes = (0, index_js_1.getBytes)(key, "key");
        // private key
        if (bytes.length === 32) {
            const pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);
            return (0, index_js_1.hexlify)(pubKey);
        }
        // raw public key; use uncompressed key with 0x04 prefix
        if (bytes.length === 64) {
            const pub = new Uint8Array(65);
            pub[0] = 0x04;
            pub.set(bytes, 1);
            bytes = pub;
        }
        const point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);
        return (0, index_js_1.hexlify)(point.toRawBytes(compressed));
    }
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
    static recoverPublicKey(digest, signature) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        const sig = signature_js_1.Signature.from(signature);
        let secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s])));
        secpSig = secpSig.addRecoveryBit(sig.yParity);
        const pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));
        (0, index_js_1.assertArgument)(pubKey != null, "invalid signautre for digest", "signature", signature);
        return "0x" + pubKey.toHex(false);
    }
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
    static addPoints(p0, p1, compressed) {
        const pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
        const pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
        return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
}
exports.SigningKey = SigningKey;
//# sourceMappingURL=signing-key.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/ethers.js":
/*!*****************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/ethers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/////////////////////////////
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;
exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.ChainstackProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;
exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EtherscanPlugin = void 0;
exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = exports.toBeArray = void 0;
var _version_js_1 = __webpack_require__(/*! ./_version.js */ "../node_modules/ethers/lib.commonjs/_version.js");
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return _version_js_1.version; } }));
var index_js_1 = __webpack_require__(/*! ./abi/index.js */ "../node_modules/ethers/lib.commonjs/abi/index.js");
Object.defineProperty(exports, "decodeBytes32String", ({ enumerable: true, get: function () { return index_js_1.decodeBytes32String; } }));
Object.defineProperty(exports, "encodeBytes32String", ({ enumerable: true, get: function () { return index_js_1.encodeBytes32String; } }));
Object.defineProperty(exports, "AbiCoder", ({ enumerable: true, get: function () { return index_js_1.AbiCoder; } }));
Object.defineProperty(exports, "ConstructorFragment", ({ enumerable: true, get: function () { return index_js_1.ConstructorFragment; } }));
Object.defineProperty(exports, "ErrorFragment", ({ enumerable: true, get: function () { return index_js_1.ErrorFragment; } }));
Object.defineProperty(exports, "EventFragment", ({ enumerable: true, get: function () { return index_js_1.EventFragment; } }));
Object.defineProperty(exports, "Fragment", ({ enumerable: true, get: function () { return index_js_1.Fragment; } }));
Object.defineProperty(exports, "FallbackFragment", ({ enumerable: true, get: function () { return index_js_1.FallbackFragment; } }));
Object.defineProperty(exports, "FunctionFragment", ({ enumerable: true, get: function () { return index_js_1.FunctionFragment; } }));
Object.defineProperty(exports, "NamedFragment", ({ enumerable: true, get: function () { return index_js_1.NamedFragment; } }));
Object.defineProperty(exports, "ParamType", ({ enumerable: true, get: function () { return index_js_1.ParamType; } }));
Object.defineProperty(exports, "StructFragment", ({ enumerable: true, get: function () { return index_js_1.StructFragment; } }));
Object.defineProperty(exports, "checkResultErrors", ({ enumerable: true, get: function () { return index_js_1.checkResultErrors; } }));
Object.defineProperty(exports, "ErrorDescription", ({ enumerable: true, get: function () { return index_js_1.ErrorDescription; } }));
Object.defineProperty(exports, "Indexed", ({ enumerable: true, get: function () { return index_js_1.Indexed; } }));
Object.defineProperty(exports, "Interface", ({ enumerable: true, get: function () { return index_js_1.Interface; } }));
Object.defineProperty(exports, "LogDescription", ({ enumerable: true, get: function () { return index_js_1.LogDescription; } }));
Object.defineProperty(exports, "Result", ({ enumerable: true, get: function () { return index_js_1.Result; } }));
Object.defineProperty(exports, "TransactionDescription", ({ enumerable: true, get: function () { return index_js_1.TransactionDescription; } }));
Object.defineProperty(exports, "Typed", ({ enumerable: true, get: function () { return index_js_1.Typed; } }));
var index_js_2 = __webpack_require__(/*! ./address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return index_js_2.getAddress; } }));
Object.defineProperty(exports, "getIcapAddress", ({ enumerable: true, get: function () { return index_js_2.getIcapAddress; } }));
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return index_js_2.getCreateAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return index_js_2.getCreate2Address; } }));
Object.defineProperty(exports, "isAddressable", ({ enumerable: true, get: function () { return index_js_2.isAddressable; } }));
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return index_js_2.isAddress; } }));
Object.defineProperty(exports, "resolveAddress", ({ enumerable: true, get: function () { return index_js_2.resolveAddress; } }));
var index_js_3 = __webpack_require__(/*! ./constants/index.js */ "../node_modules/ethers/lib.commonjs/constants/index.js");
Object.defineProperty(exports, "ZeroAddress", ({ enumerable: true, get: function () { return index_js_3.ZeroAddress; } }));
Object.defineProperty(exports, "WeiPerEther", ({ enumerable: true, get: function () { return index_js_3.WeiPerEther; } }));
Object.defineProperty(exports, "MaxUint256", ({ enumerable: true, get: function () { return index_js_3.MaxUint256; } }));
Object.defineProperty(exports, "MinInt256", ({ enumerable: true, get: function () { return index_js_3.MinInt256; } }));
Object.defineProperty(exports, "MaxInt256", ({ enumerable: true, get: function () { return index_js_3.MaxInt256; } }));
Object.defineProperty(exports, "N", ({ enumerable: true, get: function () { return index_js_3.N; } }));
Object.defineProperty(exports, "ZeroHash", ({ enumerable: true, get: function () { return index_js_3.ZeroHash; } }));
Object.defineProperty(exports, "EtherSymbol", ({ enumerable: true, get: function () { return index_js_3.EtherSymbol; } }));
Object.defineProperty(exports, "MessagePrefix", ({ enumerable: true, get: function () { return index_js_3.MessagePrefix; } }));
var index_js_4 = __webpack_require__(/*! ./contract/index.js */ "../node_modules/ethers/lib.commonjs/contract/index.js");
Object.defineProperty(exports, "BaseContract", ({ enumerable: true, get: function () { return index_js_4.BaseContract; } }));
Object.defineProperty(exports, "Contract", ({ enumerable: true, get: function () { return index_js_4.Contract; } }));
Object.defineProperty(exports, "ContractFactory", ({ enumerable: true, get: function () { return index_js_4.ContractFactory; } }));
Object.defineProperty(exports, "ContractEventPayload", ({ enumerable: true, get: function () { return index_js_4.ContractEventPayload; } }));
Object.defineProperty(exports, "ContractTransactionReceipt", ({ enumerable: true, get: function () { return index_js_4.ContractTransactionReceipt; } }));
Object.defineProperty(exports, "ContractTransactionResponse", ({ enumerable: true, get: function () { return index_js_4.ContractTransactionResponse; } }));
Object.defineProperty(exports, "ContractUnknownEventPayload", ({ enumerable: true, get: function () { return index_js_4.ContractUnknownEventPayload; } }));
Object.defineProperty(exports, "EventLog", ({ enumerable: true, get: function () { return index_js_4.EventLog; } }));
Object.defineProperty(exports, "UndecodedEventLog", ({ enumerable: true, get: function () { return index_js_4.UndecodedEventLog; } }));
var index_js_5 = __webpack_require__(/*! ./crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
Object.defineProperty(exports, "computeHmac", ({ enumerable: true, get: function () { return index_js_5.computeHmac; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return index_js_5.randomBytes; } }));
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return index_js_5.keccak256; } }));
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return index_js_5.ripemd160; } }));
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return index_js_5.sha256; } }));
Object.defineProperty(exports, "sha512", ({ enumerable: true, get: function () { return index_js_5.sha512; } }));
Object.defineProperty(exports, "pbkdf2", ({ enumerable: true, get: function () { return index_js_5.pbkdf2; } }));
Object.defineProperty(exports, "scrypt", ({ enumerable: true, get: function () { return index_js_5.scrypt; } }));
Object.defineProperty(exports, "scryptSync", ({ enumerable: true, get: function () { return index_js_5.scryptSync; } }));
Object.defineProperty(exports, "lock", ({ enumerable: true, get: function () { return index_js_5.lock; } }));
Object.defineProperty(exports, "Signature", ({ enumerable: true, get: function () { return index_js_5.Signature; } }));
Object.defineProperty(exports, "SigningKey", ({ enumerable: true, get: function () { return index_js_5.SigningKey; } }));
var index_js_6 = __webpack_require__(/*! ./hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
Object.defineProperty(exports, "id", ({ enumerable: true, get: function () { return index_js_6.id; } }));
Object.defineProperty(exports, "ensNormalize", ({ enumerable: true, get: function () { return index_js_6.ensNormalize; } }));
Object.defineProperty(exports, "isValidName", ({ enumerable: true, get: function () { return index_js_6.isValidName; } }));
Object.defineProperty(exports, "namehash", ({ enumerable: true, get: function () { return index_js_6.namehash; } }));
Object.defineProperty(exports, "dnsEncode", ({ enumerable: true, get: function () { return index_js_6.dnsEncode; } }));
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return index_js_6.hashMessage; } }));
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return index_js_6.verifyMessage; } }));
Object.defineProperty(exports, "solidityPacked", ({ enumerable: true, get: function () { return index_js_6.solidityPacked; } }));
Object.defineProperty(exports, "solidityPackedKeccak256", ({ enumerable: true, get: function () { return index_js_6.solidityPackedKeccak256; } }));
Object.defineProperty(exports, "solidityPackedSha256", ({ enumerable: true, get: function () { return index_js_6.solidityPackedSha256; } }));
Object.defineProperty(exports, "TypedDataEncoder", ({ enumerable: true, get: function () { return index_js_6.TypedDataEncoder; } }));
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return index_js_6.verifyTypedData; } }));
var index_js_7 = __webpack_require__(/*! ./providers/index.js */ "../node_modules/ethers/lib.commonjs/providers/index.js");
Object.defineProperty(exports, "getDefaultProvider", ({ enumerable: true, get: function () { return index_js_7.getDefaultProvider; } }));
Object.defineProperty(exports, "Block", ({ enumerable: true, get: function () { return index_js_7.Block; } }));
Object.defineProperty(exports, "FeeData", ({ enumerable: true, get: function () { return index_js_7.FeeData; } }));
Object.defineProperty(exports, "Log", ({ enumerable: true, get: function () { return index_js_7.Log; } }));
Object.defineProperty(exports, "TransactionReceipt", ({ enumerable: true, get: function () { return index_js_7.TransactionReceipt; } }));
Object.defineProperty(exports, "TransactionResponse", ({ enumerable: true, get: function () { return index_js_7.TransactionResponse; } }));
Object.defineProperty(exports, "AbstractSigner", ({ enumerable: true, get: function () { return index_js_7.AbstractSigner; } }));
Object.defineProperty(exports, "NonceManager", ({ enumerable: true, get: function () { return index_js_7.NonceManager; } }));
Object.defineProperty(exports, "VoidSigner", ({ enumerable: true, get: function () { return index_js_7.VoidSigner; } }));
Object.defineProperty(exports, "AbstractProvider", ({ enumerable: true, get: function () { return index_js_7.AbstractProvider; } }));
Object.defineProperty(exports, "FallbackProvider", ({ enumerable: true, get: function () { return index_js_7.FallbackProvider; } }));
Object.defineProperty(exports, "JsonRpcApiProvider", ({ enumerable: true, get: function () { return index_js_7.JsonRpcApiProvider; } }));
Object.defineProperty(exports, "JsonRpcProvider", ({ enumerable: true, get: function () { return index_js_7.JsonRpcProvider; } }));
Object.defineProperty(exports, "JsonRpcSigner", ({ enumerable: true, get: function () { return index_js_7.JsonRpcSigner; } }));
Object.defineProperty(exports, "BrowserProvider", ({ enumerable: true, get: function () { return index_js_7.BrowserProvider; } }));
Object.defineProperty(exports, "AlchemyProvider", ({ enumerable: true, get: function () { return index_js_7.AlchemyProvider; } }));
Object.defineProperty(exports, "AnkrProvider", ({ enumerable: true, get: function () { return index_js_7.AnkrProvider; } }));
Object.defineProperty(exports, "ChainstackProvider", ({ enumerable: true, get: function () { return index_js_7.ChainstackProvider; } }));
Object.defineProperty(exports, "CloudflareProvider", ({ enumerable: true, get: function () { return index_js_7.CloudflareProvider; } }));
Object.defineProperty(exports, "EtherscanProvider", ({ enumerable: true, get: function () { return index_js_7.EtherscanProvider; } }));
Object.defineProperty(exports, "InfuraProvider", ({ enumerable: true, get: function () { return index_js_7.InfuraProvider; } }));
Object.defineProperty(exports, "InfuraWebSocketProvider", ({ enumerable: true, get: function () { return index_js_7.InfuraWebSocketProvider; } }));
Object.defineProperty(exports, "PocketProvider", ({ enumerable: true, get: function () { return index_js_7.PocketProvider; } }));
Object.defineProperty(exports, "QuickNodeProvider", ({ enumerable: true, get: function () { return index_js_7.QuickNodeProvider; } }));
Object.defineProperty(exports, "IpcSocketProvider", ({ enumerable: true, get: function () { return index_js_7.IpcSocketProvider; } }));
Object.defineProperty(exports, "SocketProvider", ({ enumerable: true, get: function () { return index_js_7.SocketProvider; } }));
Object.defineProperty(exports, "WebSocketProvider", ({ enumerable: true, get: function () { return index_js_7.WebSocketProvider; } }));
Object.defineProperty(exports, "EnsResolver", ({ enumerable: true, get: function () { return index_js_7.EnsResolver; } }));
Object.defineProperty(exports, "Network", ({ enumerable: true, get: function () { return index_js_7.Network; } }));
Object.defineProperty(exports, "EnsPlugin", ({ enumerable: true, get: function () { return index_js_7.EnsPlugin; } }));
Object.defineProperty(exports, "EtherscanPlugin", ({ enumerable: true, get: function () { return index_js_7.EtherscanPlugin; } }));
Object.defineProperty(exports, "FeeDataNetworkPlugin", ({ enumerable: true, get: function () { return index_js_7.FeeDataNetworkPlugin; } }));
Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", ({ enumerable: true, get: function () { return index_js_7.FetchUrlFeeDataNetworkPlugin; } }));
Object.defineProperty(exports, "GasCostPlugin", ({ enumerable: true, get: function () { return index_js_7.GasCostPlugin; } }));
Object.defineProperty(exports, "NetworkPlugin", ({ enumerable: true, get: function () { return index_js_7.NetworkPlugin; } }));
Object.defineProperty(exports, "MulticoinProviderPlugin", ({ enumerable: true, get: function () { return index_js_7.MulticoinProviderPlugin; } }));
Object.defineProperty(exports, "SocketBlockSubscriber", ({ enumerable: true, get: function () { return index_js_7.SocketBlockSubscriber; } }));
Object.defineProperty(exports, "SocketEventSubscriber", ({ enumerable: true, get: function () { return index_js_7.SocketEventSubscriber; } }));
Object.defineProperty(exports, "SocketPendingSubscriber", ({ enumerable: true, get: function () { return index_js_7.SocketPendingSubscriber; } }));
Object.defineProperty(exports, "SocketSubscriber", ({ enumerable: true, get: function () { return index_js_7.SocketSubscriber; } }));
Object.defineProperty(exports, "UnmanagedSubscriber", ({ enumerable: true, get: function () { return index_js_7.UnmanagedSubscriber; } }));
Object.defineProperty(exports, "copyRequest", ({ enumerable: true, get: function () { return index_js_7.copyRequest; } }));
Object.defineProperty(exports, "showThrottleMessage", ({ enumerable: true, get: function () { return index_js_7.showThrottleMessage; } }));
var index_js_8 = __webpack_require__(/*! ./transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
Object.defineProperty(exports, "accessListify", ({ enumerable: true, get: function () { return index_js_8.accessListify; } }));
Object.defineProperty(exports, "computeAddress", ({ enumerable: true, get: function () { return index_js_8.computeAddress; } }));
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return index_js_8.recoverAddress; } }));
Object.defineProperty(exports, "Transaction", ({ enumerable: true, get: function () { return index_js_8.Transaction; } }));
var index_js_9 = __webpack_require__(/*! ./utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
Object.defineProperty(exports, "decodeBase58", ({ enumerable: true, get: function () { return index_js_9.decodeBase58; } }));
Object.defineProperty(exports, "encodeBase58", ({ enumerable: true, get: function () { return index_js_9.encodeBase58; } }));
Object.defineProperty(exports, "decodeBase64", ({ enumerable: true, get: function () { return index_js_9.decodeBase64; } }));
Object.defineProperty(exports, "encodeBase64", ({ enumerable: true, get: function () { return index_js_9.encodeBase64; } }));
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return index_js_9.concat; } }));
Object.defineProperty(exports, "dataLength", ({ enumerable: true, get: function () { return index_js_9.dataLength; } }));
Object.defineProperty(exports, "dataSlice", ({ enumerable: true, get: function () { return index_js_9.dataSlice; } }));
Object.defineProperty(exports, "getBytes", ({ enumerable: true, get: function () { return index_js_9.getBytes; } }));
Object.defineProperty(exports, "getBytesCopy", ({ enumerable: true, get: function () { return index_js_9.getBytesCopy; } }));
Object.defineProperty(exports, "hexlify", ({ enumerable: true, get: function () { return index_js_9.hexlify; } }));
Object.defineProperty(exports, "isHexString", ({ enumerable: true, get: function () { return index_js_9.isHexString; } }));
Object.defineProperty(exports, "isBytesLike", ({ enumerable: true, get: function () { return index_js_9.isBytesLike; } }));
Object.defineProperty(exports, "stripZerosLeft", ({ enumerable: true, get: function () { return index_js_9.stripZerosLeft; } }));
Object.defineProperty(exports, "zeroPadBytes", ({ enumerable: true, get: function () { return index_js_9.zeroPadBytes; } }));
Object.defineProperty(exports, "zeroPadValue", ({ enumerable: true, get: function () { return index_js_9.zeroPadValue; } }));
Object.defineProperty(exports, "defineProperties", ({ enumerable: true, get: function () { return index_js_9.defineProperties; } }));
Object.defineProperty(exports, "resolveProperties", ({ enumerable: true, get: function () { return index_js_9.resolveProperties; } }));
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return index_js_9.assert; } }));
Object.defineProperty(exports, "assertArgument", ({ enumerable: true, get: function () { return index_js_9.assertArgument; } }));
Object.defineProperty(exports, "assertArgumentCount", ({ enumerable: true, get: function () { return index_js_9.assertArgumentCount; } }));
Object.defineProperty(exports, "assertNormalize", ({ enumerable: true, get: function () { return index_js_9.assertNormalize; } }));
Object.defineProperty(exports, "assertPrivate", ({ enumerable: true, get: function () { return index_js_9.assertPrivate; } }));
Object.defineProperty(exports, "makeError", ({ enumerable: true, get: function () { return index_js_9.makeError; } }));
Object.defineProperty(exports, "isCallException", ({ enumerable: true, get: function () { return index_js_9.isCallException; } }));
Object.defineProperty(exports, "isError", ({ enumerable: true, get: function () { return index_js_9.isError; } }));
Object.defineProperty(exports, "EventPayload", ({ enumerable: true, get: function () { return index_js_9.EventPayload; } }));
Object.defineProperty(exports, "FetchRequest", ({ enumerable: true, get: function () { return index_js_9.FetchRequest; } }));
Object.defineProperty(exports, "FetchResponse", ({ enumerable: true, get: function () { return index_js_9.FetchResponse; } }));
Object.defineProperty(exports, "FetchCancelSignal", ({ enumerable: true, get: function () { return index_js_9.FetchCancelSignal; } }));
Object.defineProperty(exports, "FixedNumber", ({ enumerable: true, get: function () { return index_js_9.FixedNumber; } }));
Object.defineProperty(exports, "getBigInt", ({ enumerable: true, get: function () { return index_js_9.getBigInt; } }));
Object.defineProperty(exports, "getNumber", ({ enumerable: true, get: function () { return index_js_9.getNumber; } }));
Object.defineProperty(exports, "getUint", ({ enumerable: true, get: function () { return index_js_9.getUint; } }));
Object.defineProperty(exports, "toBeArray", ({ enumerable: true, get: function () { return index_js_9.toBeArray; } }));
Object.defineProperty(exports, "toBigInt", ({ enumerable: true, get: function () { return index_js_9.toBigInt; } }));
Object.defineProperty(exports, "toBeHex", ({ enumerable: true, get: function () { return index_js_9.toBeHex; } }));
Object.defineProperty(exports, "toNumber", ({ enumerable: true, get: function () { return index_js_9.toNumber; } }));
Object.defineProperty(exports, "toQuantity", ({ enumerable: true, get: function () { return index_js_9.toQuantity; } }));
Object.defineProperty(exports, "fromTwos", ({ enumerable: true, get: function () { return index_js_9.fromTwos; } }));
Object.defineProperty(exports, "toTwos", ({ enumerable: true, get: function () { return index_js_9.toTwos; } }));
Object.defineProperty(exports, "mask", ({ enumerable: true, get: function () { return index_js_9.mask; } }));
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return index_js_9.formatEther; } }));
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return index_js_9.parseEther; } }));
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return index_js_9.formatUnits; } }));
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return index_js_9.parseUnits; } }));
Object.defineProperty(exports, "toUtf8Bytes", ({ enumerable: true, get: function () { return index_js_9.toUtf8Bytes; } }));
Object.defineProperty(exports, "toUtf8CodePoints", ({ enumerable: true, get: function () { return index_js_9.toUtf8CodePoints; } }));
Object.defineProperty(exports, "toUtf8String", ({ enumerable: true, get: function () { return index_js_9.toUtf8String; } }));
Object.defineProperty(exports, "Utf8ErrorFuncs", ({ enumerable: true, get: function () { return index_js_9.Utf8ErrorFuncs; } }));
Object.defineProperty(exports, "decodeRlp", ({ enumerable: true, get: function () { return index_js_9.decodeRlp; } }));
Object.defineProperty(exports, "encodeRlp", ({ enumerable: true, get: function () { return index_js_9.encodeRlp; } }));
Object.defineProperty(exports, "uuidV4", ({ enumerable: true, get: function () { return index_js_9.uuidV4; } }));
var index_js_10 = __webpack_require__(/*! ./wallet/index.js */ "../node_modules/ethers/lib.commonjs/wallet/index.js");
Object.defineProperty(exports, "Mnemonic", ({ enumerable: true, get: function () { return index_js_10.Mnemonic; } }));
Object.defineProperty(exports, "BaseWallet", ({ enumerable: true, get: function () { return index_js_10.BaseWallet; } }));
Object.defineProperty(exports, "HDNodeWallet", ({ enumerable: true, get: function () { return index_js_10.HDNodeWallet; } }));
Object.defineProperty(exports, "HDNodeVoidWallet", ({ enumerable: true, get: function () { return index_js_10.HDNodeVoidWallet; } }));
Object.defineProperty(exports, "Wallet", ({ enumerable: true, get: function () { return index_js_10.Wallet; } }));
Object.defineProperty(exports, "defaultPath", ({ enumerable: true, get: function () { return index_js_10.defaultPath; } }));
Object.defineProperty(exports, "getAccountPath", ({ enumerable: true, get: function () { return index_js_10.getAccountPath; } }));
Object.defineProperty(exports, "getIndexedAccountPath", ({ enumerable: true, get: function () { return index_js_10.getIndexedAccountPath; } }));
Object.defineProperty(exports, "isCrowdsaleJson", ({ enumerable: true, get: function () { return index_js_10.isCrowdsaleJson; } }));
Object.defineProperty(exports, "isKeystoreJson", ({ enumerable: true, get: function () { return index_js_10.isKeystoreJson; } }));
Object.defineProperty(exports, "decryptCrowdsaleJson", ({ enumerable: true, get: function () { return index_js_10.decryptCrowdsaleJson; } }));
Object.defineProperty(exports, "decryptKeystoreJsonSync", ({ enumerable: true, get: function () { return index_js_10.decryptKeystoreJsonSync; } }));
Object.defineProperty(exports, "decryptKeystoreJson", ({ enumerable: true, get: function () { return index_js_10.decryptKeystoreJson; } }));
Object.defineProperty(exports, "encryptKeystoreJson", ({ enumerable: true, get: function () { return index_js_10.encryptKeystoreJson; } }));
Object.defineProperty(exports, "encryptKeystoreJsonSync", ({ enumerable: true, get: function () { return index_js_10.encryptKeystoreJsonSync; } }));
var index_js_11 = __webpack_require__(/*! ./wordlists/index.js */ "../node_modules/ethers/lib.commonjs/wordlists/index.js");
Object.defineProperty(exports, "Wordlist", ({ enumerable: true, get: function () { return index_js_11.Wordlist; } }));
Object.defineProperty(exports, "LangEn", ({ enumerable: true, get: function () { return index_js_11.LangEn; } }));
Object.defineProperty(exports, "WordlistOwl", ({ enumerable: true, get: function () { return index_js_11.WordlistOwl; } }));
Object.defineProperty(exports, "WordlistOwlA", ({ enumerable: true, get: function () { return index_js_11.WordlistOwlA; } }));
Object.defineProperty(exports, "wordlists", ({ enumerable: true, get: function () { return index_js_11.wordlists; } }));
//# sourceMappingURL=ethers.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/id.js":
/*!******************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/id.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.id = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  A simple hashing function which operates on UTF-8 strings to
 *  compute an 32-byte identifier.
 *
 *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
 *  the [[keccak256]].
 *
 *  @example:
 *    id("hello world")
 *    //_result:
 */
function id(value) {
    return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));
}
exports.id = id;
//# sourceMappingURL=id.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Utilities for common tasks involving hashing. Also see
 *  [cryptographic hashing](about-crypto-hashing).
 *
 *  @_section: api/hashing:Hashing Utilities  [about-hashing]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;
var id_js_1 = __webpack_require__(/*! ./id.js */ "../node_modules/ethers/lib.commonjs/hash/id.js");
Object.defineProperty(exports, "id", ({ enumerable: true, get: function () { return id_js_1.id; } }));
var namehash_js_1 = __webpack_require__(/*! ./namehash.js */ "../node_modules/ethers/lib.commonjs/hash/namehash.js");
Object.defineProperty(exports, "ensNormalize", ({ enumerable: true, get: function () { return namehash_js_1.ensNormalize; } }));
Object.defineProperty(exports, "isValidName", ({ enumerable: true, get: function () { return namehash_js_1.isValidName; } }));
Object.defineProperty(exports, "namehash", ({ enumerable: true, get: function () { return namehash_js_1.namehash; } }));
Object.defineProperty(exports, "dnsEncode", ({ enumerable: true, get: function () { return namehash_js_1.dnsEncode; } }));
var message_js_1 = __webpack_require__(/*! ./message.js */ "../node_modules/ethers/lib.commonjs/hash/message.js");
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return message_js_1.hashMessage; } }));
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return message_js_1.verifyMessage; } }));
var solidity_js_1 = __webpack_require__(/*! ./solidity.js */ "../node_modules/ethers/lib.commonjs/hash/solidity.js");
Object.defineProperty(exports, "solidityPacked", ({ enumerable: true, get: function () { return solidity_js_1.solidityPacked; } }));
Object.defineProperty(exports, "solidityPackedKeccak256", ({ enumerable: true, get: function () { return solidity_js_1.solidityPackedKeccak256; } }));
Object.defineProperty(exports, "solidityPackedSha256", ({ enumerable: true, get: function () { return solidity_js_1.solidityPackedSha256; } }));
var typed_data_js_1 = __webpack_require__(/*! ./typed-data.js */ "../node_modules/ethers/lib.commonjs/hash/typed-data.js");
Object.defineProperty(exports, "TypedDataEncoder", ({ enumerable: true, get: function () { return typed_data_js_1.TypedDataEncoder; } }));
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return typed_data_js_1.verifyTypedData; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/message.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/message.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyMessage = exports.hashMessage = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../constants/index.js */ "../node_modules/ethers/lib.commonjs/constants/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  Computes the [[link-eip-191]] personal-sign message digest to sign.
 *
 *  This prefixes the message with [[MessagePrefix]] and the decimal length
 *  of %%message%% and computes the [[keccak256]] digest.
 *
 *  If %%message%% is a string, it is converted to its UTF-8 bytes
 *  first. To compute the digest of a [[DataHexString]], it must be converted
 *  to [bytes](getBytes).
 *
 *  @example:
 *    hashMessage("Hello World")
 *    //_result:
 *
 *    // Hashes the SIX (6) string characters, i.e.
 *    // [ "0", "x", "4", "2", "4", "3" ]
 *    hashMessage("0x4243")
 *    //_result:
 *
 *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
 *    hashMessage(getBytes("0x4243"))
 *    //_result:
 *
 *    // ...which is equal to using data
 *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))
 *    //_result:
 *
 */
function hashMessage(message) {
    if (typeof (message) === "string") {
        message = (0, index_js_4.toUtf8Bytes)(message);
    }
    return (0, index_js_1.keccak256)((0, index_js_4.concat)([
        (0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix),
        (0, index_js_4.toUtf8Bytes)(String(message.length)),
        message
    ]));
}
exports.hashMessage = hashMessage;
/**
 *  Return the address of the private key that produced
 *  the signature %%sig%% during signing for %%message%%.
 */
function verifyMessage(message, sig) {
    const digest = hashMessage(message);
    return (0, index_js_3.recoverAddress)(digest, sig);
}
exports.verifyMessage = verifyMessage;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/namehash.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/namehash.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const ens_normalize_1 = __webpack_require__(/*! @adraffy/ens-normalize */ "../node_modules/@adraffy/ens-normalize/dist/index.cjs");
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    (0, index_js_2.assertArgument)(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
    return comp;
}
function ensNameSplit(name) {
    const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));
    const comps = [];
    if (name.length === 0) {
        return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes.length; i++) {
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    (0, index_js_2.assertArgument)(last < bytes.length, "invalid ENS name; empty component", "name", name);
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
/**
 *  Returns the ENS %%name%% normalized.
 */
function ensNormalize(name) {
    try {
        if (name.length === 0) {
            throw new Error("empty label");
        }
        return (0, ens_normalize_1.ens_normalize)(name);
    }
    catch (error) {
        (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, "name", name);
    }
}
exports.ensNormalize = ensNormalize;
/**
 *  Returns ``true`` if %%name%% is a valid ENS name.
 */
function isValidName(name) {
    try {
        return (ensNameSplit(name).length !== 0);
    }
    catch (error) { }
    return false;
}
exports.isValidName = isValidName;
/**
 *  Returns the [[link-namehash]] for %%name%%.
 */
function namehash(name) {
    (0, index_js_2.assertArgument)(typeof (name) === "string", "invalid ENS name; not a string", "name", name);
    (0, index_js_2.assertArgument)(name.length, `invalid ENS name (empty label)`, "name", name);
    let result = Zeros;
    const comps = ensNameSplit(name);
    while (comps.length) {
        result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)((comps.pop()))]));
    }
    return (0, index_js_2.hexlify)(result);
}
exports.namehash = namehash;
/**
 *  Returns the DNS encoded %%name%%.
 *
 *  This is used for various parts of ENS name resolution, such
 *  as the wildcard resolution.
 */
function dnsEncode(name, _maxLength) {
    const length = (_maxLength != null) ? _maxLength : 63;
    (0, index_js_2.assertArgument)(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
    return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map((comp) => {
        (0, index_js_2.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}
exports.dnsEncode = dnsEncode;
//# sourceMappingURL=namehash.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/solidity.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/solidity.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
            }
            return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));
        case "string":
            return (0, index_js_3.toUtf8Bytes)(value);
        case "bytes":
            return (0, index_js_3.getBytes)(value);
        case "bool":
            value = (!!value ? "0x01" : "0x00");
            if (isArray) {
                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
            }
            return (0, index_js_3.getBytes)(value);
    }
    let match = type.match(regexNumber);
    if (match) {
        let signed = (match[1] === "int");
        let size = parseInt(match[2] || "256");
        (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, "invalid number type", "type", type);
        if (isArray) {
            size = 256;
        }
        if (signed) {
            value = (0, index_js_3.toTwos)(value, size);
        }
        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));
    }
    match = type.match(regexBytes);
    if (match) {
        const size = parseInt(match[1]);
        (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
        (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, "value", value);
        if (isArray) {
            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));
        }
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, "value", value);
        const result = [];
        value.forEach(function (value) {
            result.push(_pack(baseType, value, true));
        });
        return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));
    }
    (0, index_js_3.assertArgument)(false, "invalid type", "type", type);
}
// @TODO: Array Enum
/**
 *   Computes the [[link-solc-packed]] representation of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPacked(types, values) {
    (0, index_js_3.assertArgument)(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
    const tight = [];
    types.forEach(function (type, index) {
        tight.push(_pack(type, values[index]));
    });
    return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));
}
exports.solidityPacked = solidityPacked;
/**
 *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedKeccak256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedKeccak256(types, values) {
    return (0, index_js_2.keccak256)(solidityPacked(types, values));
}
exports.solidityPackedKeccak256 = solidityPackedKeccak256;
/**
 *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedSha256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedSha256(types, values) {
    return (0, index_js_2.sha256)(solidityPacked(types, values));
}
exports.solidityPackedSha256 = solidityPackedSha256;
//# sourceMappingURL=solidity.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/hash/typed-data.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/hash/typed-data.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = exports.TypedDataEncoder = void 0;
//import { TypedDataDomain, TypedDataField } from "@ethersproject/providerabstract-signer";
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const id_js_1 = __webpack_require__(/*! ./id.js */ "../node_modules/ethers/lib.commonjs/hash/id.js");
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
;
;
function hexPadRight(value) {
    const bytes = (0, index_js_4.getBytes)(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);
    }
    return (0, index_js_4.hexlify)(bytes);
}
const hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);
const hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        (0, index_js_4.assertArgument)(typeof (value) === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (_value) {
        const value = (0, index_js_4.getBigInt)(_value, "domain.chainId");
        (0, index_js_4.assertArgument)(value >= 0, "invalid chain ID", "domain.chainId", _value);
        if (Number.isSafeInteger(value)) {
            return Number(value);
        }
        return (0, index_js_4.toQuantity)(value);
    },
    verifyingContract: function (value) {
        try {
            return (0, index_js_1.getAddress)(value).toLowerCase();
        }
        catch (error) { }
        (0, index_js_4.assertArgument)(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        const bytes = (0, index_js_4.getBytes)(value, "domain.salt");
        (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
        return (0, index_js_4.hexlify)(bytes);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d+)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2]);
            (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
            const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? (width - 1) : width);
            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;
            return function (_value) {
                const value = (0, index_js_4.getBigInt)(_value, "value");
                (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
                return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
            return function (value) {
                const bytes = (0, index_js_4.getBytes)(value);
                (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type}`, "value", value);
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return (0, index_js_2.keccak256)(value);
        };
        case "string": return function (value) {
            return (0, id_js_1.id)(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
// foo[][3] => { base: "foo", index: "[][3]", array: {
//     base: "foo", prefix: "foo[]", count: 3 } }
function splitArray(type) {
    const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
        return {
            base: match[1],
            index: (match[2] + match[4]),
            array: {
                base: match[1],
                prefix: (match[1] + match[2]),
                count: (match[5] ? parseInt(match[5]) : -1),
            }
        };
    }
    return { base: type };
}
/**
 *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads
 *  for signed typed data.
 *
 *  This is useful for those that wish to compute various components of a
 *  typed data hash, primary types, or sub-components, but generally the
 *  higher level [[Signer-signTypedData]] is more useful.
 */
class TypedDataEncoder {
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    primaryType;
    #types;
    /**
     *  The types.
     */
    get types() {
        return JSON.parse(this.#types);
    }
    #fullTypes;
    #encoderCache;
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     *
     *  This performs all necessary checking that types are valid and
     *  do not violate the [[link-eip-712]] structural constraints as
     *  well as computes the [[primaryType]].
     */
    constructor(_types) {
        this.#fullTypes = new Map();
        this.#encoderCache = new Map();
        // Link struct types to their direct child structs
        const links = new Map();
        // Link structs to structs which contain them as a child
        const parents = new Map();
        // Link all subtypes within a given struct
        const subtypes = new Map();
        const types = {};
        Object.keys(_types).forEach((type) => {
            types[type] = _types[type].map(({ name, type }) => {
                // Normalize the base type (unless name conflict)
                let { base, index } = splitArray(type);
                if (base === "int" && !_types["int"]) {
                    base = "int256";
                }
                if (base === "uint" && !_types["uint"]) {
                    base = "uint256";
                }
                return { name, type: (base + (index || "")) };
            });
            links.set(type, new Set());
            parents.set(type, []);
            subtypes.set(type, new Set());
        });
        this.#types = JSON.stringify(types);
        for (const name in types) {
            const uniqueNames = new Set();
            for (const field of types[name]) {
                // Check each field has a unique name
                (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
                uniqueNames.add(field.name);
                // Get the base type (drop any array specifiers)
                const baseType = splitArray(field.type).base;
                (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    continue;
                }
                (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
                // Add linkage
                parents.get(baseType).push(name);
                links.get(name).add(baseType);
            }
        }
        // Deduce the primary type
        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));
        (0, index_js_4.assertArgument)(primaryTypes.length !== 0, "missing primary type", "types", _types);
        (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", _types);
        (0, index_js_4.defineProperties)(this, { primaryType: primaryTypes[0] });
        // Check for circular type references
        function checkCircular(type, found) {
            (0, index_js_4.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
            found.add(type);
            for (const child of links.get(type)) {
                if (!parents.has(child)) {
                    continue;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                for (const subtype of found) {
                    subtypes.get(subtype).add(child);
                }
            }
            found.delete(type);
        }
        checkCircular(this.primaryType, new Set());
        // Compute each fully describe type
        for (const [name, set] of subtypes) {
            const st = Array.from(set);
            st.sort();
            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
        }
    }
    /**
     *  Returnthe encoder for the specific %%type%%.
     */
    getEncoder(type) {
        let encoder = this.#encoderCache.get(type);
        if (!encoder) {
            encoder = this.#getEncoder(type);
            this.#encoderCache.set(type, encoder);
        }
        return encoder;
    }
    #getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const array = splitArray(type).array;
        if (array) {
            const subtype = array.prefix;
            const subEncoder = this.getEncoder(subtype);
            return (value) => {
                (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
                let result = value.map(subEncoder);
                if (this.#fullTypes.has(subtype)) {
                    result = result.map(index_js_2.keccak256);
                }
                return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = (0, id_js_1.id)(this.#fullTypes.get(type));
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this.#fullTypes.has(type)) {
                        return (0, index_js_2.keccak256)(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return (0, index_js_4.concat)(values);
            };
        }
        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, "type", type);
    }
    /**
     *  Return the full type for %%name%%.
     */
    encodeType(name) {
        const result = this.#fullTypes.get(name);
        (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
    }
    /**
     *  Return the encoded %%value%% for the %%type%%.
     */
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    /**
     *  Returns the hash of %%value%% for the type of %%name%%.
     */
    hashStruct(name, value) {
        return (0, index_js_2.keccak256)(this.encodeData(name, value));
    }
    /**
     *  Return the fulled encoded %%value%% for the [[types]].
     */
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    /**
     *  Return the hash of the fully encoded %%value%% for the [[types]].
     */
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    /**
     *  @_ignore:
     */
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const array = splitArray(type).array;
        if (array) {
            (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
            return value.map((v) => this._visit(array.prefix, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, "type", type);
    }
    /**
     *  Call %%calback%% for each value in %%value%%, passing the type and
     *  component within %%value%%.
     *
     *  This is useful for replacing addresses or other transformation that
     *  may be desired on each component, based on its type.
     */
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     */
    static from(types) {
        return new TypedDataEncoder(types);
    }
    /**
     *  Return the primary type for %%types%%.
     */
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    /**
     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
     */
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    /**
     *  Return the domain hash for %%domain%%.
     */
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            if (domain[name] == null) {
                continue;
            }
            const type = domainFieldTypes[name];
            (0, index_js_4.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    /**
     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static encode(domain, types, value) {
        return (0, index_js_4.concat)([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    /**
     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static hash(domain, types, value) {
        return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    /**
     * Resolves to the value from resolving all addresses in %%value%% for
     * %%types%% and the %%domain%%.
     */
    static async resolveNames(domain, types, value, resolveName) {
        // Make a copy to isolate it from the object passed in
        domain = Object.assign({}, domain);
        // Allow passing null to ignore value
        for (const key in domain) {
            if (domain[key] == null) {
                delete domain[key];
            }
        }
        // Look up all ENS names
        const ensCache = {};
        // Do we need to look up the domain's verifyingContract?
        if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
        }
        // We are going to use the encoder to visit all the base values
        const encoder = TypedDataEncoder.from(types);
        // Get a list of all the addresses
        encoder.visit(value, (type, value) => {
            if (type === "address" && !(0, index_js_4.isHexString)(value, 20)) {
                ensCache[value] = "0x";
            }
            return value;
        });
        // Lookup each name
        for (const name in ensCache) {
            ensCache[name] = await resolveName(name);
        }
        // Replace the domain verifyingContract if needed
        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
        }
        // Replace all ENS names with their address
        value = encoder.visit(value, (type, value) => {
            if (type === "address" && ensCache[value]) {
                return ensCache[value];
            }
            return value;
        });
        return { domain, value };
    }
    /**
     *  Returns the JSON-encoded payload expected by nodes which implement
     *  the JSON-RPC [[link-eip-712]] method.
     */
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        // Get the normalized types
        types = encoder.types;
        const typesWithDomain = Object.assign({}, types);
        (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
        typesWithDomain.EIP712Domain = domainTypes;
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return (0, index_js_4.getBigInt)(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        (0, index_js_4.assertArgument)(typeof (value) === "string", "invalid string", "value", value);
                        return value;
                }
                (0, index_js_4.assertArgument)(false, "unsupported type", "type", type);
            })
        };
    }
}
exports.TypedDataEncoder = TypedDataEncoder;
/**
 *  Compute the address used to sign the typed data for the %%signature%%.
 */
function verifyTypedData(domain, types, value, signature) {
    return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);
}
exports.verifyTypedData = verifyTypedData;
//# sourceMappingURL=typed-data.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/index.js":
/*!****************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ethers = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
/**
 *  The Application Programming Interface (API) is the collection of
 *  functions, classes and types offered by the Ethers library.
 *
 *  @_section: api:Application Programming Interface  [about-api]
 *  @_navTitle: API
 */
const ethers = tslib_1.__importStar(__webpack_require__(/*! ./ethers.js */ "../node_modules/ethers/lib.commonjs/ethers.js"));
exports.ethers = ethers;
tslib_1.__exportStar(__webpack_require__(/*! ./ethers.js */ "../node_modules/ethers/lib.commonjs/ethers.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js":
/*!**************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/abstract-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  The available providers should suffice for most developers purposes,
 *  but the [[AbstractProvider]] class has many features which enable
 *  sub-classing it for specific purposes.
 *
 *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractProvider = exports.UnmanagedSubscriber = void 0;
// @TODO
// Event coalescence
//   When we register an event with an async value (e.g. address is a Signer
//   or ENS name), we need to add it immeidately for the Event API, but also
//   need time to resolve the address. Upon resolving the address, we need to
//   migrate the listener to the static event. We also need to maintain a map
//   of Signer/ENS name to address so we can sync respond to listenerCount.
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../constants/index.js */ "../node_modules/ethers/lib.commonjs/constants/index.js");
const index_js_3 = __webpack_require__(/*! ../contract/index.js */ "../node_modules/ethers/lib.commonjs/contract/index.js");
const index_js_4 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_5 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_6 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ "../node_modules/ethers/lib.commonjs/providers/ens-resolver.js");
const format_js_1 = __webpack_require__(/*! ./format.js */ "../node_modules/ethers/lib.commonjs/providers/format.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_js_1 = __webpack_require__(/*! ./provider.js */ "../node_modules/ethers/lib.commonjs/providers/provider.js");
const subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ "../node_modules/ethers/lib.commonjs/providers/subscriber-polling.js");
// Constants
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
    return (value && typeof (value.then) === "function");
}
function getTag(prefix, value) {
    return prefix + ":" + JSON.stringify(value, (k, v) => {
        if (v == null) {
            return "null";
        }
        if (typeof (v) === "bigint") {
            return `bigint:${v.toString()}`;
        }
        if (typeof (v) === "string") {
            return v.toLowerCase();
        }
        // Sort object keys
        if (typeof (v) === "object" && !Array.isArray(v)) {
            const keys = Object.keys(v);
            keys.sort();
            return keys.reduce((accum, key) => {
                accum[key] = v[key];
                return accum;
            }, {});
        }
        return v;
    });
}
/**
 *  An **UnmanagedSubscriber** is useful for events which do not require
 *  any additional management, such as ``"debug"`` which only requires
 *  emit in synchronous event loop triggered calls.
 */
class UnmanagedSubscriber {
    /**
     *  The name fof the event.
     */
    name;
    /**
     *  Create a new UnmanagedSubscriber with %%name%%.
     */
    constructor(name) { (0, index_js_6.defineProperties)(this, { name }); }
    start() { }
    stop() { }
    pause(dropWhilePaused) { }
    resume() { }
}
exports.UnmanagedSubscriber = UnmanagedSubscriber;
function copy(value) {
    return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
    items = Array.from((new Set(items)).values());
    items.sort();
    return items;
}
async function getSubscription(_event, provider) {
    if (_event == null) {
        throw new Error("invalid event");
    }
    // Normalize topic array info an EventFilter
    if (Array.isArray(_event)) {
        _event = { topics: _event };
    }
    if (typeof (_event) === "string") {
        switch (_event) {
            case "block":
            case "debug":
            case "error":
            case "finalized":
            case "network":
            case "pending":
            case "safe": {
                return { type: _event, tag: _event };
            }
        }
    }
    if ((0, index_js_6.isHexString)(_event, 32)) {
        const hash = _event.toLowerCase();
        return { type: "transaction", tag: getTag("tx", { hash }), hash };
    }
    if (_event.orphan) {
        const event = _event;
        // @TODO: Should lowercase and whatnot things here instead of copy...
        return { type: "orphan", tag: getTag("orphan", event), filter: copy(event) };
    }
    if ((_event.address || _event.topics)) {
        const event = _event;
        const filter = {
            topics: ((event.topics || []).map((t) => {
                if (t == null) {
                    return null;
                }
                if (Array.isArray(t)) {
                    return concisify(t.map((t) => t.toLowerCase()));
                }
                return t.toLowerCase();
            }))
        };
        if (event.address) {
            const addresses = [];
            const promises = [];
            const addAddress = (addr) => {
                if ((0, index_js_6.isHexString)(addr)) {
                    addresses.push(addr);
                }
                else {
                    promises.push((async () => {
                        addresses.push(await (0, index_js_1.resolveAddress)(addr, provider));
                    })());
                }
            };
            if (Array.isArray(event.address)) {
                event.address.forEach(addAddress);
            }
            else {
                addAddress(event.address);
            }
            if (promises.length) {
                await Promise.all(promises);
            }
            filter.address = concisify(addresses.map((a) => a.toLowerCase()));
        }
        return { filter, tag: getTag("event", filter), type: "event" };
    }
    (0, index_js_6.assertArgument)(false, "unknown ProviderEvent", "event", _event);
}
function getTime() { return (new Date()).getTime(); }
const defaultOptions = {
    cacheTimeout: 250,
    pollingInterval: 4000
};
/**
 *  An **AbstractProvider** provides a base class for other sub-classes to
 *  implement the [[Provider]] API by normalizing input arguments and
 *  formatting output results as well as tracking events for consistent
 *  behaviour on an eventually-consistent network.
 */
class AbstractProvider {
    #subs;
    #plugins;
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    #pausedState;
    #destroyed;
    #networkPromise;
    #anyNetwork;
    #performCache;
    // The most recent block number if running an event or -1 if no "block" event
    #lastBlockNumber;
    #nextTimer;
    #timers;
    #disableCcipRead;
    #options;
    /**
     *  Create a new **AbstractProvider** connected to %%network%%, or
     *  use the various network detection capabilities to discover the
     *  [[Network]] if necessary.
     */
    constructor(_network, options) {
        this.#options = Object.assign({}, defaultOptions, options || {});
        if (_network === "any") {
            this.#anyNetwork = true;
            this.#networkPromise = null;
        }
        else if (_network) {
            const network = network_js_1.Network.from(_network);
            this.#anyNetwork = false;
            this.#networkPromise = Promise.resolve(network);
            setTimeout(() => { this.emit("network", network, null); }, 0);
        }
        else {
            this.#anyNetwork = false;
            this.#networkPromise = null;
        }
        this.#lastBlockNumber = -1;
        this.#performCache = new Map();
        this.#subs = new Map();
        this.#plugins = new Map();
        this.#pausedState = null;
        this.#destroyed = false;
        this.#nextTimer = 1;
        this.#timers = new Map();
        this.#disableCcipRead = false;
    }
    get pollingInterval() { return this.#options.pollingInterval; }
    /**
     *  Returns ``this``, to allow an **AbstractProvider** to implement
     *  the [[ContractRunner]] interface.
     */
    get provider() { return this; }
    /**
     *  Returns all the registered plug-ins.
     */
    get plugins() {
        return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new plug-in.
     */
    attachPlugin(plugin) {
        if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        this.#plugins.set(plugin.name, plugin.connect(this));
        return this;
    }
    /**
     *  Get a plugin by name.
     */
    getPlugin(name) {
        return (this.#plugins.get(name)) || null;
    }
    /**
     *  Prevent any CCIP-read operation, regardless of whether requested
     *  in a [[call]] using ``enableCcipRead``.
     */
    get disableCcipRead() { return this.#disableCcipRead; }
    set disableCcipRead(value) { this.#disableCcipRead = !!value; }
    // Shares multiple identical requests made during the same 250ms
    async #perform(req) {
        const timeout = this.#options.cacheTimeout;
        // Caching disabled
        if (timeout < 0) {
            return await this._perform(req);
        }
        // Create a tag
        const tag = getTag(req.method, req);
        let perform = this.#performCache.get(tag);
        if (!perform) {
            perform = this._perform(req);
            this.#performCache.set(tag, perform);
            setTimeout(() => {
                if (this.#performCache.get(tag) === perform) {
                    this.#performCache.delete(tag);
                }
            }, timeout);
        }
        return await perform;
    }
    /**
     *  Resolves to the data for executing the CCIP-read operations.
     */
    async ccipReadFetch(tx, calldata, urls) {
        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
            return null;
        }
        const sender = tx.to.toLowerCase();
        const data = calldata.toLowerCase();
        const errorMessages = [];
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            // URL expansion
            const href = url.replace("{sender}", sender).replace("{data}", data);
            // If no {data} is present, use POST; otherwise GET
            //const json: string | null = (url.indexOf("{data}") >= 0) ? null: JSON.stringify({ data, sender });
            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
            //    value.status = response.statusCode;
            //    return value;
            //});
            const request = new index_js_6.FetchRequest(href);
            if (url.indexOf("{data}") === -1) {
                request.body = { data, sender };
            }
            this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
            let errorMessage = "unknown error";
            const resp = await request.send();
            try {
                const result = resp.bodyJson;
                if (result.data) {
                    this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
                    return result.data;
                }
                if (result.message) {
                    errorMessage = result.message;
                }
                this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
            }
            catch (error) { }
            // 4xx indicates the result is not present; stop
            (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
            // 5xx indicates server issue; try the next url
            errorMessages.push(errorMessage);
        }
        (0, index_js_6.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: tx, info: { urls, errorMessages }
        });
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a block before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Block]].
     */
    _wrapBlock(value, network) {
        return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a log before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Log]].
     */
    _wrapLog(value, network) {
        return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  receipt before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionReceipt]].
     */
    _wrapTransactionReceipt(value, network) {
        return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  response before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionResponse]].
     */
    _wrapTransactionResponse(tx, network) {
        return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);
    }
    /**
     *  Resolves to the Network, forcing a network detection using whatever
     *  technique the sub-class requires.
     *
     *  Sub-classes **must** override this.
     */
    _detectNetwork() {
        (0, index_js_6.assert)(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
        });
    }
    /**
     *  Sub-classes should use this to perform all built-in operations. All
     *  methods sanitizes and normalizes the values passed into this.
     *
     *  Sub-classes **must** override this.
     */
    async _perform(req) {
        (0, index_js_6.assert)(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
            operation: req.method,
            info: req
        });
    }
    // State
    async getBlockNumber() {
        const blockNumber = (0, index_js_6.getNumber)(await this.#perform({ method: "getBlockNumber" }), "%response");
        if (this.#lastBlockNumber >= 0) {
            this.#lastBlockNumber = blockNumber;
        }
        return blockNumber;
    }
    /**
     *  Returns or resolves to the address for %%address%%, resolving ENS
     *  names and [[Addressable]] objects and returning if already an
     *  address.
     */
    _getAddress(address) {
        return (0, index_js_1.resolveAddress)(address, this);
    }
    /**
     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
     *  negative values and returning if already a valid block tag.
     */
    _getBlockTag(blockTag) {
        if (blockTag == null) {
            return "latest";
        }
        switch (blockTag) {
            case "earliest":
                return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
                return blockTag;
        }
        if ((0, index_js_6.isHexString)(blockTag)) {
            if ((0, index_js_6.isHexString)(blockTag, 32)) {
                return blockTag;
            }
            return (0, index_js_6.toQuantity)(blockTag);
        }
        if (typeof (blockTag) === "bigint") {
            blockTag = (0, index_js_6.getNumber)(blockTag, "blockTag");
        }
        if (typeof (blockTag) === "number") {
            if (blockTag >= 0) {
                return (0, index_js_6.toQuantity)(blockTag);
            }
            if (this.#lastBlockNumber >= 0) {
                return (0, index_js_6.toQuantity)(this.#lastBlockNumber + blockTag);
            }
            return this.getBlockNumber().then((b) => (0, index_js_6.toQuantity)(b + blockTag));
        }
        (0, index_js_6.assertArgument)(false, "invalid blockTag", "blockTag", blockTag);
    }
    /**
     *  Returns or resolves to a filter for %%filter%%, resolving any ENS
     *  names or [[Addressable]] object and returning if already a valid
     *  filter.
     */
    _getFilter(filter) {
        // Create a canonical representation of the topics
        const topics = (filter.topics || []).map((t) => {
            if (t == null) {
                return null;
            }
            if (Array.isArray(t)) {
                return concisify(t.map((t) => t.toLowerCase()));
            }
            return t.toLowerCase();
        });
        const blockHash = ("blockHash" in filter) ? filter.blockHash : undefined;
        const resolve = (_address, fromBlock, toBlock) => {
            let address = undefined;
            switch (_address.length) {
                case 0: break;
                case 1:
                    address = _address[0];
                    break;
                default:
                    _address.sort();
                    address = _address;
            }
            if (blockHash) {
                if (fromBlock != null || toBlock != null) {
                    throw new Error("invalid filter");
                }
            }
            const filter = {};
            if (address) {
                filter.address = address;
            }
            if (topics.length) {
                filter.topics = topics;
            }
            if (fromBlock) {
                filter.fromBlock = fromBlock;
            }
            if (toBlock) {
                filter.toBlock = toBlock;
            }
            if (blockHash) {
                filter.blockHash = blockHash;
            }
            return filter;
        };
        // Addresses could be async (ENS names or Addressables)
        let address = [];
        if (filter.address) {
            if (Array.isArray(filter.address)) {
                for (const addr of filter.address) {
                    address.push(this._getAddress(addr));
                }
            }
            else {
                address.push(this._getAddress(filter.address));
            }
        }
        let fromBlock = undefined;
        if ("fromBlock" in filter) {
            fromBlock = this._getBlockTag(filter.fromBlock);
        }
        let toBlock = undefined;
        if ("toBlock" in filter) {
            toBlock = this._getBlockTag(filter.toBlock);
        }
        if (address.filter((a) => (typeof (a) !== "string")).length ||
            (fromBlock != null && typeof (fromBlock) !== "string") ||
            (toBlock != null && typeof (toBlock) !== "string")) {
            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
                return resolve(result[0], result[1], result[2]);
            });
        }
        return resolve(address, fromBlock, toBlock);
    }
    /**
     *  Returns or resolves to a transaction for %%request%%, resolving
     *  any ENS names or [[Addressable]] and returning if already a valid
     *  transaction.
     */
    _getTransactionRequest(_request) {
        const request = (0, provider_js_1.copyRequest)(_request);
        const promises = [];
        ["to", "from"].forEach((key) => {
            if (request[key] == null) {
                return;
            }
            const addr = (0, index_js_1.resolveAddress)(request[key], this);
            if (isPromise(addr)) {
                promises.push((async function () { request[key] = await addr; })());
            }
            else {
                request[key] = addr;
            }
        });
        if (request.blockTag != null) {
            const blockTag = this._getBlockTag(request.blockTag);
            if (isPromise(blockTag)) {
                promises.push((async function () { request.blockTag = await blockTag; })());
            }
            else {
                request.blockTag = blockTag;
            }
        }
        if (promises.length) {
            return (async function () {
                await Promise.all(promises);
                return request;
            })();
        }
        return request;
    }
    async getNetwork() {
        // No explicit network was set and this is our first time
        if (this.#networkPromise == null) {
            // Detect the current network (shared with all calls)
            const detectNetwork = (async () => {
                try {
                    const network = await this._detectNetwork();
                    this.emit("network", network, null);
                    return network;
                }
                catch (error) {
                    if (this.#networkPromise === detectNetwork) {
                        this.#networkPromise = null;
                    }
                    throw error;
                }
            })();
            this.#networkPromise = detectNetwork;
            return (await detectNetwork).clone();
        }
        const networkPromise = this.#networkPromise;
        const [expected, actual] = await Promise.all([
            networkPromise,
            this._detectNetwork() // The actual connected network
        ]);
        if (expected.chainId !== actual.chainId) {
            if (this.#anyNetwork) {
                // The "any" network can change, so notify listeners
                this.emit("network", actual, expected);
                // Update the network if something else hasn't already changed it
                if (this.#networkPromise === networkPromise) {
                    this.#networkPromise = Promise.resolve(actual);
                }
            }
            else {
                // Otherwise, we do not allow changes to the underlying network
                (0, index_js_6.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
                    event: "changed"
                });
            }
        }
        return expected.clone();
    }
    async getFeeData() {
        const network = await this.getNetwork();
        const getFeeDataFunc = async () => {
            const { _block, gasPrice, priorityFee } = await (0, index_js_6.resolveProperties)({
                _block: this.#getBlock("latest", false),
                gasPrice: ((async () => {
                    try {
                        const value = await this.#perform({ method: "getGasPrice" });
                        return (0, index_js_6.getBigInt)(value, "%response");
                    }
                    catch (error) { }
                    return null;
                })()),
                priorityFee: ((async () => {
                    try {
                        const value = await this.#perform({ method: "getPriorityFee" });
                        return (0, index_js_6.getBigInt)(value, "%response");
                    }
                    catch (error) { }
                    return null;
                })())
            });
            let maxFeePerGas = null;
            let maxPriorityFeePerGas = null;
            // These are the recommended EIP-1559 heuristics for fee data
            const block = this._wrapBlock(_block, network);
            if (block && block.baseFeePerGas) {
                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt("1000000000");
                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;
            }
            return new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
        };
        // Check for a FeeDataNetWorkPlugin
        const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (plugin) {
            const req = new index_js_6.FetchRequest(plugin.url);
            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
            return new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
        }
        return await getFeeDataFunc();
    }
    async estimateGas(_tx) {
        let tx = this._getTransactionRequest(_tx);
        if (isPromise(tx)) {
            tx = await tx;
        }
        return (0, index_js_6.getBigInt)(await this.#perform({
            method: "estimateGas", transaction: tx
        }), "%response");
    }
    async #call(tx, blockTag, attempt) {
        (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
        });
        // This came in as a PerformActionTransaction, so to/from are safe; we can cast
        const transaction = (0, provider_js_1.copyRequest)(tx);
        try {
            return (0, index_js_6.hexlify)(await this._perform({ method: "call", transaction, blockTag }));
        }
        catch (error) {
            // CCIP Read OffchainLookup
            if (!this.disableCcipRead && (0, index_js_6.isCallException)(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && (0, index_js_6.dataSlice)(error.data, 0, 4) === "0x556f1830") {
                const data = error.data;
                const txSender = await (0, index_js_1.resolveAddress)(transaction.to, this);
                // Parse the CCIP Read Arguments
                let ccipArgs;
                try {
                    ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(error.data, 4));
                }
                catch (error) {
                    (0, index_js_6.assert)(false, error.message, "OFFCHAIN_FAULT", {
                        reason: "BAD_DATA", transaction, info: { data }
                    });
                }
                // Check the sender of the OffchainLookup matches the transaction
                (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                    action: "call",
                    data,
                    reason: "OffchainLookup",
                    transaction: transaction,
                    invocation: null,
                    revert: {
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        name: "OffchainLookup",
                        args: ccipArgs.errorArgs
                    }
                });
                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
                (0, index_js_6.assert)(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                    reason: "FETCH_FAILED", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }
                });
                const tx = {
                    to: txSender,
                    data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
                };
                this.emit("debug", { action: "sendCcipReadCall", transaction: tx });
                try {
                    const result = await this.#call(tx, blockTag, attempt + 1);
                    this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx), result });
                    return result;
                }
                catch (error) {
                    this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx), error });
                    throw error;
                }
            }
            throw error;
        }
    }
    async #checkNetwork(promise) {
        const { value } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            value: promise
        });
        return value;
    }
    async call(_tx) {
        const { tx, blockTag } = await (0, index_js_6.resolveProperties)({
            tx: this._getTransactionRequest(_tx),
            blockTag: this._getBlockTag(_tx.blockTag)
        });
        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
    }
    // Account
    async #getAccountValue(request, _address, _blockTag) {
        let address = this._getAddress(_address);
        let blockTag = this._getBlockTag(_blockTag);
        if (typeof (address) !== "string" || typeof (blockTag) !== "string") {
            [address, blockTag] = await Promise.all([address, blockTag]);
        }
        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
    }
    async getBalance(address, blockTag) {
        return (0, index_js_6.getBigInt)(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
    }
    async getTransactionCount(address, blockTag) {
        return (0, index_js_6.getNumber)(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
    }
    async getCode(address, blockTag) {
        return (0, index_js_6.hexlify)(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
    }
    async getStorage(address, _position, blockTag) {
        const position = (0, index_js_6.getBigInt)(_position, "position");
        return (0, index_js_6.hexlify)(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
    }
    // Write
    async broadcastTransaction(signedTx) {
        const { blockNumber, hash, network } = await (0, index_js_6.resolveProperties)({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: signedTx
            }),
            network: this.getNetwork()
        });
        const tx = index_js_5.Transaction.from(signedTx);
        if (tx.hash !== hash) {
            throw new Error("@TODO: the returned hash did not match");
        }
        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
    }
    async #getBlock(block, includeTransactions) {
        // @TODO: Add CustomBlockPlugin check
        if ((0, index_js_6.isHexString)(block, 32)) {
            return await this.#perform({
                method: "getBlock", blockHash: block, includeTransactions
            });
        }
        let blockTag = this._getBlockTag(block);
        if (typeof (blockTag) !== "string") {
            blockTag = await blockTag;
        }
        return await this.#perform({
            method: "getBlock", blockTag, includeTransactions
        });
    }
    // Queries
    async getBlock(block, prefetchTxs) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#getBlock(block, !!prefetchTxs)
        });
        if (params == null) {
            return null;
        }
        return this._wrapBlock(params, network);
    }
    async getTransaction(hash) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({ method: "getTransaction", hash })
        });
        if (params == null) {
            return null;
        }
        return this._wrapTransactionResponse(params, network);
    }
    async getTransactionReceipt(hash) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({ method: "getTransactionReceipt", hash })
        });
        if (params == null) {
            return null;
        }
        // Some backends did not backfill the effectiveGasPrice into old transactions
        // in the receipt, so we look it up manually and inject it.
        if (params.gasPrice == null && params.effectiveGasPrice == null) {
            const tx = await this.#perform({ method: "getTransaction", hash });
            if (tx == null) {
                throw new Error("report this; could not find tx or effectiveGasPrice");
            }
            params.effectiveGasPrice = tx.gasPrice;
        }
        return this._wrapTransactionReceipt(params, network);
    }
    async getTransactionResult(hash) {
        const { result } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            result: this.#perform({ method: "getTransactionResult", hash })
        });
        if (result == null) {
            return null;
        }
        return (0, index_js_6.hexlify)(result);
    }
    // Bloom-filter Queries
    async getLogs(_filter) {
        let filter = this._getFilter(_filter);
        if (isPromise(filter)) {
            filter = await filter;
        }
        const { network, params } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({ method: "getLogs", filter })
        });
        return params.map((p) => this._wrapLog(p, network));
    }
    // ENS
    _getProvider(chainId) {
        (0, index_js_6.assert)(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
        });
    }
    async getResolver(name) {
        return await ens_resolver_js_1.EnsResolver.fromName(this, name);
    }
    async getAvatar(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
            return await resolver.getAvatar();
        }
        return null;
    }
    async resolveName(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
            return await resolver.getAddress();
        }
        return null;
    }
    async lookupAddress(address) {
        address = (0, index_js_1.getAddress)(address);
        const node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + ".addr.reverse");
        try {
            const ensAddr = await ens_resolver_js_1.EnsResolver.getEnsAddress(this);
            const ensContract = new index_js_3.Contract(ensAddr, [
                "function resolver(bytes32) view returns (address)"
            ], this);
            const resolver = await ensContract.resolver(node);
            if (resolver == null || resolver === index_js_2.ZeroAddress) {
                return null;
            }
            const resolverContract = new index_js_3.Contract(resolver, [
                "function name(bytes32) view returns (string)"
            ], this);
            const name = await resolverContract.name(node);
            // Failed forward resolution
            const check = await this.resolveName(name);
            if (check !== address) {
                return null;
            }
            return name;
        }
        catch (error) {
            // No data was returned from the resolver
            if ((0, index_js_6.isError)(error, "BAD_DATA") && error.value === "0x") {
                return null;
            }
            // Something reerted
            if ((0, index_js_6.isError)(error, "CALL_EXCEPTION")) {
                return null;
            }
            throw error;
        }
        return null;
    }
    async waitForTransaction(hash, _confirms, timeout) {
        const confirms = (_confirms != null) ? _confirms : 1;
        if (confirms === 0) {
            return this.getTransactionReceipt(hash);
        }
        return new Promise(async (resolve, reject) => {
            let timer = null;
            const listener = (async (blockNumber) => {
                try {
                    const receipt = await this.getTransactionReceipt(hash);
                    if (receipt != null) {
                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                            resolve(receipt);
                            //this.off("block", listener);
                            if (timer) {
                                clearTimeout(timer);
                                timer = null;
                            }
                            return;
                        }
                    }
                }
                catch (error) {
                    console.log("EEE", error);
                }
                this.once("block", listener);
            });
            if (timeout != null) {
                timer = setTimeout(() => {
                    if (timer == null) {
                        return;
                    }
                    timer = null;
                    this.off("block", listener);
                    reject((0, index_js_6.makeError)("timeout", "TIMEOUT", { reason: "timeout" }));
                }, timeout);
            }
            listener(await this.getBlockNumber());
        });
    }
    async waitForBlock(blockTag) {
        (0, index_js_6.assert)(false, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
        });
    }
    /**
     *  Clear a timer created using the [[_setTimeout]] method.
     */
    _clearTimeout(timerId) {
        const timer = this.#timers.get(timerId);
        if (!timer) {
            return;
        }
        if (timer.timer) {
            clearTimeout(timer.timer);
        }
        this.#timers.delete(timerId);
    }
    /**
     *  Create a timer that will execute %%func%% after at least %%timeout%%
     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
     *  in the next event loop.
     *
     *  [Pausing](AbstractProvider-paused) the provider will pause any
     *  associated timers.
     */
    _setTimeout(_func, timeout) {
        if (timeout == null) {
            timeout = 0;
        }
        const timerId = this.#nextTimer++;
        const func = () => {
            this.#timers.delete(timerId);
            _func();
        };
        if (this.paused) {
            this.#timers.set(timerId, { timer: null, func, time: timeout });
        }
        else {
            const timer = setTimeout(func, timeout);
            this.#timers.set(timerId, { timer, func, time: getTime() });
        }
        return timerId;
    }
    /**
     *  Perform %%func%% on each subscriber.
     */
    _forEachSubscriber(func) {
        for (const sub of this.#subs.values()) {
            func(sub.subscriber);
        }
    }
    /**
     *  Sub-classes may override this to customize subscription
     *  implementations.
     */
    _getSubscriber(sub) {
        switch (sub.type) {
            case "debug":
            case "error":
            case "network":
                return new UnmanagedSubscriber(sub.type);
            case "block": {
                const subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);
                subscriber.pollingInterval = this.pollingInterval;
                return subscriber;
            }
            case "safe":
            case "finalized":
                return new subscriber_polling_js_1.PollingBlockTagSubscriber(this, sub.type);
            case "event":
                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
            case "transaction":
                return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);
            case "orphan":
                return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);
        }
        throw new Error(`unsupported event: ${sub.type}`);
    }
    /**
     *  If a [[Subscriber]] fails and needs to replace itself, this
     *  method may be used.
     *
     *  For example, this is used for providers when using the
     *  ``eth_getFilterChanges`` method, which can return null if state
     *  filters are not supported by the backend, allowing the Subscriber
     *  to swap in a [[PollingEventSubscriber]].
     */
    _recoverSubscriber(oldSub, newSub) {
        for (const sub of this.#subs.values()) {
            if (sub.subscriber === oldSub) {
                if (sub.started) {
                    sub.subscriber.stop();
                }
                sub.subscriber = newSub;
                if (sub.started) {
                    newSub.start();
                }
                if (this.#pausedState != null) {
                    newSub.pause(this.#pausedState);
                }
                break;
            }
        }
    }
    async #hasSub(event, emitArgs) {
        let sub = await getSubscription(event, this);
        // This is a log that is removing an existing log; we actually want
        // to emit an orphan event for the removed log
        if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
            sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
        }
        return this.#subs.get(sub.tag) || null;
    }
    async #getSub(event) {
        const subscription = await getSubscription(event, this);
        // Prevent tampering with our tag in any subclass' _getSubscriber
        const tag = subscription.tag;
        let sub = this.#subs.get(tag);
        if (!sub) {
            const subscriber = this._getSubscriber(subscription);
            const addressableMap = new WeakMap();
            const nameMap = new Map();
            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
            this.#subs.set(tag, sub);
        }
        return sub;
    }
    async on(event, listener) {
        const sub = await this.#getSub(event);
        sub.listeners.push({ listener, once: false });
        if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
            }
        }
        return this;
    }
    async once(event, listener) {
        const sub = await this.#getSub(event);
        sub.listeners.push({ listener, once: true });
        if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
            }
        }
        return this;
    }
    async emit(event, ...args) {
        const sub = await this.#hasSub(event, args);
        // If there is not subscription or if a recent emit removed
        // the last of them (which also deleted the sub) do nothing
        if (!sub || sub.listeners.length === 0) {
            return false;
        }
        ;
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const payload = new index_js_6.EventPayload(this, (once ? null : listener), event);
            try {
                listener.call(this, ...args, payload);
            }
            catch (error) { }
            return !once;
        });
        if (sub.listeners.length === 0) {
            if (sub.started) {
                sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
        }
        return (count > 0);
    }
    async listenerCount(event) {
        if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
                return 0;
            }
            return sub.listeners.length;
        }
        let total = 0;
        for (const { listeners } of this.#subs.values()) {
            total += listeners.length;
        }
        return total;
    }
    async listeners(event) {
        if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
                return [];
            }
            return sub.listeners.map(({ listener }) => listener);
        }
        let result = [];
        for (const { listeners } of this.#subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
    }
    async off(event, listener) {
        const sub = await this.#hasSub(event);
        if (!sub) {
            return this;
        }
        if (listener) {
            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
            if (index >= 0) {
                sub.listeners.splice(index, 1);
            }
        }
        if (!listener || sub.listeners.length === 0) {
            if (sub.started) {
                sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
        }
        return this;
    }
    async removeAllListeners(event) {
        if (event) {
            const { tag, started, subscriber } = await this.#getSub(event);
            if (started) {
                subscriber.stop();
            }
            this.#subs.delete(tag);
        }
        else {
            for (const [tag, { started, subscriber }] of this.#subs) {
                if (started) {
                    subscriber.stop();
                }
                this.#subs.delete(tag);
            }
        }
        return this;
    }
    // Alias for "on"
    async addListener(event, listener) {
        return await this.on(event, listener);
    }
    // Alias for "off"
    async removeListener(event, listener) {
        return this.off(event, listener);
    }
    /**
     *  If this provider has been destroyed using the [[destroy]] method.
     *
     *  Once destroyed, all resources are reclaimed, internal event loops
     *  and timers are cleaned up and no further requests may be sent to
     *  the provider.
     */
    get destroyed() {
        return this.#destroyed;
    }
    /**
     *  Sub-classes may use this to shutdown any sockets or release their
     *  resources and reject any pending requests.
     *
     *  Sub-classes **must** call ``super.destroy()``.
     */
    destroy() {
        // Stop all listeners
        this.removeAllListeners();
        // Shut down all tiemrs
        for (const timerId of this.#timers.keys()) {
            this._clearTimeout(timerId);
        }
        this.#destroyed = true;
    }
    /**
     *  Whether the provider is currently paused.
     *
     *  A paused provider will not emit any events, and generally should
     *  not make any requests to the network, but that is up to sub-classes
     *  to manage.
     *
     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
     *  which will buffer any events that occur while paused until the
     *  provider is unpaused.
     */
    get paused() { return (this.#pausedState != null); }
    set paused(pause) {
        if (!!pause === this.paused) {
            return;
        }
        if (this.paused) {
            this.resume();
        }
        else {
            this.pause(false);
        }
    }
    /**
     *  Pause the provider. If %%dropWhilePaused%%, any events that occur
     *  while paused are dropped, otherwise all events will be emitted once
     *  the provider is unpaused.
     */
    pause(dropWhilePaused) {
        this.#lastBlockNumber = -1;
        if (this.#pausedState != null) {
            if (this.#pausedState == !!dropWhilePaused) {
                return;
            }
            (0, index_js_6.assert)(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                operation: "pause"
            });
        }
        this._forEachSubscriber((s) => s.pause(dropWhilePaused));
        this.#pausedState = !!dropWhilePaused;
        for (const timer of this.#timers.values()) {
            // Clear the timer
            if (timer.timer) {
                clearTimeout(timer.timer);
            }
            // Remaining time needed for when we become unpaused
            timer.time = getTime() - timer.time;
        }
    }
    /**
     *  Resume the provider.
     */
    resume() {
        if (this.#pausedState == null) {
            return;
        }
        this._forEachSubscriber((s) => s.resume());
        this.#pausedState = null;
        for (const timer of this.#timers.values()) {
            // Remaining time when we were paused
            let timeout = timer.time;
            if (timeout < 0) {
                timeout = 0;
            }
            // Start time (in cause paused, so we con compute remaininf time)
            timer.time = getTime();
            // Start the timer
            setTimeout(timer.func, timeout);
        }
    }
}
exports.AbstractProvider = AbstractProvider;
function _parseString(result, start) {
    try {
        const bytes = _parseBytes(result, start);
        if (bytes) {
            return (0, index_js_6.toUtf8String)(bytes);
        }
    }
    catch (error) { }
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") {
        return null;
    }
    try {
        const offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));
        const length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));
        return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);
    }
    catch (error) { }
    return null;
}
function numPad(value) {
    const result = (0, index_js_6.toBeArray)(value);
    if (result.length > 32) {
        throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if ((value.length % 32) === 0) {
        return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
const empty = new Uint8Array([]);
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    // Add place-holders for pointers as we add items
    for (let i = 0; i < datas.length; i++) {
        result.push(empty);
        byteCount += 32;
    }
    for (let i = 0; i < datas.length; i++) {
        const data = (0, index_js_6.getBytes)(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, index_js_6.concat)(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
    const result = {
        sender: "", urls: [], calldata: "", selector: "", extraData: "", errorArgs: []
    };
    (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
    });
    const sender = (0, index_js_6.dataSlice)(data, 0, 32);
    (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
    });
    result.sender = (0, index_js_6.dataSlice)(sender, 12);
    // Read the URLs from the response
    try {
        const urls = [];
        const urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));
        const urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));
        const urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);
        for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
                throw new Error("abort");
            }
            urls.push(url);
        }
        result.urls = urls;
    }
    catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
        });
    }
    // Get the CCIP calldata to forward
    try {
        const calldata = _parseBytes(data, 64);
        if (calldata == null) {
            throw new Error("abort");
        }
        result.calldata = calldata;
    }
    catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
        });
    }
    // Get the callbackSelector (bytes4)
    (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
    });
    result.selector = (0, index_js_6.dataSlice)(data, 96, 100);
    // Get the extra data to send back to the contract as context
    try {
        const extraData = _parseBytes(data, 128);
        if (extraData == null) {
            throw new Error("abort");
        }
        result.extraData = extraData;
    }
    catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
        });
    }
    result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
    return result;
}
//# sourceMappingURL=abstract-provider.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/abstract-signer.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/abstract-signer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoidSigner = exports.AbstractSigner = void 0;
/**
 *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes
 *  are sufficent for most developers, but this is provided to
 *  fascilitate more complex Signers.
 *
 *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]
 */
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const provider_js_1 = __webpack_require__(/*! ./provider.js */ "../node_modules/ethers/lib.commonjs/providers/provider.js");
function checkProvider(signer, operation) {
    if (signer.provider) {
        return signer.provider;
    }
    (0, index_js_3.assert)(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
    let pop = (0, provider_js_1.copyRequest)(tx);
    if (pop.to != null) {
        pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);
    }
    if (pop.from != null) {
        const from = pop.from;
        pop.from = Promise.all([
            signer.getAddress(),
            (0, index_js_1.resolveAddress)(from, signer)
        ]).then(([address, from]) => {
            (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
            return address;
        });
    }
    else {
        pop.from = signer.getAddress();
    }
    return await (0, index_js_3.resolveProperties)(pop);
}
/**
 *  An **AbstractSigner** includes most of teh functionality required
 *  to get a [[Signer]] working as expected, but requires a few
 *  Signer-specific methods be overridden.
 *
 */
class AbstractSigner {
    /**
     *  The provider this signer is connected to.
     */
    provider;
    /**
     *  Creates a new Signer connected to %%provider%%.
     */
    constructor(provider) {
        (0, index_js_3.defineProperties)(this, { provider: (provider || null) });
    }
    async getNonce(blockTag) {
        return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
    }
    async populateCall(tx) {
        const pop = await populate(this, tx);
        return pop;
    }
    async populateTransaction(tx) {
        const provider = checkProvider(this, "populateTransaction");
        const pop = await populate(this, tx);
        if (pop.nonce == null) {
            pop.nonce = await this.getNonce("pending");
        }
        if (pop.gasLimit == null) {
            pop.gasLimit = await this.estimateGas(pop);
        }
        // Populate the chain ID
        const network = await (this.provider).getNetwork();
        if (pop.chainId != null) {
            const chainId = (0, index_js_3.getBigInt)(pop.chainId);
            (0, index_js_3.assertArgument)(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
        }
        else {
            pop.chainId = network.chainId;
        }
        // Do not allow mixing pre-eip-1559 and eip-1559 properties
        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);
        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
            (0, index_js_3.assertArgument)(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
        }
        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
            (0, index_js_3.assertArgument)(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
        }
        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
            // Fully-formed EIP-1559 transaction (skip getFeeData)
            pop.type = 2;
        }
        else if (pop.type === 0 || pop.type === 1) {
            // Explicit Legacy or EIP-2930 transaction
            // We need to get fee data to determine things
            const feeData = await provider.getFeeData();
            (0, index_js_3.assert)(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            });
            // Populate missing gasPrice
            if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
            }
        }
        else {
            // We need to get fee data to determine things
            const feeData = await provider.getFeeData();
            if (pop.type == null) {
                // We need to auto-detect the intended type of this transaction...
                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                    // The network supports EIP-1559!
                    // Upgrade transaction from null to eip-1559
                    pop.type = 2;
                    if (pop.gasPrice != null) {
                        // Using legacy gasPrice property on an eip-1559 network,
                        // so use gasPrice as both fee properties
                        const gasPrice = pop.gasPrice;
                        delete pop.gasPrice;
                        pop.maxFeePerGas = gasPrice;
                        pop.maxPriorityFeePerGas = gasPrice;
                    }
                    else {
                        // Populate missing fee data
                        if (pop.maxFeePerGas == null) {
                            pop.maxFeePerGas = feeData.maxFeePerGas;
                        }
                        if (pop.maxPriorityFeePerGas == null) {
                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                        }
                    }
                }
                else if (feeData.gasPrice != null) {
                    // Network doesn't support EIP-1559...
                    // ...but they are trying to use EIP-1559 properties
                    (0, index_js_3.assert)(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                        operation: "populateTransaction"
                    });
                    // Populate missing fee data
                    if (pop.gasPrice == null) {
                        pop.gasPrice = feeData.gasPrice;
                    }
                    // Explicitly set untyped transaction to legacy
                    // @TODO: Maybe this shold allow type 1?
                    pop.type = 0;
                }
                else {
                    // getFeeData has failed us.
                    (0, index_js_3.assert)(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                        operation: "signer.getFeeData"
                    });
                }
            }
            else if (pop.type === 2 || pop.type === 3) {
                // Explicitly using EIP-1559 or EIP-4844
                // Populate missing fee data
                if (pop.maxFeePerGas == null) {
                    pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
            }
        }
        //@TOOD: Don't await all over the place; save them up for
        // the end for better batching
        return await (0, index_js_3.resolveProperties)(pop);
    }
    async estimateGas(tx) {
        return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
    }
    async call(tx) {
        return checkProvider(this, "call").call(await this.populateCall(tx));
    }
    async resolveName(name) {
        const provider = checkProvider(this, "resolveName");
        return await provider.resolveName(name);
    }
    async sendTransaction(tx) {
        const provider = checkProvider(this, "sendTransaction");
        const pop = await this.populateTransaction(tx);
        delete pop.from;
        const txObj = index_js_2.Transaction.from(pop);
        return await provider.broadcastTransaction(await this.signTransaction(txObj));
    }
}
exports.AbstractSigner = AbstractSigner;
/**
 *  A **VoidSigner** is a class deisgned to allow an address to be used
 *  in any API which accepts a Signer, but for which there are no
 *  credentials available to perform any actual signing.
 *
 *  This for example allow impersonating an account for the purpose of
 *  static calls or estimating gas, but does not allow sending transactions.
 */
class VoidSigner extends AbstractSigner {
    /**
     *  The signer address.
     */
    address;
    /**
     *  Creates a new **VoidSigner** with %%address%% attached to
     *  %%provider%%.
     */
    constructor(address, provider) {
        super(provider);
        (0, index_js_3.defineProperties)(this, { address });
    }
    async getAddress() { return this.address; }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
    #throwUnsupported(suffix, operation) {
        (0, index_js_3.assert)(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
    }
    async signTransaction(tx) {
        this.#throwUnsupported("transactions", "signTransaction");
    }
    async signMessage(message) {
        this.#throwUnsupported("messages", "signMessage");
    }
    async signTypedData(domain, types, value) {
        this.#throwUnsupported("typed-data", "signTypedData");
    }
}
exports.VoidSigner = VoidSigner;
//# sourceMappingURL=abstract-signer.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/community.js":
/*!******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/community.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 *  There are many awesome community services that provide Ethereum
 *  nodes both for developers just starting out and for large-scale
 *  communities.
 *
 *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showThrottleMessage = void 0;
// Show the throttle message only once per service
const shown = new Set();
/**
 *  Displays a warning in tht console when the community resource is
 *  being used too heavily by the app, recommending the developer
 *  acquire their own credentials instead of using the community
 *  credentials.
 *
 *  The notification will only occur once per service.
 */
function showThrottleMessage(service) {
    if (shown.has(service)) {
        return;
    }
    shown.add(service);
    console.log("========= NOTICE =========");
    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.org/api-keys/");
    console.log("==========================");
}
exports.showThrottleMessage = showThrottleMessage;
//# sourceMappingURL=community.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/default-provider.js":
/*!*************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/default-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultProvider = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ "../node_modules/ethers/lib.commonjs/providers/provider-ankr.js");
const provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ "../node_modules/ethers/lib.commonjs/providers/provider-alchemy.js");
const provider_chainstack_js_1 = __webpack_require__(/*! ./provider-chainstack.js */ "../node_modules/ethers/lib.commonjs/providers/provider-chainstack.js");
const provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ "../node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js");
const provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ "../node_modules/ethers/lib.commonjs/providers/provider-etherscan.js");
const provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ "../node_modules/ethers/lib.commonjs/providers/provider-infura.js");
//import { PocketProvider } from "./provider-pocket.js";
const provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ "../node_modules/ethers/lib.commonjs/providers/provider-quicknode.js");
const provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ "../node_modules/ethers/lib.commonjs/providers/provider-fallback.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-websocket.js");
function isWebSocketLike(value) {
    return (value && typeof (value.send) === "function" &&
        typeof (value.close) === "function");
}
const Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
/**
 *  Returns a default provider for %%network%%.
 *
 *  If %%network%% is a [[WebSocketLike]] or string that begins with
 *  ``"ws:"`` or ``"wss:"``, a [[WebSocketProvider]] is returned backed
 *  by that WebSocket or URL.
 *
 *  If %%network%% is a string that begins with ``"HTTP:"`` or ``"HTTPS:"``,
 *  a [[JsonRpcProvider]] is returned connected to that URL.
 *
 *  Otherwise, a default provider is created backed by well-known public
 *  Web3 backends (such as [[link-infura]]) using community-provided API
 *  keys.
 *
 *  The %%options%% allows specifying custom API keys per backend (setting
 *  an API key to ``"-"`` will omit that provider) and ``options.exclusive``
 *  can be set to either a backend name or and array of backend names, which
 *  will whitelist **only** those backends.
 *
 *  Current backend strings supported are:
 *  - ``"alchemy"``
 *  - ``"ankr"``
 *  - ``"cloudflare"``
 *  - ``"chainstack"``
 *  - ``"etherscan"``
 *  - ``"infura"``
 *  - ``"publicPolygon"``
 *  - ``"quicknode"``
 *
 *  @example:
 *    // Connect to a local Geth node
 *    provider = getDefaultProvider("http://localhost:8545/");
 *
 *    // Connect to Ethereum mainnet with any current and future
 *    // third-party services available
 *    provider = getDefaultProvider("mainnet");
 *
 *    // Connect to Polygon, but only allow Etherscan and
 *    // INFURA and use "MY_API_KEY" in calls to Etherscan.
 *    provider = getDefaultProvider("matic", {
 *      etherscan: "MY_API_KEY",
 *      exclusive: [ "etherscan", "infura" ]
 *    });
 */
function getDefaultProvider(network, options) {
    if (options == null) {
        options = {};
    }
    const allowService = (name) => {
        if (options[name] === "-") {
            return false;
        }
        if (typeof (options.exclusive) === "string") {
            return (name === options.exclusive);
        }
        if (Array.isArray(options.exclusive)) {
            return (options.exclusive.indexOf(name) !== -1);
        }
        return true;
    };
    if (typeof (network) === "string" && network.match(/^https?:/)) {
        return new provider_jsonrpc_js_1.JsonRpcProvider(network);
    }
    if (typeof (network) === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
        return new provider_websocket_js_1.WebSocketProvider(network);
    }
    // Get the network and name, if possible
    let staticNetwork = null;
    try {
        staticNetwork = network_js_1.Network.from(network);
    }
    catch (error) { }
    const providers = [];
    if (allowService("publicPolygon") && staticNetwork) {
        if (staticNetwork.name === "matic") {
            providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/polygon-rpc.com/", staticNetwork, { staticNetwork }));
        }
        else if (staticNetwork.name === "matic-amoy") {
            providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
        }
    }
    if (allowService("alchemy")) {
        try {
            providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));
        }
        catch (error) { }
    }
    if (allowService("ankr") && options.ankr != null) {
        try {
            providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));
        }
        catch (error) { }
    }
    if (allowService("chainstack")) {
        try {
            providers.push(new provider_chainstack_js_1.ChainstackProvider(network, options.chainstack));
        }
        catch (error) { }
    }
    if (allowService("cloudflare")) {
        try {
            providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));
        }
        catch (error) { }
    }
    if (allowService("etherscan")) {
        try {
            providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));
        }
        catch (error) { }
    }
    if (allowService("infura")) {
        try {
            let projectId = options.infura;
            let projectSecret = undefined;
            if (typeof (projectId) === "object") {
                projectSecret = projectId.projectSecret;
                projectId = projectId.projectId;
            }
            providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));
        }
        catch (error) { }
    }
    /*
        if (options.pocket !== "-") {
            try {
                let appId = options.pocket;
                let secretKey: undefined | string = undefined;
                let loadBalancer: undefined | boolean = undefined;
                if (typeof(appId) === "object") {
                    loadBalancer = !!appId.loadBalancer;
                    secretKey = appId.secretKey;
                    appId = appId.appId;
                }
                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));
            } catch (error) { console.log(error); }
        }
    */
    if (allowService("quicknode")) {
        try {
            let token = options.quicknode;
            providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));
        }
        catch (error) { }
    }
    (0, index_js_1.assert)(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
        operation: "getDefaultProvider"
    });
    // No need for a FallbackProvider
    if (providers.length === 1) {
        return providers[0];
    }
    // We use the floor because public third-party providers can be unreliable,
    // so a low number of providers with a large quorum will fail too often
    let quorum = Math.floor(providers.length / 2);
    if (quorum > 2) {
        quorum = 2;
    }
    // Testnets don't need as strong a security gaurantee and speed is
    // more useful during testing
    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
        quorum = 1;
    }
    // Provided override qorum takes priority
    if (options && options.quorum) {
        quorum = options.quorum;
    }
    return new provider_fallback_js_1.FallbackProvider(providers, undefined, { quorum });
}
exports.getDefaultProvider = getDefaultProvider;
//# sourceMappingURL=default-provider.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/ens-resolver.js":
/*!*********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/ens-resolver.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  ENS is a service which allows easy-to-remember names to map to
 *  network addresses.
 *
 *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../constants/index.js */ "../node_modules/ethers/lib.commonjs/constants/index.js");
const index_js_3 = __webpack_require__(/*! ../contract/index.js */ "../node_modules/ethers/lib.commonjs/contract/index.js");
const index_js_4 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_5 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
// @TODO: This should use the fetch-data:ipfs gateway
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
    }
    else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
    }
    else {
        (0, index_js_5.assertArgument)(false, "unsupported IPFS format", "link", link);
    }
    return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
;
;
/**
 *  A provider plugin super-class for processing multicoin address types.
 */
class MulticoinProviderPlugin {
    /**
     *  The name.
     */
    name;
    /**
     *  Creates a new **MulticoinProviderPluing** for %%name%%.
     */
    constructor(name) {
        (0, index_js_5.defineProperties)(this, { name });
    }
    connect(proivder) {
        return this;
    }
    /**
     *  Returns ``true`` if %%coinType%% is supported by this plugin.
     */
    supportsCoinType(coinType) {
        return false;
    }
    /**
     *  Resolves to the encoded %%address%% for %%coinType%%.
     */
    async encodeAddress(coinType, address) {
        throw new Error("unsupported coin");
    }
    /**
     *  Resolves to the decoded %%data%% for %%coinType%%.
     */
    async decodeAddress(coinType, data) {
        throw new Error("unsupported coin");
    }
}
exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
const BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
/**
 *  A **BasicMulticoinProviderPlugin** provides service for common
 *  coin types, which do not require additional libraries to encode or
 *  decode.
 */
class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {
    /**
     *  Creates a new **BasicMulticoinProviderPlugin**.
     */
    constructor() {
        super(BasicMulticoinPluginId);
    }
}
exports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;
const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
];
/**
 *  A connected object to a resolved ENS name resolver, which can be
 *  used to query additional details.
 */
class EnsResolver {
    /**
     *  The connected provider.
     */
    provider;
    /**
     *  The address of the resolver.
     */
    address;
    /**
     *  The name this resolver was resolved against.
     */
    name;
    // For EIP-2544 names, the ancestor that provided the resolver
    #supports2544;
    #resolver;
    constructor(provider, address, name) {
        (0, index_js_5.defineProperties)(this, { provider, address, name });
        this.#supports2544 = null;
        this.#resolver = new index_js_3.Contract(address, [
            "function supportsInterface(bytes4) view returns (bool)",
            "function resolve(bytes, bytes) view returns (bytes)",
            "function addr(bytes32) view returns (address)",
            "function addr(bytes32, uint) view returns (bytes)",
            "function text(bytes32, string) view returns (string)",
            "function contenthash(bytes32) view returns (bytes)",
        ], provider);
    }
    /**
     *  Resolves to true if the resolver supports wildcard resolution.
     */
    async supportsWildcard() {
        if (this.#supports2544 == null) {
            this.#supports2544 = (async () => {
                try {
                    return await this.#resolver.supportsInterface("0x9061b923");
                }
                catch (error) {
                    // Wildcard resolvers must understand supportsInterface
                    // and return true.
                    if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                        return false;
                    }
                    // Let future attempts try again...
                    this.#supports2544 = null;
                    throw error;
                }
            })();
        }
        return await this.#supports2544;
    }
    async #fetch(funcName, params) {
        params = (params || []).slice();
        const iface = this.#resolver.interface;
        // The first parameters is always the nodehash
        params.unshift((0, index_js_4.namehash)(this.name));
        let fragment = null;
        if (await this.supportsWildcard()) {
            fragment = iface.getFunction(funcName);
            (0, index_js_5.assert)(fragment, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName }
            });
            params = [
                (0, index_js_4.dnsEncode)(this.name, 255),
                iface.encodeFunctionData(fragment, params)
            ];
            funcName = "resolve(bytes,bytes)";
        }
        params.push({
            enableCcipRead: true
        });
        try {
            const result = await this.#resolver[funcName](...params);
            if (fragment) {
                return iface.decodeFunctionResult(fragment, result)[0];
            }
            return result;
        }
        catch (error) {
            if (!(0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                throw error;
            }
        }
        return null;
    }
    /**
     *  Resolves to the address for %%coinType%% or null if the
     *  provided %%coinType%% has not been configured.
     */
    async getAddress(coinType) {
        if (coinType == null) {
            coinType = 60;
        }
        if (coinType === 60) {
            try {
                const result = await this.#fetch("addr(bytes32)");
                // No address
                if (result == null || result === index_js_2.ZeroAddress) {
                    return null;
                }
                return result;
            }
            catch (error) {
                if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                    return null;
                }
                throw error;
            }
        }
        // Try decoding its EVM canonical chain as an EVM chain address first
        if (coinType >= 0 && coinType < 0x80000000) {
            let ethCoinType = coinType + 0x80000000;
            const data = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
            if ((0, index_js_5.isHexString)(data, 20)) {
                return (0, index_js_1.getAddress)(data);
            }
        }
        let coinPlugin = null;
        for (const plugin of this.provider.plugins) {
            if (!(plugin instanceof MulticoinProviderPlugin)) {
                continue;
            }
            if (plugin.supportsCoinType(coinType)) {
                coinPlugin = plugin;
                break;
            }
        }
        if (coinPlugin == null) {
            return null;
        }
        // keccak256("addr(bytes32,uint256")
        const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
        // No address
        if (data == null || data === "0x") {
            return null;
        }
        // Compute the address
        const address = await coinPlugin.decodeAddress(coinType, data);
        if (address != null) {
            return address;
        }
        (0, index_js_5.assert)(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${coinType})`,
            info: { coinType, data }
        });
    }
    /**
     *  Resolves to the EIP-634 text record for %%key%%, or ``null``
     *  if unconfigured.
     */
    async getText(key) {
        const data = await this.#fetch("text(bytes32,string)", [key]);
        if (data == null || data === "0x") {
            return null;
        }
        return data;
    }
    /**
     *  Rsolves to the content-hash or ``null`` if unconfigured.
     */
    async getContentHash() {
        // keccak256("contenthash()")
        const data = await this.#fetch("contenthash(bytes32)");
        // No contenthash
        if (data == null || data === "0x") {
            return null;
        }
        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)
        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
            const scheme = (ipfs[1] === "e3010170") ? "ipfs" : "ipns";
            const length = parseInt(ipfs[4], 16);
            if (ipfs[5].length === length * 2) {
                return `${scheme}:/\/${(0, index_js_5.encodeBase58)("0x" + ipfs[2])}`;
            }
        }
        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm && swarm[1].length === 64) {
            return `bzz:/\/${swarm[1]}`;
        }
        (0, index_js_5.assert)(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: { data }
        });
    }
    /**
     *  Resolves to the avatar url or ``null`` if the avatar is either
     *  unconfigured or incorrectly configured (e.g. references an NFT
     *  not owned by the address).
     *
     *  If diagnosing issues with configurations, the [[_getAvatar]]
     *  method may be useful.
     */
    async getAvatar() {
        const avatar = await this._getAvatar();
        return avatar.url;
    }
    /**
     *  When resolving an avatar, there are many steps involved, such
     *  fetching metadata and possibly validating ownership of an
     *  NFT.
     *
     *  This method can be used to examine each step and the value it
     *  was working from.
     */
    async _getAvatar() {
        const linkage = [{ type: "name", value: this.name }];
        try {
            // test data for ricmoo.eth
            //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
            const avatar = await this.getText("avatar");
            if (avatar == null) {
                linkage.push({ type: "!avatar", value: "" });
                return { url: null, linkage };
            }
            linkage.push({ type: "avatar", value: avatar });
            for (let i = 0; i < matchers.length; i++) {
                const match = avatar.match(matchers[i]);
                if (match == null) {
                    continue;
                }
                const scheme = match[1].toLowerCase();
                switch (scheme) {
                    case "https":
                    case "data":
                        linkage.push({ type: "url", value: avatar });
                        return { linkage, url: avatar };
                    case "ipfs": {
                        const url = getIpfsLink(avatar);
                        linkage.push({ type: "ipfs", value: avatar });
                        linkage.push({ type: "url", value: url });
                        return { linkage, url };
                    }
                    case "erc721":
                    case "erc1155": {
                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                        const selector = (scheme === "erc721") ? "tokenURI(uint256)" : "uri(uint256)";
                        linkage.push({ type: scheme, value: avatar });
                        // The owner of this name
                        const owner = await this.getAddress();
                        if (owner == null) {
                            linkage.push({ type: "!owner", value: "" });
                            return { url: null, linkage };
                        }
                        const comps = (match[2] || "").split("/");
                        if (comps.length !== 2) {
                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || "") });
                            return { url: null, linkage };
                        }
                        const tokenId = comps[1];
                        const contract = new index_js_3.Contract(comps[0], [
                            // ERC-721
                            "function tokenURI(uint) view returns (string)",
                            "function ownerOf(uint) view returns (address)",
                            // ERC-1155
                            "function uri(uint) view returns (string)",
                            "function balanceOf(address, uint256) view returns (uint)"
                        ], this.provider);
                        // Check that this account owns the token
                        if (scheme === "erc721") {
                            const tokenOwner = await contract.ownerOf(tokenId);
                            if (owner !== tokenOwner) {
                                linkage.push({ type: "!owner", value: tokenOwner });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "owner", value: tokenOwner });
                        }
                        else if (scheme === "erc1155") {
                            const balance = await contract.balanceOf(owner, tokenId);
                            if (!balance) {
                                linkage.push({ type: "!balance", value: "0" });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "balance", value: balance.toString() });
                        }
                        // Call the token contract for the metadata URL
                        let metadataUrl = await contract[selector](tokenId);
                        if (metadataUrl == null || metadataUrl === "0x") {
                            linkage.push({ type: "!metadata-url", value: "" });
                            return { url: null, linkage };
                        }
                        linkage.push({ type: "metadata-url-base", value: metadataUrl });
                        // ERC-1155 allows a generic {id} in the URL
                        if (scheme === "erc1155") {
                            metadataUrl = metadataUrl.replace("{id}", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));
                            linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
                        }
                        // Transform IPFS metadata links
                        if (metadataUrl.match(/^ipfs:/i)) {
                            metadataUrl = getIpfsLink(metadataUrl);
                        }
                        linkage.push({ type: "metadata-url", value: metadataUrl });
                        // Get the token metadata
                        let metadata = {};
                        const response = await (new index_js_5.FetchRequest(metadataUrl)).send();
                        response.assertOk();
                        try {
                            metadata = response.bodyJson;
                        }
                        catch (error) {
                            try {
                                linkage.push({ type: "!metadata", value: response.bodyText });
                            }
                            catch (error) {
                                const bytes = response.body;
                                if (bytes) {
                                    linkage.push({ type: "!metadata", value: (0, index_js_5.hexlify)(bytes) });
                                }
                                return { url: null, linkage };
                            }
                            return { url: null, linkage };
                        }
                        if (!metadata) {
                            linkage.push({ type: "!metadata", value: "" });
                            return { url: null, linkage };
                        }
                        linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
                        // Pull the image URL out
                        let imageUrl = metadata.image;
                        if (typeof (imageUrl) !== "string") {
                            linkage.push({ type: "!imageUrl", value: "" });
                            return { url: null, linkage };
                        }
                        if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                            // Allow
                        }
                        else {
                            // Transform IPFS link to gateway
                            const ipfs = imageUrl.match(matcherIpfs);
                            if (ipfs == null) {
                                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                                return { url: null, linkage };
                            }
                            linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                            imageUrl = getIpfsLink(imageUrl);
                        }
                        linkage.push({ type: "url", value: imageUrl });
                        return { linkage, url: imageUrl };
                    }
                }
            }
        }
        catch (error) { }
        return { linkage, url: null };
    }
    static async getEnsAddress(provider) {
        const network = await provider.getNetwork();
        const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
        // No ENS...
        (0, index_js_5.assert)(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress", info: { network }
        });
        return ensPlugin.address;
    }
    static async #getResolver(provider, name) {
        const ensAddr = await EnsResolver.getEnsAddress(provider);
        try {
            const contract = new index_js_3.Contract(ensAddr, [
                "function resolver(bytes32) view returns (address)"
            ], provider);
            const addr = await contract.resolver((0, index_js_4.namehash)(name), {
                enableCcipRead: true
            });
            if (addr === index_js_2.ZeroAddress) {
                return null;
            }
            return addr;
        }
        catch (error) {
            // ENS registry cannot throw errors on resolver(bytes32),
            // so probably a link error
            throw error;
        }
        return null;
    }
    /**
     *  Resolve to the ENS resolver for %%name%% using %%provider%% or
     *  ``null`` if unconfigured.
     */
    static async fromName(provider, name) {
        let currentName = name;
        while (true) {
            if (currentName === "" || currentName === ".") {
                return null;
            }
            // Optimization since the eth node cannot change and does
            // not have a wildcard resolver
            if (name !== "eth" && currentName === "eth") {
                return null;
            }
            // Check the current node for a resolver
            const addr = await EnsResolver.#getResolver(provider, currentName);
            // Found a resolver!
            if (addr != null) {
                const resolver = new EnsResolver(provider, addr, name);
                // Legacy resolver found, using EIP-2544 so it isn't safe to use
                if (currentName !== name && !(await resolver.supportsWildcard())) {
                    return null;
                }
                return resolver;
            }
            // Get the parent node
            currentName = currentName.split(".").slice(1).join(".");
        }
    }
}
exports.EnsResolver = EnsResolver;
//# sourceMappingURL=ens-resolver.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/format.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/format.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;
/**
 *  @_ignore
 */
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
    return (function (value) {
        if (value == null) {
            return nullValue;
        }
        return format(value);
    });
}
exports.allowNull = allowNull;
function arrayOf(format, allowNull) {
    return ((array) => {
        if (allowNull && array == null) {
            return null;
        }
        if (!Array.isArray(array)) {
            throw new Error("not an array");
        }
        return array.map((i) => format(i));
    });
}
exports.arrayOf = arrayOf;
// Requires an object which matches a fleet of other formatters
// Any FormatFunc may return `undefined` to have the value omitted
// from the result object. Calls preserve `this`.
function object(format, altNames) {
    return ((value) => {
        const result = {};
        for (const key in format) {
            let srcKey = key;
            if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                    if (altKey in value) {
                        srcKey = altKey;
                        break;
                    }
                }
            }
            try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                    result[key] = nv;
                }
            }
            catch (error) {
                const message = (error instanceof Error) ? error.message : "not-an-error";
                (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
            }
        }
        return result;
    });
}
exports.object = object;
function formatBoolean(value) {
    switch (value) {
        case true:
        case "true":
            return true;
        case false:
        case "false":
            return false;
    }
    (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
exports.formatBoolean = formatBoolean;
function formatData(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), "invalid data", "value", value);
    return value;
}
exports.formatData = formatData;
function formatHash(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), "invalid hash", "value", value);
    return value;
}
exports.formatHash = formatHash;
function formatUint256(value) {
    if (!(0, index_js_4.isHexString)(value)) {
        throw new Error("invalid uint256");
    }
    return (0, index_js_4.zeroPadValue)(value, 32);
}
exports.formatUint256 = formatUint256;
const _formatLog = object({
    address: index_js_1.getAddress,
    blockHash: formatHash,
    blockNumber: index_js_4.getNumber,
    data: formatData,
    index: index_js_4.getNumber,
    removed: allowNull(formatBoolean, false),
    topics: arrayOf(formatHash),
    transactionHash: formatHash,
    transactionIndex: index_js_4.getNumber,
}, {
    index: ["logIndex"]
});
function formatLog(value) {
    return _formatLog(value);
}
exports.formatLog = formatLog;
const _formatBlock = object({
    hash: allowNull(formatHash),
    parentHash: formatHash,
    parentBeaconBlockRoot: allowNull(formatHash, null),
    number: index_js_4.getNumber,
    timestamp: index_js_4.getNumber,
    nonce: allowNull(formatData),
    difficulty: index_js_4.getBigInt,
    gasLimit: index_js_4.getBigInt,
    gasUsed: index_js_4.getBigInt,
    stateRoot: allowNull(formatHash, null),
    receiptsRoot: allowNull(formatHash, null),
    blobGasUsed: allowNull(index_js_4.getBigInt, null),
    excessBlobGas: allowNull(index_js_4.getBigInt, null),
    miner: allowNull(index_js_1.getAddress),
    prevRandao: allowNull(formatHash, null),
    extraData: formatData,
    baseFeePerGas: allowNull(index_js_4.getBigInt)
}, {
    prevRandao: ["mixHash"]
});
function formatBlock(value) {
    const result = _formatBlock(value);
    result.transactions = value.transactions.map((tx) => {
        if (typeof (tx) === "string") {
            return tx;
        }
        return formatTransactionResponse(tx);
    });
    return result;
}
exports.formatBlock = formatBlock;
const _formatReceiptLog = object({
    transactionIndex: index_js_4.getNumber,
    blockNumber: index_js_4.getNumber,
    transactionHash: formatHash,
    address: index_js_1.getAddress,
    topics: arrayOf(formatHash),
    data: formatData,
    index: index_js_4.getNumber,
    blockHash: formatHash,
}, {
    index: ["logIndex"]
});
function formatReceiptLog(value) {
    return _formatReceiptLog(value);
}
exports.formatReceiptLog = formatReceiptLog;
const _formatTransactionReceipt = object({
    to: allowNull(index_js_1.getAddress, null),
    from: allowNull(index_js_1.getAddress, null),
    contractAddress: allowNull(index_js_1.getAddress, null),
    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
    index: index_js_4.getNumber,
    root: allowNull(index_js_4.hexlify),
    gasUsed: index_js_4.getBigInt,
    blobGasUsed: allowNull(index_js_4.getBigInt, null),
    logsBloom: allowNull(formatData),
    blockHash: formatHash,
    hash: formatHash,
    logs: arrayOf(formatReceiptLog),
    blockNumber: index_js_4.getNumber,
    //confirmations: allowNull(getNumber, null),
    cumulativeGasUsed: index_js_4.getBigInt,
    effectiveGasPrice: allowNull(index_js_4.getBigInt),
    blobGasPrice: allowNull(index_js_4.getBigInt, null),
    status: allowNull(index_js_4.getNumber),
    type: allowNull(index_js_4.getNumber, 0)
}, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"],
});
function formatTransactionReceipt(value) {
    return _formatTransactionReceipt(value);
}
exports.formatTransactionReceipt = formatTransactionReceipt;
function formatTransactionResponse(value) {
    // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address
    if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {
        value.to = "0x0000000000000000000000000000000000000000";
    }
    const result = object({
        hash: formatHash,
        // Some nodes do not return this, usually test nodes (like Ganache)
        index: allowNull(index_js_4.getNumber, undefined),
        type: (value) => {
            if (value === "0x" || value == null) {
                return 0;
            }
            return (0, index_js_4.getNumber)(value);
        },
        accessList: allowNull(index_js_3.accessListify, null),
        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull(index_js_4.getNumber, null),
        transactionIndex: allowNull(index_js_4.getNumber, null),
        from: index_js_1.getAddress,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
        gasPrice: allowNull(index_js_4.getBigInt),
        maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),
        maxFeePerGas: allowNull(index_js_4.getBigInt),
        maxFeePerBlobGas: allowNull(index_js_4.getBigInt, null),
        gasLimit: index_js_4.getBigInt,
        to: allowNull(index_js_1.getAddress, null),
        value: index_js_4.getBigInt,
        nonce: index_js_4.getNumber,
        data: formatData,
        creates: allowNull(index_js_1.getAddress, null),
        chainId: allowNull(index_js_4.getBigInt, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"],
        index: ["transactionIndex"]
    })(value);
    // If to and creates are empty, populate the creates from the value
    if (result.to == null && result.creates == null) {
        result.creates = (0, index_js_1.getCreateAddress)(result);
    }
    // @TODO: Check fee data
    // Add an access list to supported transaction types
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
        result.accessList = [];
    }
    // Compute the signature
    if (value.signature) {
        result.signature = index_js_2.Signature.from(value.signature);
    }
    else {
        result.signature = index_js_2.Signature.from(value);
    }
    // Some backends omit ChainId on legacy transactions, but we can compute it
    if (result.chainId == null) {
        const chainId = result.signature.legacyChainId;
        if (chainId != null) {
            result.chainId = chainId;
        }
    }
    // @TODO: check chainID
    /*
    if (value.chainId != null) {
        let chainId = value.chainId;

        if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }

        result.chainId = chainId;

    } else {
        let chainId = value.networkId;

        // geth-etc returns chainId
        if (chainId == null && result.v == null) {
            chainId = value.chainId;
        }

        if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }

        if (typeof(chainId) !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) { chainId = 0; }
            chainId = parseInt(chainId);
        }

        if (typeof(chainId) !== "number") { chainId = 0; }

        result.chainId = chainId;
    }
    */
    // 0x0000... should actually be null
    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
        result.blockHash = null;
    }
    return result;
}
exports.formatTransactionResponse = formatTransactionResponse;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A **Provider** provides a connection to the blockchain, whch can be
 *  used to query its current state, simulate execution and send transactions
 *  to update the state.
 *
 *  It is one of the most fundamental components of interacting with a
 *  blockchain application, and there are many ways to connect, such as over
 *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).
 *
 *  @_section: api/providers:Providers  [about-providers]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.ChainstackProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;
var abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js");
Object.defineProperty(exports, "AbstractProvider", ({ enumerable: true, get: function () { return abstract_provider_js_1.AbstractProvider; } }));
Object.defineProperty(exports, "UnmanagedSubscriber", ({ enumerable: true, get: function () { return abstract_provider_js_1.UnmanagedSubscriber; } }));
var abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-signer.js");
Object.defineProperty(exports, "AbstractSigner", ({ enumerable: true, get: function () { return abstract_signer_js_1.AbstractSigner; } }));
Object.defineProperty(exports, "VoidSigner", ({ enumerable: true, get: function () { return abstract_signer_js_1.VoidSigner; } }));
var community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
Object.defineProperty(exports, "showThrottleMessage", ({ enumerable: true, get: function () { return community_js_1.showThrottleMessage; } }));
var default_provider_js_1 = __webpack_require__(/*! ./default-provider.js */ "../node_modules/ethers/lib.commonjs/providers/default-provider.js");
Object.defineProperty(exports, "getDefaultProvider", ({ enumerable: true, get: function () { return default_provider_js_1.getDefaultProvider; } }));
var ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ "../node_modules/ethers/lib.commonjs/providers/ens-resolver.js");
Object.defineProperty(exports, "EnsResolver", ({ enumerable: true, get: function () { return ens_resolver_js_1.EnsResolver; } }));
Object.defineProperty(exports, "MulticoinProviderPlugin", ({ enumerable: true, get: function () { return ens_resolver_js_1.MulticoinProviderPlugin; } }));
var network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
Object.defineProperty(exports, "Network", ({ enumerable: true, get: function () { return network_js_1.Network; } }));
var signer_noncemanager_js_1 = __webpack_require__(/*! ./signer-noncemanager.js */ "../node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js");
Object.defineProperty(exports, "NonceManager", ({ enumerable: true, get: function () { return signer_noncemanager_js_1.NonceManager; } }));
var plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ "../node_modules/ethers/lib.commonjs/providers/plugins-network.js");
Object.defineProperty(exports, "NetworkPlugin", ({ enumerable: true, get: function () { return plugins_network_js_1.NetworkPlugin; } }));
Object.defineProperty(exports, "GasCostPlugin", ({ enumerable: true, get: function () { return plugins_network_js_1.GasCostPlugin; } }));
Object.defineProperty(exports, "EnsPlugin", ({ enumerable: true, get: function () { return plugins_network_js_1.EnsPlugin; } }));
Object.defineProperty(exports, "FeeDataNetworkPlugin", ({ enumerable: true, get: function () { return plugins_network_js_1.FeeDataNetworkPlugin; } }));
Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", ({ enumerable: true, get: function () { return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin; } }));
var provider_js_1 = __webpack_require__(/*! ./provider.js */ "../node_modules/ethers/lib.commonjs/providers/provider.js");
Object.defineProperty(exports, "Block", ({ enumerable: true, get: function () { return provider_js_1.Block; } }));
Object.defineProperty(exports, "FeeData", ({ enumerable: true, get: function () { return provider_js_1.FeeData; } }));
Object.defineProperty(exports, "Log", ({ enumerable: true, get: function () { return provider_js_1.Log; } }));
Object.defineProperty(exports, "TransactionReceipt", ({ enumerable: true, get: function () { return provider_js_1.TransactionReceipt; } }));
Object.defineProperty(exports, "TransactionResponse", ({ enumerable: true, get: function () { return provider_js_1.TransactionResponse; } }));
Object.defineProperty(exports, "copyRequest", ({ enumerable: true, get: function () { return provider_js_1.copyRequest; } }));
var provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ "../node_modules/ethers/lib.commonjs/providers/provider-fallback.js");
Object.defineProperty(exports, "FallbackProvider", ({ enumerable: true, get: function () { return provider_fallback_js_1.FallbackProvider; } }));
var provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
Object.defineProperty(exports, "JsonRpcApiProvider", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcApiProvider; } }));
Object.defineProperty(exports, "JsonRpcProvider", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcProvider; } }));
Object.defineProperty(exports, "JsonRpcSigner", ({ enumerable: true, get: function () { return provider_jsonrpc_js_1.JsonRpcSigner; } }));
var provider_browser_js_1 = __webpack_require__(/*! ./provider-browser.js */ "../node_modules/ethers/lib.commonjs/providers/provider-browser.js");
Object.defineProperty(exports, "BrowserProvider", ({ enumerable: true, get: function () { return provider_browser_js_1.BrowserProvider; } }));
var provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ "../node_modules/ethers/lib.commonjs/providers/provider-alchemy.js");
Object.defineProperty(exports, "AlchemyProvider", ({ enumerable: true, get: function () { return provider_alchemy_js_1.AlchemyProvider; } }));
var provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ "../node_modules/ethers/lib.commonjs/providers/provider-ankr.js");
Object.defineProperty(exports, "AnkrProvider", ({ enumerable: true, get: function () { return provider_ankr_js_1.AnkrProvider; } }));
var provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ "../node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js");
Object.defineProperty(exports, "CloudflareProvider", ({ enumerable: true, get: function () { return provider_cloudflare_js_1.CloudflareProvider; } }));
var provider_chainstack_js_1 = __webpack_require__(/*! ./provider-chainstack.js */ "../node_modules/ethers/lib.commonjs/providers/provider-chainstack.js");
Object.defineProperty(exports, "ChainstackProvider", ({ enumerable: true, get: function () { return provider_chainstack_js_1.ChainstackProvider; } }));
var provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ "../node_modules/ethers/lib.commonjs/providers/provider-etherscan.js");
Object.defineProperty(exports, "EtherscanProvider", ({ enumerable: true, get: function () { return provider_etherscan_js_1.EtherscanProvider; } }));
Object.defineProperty(exports, "EtherscanPlugin", ({ enumerable: true, get: function () { return provider_etherscan_js_1.EtherscanPlugin; } }));
var provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ "../node_modules/ethers/lib.commonjs/providers/provider-infura.js");
Object.defineProperty(exports, "InfuraProvider", ({ enumerable: true, get: function () { return provider_infura_js_1.InfuraProvider; } }));
Object.defineProperty(exports, "InfuraWebSocketProvider", ({ enumerable: true, get: function () { return provider_infura_js_1.InfuraWebSocketProvider; } }));
var provider_pocket_js_1 = __webpack_require__(/*! ./provider-pocket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-pocket.js");
Object.defineProperty(exports, "PocketProvider", ({ enumerable: true, get: function () { return provider_pocket_js_1.PocketProvider; } }));
var provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ "../node_modules/ethers/lib.commonjs/providers/provider-quicknode.js");
Object.defineProperty(exports, "QuickNodeProvider", ({ enumerable: true, get: function () { return provider_quicknode_js_1.QuickNodeProvider; } }));
const provider_ipcsocket_js_1 = __webpack_require__(/*! ./provider-ipcsocket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js"); /*-browser*/
Object.defineProperty(exports, "IpcSocketProvider", ({ enumerable: true, get: function () { return provider_ipcsocket_js_1.IpcSocketProvider; } }));
var provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-socket.js");
Object.defineProperty(exports, "SocketProvider", ({ enumerable: true, get: function () { return provider_socket_js_1.SocketProvider; } }));
var provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-websocket.js");
Object.defineProperty(exports, "WebSocketProvider", ({ enumerable: true, get: function () { return provider_websocket_js_1.WebSocketProvider; } }));
var provider_socket_js_2 = __webpack_require__(/*! ./provider-socket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-socket.js");
Object.defineProperty(exports, "SocketSubscriber", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketSubscriber; } }));
Object.defineProperty(exports, "SocketBlockSubscriber", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketBlockSubscriber; } }));
Object.defineProperty(exports, "SocketPendingSubscriber", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketPendingSubscriber; } }));
Object.defineProperty(exports, "SocketEventSubscriber", ({ enumerable: true, get: function () { return provider_socket_js_2.SocketEventSubscriber; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/network.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/network.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  A **Network** encapsulates the various properties required to
 *  interact with a specific chain.
 *
 *  @_subsection: api/providers:Networks  [networks]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Network = void 0;
const index_js_1 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ "../node_modules/ethers/lib.commonjs/providers/plugins-network.js");
/* * * *
// Networks which operation against an L2 can use this plugin to
// specify how to access L1, for the purpose of resolving ENS,
// for example.
export class LayerOneConnectionPlugin extends NetworkPlugin {
    readonly provider!: Provider;
// @TODO: Rename to ChainAccess and allow for connecting to any chain
    constructor(provider: Provider) {
        super("org.ethers.plugins.layer-one-connection");
        defineProperties<LayerOneConnectionPlugin>(this, { provider });
    }

    clone(): LayerOneConnectionPlugin {
        return new LayerOneConnectionPlugin(this.provider);
    }
}
*/
const Networks = new Map();
/**
 *  A **Network** provides access to a chain's properties and allows
 *  for plug-ins to extend functionality.
 */
class Network {
    #name;
    #chainId;
    #plugins;
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    constructor(name, chainId) {
        this.#name = name;
        this.#chainId = (0, index_js_2.getBigInt)(chainId);
        this.#plugins = new Map();
    }
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    toJSON() {
        return { name: this.name, chainId: String(this.chainId) };
    }
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
    get name() { return this.#name; }
    set name(value) { this.#name = value; }
    /**
     *  The network chain ID.
     */
    get chainId() { return this.#chainId; }
    set chainId(value) { this.#chainId = (0, index_js_2.getBigInt)(value, "chainId"); }
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
    matches(other) {
        if (other == null) {
            return false;
        }
        if (typeof (other) === "string") {
            try {
                return (this.chainId === (0, index_js_2.getBigInt)(other));
            }
            catch (error) { }
            return (this.name === other);
        }
        if (typeof (other) === "number" || typeof (other) === "bigint") {
            try {
                return (this.chainId === (0, index_js_2.getBigInt)(other));
            }
            catch (error) { }
            return false;
        }
        if (typeof (other) === "object") {
            if (other.chainId != null) {
                try {
                    return (this.chainId === (0, index_js_2.getBigInt)(other.chainId));
                }
                catch (error) { }
                return false;
            }
            if (other.name != null) {
                return (this.name === other.name);
            }
            return false;
        }
        return false;
    }
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
    get plugins() {
        return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
    attachPlugin(plugin) {
        if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        this.#plugins.set(plugin.name, plugin.clone());
        return this;
    }
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
    getPlugin(name) {
        return (this.#plugins.get(name)) || null;
    }
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
    getPlugins(basename) {
        return (this.plugins.filter((p) => (p.name.split("#")[0] === basename)));
    }
    /**
     *  Create a copy of this Network.
     */
    clone() {
        const clone = new Network(this.name, this.chainId);
        this.plugins.forEach((plugin) => {
            clone.attachPlugin(plugin.clone());
        });
        return clone;
    }
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
    computeIntrinsicGas(tx) {
        const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || (new plugins_network_js_1.GasCostPlugin());
        let gas = costs.txBase;
        if (tx.to == null) {
            gas += costs.txCreate;
        }
        if (tx.data) {
            for (let i = 2; i < tx.data.length; i += 2) {
                if (tx.data.substring(i, i + 2) === "00") {
                    gas += costs.txDataZero;
                }
                else {
                    gas += costs.txDataNonzero;
                }
            }
        }
        if (tx.accessList) {
            const accessList = (0, index_js_1.accessListify)(tx.accessList);
            for (const addr in accessList) {
                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
            }
        }
        return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
    static from(network) {
        injectCommonNetworks();
        // Default network
        if (network == null) {
            return Network.from("mainnet");
        }
        // Canonical name or chain ID
        if (typeof (network) === "number") {
            network = BigInt(network);
        }
        if (typeof (network) === "string" || typeof (network) === "bigint") {
            const networkFunc = Networks.get(network);
            if (networkFunc) {
                return networkFunc();
            }
            if (typeof (network) === "bigint") {
                return new Network("unknown", network);
            }
            (0, index_js_2.assertArgument)(false, "unknown network", "network", network);
        }
        // Clonable with network-like abilities
        if (typeof (network.clone) === "function") {
            const clone = network.clone();
            //if (typeof(network.name) !== "string" || typeof(network.chainId) !== "number") {
            //}
            return clone;
        }
        // Networkish
        if (typeof (network) === "object") {
            (0, index_js_2.assertArgument)(typeof (network.name) === "string" && typeof (network.chainId) === "number", "invalid network object name or chainId", "network", network);
            const custom = new Network((network.name), (network.chainId));
            if (network.ensAddress || network.ensNetwork != null) {
                custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));
            }
            //if ((<any>network).layerOneConnection) {
            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));
            //}
            return custom;
        }
        (0, index_js_2.assertArgument)(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
    static register(nameOrChainId, networkFunc) {
        if (typeof (nameOrChainId) === "number") {
            nameOrChainId = BigInt(nameOrChainId);
        }
        const existing = Networks.get(nameOrChainId);
        if (existing) {
            (0, index_js_2.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
    }
}
exports.Network = Network;
// We don't want to bring in formatUnits because it is backed by
// FixedNumber and we want to keep Networks tiny. The values
// included by the Gas Stations are also IEEE 754 with lots of
// rounding issues and exceed the strict checks formatUnits has.
function parseUnits(_value, decimals) {
    const value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
        throw new Error(`invalid gwei value: ${_value}`);
    }
    // Break into [ whole, fraction ]
    const comps = value.split(".");
    if (comps.length === 1) {
        comps.push("");
    }
    // More than 1 decimal point or too many fractional positions
    if (comps.length !== 2) {
        throw new Error(`invalid gwei value: ${_value}`);
    }
    // Pad the fraction to 9 decimalplaces
    while (comps[1].length < decimals) {
        comps[1] += "0";
    }
    // Too many decimals and some non-zero ending, take the ceiling
    if (comps[1].length > 9) {
        let frac = BigInt(comps[1].substring(0, 9));
        if (!comps[1].substring(9).match(/^0+$/)) {
            frac++;
        }
        comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
}
// Used by Polygon to use a gas station for fee data
function getGasStationPlugin(url) {
    return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
        // Prevent Cloudflare from blocking our request in node.js
        request.setHeader("User-Agent", "ethers");
        let response;
        try {
            const [_response, _feeData] = await Promise.all([
                request.send(), fetchFeeData()
            ]);
            response = _response;
            const payload = response.bodyJson.standard;
            const feeData = {
                gasPrice: _feeData.gasPrice,
                maxFeePerGas: parseUnits(payload.maxFee, 9),
                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),
            };
            return feeData;
        }
        catch (error) {
            (0, index_js_2.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
        }
    });
}
// See: https://chainlist.org
let injected = false;
function injectCommonNetworks() {
    if (injected) {
        return;
    }
    injected = true;
    /// Register popular Ethereum networks
    function registerEth(name, chainId, options) {
        const func = function () {
            const network = new Network(name, chainId);
            // We use 0 to disable ENS
            if (options.ensNetwork != null) {
                network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));
            }
            network.attachPlugin(new plugins_network_js_1.GasCostPlugin());
            (options.plugins || []).forEach((plugin) => {
                network.attachPlugin(plugin);
            });
            return network;
        };
        // Register the network by name and chain ID
        Network.register(name, func);
        Network.register(chainId, func);
        if (options.altNames) {
            options.altNames.forEach((name) => {
                Network.register(name, func);
            });
        }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
    registerEth("holesky", 17000, { ensNetwork: 17000 });
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
        ensNetwork: 1,
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("arbitrum-sepolia", 421614, {});
    registerEth("base", 8453, { ensNetwork: 1 });
    registerEth("base-goerli", 84531, {});
    registerEth("base-sepolia", 84532, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("linea-sepolia", 59141, {});
    registerEth("matic", 137, {
        ensNetwork: 1,
        plugins: [
            getGasStationPlugin("https:/\/gasstation.polygon.technology/v2")
        ]
    });
    registerEth("matic-amoy", 80002, {});
    registerEth("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [
            getGasStationPlugin("https:/\/gasstation-testnet.polygon.technology/v2")
        ]
    });
    registerEth("optimism", 10, {
        ensNetwork: 1,
        plugins: []
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("optimism-sepolia", 11155420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
}
//# sourceMappingURL=network.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/plugins-network.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/plugins-network.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;
const properties_js_1 = __webpack_require__(/*! ../utils/properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
/**
 *  A **NetworkPlugin** provides additional functionality on a [[Network]].
 */
class NetworkPlugin {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    name;
    /**
     *  Creates a new **NetworkPlugin**.
     */
    constructor(name) {
        (0, properties_js_1.defineProperties)(this, { name });
    }
    /**
     *  Creates a copy of this plugin.
     */
    clone() {
        return new NetworkPlugin(this.name);
    }
}
exports.NetworkPlugin = NetworkPlugin;
/**
 *  A **GasCostPlugin** allows a network to provide alternative values when
 *  computing the intrinsic gas required for a transaction.
 */
class GasCostPlugin extends NetworkPlugin {
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    effectiveBlock;
    /**
     *  The transactions base fee.
     */
    txBase;
    /**
     *  The fee for creating a new account.
     */
    txCreate;
    /**
     *  The fee per zero-byte in the data.
     */
    txDataZero;
    /**
     *  The fee per non-zero-byte in the data.
     */
    txDataNonzero;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    txAccessListStorageKey;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    txAccessListAddress;
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    constructor(effectiveBlock, costs) {
        if (effectiveBlock == null) {
            effectiveBlock = 0;
        }
        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);
        const props = { effectiveBlock };
        function set(name, nullish) {
            let value = (costs || {})[name];
            if (value == null) {
                value = nullish;
            }
            (0, index_js_1.assertArgument)(typeof (value) === "number", `invalud value for ${name}`, "costs", costs);
            props[name] = value;
        }
        set("txBase", 21000);
        set("txCreate", 32000);
        set("txDataZero", 4);
        set("txDataNonzero", 16);
        set("txAccessListStorageKey", 1900);
        set("txAccessListAddress", 2400);
        (0, properties_js_1.defineProperties)(this, props);
    }
    clone() {
        return new GasCostPlugin(this.effectiveBlock, this);
    }
}
exports.GasCostPlugin = GasCostPlugin;
/**
 *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry
 *  Contract address and the target network to use when using that
 *  contract.
 *
 *  Various testnets have their own instance of the contract to use, but
 *  in general, the mainnet instance supports multi-chain addresses and
 *  should be used.
 */
class EnsPlugin extends NetworkPlugin {
    /**
     *  The ENS Registrty Contract address.
     */
    address;
    /**
     *  The chain ID that the ENS contract lives on.
     */
    targetNetwork;
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    constructor(address, targetNetwork) {
        super("org.ethers.plugins.network.Ens");
        (0, properties_js_1.defineProperties)(this, {
            address: (address || EnsAddress),
            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)
        });
    }
    clone() {
        return new EnsPlugin(this.address, this.targetNetwork);
    }
}
exports.EnsPlugin = EnsPlugin;
/**
 *  A **FeeDataNetworkPlugin** allows a network to provide and alternate
 *  means to specify its fee data.
 *
 *  For example, a network which does not support [[link-eip-1559]] may
 *  choose to use a Gas Station site to approximate the gas price.
 */
class FeeDataNetworkPlugin extends NetworkPlugin {
    #feeDataFunc;
    /**
     *  The fee data function provided to the constructor.
     */
    get feeDataFunc() {
        return this.#feeDataFunc;
    }
    /**
     *  Creates a new **FeeDataNetworkPlugin**.
     */
    constructor(feeDataFunc) {
        super("org.ethers.plugins.network.FeeData");
        this.#feeDataFunc = feeDataFunc;
    }
    /**
     *  Resolves to the fee data.
     */
    async getFeeData(provider) {
        return await this.#feeDataFunc(provider);
    }
    clone() {
        return new FeeDataNetworkPlugin(this.#feeDataFunc);
    }
}
exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
    #url;
    #processFunc;
    /**
     *  The URL to initialize the FetchRequest with in %%processFunc%%.
     */
    get url() { return this.#url; }
    /**
     *  The callback to use when computing the FeeData.
     */
    get processFunc() { return this.#processFunc; }
    /**
     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
     *  be used when computing the fee data for the network.
     */
    constructor(url, processFunc) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        this.#url = url;
        this.#processFunc = processFunc;
    }
    // We are immutable, so we can serve as our own clone
    clone() { return this; }
}
exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
/*
export class CustomBlockNetworkPlugin extends NetworkPlugin {
    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;
    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;

    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {
        super("org.ethers.network-plugins.custom-block");
        this.#blockFunc = blockFunc;
        this.#blockWithTxsFunc = blockWithTxsFunc;
    }

    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {
        return await this.#blockFunc(provider, block);
    }

    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {
        return await this.#blockWithTxsFunc(provider, block);
    }

    clone(): CustomBlockNetworkPlugin {
        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);
    }
}
*/
//# sourceMappingURL=plugins-network.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-alchemy.js":
/*!*************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-alchemy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  [[link-alchemy]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlchemyProvider = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "eth-mainnet.alchemyapi.io";
        case "goerli":
            return "eth-goerli.g.alchemy.com";
        case "sepolia":
            return "eth-sepolia.g.alchemy.com";
        case "arbitrum":
            return "arb-mainnet.g.alchemy.com";
        case "arbitrum-goerli":
            return "arb-goerli.g.alchemy.com";
        case "arbitrum-sepolia":
            return "arb-sepolia.g.alchemy.com";
        case "base":
            return "base-mainnet.g.alchemy.com";
        case "base-goerli":
            return "base-goerli.g.alchemy.com";
        case "base-sepolia":
            return "base-sepolia.g.alchemy.com";
        case "matic":
            return "polygon-mainnet.g.alchemy.com";
        case "matic-amoy":
            return "polygon-amoy.g.alchemy.com";
        case "matic-mumbai":
            return "polygon-mumbai.g.alchemy.com";
        case "optimism":
            return "opt-mainnet.g.alchemy.com";
        case "optimism-goerli":
            return "opt-goerli.g.alchemy.com";
        case "optimism-sepolia":
            return "opt-sepolia.g.alchemy.com";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **AlchemyProvider** connects to the [[link-alchemy]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-alchemy-signup).
 *
 *  @_docloc: api/providers/thirdparty
 */
class AlchemyProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    apiKey;
    constructor(_network, apiKey) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
            apiKey = defaultApiKey;
        }
        const request = AlchemyProvider.getRequest(network, apiKey);
        super(request, network, { staticNetwork: network });
        (0, index_js_1.defineProperties)(this, { apiKey });
    }
    _getProvider(chainId) {
        try {
            return new AlchemyProvider(chainId, this.apiKey);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    async _perform(req) {
        // https://docs.alchemy.com/reference/trace-transaction
        if (req.method === "getTransactionResult") {
            const { trace, tx } = await (0, index_js_1.resolveProperties)({
                trace: this.send("trace_transaction", [req.hash]),
                tx: this.getTransaction(req.hash)
            });
            if (trace == null || tx == null) {
                return null;
            }
            let data;
            let error = false;
            try {
                data = trace[0].result.output;
                error = (trace[0].error === "Reverted");
            }
            catch (error) { }
            if (data) {
                (0, index_js_1.assert)(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                    action: "getTransactionResult",
                    data,
                    reason: null,
                    transaction: tx,
                    invocation: null,
                    revert: null // @TODO
                });
                return data;
            }
            (0, index_js_1.assert)(false, "could not parse trace result", "BAD_DATA", { value: trace });
        }
        return await super._perform(req);
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey);
    }
    static getRequest(network, apiKey) {
        if (apiKey == null) {
            apiKey = defaultApiKey;
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v2/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("alchemy");
                return true;
            };
        }
        return request;
    }
}
exports.AlchemyProvider = AlchemyProvider;
//# sourceMappingURL=provider-alchemy.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-ankr.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-ankr.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnkrProvider = void 0;
/**
 *  [[link-ankr]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB (``bnb``)
 *  - BNB Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]
 */
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "rpc.ankr.com/eth";
        case "goerli":
            return "rpc.ankr.com/eth_goerli";
        case "sepolia":
            return "rpc.ankr.com/eth_sepolia";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum";
        case "base":
            return "rpc.ankr.com/base";
        case "base-goerli":
            return "rpc.ankr.com/base_goerli";
        case "base-sepolia":
            return "rpc.ankr.com/base_sepolia";
        case "bnb":
            return "rpc.ankr.com/bsc";
        case "bnbt":
            return "rpc.ankr.com/bsc_testnet_chapel";
        case "matic":
            return "rpc.ankr.com/polygon";
        case "matic-mumbai":
            return "rpc.ankr.com/polygon_mumbai";
        case "optimism":
            return "rpc.ankr.com/optimism";
        case "optimism-goerli":
            return "rpc.ankr.com/optimism_testnet";
        case "optimism-sepolia":
            return "rpc.ankr.com/optimism_sepolia";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **AnkrProvider** connects to the [[link-ankr]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-ankr-signup).
 */
class AnkrProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    /**
     *  The API key for the Ankr connection.
     */
    apiKey;
    /**
     *  Create a new **AnkrProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    constructor(_network, apiKey) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
            apiKey = defaultApiKey;
        }
        // Ankr does not support filterId, so we force polling
        const options = { polling: true, staticNetwork: network };
        const request = AnkrProvider.getRequest(network, apiKey);
        super(request, network, options);
        (0, index_js_1.defineProperties)(this, { apiKey });
    }
    _getProvider(chainId) {
        try {
            return new AnkrProvider(chainId, this.apiKey);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%apiKey%%.
     */
    static getRequest(network, apiKey) {
        if (apiKey == null) {
            apiKey = defaultApiKey;
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("AnkrProvider");
                return true;
            };
        }
        return request;
    }
    getRpcError(payload, error) {
        if (payload.method === "eth_sendRawTransaction") {
            if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
                error.error.message = "replacement transaction underpriced";
            }
        }
        return super.getRpcError(payload, error);
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey);
    }
}
exports.AnkrProvider = AnkrProvider;
//# sourceMappingURL=provider-ankr.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-browser.js":
/*!*************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserProvider = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
;
/**
 *  A **BrowserProvider** is intended to wrap an injected provider which
 *  adheres to the [[link-eip-1193]] standard, which most (if not all)
 *  currently do.
 */
class BrowserProvider extends provider_jsonrpc_js_1.JsonRpcApiPollingProvider {
    #request;
    /**
     *  Connnect to the %%ethereum%% provider, optionally forcing the
     *  %%network%%.
     */
    constructor(ethereum, network) {
        (0, index_js_1.assertArgument)(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
        super(network, { batchMaxCount: 1 });
        this.#request = async (method, params) => {
            const payload = { method, params };
            this.emit("debug", { action: "sendEip1193Request", payload });
            try {
                const result = await ethereum.request(payload);
                this.emit("debug", { action: "receiveEip1193Result", result });
                return result;
            }
            catch (e) {
                const error = new Error(e.message);
                error.code = e.code;
                error.data = e.data;
                error.payload = payload;
                this.emit("debug", { action: "receiveEip1193Error", error });
                throw error;
            }
        };
    }
    async send(method, params) {
        await this._start();
        return await super.send(method, params);
    }
    async _send(payload) {
        (0, index_js_1.assertArgument)(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
        try {
            const result = await this.#request(payload.method, payload.params || []);
            return [{ id: payload.id, result }];
        }
        catch (e) {
            return [{
                    id: payload.id,
                    error: { code: e.code, data: e.data, message: e.message }
                }];
        }
    }
    getRpcError(payload, error) {
        error = JSON.parse(JSON.stringify(error));
        // EIP-1193 gives us some machine-readable error codes, so rewrite
        // them into 
        switch (error.error.code || -1) {
            case 4001:
                error.error.message = `ethers-user-denied: ${error.error.message}`;
                break;
            case 4200:
                error.error.message = `ethers-unsupported: ${error.error.message}`;
                break;
        }
        return super.getRpcError(payload, error);
    }
    /**
     *  Resolves to ``true`` if the provider manages the %%address%%.
     */
    async hasSigner(address) {
        if (address == null) {
            address = 0;
        }
        const accounts = await this.send("eth_accounts", []);
        if (typeof (address) === "number") {
            return (accounts.length > address);
        }
        address = address.toLowerCase();
        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;
    }
    async getSigner(address) {
        if (address == null) {
            address = 0;
        }
        if (!(await this.hasSigner(address))) {
            try {
                //const resp = 
                await this.#request("eth_requestAccounts", []);
                //console.log("RESP", resp);
            }
            catch (error) {
                const payload = error.payload;
                throw this.getRpcError(payload, { id: payload.id, error });
            }
        }
        return await super.getSigner(address);
    }
}
exports.BrowserProvider = BrowserProvider;
//# sourceMappingURL=provider-browser.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-chainstack.js":
/*!****************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-chainstack.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChainstackProvider = void 0;
/**
 *  [[link-chainstack]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Arbitrum (``arbitrum``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - Polygon (``matic``)
 *
 *  @_subsection: api/providers/thirdparty:Chainstack  [providers-chainstack]
 */
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
function getApiKey(name) {
    switch (name) {
        case "mainnet": return "39f1d67cedf8b7831010a665328c9197";
        case "arbitrum": return "0550c209db33c3abf4cc927e1e18cea1";
        case "bnb": return "98b5a77e531614387366f6fc5da097f8";
        case "matic": return "cd9d4d70377471aa7c142ec4a4205249";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "ethereum-mainnet.core.chainstack.com";
        case "arbitrum":
            return "arbitrum-mainnet.core.chainstack.com";
        case "bnb":
            return "bsc-mainnet.core.chainstack.com";
        case "matic":
            return "polygon-mainnet.core.chainstack.com";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **ChainstackProvider** connects to the [[link-chainstack]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-chainstack).
 */
class ChainstackProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    /**
     *  The API key for the Chainstack connection.
     */
    apiKey;
    /**
     *  Creates a new **ChainstackProvider**.
     */
    constructor(_network, apiKey) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
            apiKey = getApiKey(network.name);
        }
        const request = ChainstackProvider.getRequest(network, apiKey);
        super(request, network, { staticNetwork: network });
        (0, index_js_1.defineProperties)(this, { apiKey });
    }
    _getProvider(chainId) {
        try {
            return new ChainstackProvider(chainId, this.apiKey);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    isCommunityResource() {
        return (this.apiKey === getApiKey(this._network.name));
    }
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%apiKey%% and %%projectSecret%%.
     */
    static getRequest(network, apiKey) {
        if (apiKey == null) {
            apiKey = getApiKey(network.name);
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === getApiKey(network.name)) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("ChainstackProvider");
                return true;
            };
        }
        return request;
    }
}
exports.ChainstackProvider = ChainstackProvider;
//# sourceMappingURL=provider-chainstack.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js":
/*!****************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  About Cloudflare
 *
 *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareProvider = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
/**
 *  About Cloudflare...
 */
class CloudflareProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    constructor(_network) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        (0, index_js_1.assertArgument)(network.name === "mainnet", "unsupported network", "network", _network);
        super("https:/\/cloudflare-eth.com/", network, { staticNetwork: network });
    }
}
exports.CloudflareProvider = CloudflareProvider;
//# sourceMappingURL=provider-cloudflare.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-etherscan.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-etherscan.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  [[link-etherscan]] provides a third-party service for connecting to
 *  various blockchains over a combination of JSON-RPC and custom API
 *  endpoints.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Holesky Testnet (``holesky``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *
 *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EtherscanProvider = exports.EtherscanPlugin = void 0;
const index_js_1 = __webpack_require__(/*! ../abi/index.js */ "../node_modules/ethers/lib.commonjs/abi/index.js");
const index_js_2 = __webpack_require__(/*! ../contract/index.js */ "../node_modules/ethers/lib.commonjs/contract/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ "../node_modules/ethers/lib.commonjs/providers/plugins-network.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const THROTTLE = 2000;
function isPromise(value) {
    return (value && typeof (value.then) === "function");
}
const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
/**
 *  A Network can include an **EtherscanPlugin** to provide
 *  a custom base URL.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
class EtherscanPlugin extends plugins_network_js_1.NetworkPlugin {
    /**
     *  The Etherscan API base URL.
     */
    baseUrl;
    /**
     *  Creates a new **EtherscanProvider** which will use
     *  %%baseUrl%%.
     */
    constructor(baseUrl) {
        super(EtherscanPluginId);
        (0, index_js_4.defineProperties)(this, { baseUrl });
    }
    clone() {
        return new EtherscanPlugin(this.baseUrl);
    }
}
exports.EtherscanPlugin = EtherscanPlugin;
const skipKeys = ["enableCcipRead"];
let nextId = 1;
/**
 *  The **EtherscanBaseProvider** is the super-class of
 *  [[EtherscanProvider]], which should generally be used instead.
 *
 *  Since the **EtherscanProvider** includes additional code for
 *  [[Contract]] access, in //rare cases// that contracts are not
 *  used, this class can reduce code size.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
class EtherscanProvider extends abstract_provider_js_1.AbstractProvider {
    /**
     *  The connected network.
     */
    network;
    /**
     *  The API key or null if using the community provided bandwidth.
     */
    apiKey;
    #plugin;
    /**
     *  Creates a new **EtherscanBaseProvider**.
     */
    constructor(_network, _apiKey) {
        const apiKey = (_apiKey != null) ? _apiKey : null;
        super();
        const network = network_js_1.Network.from(_network);
        this.#plugin = network.getPlugin(EtherscanPluginId);
        (0, index_js_4.defineProperties)(this, { apiKey, network });
        // Test that the network is supported by Etherscan
        this.getBaseUrl();
    }
    /**
     *  Returns the base URL.
     *
     *  If an [[EtherscanPlugin]] is configured on the
     *  [[EtherscanBaseProvider_network]], returns the plugin's
     *  baseUrl.
     */
    getBaseUrl() {
        if (this.#plugin) {
            return this.#plugin.baseUrl;
        }
        switch (this.network.name) {
            case "mainnet":
                return "https:/\/api.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            case "sepolia":
                return "https:/\/api-sepolia.etherscan.io";
            case "holesky":
                return "https:/\/api-holesky.etherscan.io";
            case "arbitrum":
                return "https:/\/api.arbiscan.io";
            case "arbitrum-goerli":
                return "https:/\/api-goerli.arbiscan.io";
            case "bnb":
                return "https:/\/api.bscscan.com";
            case "bnbt":
                return "https:/\/api-testnet.bscscan.com";
            case "matic":
                return "https:/\/api.polygonscan.com";
            case "matic-amoy":
                return "https:/\/api-amoy.polygonscan.com";
            case "matic-mumbai":
                return "https:/\/api-testnet.polygonscan.com";
            case "optimism":
                return "https:/\/api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https:/\/api-goerli-optimistic.etherscan.io";
            default:
        }
        (0, index_js_4.assertArgument)(false, "unsupported network", "network", this.network);
    }
    /**
     *  Returns the URL for the %%module%% and %%params%%.
     */
    getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
                accum += `&${key}=${value}`;
            }
            return accum;
        }, "");
        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : "");
        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
    }
    /**
     *  Returns the URL for using POST requests.
     */
    getPostUrl() {
        return `${this.getBaseUrl()}/api`;
    }
    /**
     *  Returns the parameters for using POST requests.
     */
    getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }
    async detectNetwork() {
        return this.network;
    }
    /**
     *  Resolves to the result of calling %%module%% with %%params%%.
     *
     *  If %%post%%, the request is made as a POST request.
     */
    async fetch(module, params, post) {
        const id = nextId++;
        const url = (post ? this.getPostUrl() : this.getUrl(module, params));
        const payload = (post ? this.getPostData(module, params) : null);
        this.emit("debug", { action: "sendRequest", id, url, payload: payload });
        const request = new index_js_4.FetchRequest(url);
        request.setThrottleParams({ slotInterval: 1000 });
        request.retryFunc = (req, resp, attempt) => {
            if (this.isCommunityResource()) {
                (0, community_js_1.showThrottleMessage)("Etherscan");
            }
            return Promise.resolve(true);
        };
        request.processFunc = async (request, response) => {
            const result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};
            const throttle = ((typeof (result.result) === "string") ? result.result : "").toLowerCase().indexOf("rate limit") >= 0;
            if (module === "proxy") {
                // This JSON response indicates we are being throttled
                if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                    this.emit("debug", { action: "receiveError", id, reason: "proxy-NOTOK", error: result });
                    response.throwThrottleError(result.result, THROTTLE);
                }
            }
            else {
                if (throttle) {
                    this.emit("debug", { action: "receiveError", id, reason: "null result", error: result.result });
                    response.throwThrottleError(result.result, THROTTLE);
                }
            }
            return response;
        };
        if (payload) {
            request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
        }
        const response = await request.send();
        try {
            response.assertOk();
        }
        catch (error) {
            this.emit("debug", { action: "receiveError", id, error, reason: "assertOk" });
            (0, index_js_4.assert)(false, "response error", "SERVER_ERROR", { request, response });
        }
        if (!response.hasBody()) {
            this.emit("debug", { action: "receiveError", id, error: "missing body", reason: "null body" });
            (0, index_js_4.assert)(false, "missing response", "SERVER_ERROR", { request, response });
        }
        const result = JSON.parse((0, index_js_4.toUtf8String)(response.body));
        if (module === "proxy") {
            if (result.jsonrpc != "2.0") {
                this.emit("debug", { action: "receiveError", id, result, reason: "invalid JSON-RPC" });
                (0, index_js_4.assert)(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
            }
            if (result.error) {
                this.emit("debug", { action: "receiveError", id, result, reason: "JSON-RPC error" });
                (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }
            this.emit("debug", { action: "receiveRequest", id, result });
            return result.result;
        }
        else {
            // getLogs, getHistory have weird success responses
            if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
                this.emit("debug", { action: "receiveRequest", id, result });
                return result.result;
            }
            if (result.status != 1 || (typeof (result.message) === "string" && !result.message.match(/^OK/))) {
                this.emit("debug", { action: "receiveError", id, result });
                (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }
            this.emit("debug", { action: "receiveRequest", id, result });
            return result.result;
        }
    }
    /**
     *  Returns %%transaction%% normalized for the Etherscan API.
     */
    _getTransactionPostData(transaction) {
        const result = {};
        for (let key in transaction) {
            if (skipKeys.indexOf(key) >= 0) {
                continue;
            }
            if (transaction[key] == null) {
                continue;
            }
            let value = transaction[key];
            if (key === "type" && value === 0) {
                continue;
            }
            if (key === "blockTag" && value === "latest") {
                continue;
            }
            // Quantity-types require no leading zero, unless 0
            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
                value = (0, index_js_4.toQuantity)(value);
            }
            else if (key === "accessList") {
                value = "[" + (0, index_js_3.accessListify)(value).map((set) => {
                    return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
                }).join(",") + "]";
            }
            else {
                value = (0, index_js_4.hexlify)(value);
            }
            result[key] = value;
        }
        return result;
    }
    /**
     *  Throws the normalized Etherscan error.
     */
    _checkError(req, error, transaction) {
        // Pull any message out if, possible
        let message = "";
        if ((0, index_js_4.isError)(error, "SERVER_ERROR")) {
            // Check for an error emitted by a proxy call
            try {
                message = error.info.result.error.message;
            }
            catch (e) { }
            if (!message) {
                try {
                    message = error.info.message;
                }
                catch (e) { }
            }
        }
        if (req.method === "estimateGas") {
            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
                (0, index_js_4.assert)(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
                    transaction: req.transaction
                });
            }
        }
        if (req.method === "call" || req.method === "estimateGas") {
            if (message.match(/execution reverted/i)) {
                let data = "";
                try {
                    data = error.info.result.error.data;
                }
                catch (error) { }
                const e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
                e.info = { request: req, error };
                throw e;
            }
        }
        if (message) {
            if (req.method === "broadcastTransaction") {
                const transaction = index_js_3.Transaction.from(req.signedTransaction);
                if (message.match(/replacement/i) && message.match(/underpriced/i)) {
                    (0, index_js_4.assert)(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                        transaction
                    });
                }
                if (message.match(/insufficient funds/)) {
                    (0, index_js_4.assert)(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                        transaction
                    });
                }
                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
                    (0, index_js_4.assert)(false, "nonce has already been used", "NONCE_EXPIRED", {
                        transaction
                    });
                }
            }
        }
        // Something we could not process
        throw error;
    }
    async _detectNetwork() {
        return this.network;
    }
    async _perform(req) {
        switch (req.method) {
            case "chainId":
                return this.network.chainId;
            case "getBlockNumber":
                return this.fetch("proxy", { action: "eth_blockNumber" });
            case "getGasPrice":
                return this.fetch("proxy", { action: "eth_gasPrice" });
            case "getPriorityFee":
                // This is temporary until Etherscan completes support
                if (this.network.name === "mainnet") {
                    return "1000000000";
                }
                else if (this.network.name === "optimism") {
                    return "1000000";
                }
                else {
                    throw new Error("fallback onto the AbstractProvider default");
                }
            /* Working with Etherscan to get this added:
            try {
                const test = await this.fetch("proxy", {
                    action: "eth_maxPriorityFeePerGas"
                });
                console.log(test);
                return test;
            } catch (e) {
                console.log("DEBUG", e);
                throw e;
            }
            */
            /* This might be safe; but due to rounding neither myself
               or Etherscan are necessarily comfortable with this. :)
            try {
                const result = await this.fetch("gastracker", { action: "gasoracle" });
                console.log(result);
                const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
                const baseFee = parseUnits(result.suggestBaseFee, "gwei");
                const priorityFee = gasPrice - baseFee;
                if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
                return priorityFee;
            } catch (error) {
                console.log("DEBUG", error);
                throw error;
            }
            */
            case "getBalance":
                // Returns base-10 result
                return this.fetch("account", {
                    action: "balance",
                    address: req.address,
                    tag: req.blockTag
                });
            case "getTransactionCount":
                return this.fetch("proxy", {
                    action: "eth_getTransactionCount",
                    address: req.address,
                    tag: req.blockTag
                });
            case "getCode":
                return this.fetch("proxy", {
                    action: "eth_getCode",
                    address: req.address,
                    tag: req.blockTag
                });
            case "getStorage":
                return this.fetch("proxy", {
                    action: "eth_getStorageAt",
                    address: req.address,
                    position: req.position,
                    tag: req.blockTag
                });
            case "broadcastTransaction":
                return this.fetch("proxy", {
                    action: "eth_sendRawTransaction",
                    hex: req.signedTransaction
                }, true).catch((error) => {
                    return this._checkError(req, error, req.signedTransaction);
                });
            case "getBlock":
                if ("blockTag" in req) {
                    return this.fetch("proxy", {
                        action: "eth_getBlockByNumber",
                        tag: req.blockTag,
                        boolean: (req.includeTransactions ? "true" : "false")
                    });
                }
                (0, index_js_4.assert)(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                    operation: "getBlock(blockHash)"
                });
            case "getTransaction":
                return this.fetch("proxy", {
                    action: "eth_getTransactionByHash",
                    txhash: req.hash
                });
            case "getTransactionReceipt":
                return this.fetch("proxy", {
                    action: "eth_getTransactionReceipt",
                    txhash: req.hash
                });
            case "call": {
                if (req.blockTag !== "latest") {
                    throw new Error("EtherscanProvider does not support blockTag for call");
                }
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                try {
                    return await this.fetch("proxy", postData, true);
                }
                catch (error) {
                    return this._checkError(req, error, req.transaction);
                }
            }
            case "estimateGas": {
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                try {
                    return await this.fetch("proxy", postData, true);
                }
                catch (error) {
                    return this._checkError(req, error, req.transaction);
                }
            }
            /*
                        case "getLogs": {
                            // Needs to complain if more than one address is passed in
                            const args: Record<string, any> = { action: "getLogs" }
            
                            if (params.filter.fromBlock) {
                                args.fromBlock = checkLogTag(params.filter.fromBlock);
                            }
            
                            if (params.filter.toBlock) {
                                args.toBlock = checkLogTag(params.filter.toBlock);
                            }
            
                            if (params.filter.address) {
                                args.address = params.filter.address;
                            }
            
                            // @TODO: We can handle slightly more complicated logs using the logs API
                            if (params.filter.topics && params.filter.topics.length > 0) {
                                if (params.filter.topics.length > 1) {
                                    logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                                }
                                if (params.filter.topics.length === 1) {
                                    const topic0 = params.filter.topics[0];
                                    if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                        logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                                    }
                                    args.topic0 = topic0;
                                }
                            }
            
                            const logs: Array<any> = await this.fetch("logs", args);
            
                            // Cache txHash => blockHash
                            let blocks: { [tag: string]: string } = {};
            
                            // Add any missing blockHash to the logs
                            for (let i = 0; i < logs.length; i++) {
                                const log = logs[i];
                                if (log.blockHash != null) { continue; }
                                if (blocks[log.blockNumber] == null) {
                                    const block = await this.getBlock(log.blockNumber);
                                    if (block) {
                                        blocks[log.blockNumber] = block.hash;
                                    }
                                }
            
                                log.blockHash = blocks[log.blockNumber];
                            }
            
                            return logs;
                        }
            */
            default:
                break;
        }
        return super._perform(req);
    }
    async getNetwork() {
        return this.network;
    }
    /**
     *  Resolves to the current price of ether.
     *
     *  This returns ``0`` on any network other than ``mainnet``.
     */
    async getEtherPrice() {
        if (this.network.name !== "mainnet") {
            return 0.0;
        }
        return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
    }
    /**
     *  Resolves to a [Contract]] for %%address%%, using the
     *  Etherscan API to retreive the Contract ABI.
     */
    async getContract(_address) {
        let address = this._getAddress(_address);
        if (isPromise(address)) {
            address = await address;
        }
        try {
            const resp = await this.fetch("contract", {
                action: "getabi", address
            });
            const abi = JSON.parse(resp);
            return new index_js_2.Contract(address, abi, this);
        }
        catch (error) {
            return null;
        }
    }
    isCommunityResource() {
        return (this.apiKey == null);
    }
}
exports.EtherscanProvider = EtherscanProvider;
//# sourceMappingURL=provider-etherscan.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-fallback.js":
/*!**************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-fallback.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FallbackProvider = void 0;
/**
 *  A **FallbackProvider** provides resilience, security and performance
 *  in a way that is customizable and configurable.
 *
 *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]
 */
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const BN_1 = BigInt("1");
const BN_2 = BigInt("2");
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
function stall(duration) {
    return new Promise((resolve) => { setTimeout(resolve, duration); });
}
function getTime() { return (new Date()).getTime(); }
function stringify(value) {
    return JSON.stringify(value, (key, value) => {
        if (typeof (value) === "bigint") {
            return { type: "bigint", value: value.toString() };
        }
        return value;
    });
}
;
const defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
const defaultState = {
    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,
    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,
    _network: null, _updateNumber: null, _totalTime: 0,
    _lastFatalError: null, _lastFatalErrorTimestamp: 0
};
async function waitForSync(config, blockNumber) {
    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
        if (!config._updateNumber) {
            config._updateNumber = (async () => {
                try {
                    const blockNumber = await config.provider.getBlockNumber();
                    if (blockNumber > config.blockNumber) {
                        config.blockNumber = blockNumber;
                    }
                }
                catch (error) {
                    config.blockNumber = -2;
                    config._lastFatalError = error;
                    config._lastFatalErrorTimestamp = getTime();
                }
                config._updateNumber = null;
            })();
        }
        await config._updateNumber;
        config.outOfSync++;
        if (config._lastFatalError) {
            break;
        }
    }
}
function _normalize(value) {
    if (value == null) {
        return "null";
    }
    if (Array.isArray(value)) {
        return "[" + (value.map(_normalize)).join(",") + "]";
    }
    if (typeof (value) === "object" && typeof (value.toJSON) === "function") {
        return _normalize(value.toJSON());
    }
    switch (typeof (value)) {
        case "boolean":
        case "symbol":
            return value.toString();
        case "bigint":
        case "number":
            return BigInt(value).toString();
        case "string":
            return JSON.stringify(value);
        case "object": {
            const keys = Object.keys(value);
            keys.sort();
            return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
        }
    }
    console.log("Could not serialize", value);
    throw new Error("Hmm...");
}
function normalizeResult(value) {
    if ("error" in value) {
        const error = value.error;
        return { tag: _normalize(error), value: error };
    }
    const result = value.result;
    return { tag: _normalize(result), value: result };
}
// This strategy picks the highest weight result, as long as the weight is
// equal to or greater than quorum
function checkQuorum(quorum, results) {
    const tally = new Map();
    for (const { value, tag, weight } of results) {
        const t = tally.get(tag) || { value, weight: 0 };
        t.weight += weight;
        tally.set(tag, t);
    }
    let best = null;
    for (const r of tally.values()) {
        if (r.weight >= quorum && (!best || r.weight > best.weight)) {
            best = r;
        }
    }
    if (best) {
        return best.value;
    }
    return undefined;
}
function getMedian(quorum, results) {
    let resultWeight = 0;
    const errorMap = new Map();
    let bestError = null;
    const values = [];
    for (const { value, tag, weight } of results) {
        if (value instanceof Error) {
            const e = errorMap.get(tag) || { value, weight: 0 };
            e.weight += weight;
            errorMap.set(tag, e);
            if (bestError == null || e.weight > bestError.weight) {
                bestError = e;
            }
        }
        else {
            values.push(BigInt(value));
            resultWeight += weight;
        }
    }
    if (resultWeight < quorum) {
        // We have quorum for an error
        if (bestError && bestError.weight >= quorum) {
            return bestError.value;
        }
        // We do not have quorum for a result
        return undefined;
    }
    // Get the sorted values
    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));
    const mid = Math.floor(values.length / 2);
    // Odd-length; take the middle value
    if (values.length % 2) {
        return values[mid];
    }
    // Even length; take the ceiling of the mean of the center two values
    return (values[mid - 1] + values[mid] + BN_1) / BN_2;
}
function getAnyResult(quorum, results) {
    // If any value or error meets quorum, that is our preferred result
    const result = checkQuorum(quorum, results);
    if (result !== undefined) {
        return result;
    }
    // Otherwise, do we have any result?
    for (const r of results) {
        if (r.value) {
            return r.value;
        }
    }
    // Nope!
    return undefined;
}
function getFuzzyMode(quorum, results) {
    if (quorum === 1) {
        return (0, index_js_1.getNumber)(getMedian(quorum, results), "%internal");
    }
    const tally = new Map();
    const add = (result, weight) => {
        const t = tally.get(result) || { result, weight: 0 };
        t.weight += weight;
        tally.set(result, t);
    };
    for (const { weight, value } of results) {
        const r = (0, index_js_1.getNumber)(value);
        add(r - 1, weight);
        add(r, weight);
        add(r + 1, weight);
    }
    let bestWeight = 0;
    let bestResult = undefined;
    for (const { weight, result } of tally.values()) {
        // Use this result, if this result meets quorum and has either:
        // - a better weight
        // - or equal weight, but the result is larger
        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {
            bestWeight = weight;
            bestResult = result;
        }
    }
    return bestResult;
}
/**
 *  A **FallbackProvider** manages several [[Providers]] providing
 *  resilience by switching between slow or misbehaving nodes, security
 *  by requiring multiple backends to aggree and performance by allowing
 *  faster backends to respond earlier.
 *
 */
class FallbackProvider extends abstract_provider_js_1.AbstractProvider {
    /**
     *  The number of backends that must agree on a value before it is
     *  accpeted.
     */
    quorum;
    /**
     *  @_ignore:
     */
    eventQuorum;
    /**
     *  @_ignore:
     */
    eventWorkers;
    #configs;
    #height;
    #initialSyncPromise;
    /**
     *  Creates a new **FallbackProvider** with %%providers%% connected to
     *  %%network%%.
     *
     *  If a [[Provider]] is included in %%providers%%, defaults are used
     *  for the configuration.
     */
    constructor(providers, network, options) {
        super(network, options);
        this.#configs = providers.map((p) => {
            if (p instanceof abstract_provider_js_1.AbstractProvider) {
                return Object.assign({ provider: p }, defaultConfig, defaultState);
            }
            else {
                return Object.assign({}, defaultConfig, p, defaultState);
            }
        });
        this.#height = -2;
        this.#initialSyncPromise = null;
        if (options && options.quorum != null) {
            this.quorum = options.quorum;
        }
        else {
            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {
                accum += config.weight;
                return accum;
            }, 0) / 2);
        }
        this.eventQuorum = 1;
        this.eventWorkers = 1;
        (0, index_js_1.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), "quorum exceed provider weight", "quorum", this.quorum);
    }
    get providerConfigs() {
        return this.#configs.map((c) => {
            const result = Object.assign({}, c);
            for (const key in result) {
                if (key[0] === "_") {
                    delete result[key];
                }
            }
            return result;
        });
    }
    async _detectNetwork() {
        return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({ method: "chainId" })));
    }
    // @TODO: Add support to select providers to be the event subscriber
    //_getSubscriber(sub: Subscription): Subscriber {
    //    throw new Error("@TODO");
    //}
    /**
     *  Transforms a %%req%% into the correct method call on %%provider%%.
     */
    async _translatePerform(provider, req) {
        switch (req.method) {
            case "broadcastTransaction":
                return await provider.broadcastTransaction(req.signedTransaction);
            case "call":
                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
            case "chainId":
                return (await provider.getNetwork()).chainId;
            case "estimateGas":
                return await provider.estimateGas(req.transaction);
            case "getBalance":
                return await provider.getBalance(req.address, req.blockTag);
            case "getBlock": {
                const block = ("blockHash" in req) ? req.blockHash : req.blockTag;
                return await provider.getBlock(block, req.includeTransactions);
            }
            case "getBlockNumber":
                return await provider.getBlockNumber();
            case "getCode":
                return await provider.getCode(req.address, req.blockTag);
            case "getGasPrice":
                return (await provider.getFeeData()).gasPrice;
            case "getPriorityFee":
                return (await provider.getFeeData()).maxPriorityFeePerGas;
            case "getLogs":
                return await provider.getLogs(req.filter);
            case "getStorage":
                return await provider.getStorage(req.address, req.position, req.blockTag);
            case "getTransaction":
                return await provider.getTransaction(req.hash);
            case "getTransactionCount":
                return await provider.getTransactionCount(req.address, req.blockTag);
            case "getTransactionReceipt":
                return await provider.getTransactionReceipt(req.hash);
            case "getTransactionResult":
                return await provider.getTransactionResult(req.hash);
        }
    }
    // Grab the next (random) config that is not already part of
    // the running set
    #getNextConfig(running) {
        // @TODO: Maybe do a check here to favour (heavily) providers that
        //        do not require waitForSync and disfavour providers that
        //        seem down-ish or are behaving slowly
        const configs = Array.from(running).map((r) => r.config);
        // Shuffle the states, sorted by priority
        const allConfigs = this.#configs.slice();
        shuffle(allConfigs);
        allConfigs.sort((a, b) => (a.priority - b.priority));
        for (const config of allConfigs) {
            if (config._lastFatalError) {
                continue;
            }
            if (configs.indexOf(config) === -1) {
                return config;
            }
        }
        return null;
    }
    // Adds a new runner (if available) to running.
    #addRunner(running, req) {
        const config = this.#getNextConfig(running);
        // No runners available
        if (config == null) {
            return null;
        }
        // Create a new runner
        const runner = {
            config, result: null, didBump: false,
            perform: null, staller: null
        };
        const now = getTime();
        // Start performing this operation
        runner.perform = (async () => {
            try {
                config.requests++;
                const result = await this._translatePerform(config.provider, req);
                runner.result = { result };
            }
            catch (error) {
                config.errorResponses++;
                runner.result = { error };
            }
            const dt = (getTime() - now);
            config._totalTime += dt;
            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
            runner.perform = null;
        })();
        // Start a staller; when this times out, it's time to force
        // kicking off another runner because we are taking too long
        runner.staller = (async () => {
            await stall(config.stallTimeout);
            runner.staller = null;
        })();
        running.add(runner);
        return runner;
    }
    // Initializes the blockNumber and network for each runner and
    // blocks until initialized
    async #initialSync() {
        let initialSync = this.#initialSyncPromise;
        if (!initialSync) {
            const promises = [];
            this.#configs.forEach((config) => {
                promises.push((async () => {
                    await waitForSync(config, 0);
                    if (!config._lastFatalError) {
                        config._network = await config.provider.getNetwork();
                    }
                })());
            });
            this.#initialSyncPromise = initialSync = (async () => {
                // Wait for all providers to have a block number and network
                await Promise.all(promises);
                // Check all the networks match
                let chainId = null;
                for (const config of this.#configs) {
                    if (config._lastFatalError) {
                        continue;
                    }
                    const network = (config._network);
                    if (chainId == null) {
                        chainId = network.chainId;
                    }
                    else if (network.chainId !== chainId) {
                        (0, index_js_1.assert)(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                            operation: "new FallbackProvider"
                        });
                    }
                }
            })();
        }
        await initialSync;
    }
    async #checkQuorum(running, req) {
        // Get all the result objects
        const results = [];
        for (const runner of running) {
            if (runner.result != null) {
                const { tag, value } = normalizeResult(runner.result);
                results.push({ tag, value, weight: runner.config.weight });
            }
        }
        // Are there enough results to event meet quorum?
        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {
            return undefined;
        }
        switch (req.method) {
            case "getBlockNumber": {
                // We need to get the bootstrap block height
                if (this.#height === -2) {
                    this.#height = Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({
                        value: c.blockNumber,
                        tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),
                        weight: c.weight
                    })))));
                }
                // Find the mode across all the providers, allowing for
                // a little drift between block heights
                const mode = getFuzzyMode(this.quorum, results);
                if (mode === undefined) {
                    return undefined;
                }
                if (mode > this.#height) {
                    this.#height = mode;
                }
                return this.#height;
            }
            case "getGasPrice":
            case "getPriorityFee":
            case "estimateGas":
                return getMedian(this.quorum, results);
            case "getBlock":
                // Pending blocks are in the mempool and already
                // quite untrustworthy; just grab anything
                if ("blockTag" in req && req.blockTag === "pending") {
                    return getAnyResult(this.quorum, results);
                }
                return checkQuorum(this.quorum, results);
            case "call":
            case "chainId":
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
            case "getStorage":
            case "getTransaction":
            case "getTransactionReceipt":
            case "getLogs":
                return checkQuorum(this.quorum, results);
            case "broadcastTransaction":
                return getAnyResult(this.quorum, results);
        }
        (0, index_js_1.assert)(false, "unsupported method", "UNSUPPORTED_OPERATION", {
            operation: `_perform(${stringify(req.method)})`
        });
    }
    async #waitForQuorum(running, req) {
        if (running.size === 0) {
            throw new Error("no runners?!");
        }
        // Any promises that are interesting to watch for; an expired stall
        // or a successful perform
        const interesting = [];
        let newRunners = 0;
        for (const runner of running) {
            // No responses, yet; keep an eye on it
            if (runner.perform) {
                interesting.push(runner.perform);
            }
            // Still stalling...
            if (runner.staller) {
                interesting.push(runner.staller);
                continue;
            }
            // This runner has already triggered another runner
            if (runner.didBump) {
                continue;
            }
            // Got a response (result or error) or stalled; kick off another runner
            runner.didBump = true;
            newRunners++;
        }
        // Check if we have reached quorum on a result (or error)
        const value = await this.#checkQuorum(running, req);
        if (value !== undefined) {
            if (value instanceof Error) {
                throw value;
            }
            return value;
        }
        // Add any new runners, because a staller timed out or a result
        // or error response came in.
        for (let i = 0; i < newRunners; i++) {
            this.#addRunner(running, req);
        }
        // All providers have returned, and we have no result
        (0, index_js_1.assert)(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
            request: "%sub-requests",
            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }
        });
        // Wait for someone to either complete its perform or stall out
        await Promise.race(interesting);
        // This is recursive, but at worst case the depth is 2x the
        // number of providers (each has a perform and a staller)
        return await this.#waitForQuorum(running, req);
    }
    async _perform(req) {
        // Broadcasting a transaction is rare (ish) and already incurs
        // a cost on the user, so spamming is safe-ish. Just send it to
        // every backend.
        if (req.method === "broadcastTransaction") {
            // Once any broadcast provides a positive result, use it. No
            // need to wait for anyone else
            const results = this.#configs.map((c) => null);
            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {
                try {
                    const result = await provider._perform(req);
                    results[index] = Object.assign(normalizeResult({ result }), { weight });
                }
                catch (error) {
                    results[index] = Object.assign(normalizeResult({ error }), { weight });
                }
            });
            // As each promise finishes...
            while (true) {
                // Check for a valid broadcast result
                const done = results.filter((r) => (r != null));
                for (const { value } of done) {
                    if (!(value instanceof Error)) {
                        return value;
                    }
                }
                // Check for a legit broadcast error (one which we cannot
                // recover from; some nodes may return the following red
                // herring events:
                // - alredy seend (UNKNOWN_ERROR)
                // - NONCE_EXPIRED
                // - REPLACEMENT_UNDERPRICED
                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));
                if ((0, index_js_1.isError)(result, "INSUFFICIENT_FUNDS")) {
                    throw result;
                }
                // Kick off the next provider (if any)
                const waiting = broadcasts.filter((b, i) => (results[i] == null));
                if (waiting.length === 0) {
                    break;
                }
                await Promise.race(waiting);
            }
            // Use standard quorum results; any result was returned above,
            // so this will find any error that met quorum if any
            const result = getAnyResult(this.quorum, results);
            (0, index_js_1.assert)(result !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
                request: "%sub-requests",
                info: { request: req, results: results.map(stringify) }
            });
            if (result instanceof Error) {
                throw result;
            }
            return result;
        }
        await this.#initialSync();
        // Bootstrap enough runners to meet quorum
        const running = new Set();
        let inflightQuorum = 0;
        while (true) {
            const runner = this.#addRunner(running, req);
            if (runner == null) {
                break;
            }
            inflightQuorum += runner.config.weight;
            if (inflightQuorum >= this.quorum) {
                break;
            }
        }
        const result = await this.#waitForQuorum(running, req);
        // Track requests sent to a provider that are still
        // outstanding after quorum has been otherwise found
        for (const runner of running) {
            if (runner.perform && runner.result == null) {
                runner.config.lateResponses++;
            }
        }
        return result;
    }
    async destroy() {
        for (const { provider } of this.#configs) {
            provider.destroy();
        }
        super.destroy();
    }
}
exports.FallbackProvider = FallbackProvider;
//# sourceMappingURL=provider-fallback.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-infura.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-infura.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
/**
 *  [[link-infura]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Linea (``linea``)
 *  - Linea Goerli Testnet (``linea-goerli``)
 *  - Linea Sepolia Testnet (``linea-sepolia``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]
 */
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-websocket.js");
const defaultProjectId = "84842078b09946638c03157f83405213";
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "mainnet.infura.io";
        case "goerli":
            return "goerli.infura.io";
        case "sepolia":
            return "sepolia.infura.io";
        case "arbitrum":
            return "arbitrum-mainnet.infura.io";
        case "arbitrum-goerli":
            return "arbitrum-goerli.infura.io";
        case "arbitrum-sepolia":
            return "arbitrum-sepolia.infura.io";
        case "base":
            return "base-mainnet.infura.io";
        case "base-goerlia":
            return "base-goerli.infura.io";
        case "base-sepolia":
            return "base-sepolia.infura.io";
        case "bnb":
            return "bnbsmartchain-mainnet.infura.io";
        case "bnbt":
            return "bnbsmartchain-testnet.infura.io";
        case "linea":
            return "linea-mainnet.infura.io";
        case "linea-goerli":
            return "linea-goerli.infura.io";
        case "linea-sepolia":
            return "linea-sepolia.infura.io";
        case "matic":
            return "polygon-mainnet.infura.io";
        case "matic-amoy":
            return "polygon-amoy.infura.io";
        case "matic-mumbai":
            return "polygon-mumbai.infura.io";
        case "optimism":
            return "optimism-mainnet.infura.io";
        case "optimism-goerli":
            return "optimism-goerli.infura.io";
        case "optimism-sepolia":
            return "optimism-sepolia.infura.io";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **InfuraWebSocketProvider** connects to the [[link-infura]]
 *  WebSocket end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
class InfuraWebSocketProvider extends provider_websocket_js_1.WebSocketProvider {
    /**
     *  The Project ID for the INFURA connection.
     */
    projectId;
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    projectSecret;
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
    constructor(network, projectId) {
        const provider = new InfuraProvider(network, projectId);
        const req = provider._getConnection();
        (0, index_js_1.assert)(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
        const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, provider._network);
        (0, index_js_1.defineProperties)(this, {
            projectId: provider.projectId,
            projectSecret: provider.projectSecret
        });
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
}
exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
/**
 *  The **InfuraProvider** connects to the [[link-infura]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
class InfuraProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    /**
     *  The Project ID for the INFURA connection.
     */
    projectId;
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    projectSecret;
    /**
     *  Creates a new **InfuraProvider**.
     */
    constructor(_network, projectId, projectSecret) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (projectId == null) {
            projectId = defaultProjectId;
        }
        if (projectSecret == null) {
            projectSecret = null;
        }
        const request = InfuraProvider.getRequest(network, projectId, projectSecret);
        super(request, network, { staticNetwork: network });
        (0, index_js_1.defineProperties)(this, { projectId, projectSecret });
    }
    _getProvider(chainId) {
        try {
            return new InfuraProvider(chainId, this.projectId, this.projectSecret);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
    static getWebSocketProvider(network, projectId) {
        return new InfuraWebSocketProvider(network, projectId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%projectId%% and %%projectSecret%%.
     */
    static getRequest(network, projectId, projectSecret) {
        if (projectId == null) {
            projectId = defaultProjectId;
        }
        if (projectSecret == null) {
            projectSecret = null;
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v3/${projectId}`);
        request.allowGzip = true;
        if (projectSecret) {
            request.setCredentials("", projectSecret);
        }
        if (projectId === defaultProjectId) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("InfuraProvider");
                return true;
            };
        }
        return request;
    }
}
exports.InfuraProvider = InfuraProvider;
//# sourceMappingURL=provider-infura.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpcSocketProvider = void 0;
const net_1 = __webpack_require__(/*! net */ "net");
const provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-socket.js");
// @TODO: Is this sufficient? Is this robust? Will newlines occur between
// all payloads and only between payloads?
function splitBuffer(data) {
    const messages = [];
    let lastStart = 0;
    while (true) {
        const nl = data.indexOf(10, lastStart);
        if (nl === -1) {
            break;
        }
        messages.push(data.subarray(lastStart, nl).toString().trim());
        lastStart = nl + 1;
    }
    return { messages, remaining: data.subarray(lastStart) };
}
/**
 *  An **IpcSocketProvider** connects over an IPC socket on the host
 *  which provides fast access to the node, but requires the node and
 *  the script run on the same machine.
 */
class IpcSocketProvider extends provider_socket_js_1.SocketProvider {
    #socket;
    /**
     *  The connected socket.
     */
    get socket() { return this.#socket; }
    constructor(path, network, options) {
        super(network, options);
        this.#socket = (0, net_1.connect)(path);
        this.socket.on("ready", async () => {
            try {
                await this._start();
            }
            catch (error) {
                console.log("failed to start IpcSocketProvider", error);
                // @TODO: Now what? Restart?
            }
        });
        let response = Buffer.alloc(0);
        this.socket.on("data", (data) => {
            response = Buffer.concat([response, data]);
            const { messages, remaining } = splitBuffer(response);
            messages.forEach((message) => {
                this._processMessage(message);
            });
            response = remaining;
        });
        this.socket.on("end", () => {
            this.emit("close");
            this.socket.destroy();
            this.socket.end();
        });
    }
    destroy() {
        this.socket.destroy();
        this.socket.end();
        super.destroy();
    }
    async _write(message) {
        this.socket.write(message);
    }
}
exports.IpcSocketProvider = IpcSocketProvider;
//# sourceMappingURL=provider-ipcsocket.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js":
/*!*************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  One of the most common ways to interact with the blockchain is
 *  by a node running a JSON-RPC interface which can be connected to,
 *  based on the transport, using:
 *
 *  - HTTP or HTTPS - [[JsonRpcProvider]]
 *  - WebSocket - [[WebSocketProvider]]
 *  - IPC - [[IpcSocketProvider]]
 *
 * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;
// @TODO:
// - Add the batching API
// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false
const index_js_1 = __webpack_require__(/*! ../abi/index.js */ "../node_modules/ethers/lib.commonjs/abi/index.js");
const index_js_2 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_3 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_4 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_5 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js");
const abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-signer.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const subscriber_filterid_js_1 = __webpack_require__(/*! ./subscriber-filterid.js */ "../node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js");
const subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ "../node_modules/ethers/lib.commonjs/providers/subscriber-polling.js");
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
//const Methods = "getAddress,then".split(/,/g);
function deepCopy(value) {
    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {
        return value;
    }
    // Keep any Addressable
    if (typeof (value.getAddress) === "function") {
        return value;
    }
    if (Array.isArray(value)) {
        return (value.map(deepCopy));
    }
    if (typeof (value) === "object") {
        return Object.keys(value).reduce((accum, key) => {
            accum[key] = value[key];
            return accum;
        }, {});
    }
    throw new Error(`should not happen: ${value} (${typeof (value)})`);
}
function stall(duration) {
    return new Promise((resolve) => { setTimeout(resolve, duration); });
}
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
function isPollable(value) {
    return (value && typeof (value.pollingInterval) === "number");
}
const defaultOptions = {
    polling: false,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: (1 << 20),
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4000
};
// @TODO: Unchecked Signers
class JsonRpcSigner extends abstract_signer_js_1.AbstractSigner {
    address;
    constructor(provider, address) {
        super(provider);
        address = (0, index_js_2.getAddress)(address);
        (0, index_js_5.defineProperties)(this, { address });
    }
    connect(provider) {
        (0, index_js_5.assert)(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
        });
    }
    async getAddress() {
        return this.address;
    }
    // JSON-RPC will automatially fill in nonce, etc. so we just check from
    async populateTransaction(tx) {
        return await this.populateCall(tx);
    }
    // Returns just the hash of the transaction after sent, which is what
    // the bare JSON-RPC API does;
    async sendUncheckedTransaction(_tx) {
        const tx = deepCopy(_tx);
        const promises = [];
        // Make sure the from matches the sender
        if (tx.from) {
            const _from = tx.from;
            promises.push((async () => {
                const from = await (0, index_js_2.resolveAddress)(_from, this.provider);
                (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                tx.from = from;
            })());
        }
        else {
            tx.from = this.address;
        }
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (tx.gasLimit == null) {
            promises.push((async () => {
                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
            })());
        }
        // The address may be an ENS name or Addressable
        if (tx.to != null) {
            const _to = tx.to;
            promises.push((async () => {
                tx.to = await (0, index_js_2.resolveAddress)(_to, this.provider);
            })());
        }
        // Wait until all of our properties are filled in
        if (promises.length) {
            await Promise.all(promises);
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return this.provider.send("eth_sendTransaction", [hexTx]);
    }
    async sendTransaction(tx) {
        // This cannot be mined any earlier than any recent block
        const blockNumber = await this.provider.getBlockNumber();
        // Send the transaction
        const hash = await this.sendUncheckedTransaction(tx);
        // Unfortunately, JSON-RPC only provides and opaque transaction hash
        // for a response, and we need the actual transaction, so we poll
        // for it; it should show up very quickly
        return await (new Promise((resolve, reject) => {
            const timeouts = [1000, 100];
            let invalids = 0;
            const checkTx = async () => {
                try {
                    // Try getting the transaction
                    const tx = await this.provider.getTransaction(hash);
                    if (tx != null) {
                        resolve(tx.replaceableTransaction(blockNumber));
                        return;
                    }
                }
                catch (error) {
                    // If we were cancelled: stop polling.
                    // If the data is bad: the node returns bad transactions
                    // If the network changed: calling again will also fail
                    // If unsupported: likely destroyed
                    if ((0, index_js_5.isError)(error, "CANCELLED") || (0, index_js_5.isError)(error, "BAD_DATA") ||
                        (0, index_js_5.isError)(error, "NETWORK_ERROR" || 0)) {
                        if (error.info == null) {
                            error.info = {};
                        }
                        error.info.sendTransactionHash = hash;
                        reject(error);
                        return;
                    }
                    // Stop-gap for misbehaving backends; see #4513
                    if ((0, index_js_5.isError)(error, "INVALID_ARGUMENT")) {
                        invalids++;
                        if (error.info == null) {
                            error.info = {};
                        }
                        error.info.sendTransactionHash = hash;
                        if (invalids > 10) {
                            reject(error);
                            return;
                        }
                    }
                    // Notify anyone that cares; but we will try again, since
                    // it is likely an intermittent service error
                    this.provider.emit("error", (0, index_js_5.makeError)("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
                }
                // Wait another 4 seconds
                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);
            };
            checkTx();
        }));
    }
    async signTransaction(_tx) {
        const tx = deepCopy(_tx);
        // Make sure the from matches the sender
        if (tx.from) {
            const from = await (0, index_js_2.resolveAddress)(tx.from, this.provider);
            (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from;
        }
        else {
            tx.from = this.address;
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return await this.provider.send("eth_signTransaction", [hexTx]);
    }
    async signMessage(_message) {
        const message = ((typeof (_message) === "string") ? (0, index_js_5.toUtf8Bytes)(_message) : _message);
        return await this.provider.send("personal_sign", [
            (0, index_js_5.hexlify)(message), this.address.toLowerCase()
        ]);
    }
    async signTypedData(domain, types, _value) {
        const value = deepCopy(_value);
        // Populate any ENS names (in-place)
        const populated = await index_js_3.TypedDataEncoder.resolveNames(domain, types, value, async (value) => {
            const address = await (0, index_js_2.resolveAddress)(value);
            (0, index_js_5.assertArgument)(address != null, "TypedData does not support null address", "value", value);
            return address;
        });
        return await this.provider.send("eth_signTypedData_v4", [
            this.address.toLowerCase(),
            JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
    }
    async unlock(password) {
        return this.provider.send("personal_unlockAccount", [
            this.address.toLowerCase(), password, null
        ]);
    }
    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
    async _legacySignMessage(_message) {
        const message = ((typeof (_message) === "string") ? (0, index_js_5.toUtf8Bytes)(_message) : _message);
        return await this.provider.send("eth_sign", [
            this.address.toLowerCase(), (0, index_js_5.hexlify)(message)
        ]);
    }
}
exports.JsonRpcSigner = JsonRpcSigner;
/**
 *  The JsonRpcApiProvider is an abstract class and **MUST** be
 *  sub-classed.
 *
 *  It provides the base for all JSON-RPC-based Provider interaction.
 *
 *  Sub-classing Notes:
 *  - a sub-class MUST override _send
 *  - a sub-class MUST call the `_start()` method once connected
 */
class JsonRpcApiProvider extends abstract_provider_js_1.AbstractProvider {
    #options;
    // The next ID to use for the JSON-RPC ID field
    #nextId;
    // Payloads are queued and triggered in batches using the drainTimer
    #payloads;
    #drainTimer;
    #notReady;
    #network;
    #pendingDetectNetwork;
    #scheduleDrain() {
        if (this.#drainTimer) {
            return;
        }
        // If we aren't using batching, no harm in sending it immediately
        const stallTime = (this._getOption("batchMaxCount") === 1) ? 0 : this._getOption("batchStallTime");
        this.#drainTimer = setTimeout(() => {
            this.#drainTimer = null;
            const payloads = this.#payloads;
            this.#payloads = [];
            while (payloads.length) {
                // Create payload batches that satisfy our batch constraints
                const batch = [(payloads.shift())];
                while (payloads.length) {
                    if (batch.length === this.#options.batchMaxCount) {
                        break;
                    }
                    batch.push((payloads.shift()));
                    const bytes = JSON.stringify(batch.map((p) => p.payload));
                    if (bytes.length > this.#options.batchMaxSize) {
                        payloads.unshift((batch.pop()));
                        break;
                    }
                }
                // Process the result to each payload
                (async () => {
                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));
                    this.emit("debug", { action: "sendRpcPayload", payload });
                    try {
                        const result = await this._send(payload);
                        this.emit("debug", { action: "receiveRpcResult", result });
                        // Process results in batch order
                        for (const { resolve, reject, payload } of batch) {
                            if (this.destroyed) {
                                reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
                                continue;
                            }
                            // Find the matching result
                            const resp = result.filter((r) => (r.id === payload.id))[0];
                            // No result; the node failed us in unexpected ways
                            if (resp == null) {
                                const error = (0, index_js_5.makeError)("missing response for request", "BAD_DATA", {
                                    value: result, info: { payload }
                                });
                                this.emit("error", error);
                                reject(error);
                                continue;
                            }
                            // The response is an error
                            if ("error" in resp) {
                                reject(this.getRpcError(payload, resp));
                                continue;
                            }
                            // All good; send the result
                            resolve(resp.result);
                        }
                    }
                    catch (error) {
                        this.emit("debug", { action: "receiveRpcError", error });
                        for (const { reject } of batch) {
                            // @TODO: augment the error with the payload
                            reject(error);
                        }
                    }
                })();
            }
        }, stallTime);
    }
    constructor(network, options) {
        super(network, options);
        this.#nextId = 1;
        this.#options = Object.assign({}, defaultOptions, options || {});
        this.#payloads = [];
        this.#drainTimer = null;
        this.#network = null;
        this.#pendingDetectNetwork = null;
        {
            let resolve = null;
            const promise = new Promise((_resolve) => {
                resolve = _resolve;
            });
            this.#notReady = { promise, resolve };
        }
        const staticNetwork = this._getOption("staticNetwork");
        if (typeof (staticNetwork) === "boolean") {
            (0, index_js_5.assertArgument)(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
            if (staticNetwork && network != null) {
                this.#network = network_js_1.Network.from(network);
            }
        }
        else if (staticNetwork) {
            // Make sure any static network is compatbile with the provided netwrok
            (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
            this.#network = staticNetwork;
        }
    }
    /**
     *  Returns the value associated with the option %%key%%.
     *
     *  Sub-classes can use this to inquire about configuration options.
     */
    _getOption(key) {
        return this.#options[key];
    }
    /**
     *  Gets the [[Network]] this provider has committed to. On each call, the network
     *  is detected, and if it has changed, the call will reject.
     */
    get _network() {
        (0, index_js_5.assert)(this.#network, "network is not available yet", "NETWORK_ERROR");
        return this.#network;
    }
    /**
     *  Resolves to the non-normalized value by performing %%req%%.
     *
     *  Sub-classes may override this to modify behavior of actions,
     *  and should generally call ``super._perform`` as a fallback.
     */
    async _perform(req) {
        // Legacy networks do not like the type field being passed along (which
        // is fair), so we delete type if it is 0 and a non-EIP-1559 network
        if (req.method === "call" || req.method === "estimateGas") {
            let tx = req.transaction;
            if (tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type)) {
                // If there are no EIP-1559 properties, it might be non-EIP-a559
                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                    const feeData = await this.getFeeData();
                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                        // Network doesn't know about EIP-1559 (and hence type)
                        req = Object.assign({}, req, {
                            transaction: Object.assign({}, tx, { type: undefined })
                        });
                    }
                }
            }
        }
        const request = this.getRpcRequest(req);
        if (request != null) {
            return await this.send(request.method, request.args);
        }
        return super._perform(req);
    }
    /**
     *  Sub-classes may override this; it detects the *actual* network that
     *  we are **currently** connected to.
     *
     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
     *  _send primitive must be used instead.
     */
    async _detectNetwork() {
        const network = this._getOption("staticNetwork");
        if (network) {
            if (network === true) {
                if (this.#network) {
                    return this.#network;
                }
            }
            else {
                return network;
            }
        }
        if (this.#pendingDetectNetwork) {
            return await this.#pendingDetectNetwork;
        }
        // If we are ready, use ``send``, which enabled requests to be batched
        if (this.ready) {
            this.#pendingDetectNetwork = (async () => {
                try {
                    const result = network_js_1.Network.from((0, index_js_5.getBigInt)(await this.send("eth_chainId", [])));
                    this.#pendingDetectNetwork = null;
                    return result;
                }
                catch (error) {
                    this.#pendingDetectNetwork = null;
                    throw error;
                }
            })();
            return await this.#pendingDetectNetwork;
        }
        // We are not ready yet; use the primitive _send
        this.#pendingDetectNetwork = (async () => {
            const payload = {
                id: this.#nextId++, method: "eth_chainId", params: [], jsonrpc: "2.0"
            };
            this.emit("debug", { action: "sendRpcPayload", payload });
            let result;
            try {
                result = (await this._send(payload))[0];
                this.#pendingDetectNetwork = null;
            }
            catch (error) {
                this.#pendingDetectNetwork = null;
                this.emit("debug", { action: "receiveRpcError", error });
                throw error;
            }
            this.emit("debug", { action: "receiveRpcResult", result });
            if ("result" in result) {
                return network_js_1.Network.from((0, index_js_5.getBigInt)(result.result));
            }
            throw this.getRpcError(payload, result);
        })();
        return await this.#pendingDetectNetwork;
    }
    /**
     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
     *  will be passed to [[_send]] from [[send]]. If it is overridden, then
     *  ``super._start()`` **MUST** be called.
     *
     *  Calling it multiple times is safe and has no effect.
     */
    _start() {
        if (this.#notReady == null || this.#notReady.resolve == null) {
            return;
        }
        this.#notReady.resolve();
        this.#notReady = null;
        (async () => {
            // Bootstrap the network
            while (this.#network == null && !this.destroyed) {
                try {
                    this.#network = await this._detectNetwork();
                }
                catch (error) {
                    if (this.destroyed) {
                        break;
                    }
                    console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
                    this.emit("error", (0, index_js_5.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
                    await stall(1000);
                }
            }
            // Start dispatching requests
            this.#scheduleDrain();
        })();
    }
    /**
     *  Resolves once the [[_start]] has been called. This can be used in
     *  sub-classes to defer sending data until the connection has been
     *  established.
     */
    async _waitUntilReady() {
        if (this.#notReady == null) {
            return;
        }
        return await this.#notReady.promise;
    }
    /**
     *  Return a Subscriber that will manage the %%sub%%.
     *
     *  Sub-classes may override this to modify the behavior of
     *  subscription management.
     */
    _getSubscriber(sub) {
        // Pending Filters aren't availble via polling
        if (sub.type === "pending") {
            return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);
        }
        if (sub.type === "event") {
            if (this._getOption("polling")) {
                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
            }
            return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);
        }
        // Orphaned Logs are handled automatically, by the filter, since
        // logs with removed are emitted by it
        if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
            return new abstract_provider_js_1.UnmanagedSubscriber("orphan");
        }
        return super._getSubscriber(sub);
    }
    /**
     *  Returns true only if the [[_start]] has been called.
     */
    get ready() { return this.#notReady == null; }
    /**
     *  Returns %%tx%% as a normalized JSON-RPC transaction request,
     *  which has all values hexlified and any numeric values converted
     *  to Quantity values.
     */
    getRpcTransaction(tx) {
        const result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            let dstKey = key;
            if (key === "gasLimit") {
                dstKey = "gas";
            }
            result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], `tx.${key}`));
        });
        // Make sure addresses and data are lowercase
        ["from", "to", "data"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            result[key] = (0, index_js_5.hexlify)(tx[key]);
        });
        // Normalize the access list object
        if (tx.accessList) {
            result["accessList"] = (0, index_js_4.accessListify)(tx.accessList);
        }
        return result;
    }
    /**
     *  Returns the request method and arguments required to perform
     *  %%req%%.
     */
    getRpcRequest(req) {
        switch (req.method) {
            case "chainId":
                return { method: "eth_chainId", args: [] };
            case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
            case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
            case "getPriorityFee":
                return { method: "eth_maxPriorityFeePerGas", args: [] };
            case "getBalance":
                return {
                    method: "eth_getBalance",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getTransactionCount":
                return {
                    method: "eth_getTransactionCount",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getCode":
                return {
                    method: "eth_getCode",
                    args: [getLowerCase(req.address), req.blockTag]
                };
            case "getStorage":
                return {
                    method: "eth_getStorageAt",
                    args: [
                        getLowerCase(req.address),
                        ("0x" + req.position.toString(16)),
                        req.blockTag
                    ]
                };
            case "broadcastTransaction":
                return {
                    method: "eth_sendRawTransaction",
                    args: [req.signedTransaction]
                };
            case "getBlock":
                if ("blockTag" in req) {
                    return {
                        method: "eth_getBlockByNumber",
                        args: [req.blockTag, !!req.includeTransactions]
                    };
                }
                else if ("blockHash" in req) {
                    return {
                        method: "eth_getBlockByHash",
                        args: [req.blockHash, !!req.includeTransactions]
                    };
                }
                break;
            case "getTransaction":
                return {
                    method: "eth_getTransactionByHash",
                    args: [req.hash]
                };
            case "getTransactionReceipt":
                return {
                    method: "eth_getTransactionReceipt",
                    args: [req.hash]
                };
            case "call":
                return {
                    method: "eth_call",
                    args: [this.getRpcTransaction(req.transaction), req.blockTag]
                };
            case "estimateGas": {
                return {
                    method: "eth_estimateGas",
                    args: [this.getRpcTransaction(req.transaction)]
                };
            }
            case "getLogs":
                if (req.filter && req.filter.address != null) {
                    if (Array.isArray(req.filter.address)) {
                        req.filter.address = req.filter.address.map(getLowerCase);
                    }
                    else {
                        req.filter.address = getLowerCase(req.filter.address);
                    }
                }
                return { method: "eth_getLogs", args: [req.filter] };
        }
        return null;
    }
    /**
     *  Returns an ethers-style Error for the given JSON-RPC error
     *  %%payload%%, coalescing the various strings and error shapes
     *  that different nodes return, coercing them into a machine-readable
     *  standardized error.
     */
    getRpcError(payload, _error) {
        const { method } = payload;
        const { error } = _error;
        if (method === "eth_estimateGas" && error.message) {
            const msg = error.message;
            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
                return (0, index_js_5.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
                    transaction: (payload.params[0]),
                    info: { payload, error }
                });
            }
        }
        if (method === "eth_call" || method === "eth_estimateGas") {
            const result = spelunkData(error);
            const e = index_js_1.AbiCoder.getBuiltinCallException((method === "eth_call") ? "call" : "estimateGas", (payload.params[0]), (result ? result.data : null));
            e.info = { error, payload };
            return e;
        }
        // Only estimateGas and call can return arbitrary contract-defined text, so now we
        // we can process text safely.
        const message = JSON.stringify(spelunkMessage(error));
        if (typeof (error.message) === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
            const actionMap = {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess",
            };
            return (0, index_js_5.makeError)(`user rejected action`, "ACTION_REJECTED", {
                action: (actionMap[method] || "unknown"),
                reason: "rejected",
                info: { payload, error }
            });
        }
        if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
            const transaction = (payload.params[0]);
            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
                return (0, index_js_5.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                    transaction, info: { error }
                });
            }
            if (message.match(/nonce/i) && message.match(/too low/i)) {
                return (0, index_js_5.makeError)("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
            }
            // "replacement transaction underpriced"
            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
                return (0, index_js_5.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
            }
            if (message.match(/only replay-protected/i)) {
                return (0, index_js_5.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                    operation: method, info: { transaction, info: { error } }
                });
            }
        }
        let unsupported = !!message.match(/the method .* does not exist/i);
        if (!unsupported) {
            if (error && error.details && error.details.startsWith("Unauthorized method:")) {
                unsupported = true;
            }
        }
        if (unsupported) {
            return (0, index_js_5.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
                operation: payload.method, info: { error, payload }
            });
        }
        return (0, index_js_5.makeError)("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
    }
    /**
     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
     *  over the underlying channel. This can be used to call methods
     *  on the backend that do not have a high-level API within the Provider
     *  API.
     *
     *  This method queues requests according to the batch constraints
     *  in the options, assigns the request a unique ID.
     *
     *  **Do NOT override** this method in sub-classes; instead
     *  override [[_send]] or force the options values in the
     *  call to the constructor to modify this method's behavior.
     */
    send(method, params) {
        // @TODO: cache chainId?? purge on switch_networks
        // We have been destroyed; no operations are supported anymore
        if (this.destroyed) {
            return Promise.reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
        }
        const id = this.#nextId++;
        const promise = new Promise((resolve, reject) => {
            this.#payloads.push({
                resolve, reject,
                payload: { method, params, id, jsonrpc: "2.0" }
            });
        });
        // If there is not a pending drainTimer, set one
        this.#scheduleDrain();
        return promise;
    }
    /**
     *  Resolves to the [[Signer]] account for  %%address%% managed by
     *  the client.
     *
     *  If the %%address%% is a number, it is used as an index in the
     *  the accounts from [[listAccounts]].
     *
     *  This can only be used on clients which manage accounts (such as
     *  Geth with imported account or MetaMask).
     *
     *  Throws if the account doesn't exist.
     */
    async getSigner(address) {
        if (address == null) {
            address = 0;
        }
        const accountsPromise = this.send("eth_accounts", []);
        // Account index
        if (typeof (address) === "number") {
            const accounts = (await accountsPromise);
            if (address >= accounts.length) {
                throw new Error("no such account");
            }
            return new JsonRpcSigner(this, accounts[address]);
        }
        const { accounts } = await (0, index_js_5.resolveProperties)({
            network: this.getNetwork(),
            accounts: accountsPromise
        });
        // Account address
        address = (0, index_js_2.getAddress)(address);
        for (const account of accounts) {
            if ((0, index_js_2.getAddress)(account) === address) {
                return new JsonRpcSigner(this, address);
            }
        }
        throw new Error("invalid account");
    }
    async listAccounts() {
        const accounts = await this.send("eth_accounts", []);
        return accounts.map((a) => new JsonRpcSigner(this, a));
    }
    destroy() {
        // Stop processing requests
        if (this.#drainTimer) {
            clearTimeout(this.#drainTimer);
            this.#drainTimer = null;
        }
        // Cancel all pending requests
        for (const { payload, reject } of this.#payloads) {
            reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
        }
        this.#payloads = [];
        // Parent clean-up
        super.destroy();
    }
}
exports.JsonRpcApiProvider = JsonRpcApiProvider;
// @TODO: remove this in v7, it is not exported because this functionality
// is exposed in the JsonRpcApiProvider by setting polling to true. It should
// be safe to remove regardless, because it isn't reachable, but just in case.
/**
 *  @_ignore:
 */
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
    #pollingInterval;
    constructor(network, options) {
        super(network, options);
        let pollingInterval = this._getOption("pollingInterval");
        if (pollingInterval == null) {
            pollingInterval = defaultOptions.pollingInterval;
        }
        this.#pollingInterval = pollingInterval;
    }
    _getSubscriber(sub) {
        const subscriber = super._getSubscriber(sub);
        if (isPollable(subscriber)) {
            subscriber.pollingInterval = this.#pollingInterval;
        }
        return subscriber;
    }
    /**
     *  The polling interval (default: 4000 ms)
     */
    get pollingInterval() { return this.#pollingInterval; }
    set pollingInterval(value) {
        if (!Number.isInteger(value) || value < 0) {
            throw new Error("invalid interval");
        }
        this.#pollingInterval = value;
        this._forEachSubscriber((sub) => {
            if (isPollable(sub)) {
                sub.pollingInterval = this.#pollingInterval;
            }
        });
    }
}
exports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;
/**
 *  The JsonRpcProvider is one of the most common Providers,
 *  which performs all operations over HTTP (or HTTPS) requests.
 *
 *  Events are processed by polling the backend for the current block
 *  number; when it advances, all block-base events are then checked
 *  for updates.
 */
class JsonRpcProvider extends JsonRpcApiPollingProvider {
    #connect;
    constructor(url, network, options) {
        if (url == null) {
            url = "http:/\/localhost:8545";
        }
        super(network, options);
        if (typeof (url) === "string") {
            this.#connect = new index_js_5.FetchRequest(url);
        }
        else {
            this.#connect = url.clone();
        }
    }
    _getConnection() {
        return this.#connect.clone();
    }
    async send(method, params) {
        // All requests are over HTTP, so we can just start handling requests
        // We do this here rather than the constructor so that we don't send any
        // requests to the network (i.e. eth_chainId) until we absolutely have to.
        await this._start();
        return await super.send(method, params);
    }
    async _send(payload) {
        // Configure a POST connection for the requested method
        const request = this._getConnection();
        request.body = JSON.stringify(payload);
        request.setHeader("content-type", "application/json");
        const response = await request.send();
        response.assertOk();
        let resp = response.bodyJson;
        if (!Array.isArray(resp)) {
            resp = [resp];
        }
        return resp;
    }
}
exports.JsonRpcProvider = JsonRpcProvider;
function spelunkData(value) {
    if (value == null) {
        return null;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {
        return { message: value.message, data: value.data };
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (const key in value) {
            const result = spelunkData(value[key]);
            if (result) {
                return result;
            }
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return spelunkData(JSON.parse(value));
        }
        catch (error) { }
    }
    return null;
}
function _spelunkMessage(value, result) {
    if (value == null) {
        return;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string") {
        result.push(value.message);
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (const key in value) {
            _spelunkMessage(value[key], result);
        }
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return _spelunkMessage(JSON.parse(value), result);
        }
        catch (error) { }
    }
}
function spelunkMessage(value) {
    const result = [];
    _spelunkMessage(value, result);
    return result;
}
//# sourceMappingURL=provider-jsonrpc.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-pocket.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-pocket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PocketProvider = void 0;
/**
 *  [[link-pocket]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Polygon (``matic``)
 *  - Arbitrum (``arbitrum``)
 *
 *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]
 */
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "eth-mainnet.gateway.pokt.network";
        case "goerli":
            return "eth-goerli.gateway.pokt.network";
        case "matic":
            return "poly-mainnet.gateway.pokt.network";
        case "matic-mumbai":
            return "polygon-mumbai-rpc.gateway.pokt.network";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **PocketProvider** connects to the [[link-pocket]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-pocket-signup).
 */
class PocketProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    /**
     *  The Application ID for the Pocket connection.
     */
    applicationId;
    /**
     *  The Application Secret for making authenticated requests
     *  to the Pocket connection.
     */
    applicationSecret;
    /**
     *  Create a new **PocketProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    constructor(_network, applicationId, applicationSecret) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (applicationId == null) {
            applicationId = defaultApplicationId;
        }
        if (applicationSecret == null) {
            applicationSecret = null;
        }
        const options = { staticNetwork: network };
        const request = PocketProvider.getRequest(network, applicationId, applicationSecret);
        super(request, network, options);
        (0, index_js_1.defineProperties)(this, { applicationId, applicationSecret });
    }
    _getProvider(chainId) {
        try {
            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%applicationId%%.
     */
    static getRequest(network, applicationId, applicationSecret) {
        if (applicationId == null) {
            applicationId = defaultApplicationId;
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v1/lb/${applicationId}`);
        request.allowGzip = true;
        if (applicationSecret) {
            request.setCredentials("", applicationSecret);
        }
        if (applicationId === defaultApplicationId) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("PocketProvider");
                return true;
            };
        }
        return request;
    }
    isCommunityResource() {
        return (this.applicationId === defaultApplicationId);
    }
}
exports.PocketProvider = PocketProvider;
//# sourceMappingURL=provider-pocket.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-quicknode.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-quicknode.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  [[link-quicknode]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Holesky Testnet (``holesky``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base Mainnet (``base``);
 *  - Base Goerli Testnet (``base-goerli``);
 *  - Base Sepolia Testnet (``base-sepolia``);
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickNodeProvider = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const community_js_1 = __webpack_require__(/*! ./community.js */ "../node_modules/ethers/lib.commonjs/providers/community.js");
const network_js_1 = __webpack_require__(/*! ./network.js */ "../node_modules/ethers/lib.commonjs/providers/network.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
const defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost(name) {
    switch (name) {
        case "mainnet":
            return "ethers.quiknode.pro";
        case "goerli":
            return "ethers.ethereum-goerli.quiknode.pro";
        case "sepolia":
            return "ethers.ethereum-sepolia.quiknode.pro";
        case "holesky":
            return "ethers.ethereum-holesky.quiknode.pro";
        case "arbitrum":
            return "ethers.arbitrum-mainnet.quiknode.pro";
        case "arbitrum-goerli":
            return "ethers.arbitrum-goerli.quiknode.pro";
        case "arbitrum-sepolia":
            return "ethers.arbitrum-sepolia.quiknode.pro";
        case "base":
            return "ethers.base-mainnet.quiknode.pro";
        case "base-goerli":
            return "ethers.base-goerli.quiknode.pro";
        case "base-spolia":
            return "ethers.base-sepolia.quiknode.pro";
        case "bnb":
            return "ethers.bsc.quiknode.pro";
        case "bnbt":
            return "ethers.bsc-testnet.quiknode.pro";
        case "matic":
            return "ethers.matic.quiknode.pro";
        case "matic-mumbai":
            return "ethers.matic-testnet.quiknode.pro";
        case "optimism":
            return "ethers.optimism.quiknode.pro";
        case "optimism-goerli":
            return "ethers.optimism-goerli.quiknode.pro";
        case "optimism-sepolia":
            return "ethers.optimism-sepolia.quiknode.pro";
        case "xdai":
            return "ethers.xdai.quiknode.pro";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/*
@TODO:
  These networks are not currently present in the Network
  default included networks. Research them and ensure they
  are EVM compatible and work with ethers

  http://ethers.matic-amoy.quiknode.pro

  http://ethers.avalanche-mainnet.quiknode.pro
  http://ethers.avalanche-testnet.quiknode.pro
  http://ethers.blast-sepolia.quiknode.pro
  http://ethers.celo-mainnet.quiknode.pro
  http://ethers.fantom.quiknode.pro
  http://ethers.imx-demo.quiknode.pro
  http://ethers.imx-mainnet.quiknode.pro
  http://ethers.imx-testnet.quiknode.pro
  http://ethers.near-mainnet.quiknode.pro
  http://ethers.near-testnet.quiknode.pro
  http://ethers.nova-mainnet.quiknode.pro
  http://ethers.scroll-mainnet.quiknode.pro
  http://ethers.scroll-testnet.quiknode.pro
  http://ethers.tron-mainnet.quiknode.pro
  http://ethers.zkevm-mainnet.quiknode.pro
  http://ethers.zkevm-testnet.quiknode.pro
  http://ethers.zksync-mainnet.quiknode.pro
  http://ethers.zksync-testnet.quiknode.pro
*/
/**
 *  The **QuickNodeProvider** connects to the [[link-quicknode]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API token is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-quicknode).
 */
class QuickNodeProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
    /**
     *  The API token.
     */
    token;
    /**
     *  Creates a new **QuickNodeProvider**.
     */
    constructor(_network, token) {
        if (_network == null) {
            _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (token == null) {
            token = defaultToken;
        }
        const request = QuickNodeProvider.getRequest(network, token);
        super(request, network, { staticNetwork: network });
        (0, index_js_1.defineProperties)(this, { token });
    }
    _getProvider(chainId) {
        try {
            return new QuickNodeProvider(chainId, this.token);
        }
        catch (error) { }
        return super._getProvider(chainId);
    }
    isCommunityResource() {
        return (this.token === defaultToken);
    }
    /**
     *  Returns a new request prepared for %%network%% and the
     *  %%token%%.
     */
    static getRequest(network, token) {
        if (token == null) {
            token = defaultToken;
        }
        const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/${token}`);
        request.allowGzip = true;
        //if (projectSecret) { request.setCredentials("", projectSecret); }
        if (token === defaultToken) {
            request.retryFunc = async (request, response, attempt) => {
                (0, community_js_1.showThrottleMessage)("QuickNodeProvider");
                return true;
            };
        }
        return request;
    }
}
exports.QuickNodeProvider = QuickNodeProvider;
//# sourceMappingURL=provider-quicknode.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-socket.js":
/*!************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-socket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Generic long-lived socket provider.
 *
 *  Sub-classing notes
 *  - a sub-class MUST call the `_start()` method once connected
 *  - a sub-class MUST override the `_write(string)` method
 *  - a sub-class MUST call `_processMessage(string)` for each message
 *
 *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;
const abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-provider.js");
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ "../node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js");
/**
 *  A **SocketSubscriber** uses a socket transport to handle events and
 *  should use [[_emit]] to manage the events.
 */
class SocketSubscriber {
    #provider;
    #filter;
    /**
     *  The filter.
     */
    get filter() { return JSON.parse(this.#filter); }
    #filterId;
    #paused;
    #emitPromise;
    /**
     *  Creates a new **SocketSubscriber** attached to %%provider%% listening
     *  to %%filter%%.
     */
    constructor(provider, filter) {
        this.#provider = provider;
        this.#filter = JSON.stringify(filter);
        this.#filterId = null;
        this.#paused = null;
        this.#emitPromise = null;
    }
    start() {
        this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
            ;
            this.#provider._register(filterId, this);
            return filterId;
        });
    }
    stop() {
        (this.#filterId).then((filterId) => {
            if (this.#provider.destroyed) {
                return;
            }
            this.#provider.send("eth_unsubscribe", [filterId]);
        });
        this.#filterId = null;
    }
    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
    //        and resume
    pause(dropWhilePaused) {
        (0, index_js_1.assert)(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
        this.#paused = !!dropWhilePaused;
    }
    resume() {
        this.#paused = null;
    }
    /**
     *  @_ignore:
     */
    _handleMessage(message) {
        if (this.#filterId == null) {
            return;
        }
        if (this.#paused === null) {
            let emitPromise = this.#emitPromise;
            if (emitPromise == null) {
                emitPromise = this._emit(this.#provider, message);
            }
            else {
                emitPromise = emitPromise.then(async () => {
                    await this._emit(this.#provider, message);
                });
            }
            this.#emitPromise = emitPromise.then(() => {
                if (this.#emitPromise === emitPromise) {
                    this.#emitPromise = null;
                }
            });
        }
    }
    /**
     *  Sub-classes **must** override this to emit the events on the
     *  provider.
     */
    async _emit(provider, message) {
        throw new Error("sub-classes must implemente this; _emit");
    }
}
exports.SocketSubscriber = SocketSubscriber;
/**
 *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits
 *  ``"block"`` events.
 */
class SocketBlockSubscriber extends SocketSubscriber {
    /**
     *  @_ignore:
     */
    constructor(provider) {
        super(provider, ["newHeads"]);
    }
    async _emit(provider, message) {
        provider.emit("block", parseInt(message.number));
    }
}
exports.SocketBlockSubscriber = SocketBlockSubscriber;
/**
 *  A **SocketPendingSubscriber** listens for pending transacitons and emits
 *  ``"pending"`` events.
 */
class SocketPendingSubscriber extends SocketSubscriber {
    /**
     *  @_ignore:
     */
    constructor(provider) {
        super(provider, ["newPendingTransactions"]);
    }
    async _emit(provider, message) {
        provider.emit("pending", message);
    }
}
exports.SocketPendingSubscriber = SocketPendingSubscriber;
/**
 *  A **SocketEventSubscriber** listens for event logs.
 */
class SocketEventSubscriber extends SocketSubscriber {
    #logFilter;
    /**
     *  The filter.
     */
    get logFilter() { return JSON.parse(this.#logFilter); }
    /**
     *  @_ignore:
     */
    constructor(provider, filter) {
        super(provider, ["logs", filter]);
        this.#logFilter = JSON.stringify(filter);
    }
    async _emit(provider, message) {
        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
    }
}
exports.SocketEventSubscriber = SocketEventSubscriber;
/**
 *  A **SocketProvider** is backed by a long-lived connection over a
 *  socket, which can subscribe and receive real-time messages over
 *  its communication channel.
 */
class SocketProvider extends provider_jsonrpc_js_1.JsonRpcApiProvider {
    #callbacks;
    // Maps each filterId to its subscriber
    #subs;
    // If any events come in before a subscriber has finished
    // registering, queue them
    #pending;
    /**
     *  Creates a new **SocketProvider** connected to %%network%%.
     *
     *  If unspecified, the network will be discovered.
     */
    constructor(network, _options) {
        // Copy the options
        const options = Object.assign({}, (_options != null) ? _options : {});
        // Support for batches is generally not supported for
        // connection-base providers; if this changes in the future
        // the _send should be updated to reflect this
        (0, index_js_1.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
        options.batchMaxCount = 1;
        // Socket-based Providers (generally) cannot change their network,
        // since they have a long-lived connection; but let people override
        // this if they have just cause.
        if (options.staticNetwork == null) {
            options.staticNetwork = true;
        }
        super(network, options);
        this.#callbacks = new Map();
        this.#subs = new Map();
        this.#pending = new Map();
    }
    // This value is only valid after _start has been called
    /*
    get _network(): Network {
        if (this.#network == null) {
            throw new Error("this shouldn't happen");
        }
        return this.#network.clone();
    }
    */
    _getSubscriber(sub) {
        switch (sub.type) {
            case "close":
                return new abstract_provider_js_1.UnmanagedSubscriber("close");
            case "block":
                return new SocketBlockSubscriber(this);
            case "pending":
                return new SocketPendingSubscriber(this);
            case "event":
                return new SocketEventSubscriber(this, sub.filter);
            case "orphan":
                // Handled auto-matically within AbstractProvider
                // when the log.removed = true
                if (sub.filter.orphan === "drop-log") {
                    return new abstract_provider_js_1.UnmanagedSubscriber("drop-log");
                }
        }
        return super._getSubscriber(sub);
    }
    /**
     *  Register a new subscriber. This is used internalled by Subscribers
     *  and generally is unecessary unless extending capabilities.
     */
    _register(filterId, subscriber) {
        this.#subs.set(filterId, subscriber);
        const pending = this.#pending.get(filterId);
        if (pending) {
            for (const message of pending) {
                subscriber._handleMessage(message);
            }
            this.#pending.delete(filterId);
        }
    }
    async _send(payload) {
        // WebSocket provider doesn't accept batches
        (0, index_js_1.assertArgument)(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
        // @TODO: stringify payloads here and store to prevent mutations
        // Prepare a promise to respond to
        const promise = new Promise((resolve, reject) => {
            this.#callbacks.set(payload.id, { payload, resolve, reject });
        });
        // Wait until the socket is connected before writing to it
        await this._waitUntilReady();
        // Write the request to the socket
        await this._write(JSON.stringify(payload));
        return [await promise];
    }
    // Sub-classes must call this once they are connected
    /*
    async _start(): Promise<void> {
        if (this.#ready) { return; }

        for (const { payload } of this.#callbacks.values()) {
            await this._write(JSON.stringify(payload));
        }

        this.#ready = (async function() {
            await super._start();
        })();
    }
    */
    /**
     *  Sub-classes **must** call this with messages received over their
     *  transport to be processed and dispatched.
     */
    async _processMessage(message) {
        const result = (JSON.parse(message));
        if (result && typeof (result) === "object" && "id" in result) {
            const callback = this.#callbacks.get(result.id);
            if (callback == null) {
                this.emit("error", (0, index_js_1.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
                    reasonCode: "UNKNOWN_ID",
                    result
                }));
                return;
            }
            this.#callbacks.delete(result.id);
            callback.resolve(result);
        }
        else if (result && result.method === "eth_subscription") {
            const filterId = result.params.subscription;
            const subscriber = this.#subs.get(filterId);
            if (subscriber) {
                subscriber._handleMessage(result.params.result);
            }
            else {
                let pending = this.#pending.get(filterId);
                if (pending == null) {
                    pending = [];
                    this.#pending.set(filterId, pending);
                }
                pending.push(result.params.result);
            }
        }
        else {
            this.emit("error", (0, index_js_1.makeError)("received unexpected message", "UNKNOWN_ERROR", {
                reasonCode: "UNEXPECTED_MESSAGE",
                result
            }));
            return;
        }
    }
    /**
     *  Sub-classes **must** override this to send %%message%% over their
     *  transport.
     */
    async _write(message) {
        throw new Error("sub-classes must override this");
    }
}
exports.SocketProvider = SocketProvider;
//# sourceMappingURL=provider-socket.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider-websocket.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider-websocket.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketProvider = void 0;
const ws_js_1 = __webpack_require__(/*! ./ws.js */ "../node_modules/ethers/lib.commonjs/providers/ws.js"); /*-browser*/
const provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ "../node_modules/ethers/lib.commonjs/providers/provider-socket.js");
/**
 *  A JSON-RPC provider which is backed by a WebSocket.
 *
 *  WebSockets are often preferred because they retain a live connection
 *  to a server, which permits more instant access to events.
 *
 *  However, this incurs higher server infrasturture costs, so additional
 *  resources may be required to host your own WebSocket nodes and many
 *  third-party services charge additional fees for WebSocket endpoints.
 */
class WebSocketProvider extends provider_socket_js_1.SocketProvider {
    #connect;
    #websocket;
    get websocket() {
        if (this.#websocket == null) {
            throw new Error("websocket closed");
        }
        return this.#websocket;
    }
    constructor(url, network, options) {
        super(network, options);
        if (typeof (url) === "string") {
            this.#connect = () => { return new ws_js_1.WebSocket(url); };
            this.#websocket = this.#connect();
        }
        else if (typeof (url) === "function") {
            this.#connect = url;
            this.#websocket = url();
        }
        else {
            this.#connect = null;
            this.#websocket = url;
        }
        this.websocket.onopen = async () => {
            try {
                await this._start();
                this.resume();
            }
            catch (error) {
                console.log("failed to start WebsocketProvider", error);
                // @TODO: now what? Attempt reconnect?
            }
        };
        this.websocket.onmessage = (message) => {
            this._processMessage(message.data);
        };
        /*
                this.websocket.onclose = (event) => {
                    // @TODO: What event.code should we reconnect on?
                    const reconnect = false;
                    if (reconnect) {
                        this.pause(true);
                        if (this.#connect) {
                            this.#websocket = this.#connect();
                            this.#websocket.onopen = ...
                            // @TODO: this requires the super class to rebroadcast; move it there
                        }
                        this._reconnect();
                    }
                };
        */
    }
    async _write(message) {
        this.websocket.send(message);
    }
    async destroy() {
        if (this.#websocket != null) {
            this.#websocket.close();
            this.#websocket = null;
        }
        super.destroy();
    }
}
exports.WebSocketProvider = WebSocketProvider;
//# sourceMappingURL=provider-websocket.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/provider.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/provider.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;
//import { resolveAddress } from "@ethersproject/address";
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const index_js_2 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const BN_0 = BigInt(0);
// -----------------------
function getValue(value) {
    if (value == null) {
        return null;
    }
    return value;
}
function toJson(value) {
    if (value == null) {
        return null;
    }
    return value.toString();
}
// @TODO? <T extends FeeData = { }> implements Required<T>
/**
 *  A **FeeData** wraps all the fee-related values associated with
 *  the network.
 */
class FeeData {
    /**
     *  The gas price for legacy networks.
     */
    gasPrice;
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    maxFeePerGas;
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    maxPriorityFeePerGas;
    /**
     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
     *  %%maxPriorityFeePerGas%%.
     */
    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
        (0, index_js_1.defineProperties)(this, {
            gasPrice: getValue(gasPrice),
            maxFeePerGas: getValue(maxFeePerGas),
            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
        });
    }
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON() {
        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
        return {
            _type: "FeeData",
            gasPrice: toJson(gasPrice),
            maxFeePerGas: toJson(maxFeePerGas),
            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),
        };
    }
}
exports.FeeData = FeeData;
;
/**
 *  Returns a copy of %%req%% with all properties coerced to their strict
 *  types.
 */
function copyRequest(req) {
    const result = {};
    // These could be addresses, ENS names or Addressables
    if (req.to) {
        result.to = req.to;
    }
    if (req.from) {
        result.from = req.from;
    }
    if (req.data) {
        result.data = (0, index_js_1.hexlify)(req.data);
    }
    const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const key of bigIntKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = (0, index_js_1.getBigInt)(req[key], `request.${key}`);
    }
    const numberKeys = "type,nonce".split(/,/);
    for (const key of numberKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = (0, index_js_1.getNumber)(req[key], `request.${key}`);
    }
    if (req.accessList) {
        result.accessList = (0, index_js_2.accessListify)(req.accessList);
    }
    if ("blockTag" in req) {
        result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
        result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
        result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
        result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
        result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
        result.blobs = req.blobs.map((b) => {
            if ((0, index_js_1.isBytesLike)(b)) {
                return (0, index_js_1.hexlify)(b);
            }
            return Object.assign({}, b);
        });
    }
    return result;
}
exports.copyRequest = copyRequest;
/**
 *  A **Block** represents the data associated with a full block on
 *  Ethereum.
 */
class Block {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    number;
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    hash;
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    timestamp;
    /**
     *  The block hash of the parent block.
     */
    parentHash;
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    parentBeaconBlockRoot;
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    nonce;
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    difficulty;
    /**
     *  The total gas limit for this block.
     */
    gasLimit;
    /**
     *  The total gas used in this block.
     */
    gasUsed;
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    stateRoot;
    /**
     *  The hash of the transaction receipts trie.
     */
    receiptsRoot;
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    blobGasUsed;
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    excessBlobGas;
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    miner;
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    prevRandao;
    /**
     *  Any extra data the validator wished to include.
     */
    extraData;
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    baseFeePerGas;
    #transactions;
    /**
     *  Create a new **Block** object.
     *
     *  This should generally not be necessary as the unless implementing a
     *  low-level library.
     */
    constructor(block, provider) {
        this.#transactions = block.transactions.map((tx) => {
            if (typeof (tx) !== "string") {
                return new TransactionResponse(tx, provider);
            }
            return tx;
        });
        (0, index_js_1.defineProperties)(this, {
            provider,
            hash: getValue(block.hash),
            number: block.number,
            timestamp: block.timestamp,
            parentHash: block.parentHash,
            parentBeaconBlockRoot: block.parentBeaconBlockRoot,
            nonce: block.nonce,
            difficulty: block.difficulty,
            gasLimit: block.gasLimit,
            gasUsed: block.gasUsed,
            blobGasUsed: block.blobGasUsed,
            excessBlobGas: block.excessBlobGas,
            miner: block.miner,
            prevRandao: getValue(block.prevRandao),
            extraData: block.extraData,
            baseFeePerGas: getValue(block.baseFeePerGas),
            stateRoot: block.stateRoot,
            receiptsRoot: block.receiptsRoot,
        });
    }
    /**
     *  Returns the list of transaction hashes, in the order
     *  they were executed within the block.
     */
    get transactions() {
        return this.#transactions.map((tx) => {
            if (typeof (tx) === "string") {
                return tx;
            }
            return tx.hash;
        });
    }
    /**
     *  Returns the complete transactions, in the order they
     *  were executed within the block.
     *
     *  This is only available for blocks which prefetched
     *  transactions, by passing ``true`` to %%prefetchTxs%%
     *  into [[Provider-getBlock]].
     */
    get prefetchedTransactions() {
        const txs = this.#transactions.slice();
        // Doesn't matter...
        if (txs.length === 0) {
            return [];
        }
        // Make sure we prefetched the transactions
        (0, index_js_1.assert)(typeof (txs[0]) === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
        });
        return txs;
    }
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON() {
        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
        return {
            _type: "Block",
            baseFeePerGas: toJson(baseFeePerGas),
            difficulty: toJson(difficulty),
            extraData,
            gasLimit: toJson(gasLimit),
            gasUsed: toJson(gasUsed),
            blobGasUsed: toJson(this.blobGasUsed),
            excessBlobGas: toJson(this.excessBlobGas),
            hash, miner, prevRandao, nonce, number, parentHash, timestamp,
            parentBeaconBlockRoot, stateRoot, receiptsRoot,
            transactions,
        };
    }
    [Symbol.iterator]() {
        let index = 0;
        const txs = this.transactions;
        return {
            next: () => {
                if (index < this.length) {
                    return {
                        value: txs[index++], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The number of transactions in this block.
     */
    get length() { return this.#transactions.length; }
    /**
     *  The [[link-js-date]] this block was included at.
     */
    get date() {
        if (this.timestamp == null) {
            return null;
        }
        return new Date(this.timestamp * 1000);
    }
    /**
     *  Get the transaction at %%indexe%% within this block.
     */
    async getTransaction(indexOrHash) {
        // Find the internal value by its index or hash
        let tx = undefined;
        if (typeof (indexOrHash) === "number") {
            tx = this.#transactions[indexOrHash];
        }
        else {
            const hash = indexOrHash.toLowerCase();
            for (const v of this.#transactions) {
                if (typeof (v) === "string") {
                    if (v !== hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
                else {
                    if (v.hash === hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
            }
        }
        if (tx == null) {
            throw new Error("no such tx");
        }
        if (typeof (tx) === "string") {
            return (await this.provider.getTransaction(tx));
        }
        else {
            return tx;
        }
    }
    /**
     *  If a **Block** was fetched with a request to include the transactions
     *  this will allow synchronous access to those transactions.
     *
     *  If the transactions were not prefetched, this will throw.
     */
    getPrefetchedTransaction(indexOrHash) {
        const txs = this.prefetchedTransactions;
        if (typeof (indexOrHash) === "number") {
            return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        for (const tx of txs) {
            if (tx.hash === indexOrHash) {
                return tx;
            }
        }
        (0, index_js_1.assertArgument)(false, "no matching transaction", "indexOrHash", indexOrHash);
    }
    /**
     *  Returns true if this block been mined. This provides a type guard
     *  for all properties on a [[MinedBlock]].
     */
    isMined() { return !!this.hash; }
    /**
     *  Returns true if this block is an [[link-eip-2930]] block.
     */
    isLondon() {
        return !!this.baseFeePerGas;
    }
    /**
     *  @_ignore:
     */
    orphanedEvent() {
        if (!this.isMined()) {
            throw new Error("");
        }
        return createOrphanedBlockFilter(this);
    }
}
exports.Block = Block;
//////////////////////
// Log
/**
 *  A **Log** in Ethereum represents an event that has been included in a
 *  transaction using the ``LOG*`` opcodes, which are most commonly used by
 *  Solidity's emit for announcing events.
 */
class Log {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    transactionHash;
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    blockHash;
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    blockNumber;
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    removed;
    /**
     *  The address of the contract that emitted this log.
     */
    address;
    /**
     *  The data included in this log when it was emitted.
     */
    data;
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    topics;
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    index;
    /**
     *  The index within the transaction of this log.
     */
    transactionIndex;
    /**
     *  @_ignore:
     */
    constructor(log, provider) {
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        (0, index_js_1.defineProperties)(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex,
        });
    }
    /**
     *  Returns a JSON-compatible object.
     */
    toJSON() {
        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
        return {
            _type: "log",
            address, blockHash, blockNumber, data, index,
            removed, topics, transactionHash, transactionIndex
        };
    }
    /**
     *  Returns the block that this log occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        (0, index_js_1.assert)(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
        return block;
    }
    /**
     *  Returns the transaction that this log occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        (0, index_js_1.assert)(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
        return tx;
    }
    /**
     *  Returns the transaction receipt fot the transaction that this
     *  log occurred in.
     */
    async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        (0, index_js_1.assert)(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
        return receipt;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedLogFilter(this);
    }
}
exports.Log = Log;
//////////////////////
// Transaction Receipt
/*
export interface LegacyTransactionReceipt {
    byzantium: false;
    status: null;
    root: string;
}

export interface ByzantiumTransactionReceipt {
    byzantium: true;
    status: number;
    root: null;
}
*/
/**
 *  A **TransactionReceipt** includes additional information about a
 *  transaction that is only available after it has been mined.
 */
class TransactionReceipt {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    provider;
    /**
     *  The address the transaction was sent to.
     */
    to;
    /**
     *  The sender of the transaction.
     */
    from;
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    contractAddress;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The index of this transaction within the block transactions.
     */
    index;
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    blockHash;
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    blockNumber;
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    logsBloom;
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    gasUsed;
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    blobGasUsed;
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    cumulativeGasUsed;
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    gasPrice;
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    blobGasPrice;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    type;
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    status;
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    root;
    #logs;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.#logs = Object.freeze(tx.logs.map((log) => {
            return new Log(log, provider);
        }));
        let gasPrice = BN_0;
        if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
        }
        else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
        }
        (0, index_js_1.defineProperties)(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            blobGasUsed: tx.blobGasUsed,
            gasPrice,
            blobGasPrice: tx.blobGasPrice,
            type: tx.type,
            //byzantium: tx.byzantium,
            status: tx.status,
            root: tx.root
        });
    }
    /**
     *  The logs for this transaction.
     */
    get logs() { return this.#logs; }
    /**
     *  Returns a JSON-compatible representation.
     */
    toJSON() {
        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, 
        status, root } = this;
        return {
            _type: "TransactionReceipt",
            blockHash, blockNumber,
            //byzantium, 
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from,
            gasPrice: toJson(this.gasPrice),
            blobGasUsed: toJson(this.blobGasUsed),
            blobGasPrice: toJson(this.blobGasPrice),
            gasUsed: toJson(this.gasUsed),
            hash, index, logs, logsBloom, root, status, to
        };
    }
    /**
     *  @_ignore:
     */
    get length() { return this.logs.length; }
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => {
                if (index < this.length) {
                    return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The total fee for this transaction, in wei.
     */
    get fee() {
        return this.gasUsed * this.gasPrice;
    }
    /**
     *  Resolves to the block this transaction occurred in.
     */
    async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to the transaction this transaction occurred in.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
            throw new Error("TODO");
        }
        return tx;
    }
    /**
     *  Resolves to the return value of the execution of this transaction.
     *
     *  Support for this feature is limited, as it requires an archive node
     *  with the ``debug_`` or ``trace_`` API enabled.
     */
    async getResult() {
        return (await this.provider.getTransactionResult(this.hash));
    }
    /**
     *  Resolves to the number of confirmations this transaction has.
     */
    async confirmations() {
        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
    }
    /**
     *  @_ignore:
     */
    removedEvent() {
        return createRemovedTransactionFilter(this);
    }
    /**
     *  @_ignore:
     */
    reorderedEvent(other) {
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
        return createReorderedTransactionFilter(this, other);
    }
}
exports.TransactionReceipt = TransactionReceipt;
/**
 *  A **TransactionResponse** includes all properties about a transaction
 *  that was sent to the network, which may or may not be included in a
 *  block.
 *
 *  The [[TransactionResponse-isMined]] can be used to check if the
 *  transaction has been mined as well as type guard that the otherwise
 *  possibly ``null`` properties are defined.
 */
class TransactionResponse {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    provider;
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockNumber;
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    blockHash;
    /**
     *  The index within the block that this transaction resides at.
     */
    index;
    /**
     *  The transaction hash.
     */
    hash;
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    type;
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    to;
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    from;
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    nonce;
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    gasLimit;
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    gasPrice;
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    maxPriorityFeePerGas;
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    maxFeePerGas;
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    maxFeePerBlobGas;
    /**
     *  The data.
     */
    data;
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    value;
    /**
     *  The chain ID.
     */
    chainId;
    /**
     *  The signature.
     */
    signature;
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    accessList;
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    blobVersionedHashes;
    #startBlock;
    /**
     *  @_ignore:
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;
        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.gasPrice = tx.gasPrice;
        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;
        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;
        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = (tx.accessList != null) ? tx.accessList : null;
        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;
        this.#startBlock = -1;
    }
    /**
     *  Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
        return {
            _type: "TransactionResponse",
            accessList, blockNumber, blockHash,
            blobVersionedHashes,
            chainId: toJson(this.chainId),
            data, from,
            gasLimit: toJson(this.gasLimit),
            gasPrice: toJson(this.gasPrice),
            hash,
            maxFeePerGas: toJson(this.maxFeePerGas),
            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
            nonce, signature, to, index, type,
            value: toJson(this.value),
        };
    }
    /**
     *  Resolves to the Block that this transaction was included in.
     *
     *  This will return null if the transaction has not been included yet.
     */
    async getBlock() {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
                blockNumber = tx.blockNumber;
            }
        }
        if (blockNumber == null) {
            return null;
        }
        const block = this.provider.getBlock(blockNumber);
        if (block == null) {
            throw new Error("TODO");
        }
        return block;
    }
    /**
     *  Resolves to this transaction being re-requested from the
     *  provider. This can be used if you have an unmined transaction
     *  and wish to get an up-to-date populated instance.
     */
    async getTransaction() {
        return this.provider.getTransaction(this.hash);
    }
    /**
     *  Resolve to the number of confirmations this transaction has.
     */
    async confirmations() {
        if (this.blockNumber == null) {
            const { tx, blockNumber } = await (0, index_js_1.resolveProperties)({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            // Not mined yet...
            if (tx == null || tx.blockNumber == null) {
                return 0;
            }
            return blockNumber - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber();
        return blockNumber - this.blockNumber + 1;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    async wait(_confirms, _timeout) {
        const confirms = (_confirms == null) ? 1 : _confirms;
        const timeout = (_timeout == null) ? 0 : _timeout;
        let startBlock = this.#startBlock;
        let nextScan = -1;
        let stopScanning = (startBlock === -1) ? true : false;
        const checkReplacement = async () => {
            // Get the current transaction count for this sender
            if (stopScanning) {
                return null;
            }
            const { blockNumber, nonce } = await (0, index_js_1.resolveProperties)({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from)
            });
            // No transaction or our nonce has not been mined yet; but we
            // can start scanning later when we do start
            if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
            }
            // We were mined; no replacement
            if (stopScanning) {
                return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
                return;
            }
            // We were replaced; start scanning for that transaction
            // Starting to scan; look back a few extra blocks for safety
            if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.#startBlock) {
                    nextScan = this.#startBlock;
                }
            }
            while (nextScan <= blockNumber) {
                // Get the next block to scan
                if (stopScanning) {
                    return null;
                }
                const block = await this.provider.getBlock(nextScan, true);
                // This should not happen; but we'll try again shortly
                if (block == null) {
                    return;
                }
                // We were mined; no replacement
                for (const hash of block) {
                    if (hash === this.hash) {
                        return;
                    }
                }
                // Search for the transaction that replaced us
                for (let i = 0; i < block.length; i++) {
                    const tx = await block.getTransaction(i);
                    if (tx.from === this.from && tx.nonce === this.nonce) {
                        // Get the receipt
                        if (stopScanning) {
                            return null;
                        }
                        const receipt = await this.provider.getTransactionReceipt(tx.hash);
                        // This should not happen; but we'll try again shortly
                        if (receipt == null) {
                            return;
                        }
                        // We will retry this on the next block (this case could be optimized)
                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {
                            return;
                        }
                        // The reason we were replaced
                        let reason = "replaced";
                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                            reason = "repriced";
                        }
                        else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0) {
                            reason = "cancelled";
                        }
                        (0, index_js_1.assert)(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                            cancelled: (reason === "replaced" || reason === "cancelled"),
                            reason,
                            replacement: tx.replaceableTransaction(startBlock),
                            hash: tx.hash,
                            receipt
                        });
                    }
                }
                nextScan++;
            }
            return;
        };
        const checkReceipt = (receipt) => {
            if (receipt == null || receipt.status !== 0) {
                return receipt;
            }
            (0, index_js_1.assert)(false, "transaction execution reverted", "CALL_EXCEPTION", {
                action: "sendTransaction",
                data: null, reason: null, invocation: null, revert: null,
                transaction: {
                    to: receipt.to,
                    from: receipt.from,
                    data: "" // @TODO: in v7, split out sendTransaction properties
                }, receipt
            });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
            return checkReceipt(receipt);
        }
        if (receipt) {
            if ((await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
            }
        }
        else {
            // Check for a replacement; throws if a replacement was found
            await checkReplacement();
            // Allow null only when the confirms is 0
            if (confirms === 0) {
                return null;
            }
        }
        const waiter = new Promise((resolve, reject) => {
            // List of things to cancel when we have a result (one way or the other)
            const cancellers = [];
            const cancel = () => { cancellers.forEach((c) => c()); };
            // On cancel, stop scanning for replacements
            cancellers.push(() => { stopScanning = true; });
            // Set up any timeout requested
            if (timeout > 0) {
                const timer = setTimeout(() => {
                    cancel();
                    reject((0, index_js_1.makeError)("wait for transaction timeout", "TIMEOUT"));
                }, timeout);
                cancellers.push(() => { clearTimeout(timer); });
            }
            const txListener = async (receipt) => {
                // Done; return it!
                if ((await receipt.confirmations()) >= confirms) {
                    cancel();
                    try {
                        resolve(checkReceipt(receipt));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            };
            cancellers.push(() => { this.provider.off(this.hash, txListener); });
            this.provider.on(this.hash, txListener);
            // We support replacement detection; start checking
            if (startBlock >= 0) {
                const replaceListener = async () => {
                    try {
                        // Check for a replacement; this throws only if one is found
                        await checkReplacement();
                    }
                    catch (error) {
                        // We were replaced (with enough confirms); re-throw the error
                        if ((0, index_js_1.isError)(error, "TRANSACTION_REPLACED")) {
                            cancel();
                            reject(error);
                            return;
                        }
                    }
                    // Rescheudle a check on the next block
                    if (!stopScanning) {
                        this.provider.once("block", replaceListener);
                    }
                };
                cancellers.push(() => { this.provider.off("block", replaceListener); });
                this.provider.once("block", replaceListener);
            }
        });
        return await waiter;
    }
    /**
     *  Returns ``true`` if this transaction has been included.
     *
     *  This is effective only as of the time the TransactionResponse
     *  was instantiated. To get up-to-date information, use
     *  [[getTransaction]].
     *
     *  This provides a Type Guard that this transaction will have
     *  non-null property values for properties that are null for
     *  unmined transactions.
     */
    isMined() {
        return (this.blockHash != null);
    }
    /**
     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
     *  transaction.
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLegacy() {
        return (this.type === 0);
    }
    /**
     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
     *  transaction. See [[link-eip-2070]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isBerlin() {
        return (this.type === 1);
    }
    /**
     *  Returns true if the transaction is a London (i.e. ``type == 2``)
     *  transaction. See [[link-eip-1559]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLondon() {
        return (this.type === 2);
    }
    /**
     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
     *  transaction. See [[link-eip-4844]].
     */
    isCancun() {
        return (this.type === 3);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that evict this transaction.
     */
    removedEvent() {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createRemovedTransactionFilter(this);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that re-order this event against %%other%%.
     */
    reorderedEvent(other) {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createReorderedTransactionFilter(this, other);
    }
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
    replaceableTransaction(startBlock) {
        (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        const tx = new TransactionResponse(this, this.provider);
        tx.#startBlock = startBlock;
        return tx;
    }
}
exports.TransactionResponse = TransactionResponse;
function createOrphanedBlockFilter(block) {
    return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
    return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
    return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
    return { orphan: "drop-log", log: {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            address: log.address,
            data: log.data,
            topics: Object.freeze(log.topics.slice()),
            index: log.index
        } };
}
//# sourceMappingURL=provider.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js":
/*!****************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonceManager = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ "../node_modules/ethers/lib.commonjs/providers/abstract-signer.js");
/**
 *  A **NonceManager** wraps another [[Signer]] and automatically manages
 *  the nonce, ensuring serialized and sequential nonces are used during
 *  transaction.
 */
class NonceManager extends abstract_signer_js_1.AbstractSigner {
    /**
     *  The Signer being managed.
     */
    signer;
    #noncePromise;
    #delta;
    /**
     *  Creates a new **NonceManager** to manage %%signer%%.
     */
    constructor(signer) {
        super(signer.provider);
        (0, index_js_1.defineProperties)(this, { signer });
        this.#noncePromise = null;
        this.#delta = 0;
    }
    async getAddress() {
        return this.signer.getAddress();
    }
    connect(provider) {
        return new NonceManager(this.signer.connect(provider));
    }
    async getNonce(blockTag) {
        if (blockTag === "pending") {
            if (this.#noncePromise == null) {
                this.#noncePromise = super.getNonce("pending");
            }
            const delta = this.#delta;
            return (await this.#noncePromise) + delta;
        }
        return super.getNonce(blockTag);
    }
    /**
     *  Manually increment the nonce. This may be useful when managng
     *  offline transactions.
     */
    increment() {
        this.#delta++;
    }
    /**
     *  Resets the nonce, causing the **NonceManager** to reload the current
     *  nonce from the blockchain on the next transaction.
     */
    reset() {
        this.#delta = 0;
        this.#noncePromise = null;
    }
    async sendTransaction(tx) {
        const noncePromise = this.getNonce("pending");
        this.increment();
        tx = await this.signer.populateTransaction(tx);
        tx.nonce = await noncePromise;
        // @TODO: Maybe handle interesting/recoverable errors?
        // Like don't increment if the tx was certainly not sent
        return await this.signer.sendTransaction(tx);
    }
    signTransaction(tx) {
        return this.signer.signTransaction(tx);
    }
    signMessage(message) {
        return this.signer.signMessage(message);
    }
    signTypedData(domain, types, value) {
        return this.signer.signTypedData(domain, types, value);
    }
}
exports.NonceManager = NonceManager;
//# sourceMappingURL=signer-noncemanager.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js":
/*!****************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ "../node_modules/ethers/lib.commonjs/providers/subscriber-polling.js");
function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 *  Some backends support subscribing to events using a Filter ID.
 *
 *  When subscribing with this technique, the node issues a unique
 *  //Filter ID//. At this point the node dedicates resources to
 *  the filter, so that periodic calls to follow up on the //Filter ID//
 *  will receive any events since the last call.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdSubscriber {
    #provider;
    #filterIdPromise;
    #poller;
    #running;
    #network;
    #hault;
    /**
     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
     *  and [[_emitResults]] to setup the subscription and provide the event
     *  to the %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#filterIdPromise = null;
        this.#poller = this.#poll.bind(this);
        this.#running = false;
        this.#network = null;
        this.#hault = false;
    }
    /**
     *  Sub-classes **must** override this to begin the subscription.
     */
    _subscribe(provider) {
        throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle the events.
     */
    _emitResults(provider, result) {
        throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle recovery on errors.
     */
    _recover(provider) {
        throw new Error("subclasses must override this");
    }
    async #poll(blockNumber) {
        try {
            // Subscribe if necessary
            if (this.#filterIdPromise == null) {
                this.#filterIdPromise = this._subscribe(this.#provider);
            }
            // Get the Filter ID
            let filterId = null;
            try {
                filterId = await this.#filterIdPromise;
            }
            catch (error) {
                if (!(0, index_js_1.isError)(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
                    throw error;
                }
            }
            // The backend does not support Filter ID; downgrade to
            // polling
            if (filterId == null) {
                this.#filterIdPromise = null;
                this.#provider._recoverSubscriber(this, this._recover(this.#provider));
                return;
            }
            const network = await this.#provider.getNetwork();
            if (!this.#network) {
                this.#network = network;
            }
            if (this.#network.chainId !== network.chainId) {
                throw new Error("chaid changed");
            }
            if (this.#hault) {
                return;
            }
            const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
            await this._emitResults(this.#provider, result);
        }
        catch (error) {
            console.log("@TODO", error);
        }
        this.#provider.once("block", this.#poller);
    }
    #teardown() {
        const filterIdPromise = this.#filterIdPromise;
        if (filterIdPromise) {
            this.#filterIdPromise = null;
            filterIdPromise.then((filterId) => {
                if (this.#provider.destroyed) {
                    return;
                }
                this.#provider.send("eth_uninstallFilter", [filterId]);
            });
        }
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        this.#poll(-2);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#hault = true;
        this.#teardown();
        this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
        if (dropWhilePaused) {
            this.#teardown();
        }
        this.#provider.off("block", this.#poller);
    }
    resume() { this.start(); }
}
exports.FilterIdSubscriber = FilterIdSubscriber;
/**
 *  A **FilterIdSubscriber** for receiving contract events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdEventSubscriber extends FilterIdSubscriber {
    #event;
    /**
     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
     *  listening for %%filter%%.
     */
    constructor(provider, filter) {
        super(provider);
        this.#event = copy(filter);
    }
    _recover(provider) {
        return new subscriber_polling_js_1.PollingEventSubscriber(provider, this.#event);
    }
    async _subscribe(provider) {
        const filterId = await provider.send("eth_newFilter", [this.#event]);
        return filterId;
    }
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit(this.#event, provider._wrapLog(result, provider._network));
        }
    }
}
exports.FilterIdEventSubscriber = FilterIdEventSubscriber;
/**
 *  A **FilterIdSubscriber** for receiving pending transactions events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class FilterIdPendingSubscriber extends FilterIdSubscriber {
    async _subscribe(provider) {
        return await provider.send("eth_newPendingTransactionFilter", []);
    }
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit("pending", result);
        }
    }
}
exports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;
//# sourceMappingURL=subscriber-filterid.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/subscriber-polling.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/subscriber-polling.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.PollingBlockTagSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 *  Return the polling subscriber for common events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
function getPollingSubscriber(provider, event) {
    if (event === "block") {
        return new PollingBlockSubscriber(provider);
    }
    if ((0, index_js_1.isHexString)(event, 32)) {
        return new PollingTransactionSubscriber(provider, event);
    }
    (0, index_js_1.assert)(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
        operation: "getPollingSubscriber", info: { event }
    });
}
exports.getPollingSubscriber = getPollingSubscriber;
// @TODO: refactor this
/**
 *  A **PollingBlockSubscriber** polls at a regular interval for a change
 *  in the block number.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingBlockSubscriber {
    #provider;
    #poller;
    #interval;
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    #blockNumber;
    /**
     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#poller = null;
        this.#interval = 4000;
        this.#blockNumber = -2;
    }
    /**
     *  The polling interval.
     */
    get pollingInterval() { return this.#interval; }
    set pollingInterval(value) { this.#interval = value; }
    async #poll() {
        try {
            const blockNumber = await this.#provider.getBlockNumber();
            // Bootstrap poll to setup our initial block number
            if (this.#blockNumber === -2) {
                this.#blockNumber = blockNumber;
                return;
            }
            // @TODO: Put a cap on the maximum number of events per loop?
            if (blockNumber !== this.#blockNumber) {
                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                    // We have been stopped
                    if (this.#poller == null) {
                        return;
                    }
                    await this.#provider.emit("block", b);
                }
                this.#blockNumber = blockNumber;
            }
        }
        catch (error) {
            // @TODO: Minor bump, add an "error" event to let subscribers
            //        know things went awry.
            //console.log(error);
        }
        // We have been stopped
        if (this.#poller == null) {
            return;
        }
        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    }
    start() {
        if (this.#poller) {
            return;
        }
        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
        this.#poll();
    }
    stop() {
        if (!this.#poller) {
            return;
        }
        this.#provider._clearTimeout(this.#poller);
        this.#poller = null;
    }
    pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
            this.#blockNumber = -2;
        }
    }
    resume() {
        this.start();
    }
}
exports.PollingBlockSubscriber = PollingBlockSubscriber;
/**
 *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]
 *  implmentation which will be called on every new block.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class OnBlockSubscriber {
    #provider;
    #poll;
    #running;
    /**
     *  Create a new **OnBlockSubscriber** attached to %%provider%%.
     */
    constructor(provider) {
        this.#provider = provider;
        this.#running = false;
        this.#poll = (blockNumber) => {
            this._poll(blockNumber, this.#provider);
        };
    }
    /**
     *  Called on every new block.
     */
    async _poll(blockNumber, provider) {
        throw new Error("sub-classes must override this");
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        this.#poll(-2);
        this.#provider.on("block", this.#poll);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#provider.off("block", this.#poll);
    }
    pause(dropWhilePaused) { this.stop(); }
    resume() { this.start(); }
}
exports.OnBlockSubscriber = OnBlockSubscriber;
class PollingBlockTagSubscriber extends OnBlockSubscriber {
    #tag;
    #lastBlock;
    constructor(provider, tag) {
        super(provider);
        this.#tag = tag;
        this.#lastBlock = -2;
    }
    pause(dropWhilePaused) {
        if (dropWhilePaused) {
            this.#lastBlock = -2;
        }
        super.pause(dropWhilePaused);
    }
    async _poll(blockNumber, provider) {
        const block = await provider.getBlock(this.#tag);
        if (block == null) {
            return;
        }
        if (this.#lastBlock === -2) {
            this.#lastBlock = block.number;
        }
        else if (block.number > this.#lastBlock) {
            provider.emit(this.#tag, block.number);
            this.#lastBlock = block.number;
        }
    }
}
exports.PollingBlockTagSubscriber = PollingBlockTagSubscriber;
/**
 *  @_ignore:
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingOrphanSubscriber extends OnBlockSubscriber {
    #filter;
    constructor(provider, filter) {
        super(provider);
        this.#filter = copy(filter);
    }
    async _poll(blockNumber, provider) {
        throw new Error("@TODO");
        console.log(this.#filter);
    }
}
exports.PollingOrphanSubscriber = PollingOrphanSubscriber;
/**
 *  A **PollingTransactionSubscriber** will poll for a given transaction
 *  hash for its receipt.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingTransactionSubscriber extends OnBlockSubscriber {
    #hash;
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%hash%%.
     */
    constructor(provider, hash) {
        super(provider);
        this.#hash = hash;
    }
    async _poll(blockNumber, provider) {
        const tx = await provider.getTransactionReceipt(this.#hash);
        if (tx) {
            provider.emit(this.#hash, tx);
        }
    }
}
exports.PollingTransactionSubscriber = PollingTransactionSubscriber;
/**
 *  A **PollingEventSubscriber** will poll for a given filter for its logs.
 *
 *  @_docloc: api/providers/abstract-provider
 */
class PollingEventSubscriber {
    #provider;
    #filter;
    #poller;
    #running;
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    #blockNumber;
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%filter%%.
     */
    constructor(provider, filter) {
        this.#provider = provider;
        this.#filter = copy(filter);
        this.#poller = this.#poll.bind(this);
        this.#running = false;
        this.#blockNumber = -2;
    }
    async #poll(blockNumber) {
        // The initial block hasn't been determined yet
        if (this.#blockNumber === -2) {
            return;
        }
        const filter = copy(this.#filter);
        filter.fromBlock = this.#blockNumber + 1;
        filter.toBlock = blockNumber;
        const logs = await this.#provider.getLogs(filter);
        // No logs could just mean the node has not indexed them yet,
        // so we keep a sliding window of 60 blocks to keep scanning
        if (logs.length === 0) {
            if (this.#blockNumber < blockNumber - 60) {
                this.#blockNumber = blockNumber - 60;
            }
            return;
        }
        for (const log of logs) {
            this.#provider.emit(this.#filter, log);
            // Only advance the block number when logs were found to
            // account for networks (like BNB and Polygon) which may
            // sacrifice event consistency for block event speed
            this.#blockNumber = log.blockNumber;
        }
    }
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        if (this.#blockNumber === -2) {
            this.#provider.getBlockNumber().then((blockNumber) => {
                this.#blockNumber = blockNumber;
            });
        }
        this.#provider.on("block", this.#poller);
    }
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
            this.#blockNumber = -2;
        }
    }
    resume() {
        this.start();
    }
}
exports.PollingEventSubscriber = PollingEventSubscriber;
//# sourceMappingURL=subscriber-polling.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/providers/ws.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/providers/ws.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocket = void 0;
var ws_1 = __webpack_require__(/*! ws */ "../node_modules/ws/index.js");
Object.defineProperty(exports, "WebSocket", ({ enumerable: true, get: function () { return ws_1.WebSocket; } }));
//# sourceMappingURL=ws.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/transaction/accesslist.js":
/*!*********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/transaction/accesslist.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.accessListify = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
function accessSetify(addr, storageKeys) {
    return {
        address: (0, index_js_1.getAddress)(addr),
        storageKeys: storageKeys.map((storageKey, index) => {
            (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
            return storageKey.toLowerCase();
        })
    };
}
/**
 *  Returns a [[AccessList]] from any ethers-supported access-list structure.
 */
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                (0, index_js_2.assertArgument)(set.length === 2, "invalid slot set", `value[${index}]`, set);
                return accessSetify(set[0], set[1]);
            }
            (0, index_js_2.assertArgument)(set != null && typeof (set) === "object", "invalid address-slot set", "value", value);
            return accessSetify(set.address, set.storageKeys);
        });
    }
    (0, index_js_2.assertArgument)(value != null && typeof (value) === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}
exports.accessListify = accessListify;
//# sourceMappingURL=accesslist.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/transaction/address.js":
/*!******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/transaction/address.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverAddress = exports.computeAddress = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
/**
 *  Returns the address for the %%key%%.
 *
 *  The key may be any standard form of public key or a private key.
 */
function computeAddress(key) {
    let pubkey;
    if (typeof (key) === "string") {
        pubkey = index_js_2.SigningKey.computePublicKey(key, false);
    }
    else {
        pubkey = key.publicKey;
    }
    return (0, index_js_1.getAddress)((0, index_js_2.keccak256)("0x" + pubkey.substring(4)).substring(26));
}
exports.computeAddress = computeAddress;
/**
 *  Returns the recovered address for the private key that was
 *  used to sign %%digest%% that resulted in %%signature%%.
 */
function recoverAddress(digest, signature) {
    return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));
}
exports.recoverAddress = recoverAddress;
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/transaction/index.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/transaction/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  Each state-changing operation on Ethereum requires a transaction.
 *
 *  @_section api/transaction:Transactions  [about-transactions]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;
null;
var accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ "../node_modules/ethers/lib.commonjs/transaction/accesslist.js");
Object.defineProperty(exports, "accessListify", ({ enumerable: true, get: function () { return accesslist_js_1.accessListify; } }));
var address_js_1 = __webpack_require__(/*! ./address.js */ "../node_modules/ethers/lib.commonjs/transaction/address.js");
Object.defineProperty(exports, "computeAddress", ({ enumerable: true, get: function () { return address_js_1.computeAddress; } }));
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return address_js_1.recoverAddress; } }));
var transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "../node_modules/ethers/lib.commonjs/transaction/transaction.js");
Object.defineProperty(exports, "Transaction", ({ enumerable: true, get: function () { return transaction_js_1.Transaction; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/transaction/transaction.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/transaction/transaction.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const addresses_js_1 = __webpack_require__(/*! ../constants/addresses.js */ "../node_modules/ethers/lib.commonjs/constants/addresses.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ "../node_modules/ethers/lib.commonjs/transaction/accesslist.js");
const address_js_1 = __webpack_require__(/*! ./address.js */ "../node_modules/ethers/lib.commonjs/transaction/address.js");
const BN_0 = BigInt(0);
const BN_2 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version, hash) {
    let versioned = version.toString(16);
    while (versioned.length < 2) {
        versioned = "0" + versioned;
    }
    versioned += (0, index_js_2.sha256)(hash).substring(4);
    return "0x" + versioned;
}
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return (0, index_js_1.getAddress)(value);
}
function handleAccessList(value, param) {
    try {
        return (0, accesslist_js_1.accessListify)(value);
    }
    catch (error) {
        (0, index_js_3.assertArgument)(false, error.message, param, value);
    }
}
function handleNumber(_value, param) {
    if (_value === "0x") {
        return 0;
    }
    return (0, index_js_3.getNumber)(_value, param);
}
function handleUint(_value, param) {
    if (_value === "0x") {
        return BN_0;
    }
    const value = (0, index_js_3.getBigInt)(_value, param);
    (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
    return value;
}
function formatNumber(_value, name) {
    const value = (0, index_js_3.getBigInt)(_value, "value");
    const result = (0, index_js_3.toBeArray)(value);
    (0, index_js_3.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);
    return result;
}
function formatAccessList(value) {
    return (0, accesslist_js_1.accessListify)(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
    (0, index_js_3.assertArgument)(Array.isArray(value), `invalid ${param}`, "value", value);
    for (let i = 0; i < value.length; i++) {
        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
    }
    return value;
}
function _parseLegacy(data) {
    const fields = (0, index_js_3.decodeRlp)(data);
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
    const tx = {
        type: 0,
        nonce: handleNumber(fields[0], "nonce"),
        gasPrice: handleUint(fields[1], "gasPrice"),
        gasLimit: handleUint(fields[2], "gasLimit"),
        to: handleAddress(fields[3]),
        value: handleUint(fields[4], "value"),
        data: (0, index_js_3.hexlify)(fields[5]),
        chainId: BN_0
    };
    // Legacy unsigned transaction
    if (fields.length === 6) {
        return tx;
    }
    const v = handleUint(fields[6], "v");
    const r = handleUint(fields[7], "r");
    const s = handleUint(fields[8], "s");
    if (r === BN_0 && s === BN_0) {
        // EIP-155 unsigned transaction
        tx.chainId = v;
    }
    else {
        // Compute the EIP-155 chain ID (or 0 for legacy)
        let chainId = (v - BN_35) / BN_2;
        if (chainId < BN_0) {
            chainId = BN_0;
        }
        tx.chainId = chainId;
        // Signed Legacy Transaction
        (0, index_js_3.assertArgument)(chainId !== BN_0 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
        tx.signature = index_js_2.Signature.from({
            r: (0, index_js_3.zeroPadValue)(fields[7], 32),
            s: (0, index_js_3.zeroPadValue)(fields[8], 32),
            v
        });
        //tx.hash = keccak256(data);
    }
    return tx;
}
function _serializeLegacy(tx, sig) {
    const fields = [
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
    ];
    let chainId = BN_0;
    if (tx.chainId != BN_0) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = (0, index_js_3.getBigInt)(tx.chainId, "tx.chainId");
        // We have a chainId in the tx and an EIP-155 v in the signature,
        // make sure they agree with each other
        (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    else if (tx.signature) {
        // No explicit chainId, but EIP-155 have a derived implicit chainId
        const legacy = tx.signature.legacyChainId;
        if (legacy != null) {
            chainId = legacy;
        }
    }
    // Requesting an unsigned transaction
    if (!sig) {
        // We have an EIP-155 transaction (chainId was specified and non-zero)
        if (chainId !== BN_0) {
            fields.push((0, index_js_3.toBeArray)(chainId));
            fields.push("0x");
            fields.push("0x");
        }
        return (0, index_js_3.encodeRlp)(fields);
    }
    // @TODO: We should probably check that tx.signature, chainId, and sig
    //        match but that logic could break existing code, so schedule
    //        this for the next major bump.
    // Compute the EIP-155 v
    let v = BigInt(27 + sig.yParity);
    if (chainId !== BN_0) {
        v = index_js_2.Signature.getChainIdV(chainId, sig.v);
    }
    else if (BigInt(sig.v) !== v) {
        (0, index_js_3.assertArgument)(false, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    // Add the signature
    fields.push((0, index_js_3.toBeArray)(v));
    fields.push((0, index_js_3.toBeArray)(sig.r));
    fields.push((0, index_js_3.toBeArray)(sig.s));
    return (0, index_js_3.encodeRlp)(fields);
}
function _parseEipSignature(tx, fields) {
    let yParity;
    try {
        yParity = handleNumber(fields[0], "yParity");
        if (yParity !== 0 && yParity !== 1) {
            throw new Error("bad yParity");
        }
    }
    catch (error) {
        (0, index_js_3.assertArgument)(false, "invalid yParity", "yParity", fields[0]);
    }
    const r = (0, index_js_3.zeroPadValue)(fields[1], 32);
    const s = (0, index_js_3.zeroPadValue)(fields[2], 32);
    const signature = index_js_2.Signature.from({ r, s, yParity });
    tx.signature = signature;
}
function _parseEip1559(data) {
    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", (0, index_js_3.hexlify)(data));
    const tx = {
        type: 2,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: (0, index_js_3.hexlify)(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
    };
    // Unsigned EIP-1559 Transaction
    if (fields.length === 9) {
        return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(9));
    return tx;
}
function _serializeEip1559(tx, sig) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
    }
    return (0, index_js_3.concat)(["0x02", (0, index_js_3.encodeRlp)(fields)]);
}
function _parseEip2930(data) {
    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", (0, index_js_3.hexlify)(data));
    const tx = {
        type: 1,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        gasPrice: handleUint(fields[2], "gasPrice"),
        gasLimit: handleUint(fields[3], "gasLimit"),
        to: handleAddress(fields[4]),
        value: handleUint(fields[5], "value"),
        data: (0, index_js_3.hexlify)(fields[6]),
        accessList: handleAccessList(fields[7], "accessList")
    };
    // Unsigned EIP-2930 Transaction
    if (fields.length === 8) {
        return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(8));
    return tx;
}
function _serializeEip2930(tx, sig) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || "0x"),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "recoveryParam"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
    }
    return (0, index_js_3.concat)(["0x01", (0, index_js_3.encodeRlp)(fields)]);
}
function _parseEip4844(data) {
    let fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    let typeName = "3";
    let blobs = null;
    // Parse the network format
    if (fields.length === 4 && Array.isArray(fields[0])) {
        typeName = "3 (network format)";
        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
        (0, index_js_3.assertArgument)(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
        (0, index_js_3.assertArgument)(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
        (0, index_js_3.assertArgument)(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
        (0, index_js_3.assertArgument)(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
        (0, index_js_3.assertArgument)(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
        blobs = [];
        for (let i = 0; i < fields[1].length; i++) {
            blobs.push({
                data: fBlobs[i],
                commitment: fCommits[i],
                proof: fProofs[i],
            });
        }
        fields = fields[0];
    }
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", (0, index_js_3.hexlify)(data));
    const tx = {
        type: 3,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: (0, index_js_3.hexlify)(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
        maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
        blobVersionedHashes: fields[10]
    };
    if (blobs) {
        tx.blobs = blobs;
    }
    (0, index_js_3.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
    (0, index_js_3.assertArgument)(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
    }
    // Unsigned EIP-4844 Transaction
    if (fields.length === 11) {
        return tx;
    }
    // @TODO: Do we need to do this? This is only called internally
    // and used to verify hashes; it might save time to not do this
    //tx.hash = keccak256(concat([ "0x03", encodeRlp(fields) ]));
    _parseEipSignature(tx, fields.slice(11));
    return tx;
}
function _serializeEip4844(tx, sig, blobs) {
    const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        (tx.to || addresses_js_1.ZeroAddress),
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || []),
        formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
        formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
    ];
    if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
        // We have blobs; return the network wrapped format
        if (blobs) {
            return (0, index_js_3.concat)([
                "0x03",
                (0, index_js_3.encodeRlp)([
                    fields,
                    blobs.map((b) => b.data),
                    blobs.map((b) => b.commitment),
                    blobs.map((b) => b.proof),
                ])
            ]);
        }
    }
    return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)(fields)]);
}
/**
 *  A **Transaction** describes an operation to be executed on
 *  Ethereum by an Externally Owned Account (EOA). It includes
 *  who (the [[to]] address), what (the [[data]]) and how much (the
 *  [[value]] in ether) the operation should entail.
 *
 *  @example:
 *    tx = new Transaction()
 *    //_result:
 *
 *    tx.data = "0x1234";
 *    //_result:
 */
class Transaction {
    #type;
    #to;
    #data;
    #nonce;
    #gasLimit;
    #gasPrice;
    #maxPriorityFeePerGas;
    #maxFeePerGas;
    #value;
    #chainId;
    #sig;
    #accessList;
    #maxFeePerBlobGas;
    #blobVersionedHashes;
    #kzg;
    #blobs;
    /**
     *  The transaction type.
     *
     *  If null, the type will be automatically inferred based on
     *  explicit properties.
     */
    get type() { return this.#type; }
    set type(value) {
        switch (value) {
            case null:
                this.#type = null;
                break;
            case 0:
            case "legacy":
                this.#type = 0;
                break;
            case 1:
            case "berlin":
            case "eip-2930":
                this.#type = 1;
                break;
            case 2:
            case "london":
            case "eip-1559":
                this.#type = 2;
                break;
            case 3:
            case "cancun":
            case "eip-4844":
                this.#type = 3;
                break;
            default:
                (0, index_js_3.assertArgument)(false, "unsupported transaction type", "type", value);
        }
    }
    /**
     *  The name of the transaction type.
     */
    get typeName() {
        switch (this.type) {
            case 0: return "legacy";
            case 1: return "eip-2930";
            case 2: return "eip-1559";
            case 3: return "eip-4844";
        }
        return null;
    }
    /**
     *  The ``to`` address for the transaction or ``null`` if the
     *  transaction is an ``init`` transaction.
     */
    get to() {
        const value = this.#to;
        if (value == null && this.type === 3) {
            return addresses_js_1.ZeroAddress;
        }
        return value;
    }
    set to(value) {
        this.#to = (value == null) ? null : (0, index_js_1.getAddress)(value);
    }
    /**
     *  The transaction nonce.
     */
    get nonce() { return this.#nonce; }
    set nonce(value) { this.#nonce = (0, index_js_3.getNumber)(value, "value"); }
    /**
     *  The gas limit.
     */
    get gasLimit() { return this.#gasLimit; }
    set gasLimit(value) { this.#gasLimit = (0, index_js_3.getBigInt)(value); }
    /**
     *  The gas price.
     *
     *  On legacy networks this defines the fee that will be paid. On
     *  EIP-1559 networks, this should be ``null``.
     */
    get gasPrice() {
        const value = this.#gasPrice;
        if (value == null && (this.type === 0 || this.type === 1)) {
            return BN_0;
        }
        return value;
    }
    set gasPrice(value) {
        this.#gasPrice = (value == null) ? null : (0, index_js_3.getBigInt)(value, "gasPrice");
    }
    /**
     *  The maximum priority fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxPriorityFeePerGas() {
        const value = this.#maxPriorityFeePerGas;
        if (value == null) {
            if (this.type === 2 || this.type === 3) {
                return BN_0;
            }
            return null;
        }
        return value;
    }
    set maxPriorityFeePerGas(value) {
        this.#maxPriorityFeePerGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, "maxPriorityFeePerGas");
    }
    /**
     *  The maximum total fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxFeePerGas() {
        const value = this.#maxFeePerGas;
        if (value == null) {
            if (this.type === 2 || this.type === 3) {
                return BN_0;
            }
            return null;
        }
        return value;
    }
    set maxFeePerGas(value) {
        this.#maxFeePerGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, "maxFeePerGas");
    }
    /**
     *  The transaction data. For ``init`` transactions this is the
     *  deployment code.
     */
    get data() { return this.#data; }
    set data(value) { this.#data = (0, index_js_3.hexlify)(value); }
    /**
     *  The amount of ether (in wei) to send in this transactions.
     */
    get value() { return this.#value; }
    set value(value) {
        this.#value = (0, index_js_3.getBigInt)(value, "value");
    }
    /**
     *  The chain ID this transaction is valid on.
     */
    get chainId() { return this.#chainId; }
    set chainId(value) { this.#chainId = (0, index_js_3.getBigInt)(value); }
    /**
     *  If signed, the signature for this transaction.
     */
    get signature() { return this.#sig || null; }
    set signature(value) {
        this.#sig = (value == null) ? null : index_js_2.Signature.from(value);
    }
    /**
     *  The access list.
     *
     *  An access list permits discounted (but pre-paid) access to
     *  bytecode and state variable access within contract execution.
     */
    get accessList() {
        const value = this.#accessList || null;
        if (value == null) {
            if (this.type === 1 || this.type === 2 || this.type === 3) {
                // @TODO: in v7, this should assign the value or become
                // a live object itself, otherwise mutation is inconsistent
                return [];
            }
            return null;
        }
        return value;
    }
    set accessList(value) {
        this.#accessList = (value == null) ? null : (0, accesslist_js_1.accessListify)(value);
    }
    /**
     *  The max fee per blob gas for Cancun transactions.
     */
    get maxFeePerBlobGas() {
        const value = this.#maxFeePerBlobGas;
        if (value == null && this.type === 3) {
            return BN_0;
        }
        return value;
    }
    set maxFeePerBlobGas(value) {
        this.#maxFeePerBlobGas = (value == null) ? null : (0, index_js_3.getBigInt)(value, "maxFeePerBlobGas");
    }
    /**
     *  The BLOb versioned hashes for Cancun transactions.
     */
    get blobVersionedHashes() {
        // @TODO: Mutation is inconsistent; if unset, the returned value
        // cannot mutate the object, if set it can
        let value = this.#blobVersionedHashes;
        if (value == null && this.type === 3) {
            return [];
        }
        return value;
    }
    set blobVersionedHashes(value) {
        if (value != null) {
            (0, index_js_3.assertArgument)(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
            value = value.slice();
            for (let i = 0; i < value.length; i++) {
                (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
            }
        }
        this.#blobVersionedHashes = value;
    }
    /**
     *  The BLObs for the Transaction, if any.
     *
     *  If ``blobs`` is non-``null``, then the [[seriailized]]
     *  will return the network formatted sidecar, otherwise it
     *  will return the standard [[link-eip-2718]] payload. The
     *  [[unsignedSerialized]] is unaffected regardless.
     *
     *  When setting ``blobs``, either fully valid [[Blob]] objects
     *  may be specified (i.e. correctly padded, with correct
     *  committments and proofs) or a raw [[BytesLike]] may
     *  be provided.
     *
     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
     *  be already set. The blob will be correctly padded and the
     *  [[KzgLibrary]] will be used to compute the committment and
     *  proof for the blob.
     *
     *  A BLOb is a sequence of field elements, each of which must
     *  be within the BLS field modulo, so some additional processing
     *  may be required to encode arbitrary data to ensure each 32 byte
     *  field is within the valid range.
     *
     *  Setting this automatically populates [[blobVersionedHashes]],
     *  overwriting any existing values. Setting this to ``null``
     *  does **not** remove the [[blobVersionedHashes]], leaving them
     *  present.
     */
    get blobs() {
        if (this.#blobs == null) {
            return null;
        }
        return this.#blobs.map((b) => Object.assign({}, b));
    }
    set blobs(_blobs) {
        if (_blobs == null) {
            this.#blobs = null;
            return;
        }
        const blobs = [];
        const versionedHashes = [];
        for (let i = 0; i < _blobs.length; i++) {
            const blob = _blobs[i];
            if ((0, index_js_3.isBytesLike)(blob)) {
                (0, index_js_3.assert)(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                    operation: "set blobs()"
                });
                let data = (0, index_js_3.getBytes)(blob);
                (0, index_js_3.assertArgument)(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
                // Pad blob if necessary
                if (data.length !== BLOB_SIZE) {
                    const padded = new Uint8Array(BLOB_SIZE);
                    padded.set(data);
                    data = padded;
                }
                const commit = this.#kzg.blobToKzgCommitment(data);
                const proof = (0, index_js_3.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));
                blobs.push({
                    data: (0, index_js_3.hexlify)(data),
                    commitment: (0, index_js_3.hexlify)(commit),
                    proof
                });
                versionedHashes.push(getVersionedHash(1, commit));
            }
            else {
                const commit = (0, index_js_3.hexlify)(blob.commitment);
                blobs.push({
                    data: (0, index_js_3.hexlify)(blob.data),
                    commitment: commit,
                    proof: (0, index_js_3.hexlify)(blob.proof)
                });
                versionedHashes.push(getVersionedHash(1, commit));
            }
        }
        this.#blobs = blobs;
        this.#blobVersionedHashes = versionedHashes;
    }
    get kzg() { return this.#kzg; }
    set kzg(kzg) {
        this.#kzg = kzg;
    }
    /**
     *  Creates a new Transaction with default values.
     */
    constructor() {
        this.#type = null;
        this.#to = null;
        this.#nonce = 0;
        this.#gasLimit = BN_0;
        this.#gasPrice = null;
        this.#maxPriorityFeePerGas = null;
        this.#maxFeePerGas = null;
        this.#data = "0x";
        this.#value = BN_0;
        this.#chainId = BN_0;
        this.#sig = null;
        this.#accessList = null;
        this.#maxFeePerBlobGas = null;
        this.#blobVersionedHashes = null;
        this.#blobs = null;
        this.#kzg = null;
    }
    /**
     *  The transaction hash, if signed. Otherwise, ``null``.
     */
    get hash() {
        if (this.signature == null) {
            return null;
        }
        return (0, index_js_2.keccak256)(this.#getSerialized(true, false));
    }
    /**
     *  The pre-image hash of this transaction.
     *
     *  This is the digest that a [[Signer]] must sign to authorize
     *  this transaction.
     */
    get unsignedHash() {
        return (0, index_js_2.keccak256)(this.unsignedSerialized);
    }
    /**
     *  The sending address, if signed. Otherwise, ``null``.
     */
    get from() {
        if (this.signature == null) {
            return null;
        }
        return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);
    }
    /**
     *  The public key of the sender, if signed. Otherwise, ``null``.
     */
    get fromPublicKey() {
        if (this.signature == null) {
            return null;
        }
        return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
    }
    /**
     *  Returns true if signed.
     *
     *  This provides a Type Guard that properties requiring a signed
     *  transaction are non-null.
     */
    isSigned() {
        return this.signature != null;
    }
    #getSerialized(signed, sidecar) {
        (0, index_js_3.assert)(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
        const sig = signed ? this.signature : null;
        switch (this.inferType()) {
            case 0:
                return _serializeLegacy(this, sig);
            case 1:
                return _serializeEip2930(this, sig);
            case 2:
                return _serializeEip1559(this, sig);
            case 3:
                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
        }
        (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    }
    /**
     *  The serialized transaction.
     *
     *  This throws if the transaction is unsigned. For the pre-image,
     *  use [[unsignedSerialized]].
     */
    get serialized() {
        return this.#getSerialized(true, true);
    }
    /**
     *  The transaction pre-image.
     *
     *  The hash of this is the digest which needs to be signed to
     *  authorize this transaction.
     */
    get unsignedSerialized() {
        return this.#getSerialized(false, false);
    }
    /**
     *  Return the most "likely" type; currently the highest
     *  supported transaction type.
     */
    inferType() {
        const types = this.inferTypes();
        // Prefer London (EIP-1559) over Cancun (BLOb)
        if (types.indexOf(2) >= 0) {
            return 2;
        }
        // Return the highest inferred type
        return (types.pop());
    }
    /**
     *  Validates the explicit properties and returns a list of compatible
     *  transaction types.
     */
    inferTypes() {
        // Checks that there are no conflicting properties set
        const hasGasPrice = this.gasPrice != null;
        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);
        const hasAccessList = (this.accessList != null);
        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);
        //if (hasGasPrice && hasFee) {
        //    throw new Error("transaction cannot have gasPrice and maxFeePerGas");
        //}
        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
            (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
        }
        //if (this.type === 2 && hasGasPrice) {
        //    throw new Error("eip-1559 transaction cannot have gasPrice");
        //}
        (0, index_js_3.assert)(!hasFee || (this.type !== 0 && this.type !== 1), "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
        (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
        const types = [];
        // Explicit type
        if (this.type != null) {
            types.push(this.type);
        }
        else {
            if (hasFee) {
                types.push(2);
            }
            else if (hasGasPrice) {
                types.push(1);
                if (!hasAccessList) {
                    types.push(0);
                }
            }
            else if (hasAccessList) {
                types.push(1);
                types.push(2);
            }
            else if (hasBlob && this.to) {
                types.push(3);
            }
            else {
                types.push(0);
                types.push(1);
                types.push(2);
                types.push(3);
            }
        }
        types.sort();
        return types;
    }
    /**
     *  Returns true if this transaction is a legacy transaction (i.e.
     *  ``type === 0``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLegacy() {
        return (this.type === 0);
    }
    /**
     *  Returns true if this transaction is berlin hardform transaction (i.e.
     *  ``type === 1``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isBerlin() {
        return (this.type === 1);
    }
    /**
     *  Returns true if this transaction is london hardform transaction (i.e.
     *  ``type === 2``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLondon() {
        return (this.type === 2);
    }
    /**
     *  Returns true if this transaction is an [[link-eip-4844]] BLOB
     *  transaction.
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isCancun() {
        return (this.type === 3);
    }
    /**
     *  Create a copy of this transaciton.
     */
    clone() {
        return Transaction.from(this);
    }
    /**
     *  Return a JSON-friendly object.
     */
    toJSON() {
        const s = (v) => {
            if (v == null) {
                return null;
            }
            return v.toString();
        };
        return {
            type: this.type,
            to: this.to,
            //            from: this.from,
            data: this.data,
            nonce: this.nonce,
            gasLimit: s(this.gasLimit),
            gasPrice: s(this.gasPrice),
            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
            maxFeePerGas: s(this.maxFeePerGas),
            value: s(this.value),
            chainId: s(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        };
    }
    /**
     *  Create a **Transaction** from a serialized transaction or a
     *  Transaction-like object.
     */
    static from(tx) {
        if (tx == null) {
            return new Transaction();
        }
        if (typeof (tx) === "string") {
            const payload = (0, index_js_3.getBytes)(tx);
            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??
                return Transaction.from(_parseLegacy(payload));
            }
            switch (payload[0]) {
                case 1: return Transaction.from(_parseEip2930(payload));
                case 2: return Transaction.from(_parseEip1559(payload));
                case 3: return Transaction.from(_parseEip4844(payload));
            }
            (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
        }
        const result = new Transaction();
        if (tx.type != null) {
            result.type = tx.type;
        }
        if (tx.to != null) {
            result.to = tx.to;
        }
        if (tx.nonce != null) {
            result.nonce = tx.nonce;
        }
        if (tx.gasLimit != null) {
            result.gasLimit = tx.gasLimit;
        }
        if (tx.gasPrice != null) {
            result.gasPrice = tx.gasPrice;
        }
        if (tx.maxPriorityFeePerGas != null) {
            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        }
        if (tx.maxFeePerGas != null) {
            result.maxFeePerGas = tx.maxFeePerGas;
        }
        if (tx.maxFeePerBlobGas != null) {
            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
        }
        if (tx.data != null) {
            result.data = tx.data;
        }
        if (tx.value != null) {
            result.value = tx.value;
        }
        if (tx.chainId != null) {
            result.chainId = tx.chainId;
        }
        if (tx.signature != null) {
            result.signature = index_js_2.Signature.from(tx.signature);
        }
        if (tx.accessList != null) {
            result.accessList = tx.accessList;
        }
        // This will get overwritten by blobs, if present
        if (tx.blobVersionedHashes != null) {
            result.blobVersionedHashes = tx.blobVersionedHashes;
        }
        // Make sure we assign the kzg before assigning blobs, which
        // require the library in the event raw blob data is provided.
        if (tx.kzg != null) {
            result.kzg = tx.kzg;
        }
        if (tx.blobs != null) {
            result.blobs = tx.blobs;
        }
        if (tx.hash != null) {
            (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
            (0, index_js_3.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
        }
        if (tx.from != null) {
            (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
            (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
        }
        return result;
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/base58.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/base58.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value
 *  to be encoded as a compact string using a radix of 58 using only
 *  alpha-numeric characters. Confusingly similar characters are omitted
 *  (i.e. ``"l0O"``).
 *
 *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,
 *  since any zero-bytes on the left would get removed. To mitigate this
 *  issue most schemes that use Base58 choose specific high-order values
 *  to ensure non-zero prefixes.
 *
 *  @_subsection: api/utils:Base58 Encoding [about-base58]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeBase58 = exports.encodeBase58 = void 0;
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const maths_js_1 = __webpack_require__(/*! ./maths.js */ "../node_modules/ethers/lib.commonjs/utils/maths.js");
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
    if (Lookup == null) {
        Lookup = {};
        for (let i = 0; i < Alphabet.length; i++) {
            Lookup[Alphabet[i]] = BigInt(i);
        }
    }
    const result = Lookup[letter];
    (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, "letter", letter);
    return result;
}
const BN_0 = BigInt(0);
const BN_58 = BigInt(58);
/**
 *  Encode %%value%% as a Base58-encoded string.
 */
function encodeBase58(_value) {
    const bytes = (0, data_js_1.getBytes)(_value);
    let value = (0, maths_js_1.toBigInt)(bytes);
    let result = "";
    while (value) {
        result = Alphabet[Number(value % BN_58)] + result;
        value /= BN_58;
    }
    // Account for leading padding zeros
    for (let i = 0; i < bytes.length; i++) {
        if (bytes[i]) {
            break;
        }
        result = Alphabet[0] + result;
    }
    return result;
}
exports.encodeBase58 = encodeBase58;
/**
 *  Decode the Base58-encoded %%value%%.
 */
function decodeBase58(value) {
    let result = BN_0;
    for (let i = 0; i < value.length; i++) {
        result *= BN_58;
        result += getAlpha(value[i]);
    }
    return result;
}
exports.decodeBase58 = decodeBase58;
//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/base64.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/base64.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBase64 = exports.decodeBase64 = void 0;
/**
 *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode
 *  arbitrary bytes into a string using 65 printable symbols, the
 *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,
 *  ``"+"`` and ``"/"`` with the ``"="`` used for padding.
 *
 *  @_subsection: api/utils:Base64 Encoding  [about-base64]
 */
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
/**
 *  Decodes the base-64 encoded %%value%%.
 *
 *  @example:
 *    // The decoded value is always binary data...
 *    result = decodeBase64("SGVsbG8gV29ybGQhIQ==")
 *    //_result:
 *
 *    // ...use toUtf8String to convert it to a string.
 *    toUtf8String(result)
 *    //_result:
 *
 *    // Decoding binary data
 *    decodeBase64("EjQ=")
 *    //_result:
 */
function decodeBase64(value) {
    return (0, data_js_1.getBytesCopy)(Buffer.from(value, "base64"));
}
exports.decodeBase64 = decodeBase64;
;
/**
 *  Encodes %%data%% as a base-64 encoded string.
 *
 *  @example:
 *    // Encoding binary data as a hexstring
 *    encodeBase64("0x1234")
 *    //_result:
 *
 *    // Encoding binary data as a Uint8Array
 *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))
 *    //_result:
 *
 *    // The input MUST be data...
 *    encodeBase64("Hello World!!")
 *    //_error:
 *
 *    // ...use toUtf8Bytes for this.
 *    encodeBase64(toUtf8Bytes("Hello World!!"))
 *    //_result:
 */
function encodeBase64(data) {
    return Buffer.from((0, data_js_1.getBytes)(data)).toString("base64");
}
exports.encodeBase64 = encodeBase64;
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/data.js":
/*!*********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;
/**
 *  Some data helpers.
 *
 *
 *  @_subsection api/utils:Data Helpers  [about-data]
 */
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
        if (copy) {
            return new Uint8Array(value);
        }
        return value;
    }
    if (typeof (value) === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
        const result = new Uint8Array((value.length - 2) / 2);
        let offset = 2;
        for (let i = 0; i < result.length; i++) {
            result[i] = parseInt(value.substring(offset, offset + 2), 16);
            offset += 2;
        }
        return result;
    }
    (0, errors_js_1.assertArgument)(false, "invalid BytesLike value", name || "value", value);
}
/**
 *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
 *  the original %%value%% is returned; if a copy is required use
 *  [[getBytesCopy]].
 *
 *  @see: getBytesCopy
 */
function getBytes(value, name) {
    return _getBytes(value, name, false);
}
exports.getBytes = getBytes;
/**
 *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
 *  to prevent any modifications of the returned value from being
 *  reflected elsewhere.
 *
 *  @see: getBytes
 */
function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
}
exports.getBytesCopy = getBytesCopy;
/**
 *  Returns true if %%value%% is a valid [[HexString]].
 *
 *  If %%length%% is ``true`` or a //number//, it also checks that
 *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
 *  bytes of data (e.g. ``0x1234`` is 2 bytes).
 */
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (typeof (length) === "number" && value.length !== 2 + 2 * length) {
        return false;
    }
    if (length === true && (value.length % 2) !== 0) {
        return false;
    }
    return true;
}
exports.isHexString = isHexString;
/**
 *  Returns true if %%value%% is a valid representation of arbitrary
 *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
 */
function isBytesLike(value) {
    return (isHexString(value, true) || (value instanceof Uint8Array));
}
exports.isBytesLike = isBytesLike;
const HexCharacters = "0123456789abcdef";
/**
 *  Returns a [[DataHexString]] representation of %%data%%.
 */
function hexlify(data) {
    const bytes = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes.length; i++) {
        const v = bytes[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
}
exports.hexlify = hexlify;
/**
 *  Returns a [[DataHexString]] by concatenating all values
 *  within %%data%%.
 */
function concat(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
exports.concat = concat;
/**
 *  Returns the length of %%data%%, in bytes.
 */
function dataLength(data) {
    if (isHexString(data, true)) {
        return (data.length - 2) / 2;
    }
    return getBytes(data).length;
}
exports.dataLength = dataLength;
/**
 *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
 *  offset to the %%end%% offset.
 *
 *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
 */
function dataSlice(data, start, end) {
    const bytes = getBytes(data);
    if (end != null && end > bytes.length) {
        (0, errors_js_1.assert)(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
            buffer: bytes, length: bytes.length, offset: end
        });
    }
    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));
}
exports.dataSlice = dataSlice;
/**
 *  Return the [[DataHexString]] result by stripping all **leading**
 ** zero bytes from %%data%%.
 */
function stripZerosLeft(data) {
    let bytes = hexlify(data).substring(2);
    while (bytes.startsWith("00")) {
        bytes = bytes.substring(2);
    }
    return "0x" + bytes;
}
exports.stripZerosLeft = stripZerosLeft;
function zeroPad(data, length, left) {
    const bytes = getBytes(data);
    (0, errors_js_1.assert)(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(bytes),
        length: length,
        offset: length + 1
    });
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
        result.set(bytes, length - bytes.length);
    }
    else {
        result.set(bytes, 0);
    }
    return hexlify(result);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **left**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **values** are in Solidity
 *  (e.g. ``uint128``).
 */
function zeroPadValue(data, length) {
    return zeroPad(data, length, true);
}
exports.zeroPadValue = zeroPadValue;
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **right**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **bytes** are in Solidity
 *  (e.g. ``bytes16``).
 */
function zeroPadBytes(data, length) {
    return zeroPad(data, length, false);
}
exports.zeroPadBytes = zeroPadBytes;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/errors.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/errors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  All errors in ethers include properties to ensure they are both
 *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).
 *
 *  The [[isError]] function can be used to check the error ``code`` and
 *  provide a type guard for the properties present on that error interface.
 *
 *  @_section: api/utils/errors:Errors  [about-errors]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;
const _version_js_1 = __webpack_require__(/*! ../_version.js */ "../node_modules/ethers/lib.commonjs/_version.js");
const properties_js_1 = __webpack_require__(/*! ./properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
function stringify(value) {
    if (value == null) {
        return "null";
    }
    if (Array.isArray(value)) {
        return "[ " + (value.map(stringify)).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
        const HEX = "0123456789abcdef";
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            result += HEX[value[i] >> 4];
            result += HEX[value[i] & 0xf];
        }
        return result;
    }
    if (typeof (value) === "object" && typeof (value.toJSON) === "function") {
        return stringify(value.toJSON());
    }
    switch (typeof (value)) {
        case "boolean":
        case "symbol":
            return value.toString();
        case "bigint":
            return BigInt(value).toString();
        case "number":
            return (value).toString();
        case "string":
            return JSON.stringify(value);
        case "object": {
            const keys = Object.keys(value);
            keys.sort();
            return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
        }
    }
    return `[ COULD NOT SERIALIZE ]`;
}
/**
 *  Returns true if the %%error%% matches an error thrown by ethers
 *  that matches the error %%code%%.
 *
 *  In TypeScript environments, this can be used to check that %%error%%
 *  matches an EthersError type, which means the expected properties will
 *  be set.
 *
 *  @See [ErrorCodes](api:ErrorCode)
 *  @example
 *    try {
 *      // code....
 *    } catch (e) {
 *      if (isError(e, "CALL_EXCEPTION")) {
 *          // The Type Guard has validated this object
 *          console.log(e.data);
 *      }
 *    }
 */
function isError(error, code) {
    return (error && error.code === code);
}
exports.isError = isError;
/**
 *  Returns true if %%error%% is a [[CallExceptionError].
 */
function isCallException(error) {
    return isError(error, "CALL_EXCEPTION");
}
exports.isCallException = isCallException;
/**
 *  Returns a new Error configured to the format ethers emits errors, with
 *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties
 *  for the corresponding EthersError.
 *
 *  Each error in ethers includes the version of ethers, a
 *  machine-readable [[ErrorCode]], and depending on %%code%%, additional
 *  required properties. The error message will also include the %%message%%,
 *  ethers version, %%code%% and all additional properties, serialized.
 */
function makeError(message, code, info) {
    let shortMessage = message;
    {
        const details = [];
        if (info) {
            if ("message" in info || "code" in info || "name" in info) {
                throw new Error(`value will overwrite populated values: ${stringify(info)}`);
            }
            for (const key in info) {
                if (key === "shortMessage") {
                    continue;
                }
                const value = (info[key]);
                //                try {
                details.push(key + "=" + stringify(value));
                //                } catch (error: any) {
                //                console.log("MMM", error.message);
                //                    details.push(key + "=[could not serialize object]");
                //                }
            }
        }
        details.push(`code=${code}`);
        details.push(`version=${_version_js_1.version}`);
        if (details.length) {
            message += " (" + details.join(", ") + ")";
        }
    }
    let error;
    switch (code) {
        case "INVALID_ARGUMENT":
            error = new TypeError(message);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            error = new RangeError(message);
            break;
        default:
            error = new Error(message);
    }
    (0, properties_js_1.defineProperties)(error, { code });
    if (info) {
        Object.assign(error, info);
    }
    if (error.shortMessage == null) {
        (0, properties_js_1.defineProperties)(error, { shortMessage });
    }
    return error;
}
exports.makeError = makeError;
/**
 *  Throws an EthersError with %%message%%, %%code%% and additional error
 *  %%info%% when %%check%% is falsish..
 *
 *  @see [[api:makeError]]
 */
function assert(check, message, code, info) {
    if (!check) {
        throw makeError(message, code, info);
    }
}
exports.assert = assert;
/**
 *  A simple helper to simply ensuring provided arguments match expected
 *  constraints, throwing if not.
 *
 *  In TypeScript environments, the %%check%% has been asserted true, so
 *  any further code does not need additional compile-time checks.
 */
function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value: value });
}
exports.assertArgument = assertArgument;
function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
        message = "";
    }
    if (message) {
        message = ": " + message;
    }
    assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
    assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
        count: count,
        expectedCount: expectedCount
    });
}
exports.assertArgumentCount = assertArgumentCount;
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
        // General test for normalize
        /* c8 ignore start */
        if ("test".normalize(form) !== "test") {
            throw new Error("bad");
        }
        ;
        /* c8 ignore stop */
        if (form === "NFD") {
            const check = String.fromCharCode(0xe9).normalize("NFD");
            const expected = String.fromCharCode(0x65, 0x0301);
            /* c8 ignore start */
            if (check !== expected) {
                throw new Error("broken");
            }
            /* c8 ignore stop */
        }
        accum.push(form);
    }
    catch (error) { }
    return accum;
}, []);
/**
 *  Throws if the normalization %%form%% is not supported.
 */
function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
        operation: "String.prototype.normalize", info: { form }
    });
}
exports.assertNormalize = assertNormalize;
/**
 *  Many classes use file-scoped values to guard the constructor,
 *  making it effectively private. This facilitates that pattern
 *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
 *  throwing if not, indicating the %%className%% if provided.
 */
function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
        className = "";
    }
    if (givenGuard !== guard) {
        let method = className, operation = "new";
        if (className) {
            method += ".";
            operation += " " + className;
        }
        assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
            operation
        });
    }
}
exports.assertPrivate = assertPrivate;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/events.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/events.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventPayload = void 0;
/**
 *  Events allow for applications to use the observer pattern, which
 *  allows subscribing and publishing events, outside the normal
 *  execution paths.
 *
 *  @_section api/utils/events:Events  [about-events]
 */
const properties_js_1 = __webpack_require__(/*! ./properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
/**
 *  When an [[EventEmitterable]] triggers a [[Listener]], the
 *  callback always ahas one additional argument passed, which is
 *  an **EventPayload**.
 */
class EventPayload {
    /**
     *  The event filter.
     */
    filter;
    /**
     *  The **EventEmitterable**.
     */
    emitter;
    #listener;
    /**
     *  Create a new **EventPayload** for %%emitter%% with
     *  the %%listener%% and for %%filter%%.
     */
    constructor(emitter, listener, filter) {
        this.#listener = listener;
        (0, properties_js_1.defineProperties)(this, { emitter, filter });
    }
    /**
     *  Unregister the triggered listener for future events.
     */
    async removeListener() {
        if (this.#listener == null) {
            return;
        }
        await this.emitter.off(this.filter, this.#listener);
    }
}
exports.EventPayload = EventPayload;
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/fetch.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/fetch.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;
/**
 *  Fetching content from the web is environment-specific, so Ethers
 *  provides an abstraction that each environment can implement to provide
 *  this service.
 *
 *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to
 *  create a request object, register event listeners and process data
 *  and populate the [[FetchResponse]].
 *
 *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting
 *  ``Promise`` is waited on to retrieve the payload.
 *
 *  The [[FetchRequest]] is responsible for handling many common situations,
 *  such as redirects, server throttling, authentication, etc.
 *
 *  It also handles common gateways, such as IPFS and data URIs.
 *
 *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]
 */
const base64_js_1 = __webpack_require__(/*! ./base64.js */ "../node_modules/ethers/lib.commonjs/utils/base64.js");
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const properties_js_1 = __webpack_require__(/*! ./properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
const utf8_js_1 = __webpack_require__(/*! ./utf8.js */ "../node_modules/ethers/lib.commonjs/utils/utf8.js");
const geturl_js_1 = __webpack_require__(/*! ./geturl.js */ "../node_modules/ethers/lib.commonjs/utils/geturl.js");
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
// The global FetchGetUrlFunc implementation.
let defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
// If locked, new Gateways cannot be added
let locked = false;
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
async function dataGatewayFunc(url, signal) {
    try {
        const match = url.match(reData);
        if (!match) {
            throw new Error("invalid data");
        }
        return new FetchResponse(200, "OK", {
            "content-type": (match[1] || "text/plain"),
        }, (match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3])));
    }
    catch (error) {
        return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
    }
}
/**
 *  Returns a [[FetchGatewayFunc]] for fetching content from a standard
 *  IPFS gateway hosted at %%baseUrl%%.
 */
function getIpfsGatewayFunc(baseUrl) {
    async function gatewayIpfs(url, signal) {
        try {
            const match = url.match(reIpfs);
            if (!match) {
                throw new Error("invalid link");
            }
            return new FetchRequest(`${baseUrl}${match[2]}`);
        }
        catch (error) {
            return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
        }
    }
    return gatewayIpfs;
}
const Gateways = {
    "data": dataGatewayFunc,
    "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
};
const fetchSignals = new WeakMap();
/**
 *  @_ignore
 */
class FetchCancelSignal {
    #listeners;
    #cancelled;
    constructor(request) {
        this.#listeners = [];
        this.#cancelled = false;
        fetchSignals.set(request, () => {
            if (this.#cancelled) {
                return;
            }
            this.#cancelled = true;
            for (const listener of this.#listeners) {
                setTimeout(() => { listener(); }, 0);
            }
            this.#listeners = [];
        });
    }
    addListener(listener) {
        (0, errors_js_1.assert)(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
        });
        this.#listeners.push(listener);
    }
    get cancelled() { return this.#cancelled; }
    checkSignal() {
        (0, errors_js_1.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
    }
}
exports.FetchCancelSignal = FetchCancelSignal;
// Check the signal, throwing if it is cancelled
function checkSignal(signal) {
    if (signal == null) {
        throw new Error("missing signal; should not happen");
    }
    signal.checkSignal();
    return signal;
}
/**
 *  Represents a request for a resource using a URI.
 *
 *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
 *  and ``IPFS:``.
 *
 *  Additional schemes can be added globally using [[registerGateway]].
 *
 *  @example:
 *    req = new FetchRequest("https://www.ricmoo.com")
 *    resp = await req.send()
 *    resp.body.length
 *    //_result:
 */
class FetchRequest {
    #allowInsecure;
    #gzip;
    #headers;
    #method;
    #timeout;
    #url;
    #body;
    #bodyType;
    #creds;
    // Hooks
    #preflight;
    #process;
    #retry;
    #signal;
    #throttle;
    #getUrlFunc;
    /**
     *  The fetch URL to request.
     */
    get url() { return this.#url; }
    set url(url) {
        this.#url = String(url);
    }
    /**
     *  The fetch body, if any, to send as the request body. //(default: null)//
     *
     *  When setting a body, the intrinsic ``Content-Type`` is automatically
     *  set and will be used if **not overridden** by setting a custom
     *  header.
     *
     *  If %%body%% is null, the body is cleared (along with the
     *  intrinsic ``Content-Type``).
     *
     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
     *  ``text/plain``.
     *
     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
     *  ``application/octet-stream``.
     *
     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
     *  set to ``application/json``.
     */
    get body() {
        if (this.#body == null) {
            return null;
        }
        return new Uint8Array(this.#body);
    }
    set body(body) {
        if (body == null) {
            this.#body = undefined;
            this.#bodyType = undefined;
        }
        else if (typeof (body) === "string") {
            this.#body = (0, utf8_js_1.toUtf8Bytes)(body);
            this.#bodyType = "text/plain";
        }
        else if (body instanceof Uint8Array) {
            this.#body = body;
            this.#bodyType = "application/octet-stream";
        }
        else if (typeof (body) === "object") {
            this.#body = (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body));
            this.#bodyType = "application/json";
        }
        else {
            throw new Error("invalid body");
        }
    }
    /**
     *  Returns true if the request has a body.
     */
    hasBody() {
        return (this.#body != null);
    }
    /**
     *  The HTTP method to use when requesting the URI. If no method
     *  has been explicitly set, then ``GET`` is used if the body is
     *  null and ``POST`` otherwise.
     */
    get method() {
        if (this.#method) {
            return this.#method;
        }
        if (this.hasBody()) {
            return "POST";
        }
        return "GET";
    }
    set method(method) {
        if (method == null) {
            method = "";
        }
        this.#method = String(method).toUpperCase();
    }
    /**
     *  The headers that will be used when requesting the URI. All
     *  keys are lower-case.
     *
     *  This object is a copy, so any changes will **NOT** be reflected
     *  in the ``FetchRequest``.
     *
     *  To set a header entry, use the ``setHeader`` method.
     */
    get headers() {
        const headers = Object.assign({}, this.#headers);
        if (this.#creds) {
            headers["authorization"] = `Basic ${(0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(this.#creds))}`;
        }
        ;
        if (this.allowGzip) {
            headers["accept-encoding"] = "gzip";
        }
        if (headers["content-type"] == null && this.#bodyType) {
            headers["content-type"] = this.#bodyType;
        }
        if (this.body) {
            headers["content-length"] = String(this.body.length);
        }
        return headers;
    }
    /**
     *  Get the header for %%key%%, ignoring case.
     */
    getHeader(key) {
        return this.headers[key.toLowerCase()];
    }
    /**
     *  Set the header for %%key%% to %%value%%. All values are coerced
     *  to a string.
     */
    setHeader(key, value) {
        this.#headers[String(key).toLowerCase()] = String(value);
    }
    /**
     *  Clear all headers, resetting all intrinsic headers.
     */
    clearHeaders() {
        this.#headers = {};
    }
    [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    const key = keys[index++];
                    return {
                        value: [key, headers[key]], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    /**
     *  The value that will be sent for the ``Authorization`` header.
     *
     *  To set the credentials, use the ``setCredentials`` method.
     */
    get credentials() {
        return this.#creds || null;
    }
    /**
     *  Sets an ``Authorization`` for %%username%% with %%password%%.
     */
    setCredentials(username, password) {
        (0, errors_js_1.assertArgument)(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
        this.#creds = `${username}:${password}`;
    }
    /**
     *  Enable and request gzip-encoded responses. The response will
     *  automatically be decompressed. //(default: true)//
     */
    get allowGzip() {
        return this.#gzip;
    }
    set allowGzip(value) {
        this.#gzip = !!value;
    }
    /**
     *  Allow ``Authentication`` credentials to be sent over insecure
     *  channels. //(default: false)//
     */
    get allowInsecureAuthentication() {
        return !!this.#allowInsecure;
    }
    set allowInsecureAuthentication(value) {
        this.#allowInsecure = !!value;
    }
    /**
     *  The timeout (in milliseconds) to wait for a complete response.
     *  //(default: 5 minutes)//
     */
    get timeout() { return this.#timeout; }
    set timeout(timeout) {
        (0, errors_js_1.assertArgument)(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
        this.#timeout = timeout;
    }
    /**
     *  This function is called prior to each request, for example
     *  during a redirection or retry in case of server throttling.
     *
     *  This offers an opportunity to populate headers or update
     *  content before sending a request.
     */
    get preflightFunc() {
        return this.#preflight || null;
    }
    set preflightFunc(preflight) {
        this.#preflight = preflight;
    }
    /**
     *  This function is called after each response, offering an
     *  opportunity to provide client-level throttling or updating
     *  response data.
     *
     *  Any error thrown in this causes the ``send()`` to throw.
     *
     *  To schedule a retry attempt (assuming the maximum retry limit
     *  has not been reached), use [[response.throwThrottleError]].
     */
    get processFunc() {
        return this.#process || null;
    }
    set processFunc(process) {
        this.#process = process;
    }
    /**
     *  This function is called on each retry attempt.
     */
    get retryFunc() {
        return this.#retry || null;
    }
    set retryFunc(retry) {
        this.#retry = retry;
    }
    /**
     *  This function is called to fetch content from HTTP and
     *  HTTPS URLs and is platform specific (e.g. nodejs vs
     *  browsers).
     *
     *  This is by default the currently registered global getUrl
     *  function, which can be changed using [[registerGetUrl]].
     *  If this has been set, setting is to ``null`` will cause
     *  this FetchRequest (and any future clones) to revert back to
     *  using the currently registered global getUrl function.
     *
     *  Setting this is generally not necessary, but may be useful
     *  for developers that wish to intercept requests or to
     *  configurege a proxy or other agent.
     */
    get getUrlFunc() {
        return this.#getUrlFunc || defaultGetUrlFunc;
    }
    set getUrlFunc(value) {
        this.#getUrlFunc = value;
    }
    /**
     *  Create a new FetchRequest instance with default values.
     *
     *  Once created, each property may be set before issuing a
     *  ``.send()`` to make the request.
     */
    constructor(url) {
        this.#url = String(url);
        this.#allowInsecure = false;
        this.#gzip = true;
        this.#headers = {};
        this.#method = "";
        this.#timeout = 300000;
        this.#throttle = {
            slotInterval: SLOT_INTERVAL,
            maxAttempts: MAX_ATTEMPTS
        };
        this.#getUrlFunc = null;
    }
    toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : "null"}>`;
    }
    /**
     *  Update the throttle parameters used to determine maximum
     *  attempts and exponential-backoff properties.
     */
    setThrottleParams(params) {
        if (params.slotInterval != null) {
            this.#throttle.slotInterval = params.slotInterval;
        }
        if (params.maxAttempts != null) {
            this.#throttle.maxAttempts = params.maxAttempts;
        }
    }
    async #send(attempt, expires, delay, _request, _response) {
        if (attempt >= this.#throttle.maxAttempts) {
            return _response.makeServerError("exceeded maximum retry limit");
        }
        (0, errors_js_1.assert)(getTime() <= expires, "timeout", "TIMEOUT", {
            operation: "request.send", reason: "timeout", request: _request
        });
        if (delay > 0) {
            await wait(delay);
        }
        let req = this.clone();
        const scheme = (req.url.split(":")[0] || "").toLowerCase();
        // Process any Gateways
        if (scheme in Gateways) {
            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
            if (result instanceof FetchResponse) {
                let response = result;
                if (this.processFunc) {
                    checkSignal(_request.#signal);
                    try {
                        response = await this.processFunc(req, response);
                    }
                    catch (error) {
                        // Something went wrong during processing; throw a 5xx server error
                        if (error.throttle == null || typeof (error.stall) !== "number") {
                            response.makeServerError("error in post-processing function", error).assertOk();
                        }
                        // Ignore throttling
                    }
                }
                return response;
            }
            req = result;
        }
        // We have a preflight function; update the request
        if (this.preflightFunc) {
            req = await this.preflightFunc(req);
        }
        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
        if (response.statusCode === 301 || response.statusCode === 302) {
            // Redirect
            try {
                const location = response.headers.location || "";
                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
            }
            catch (error) { }
            // Things won't get any better on another attempt; abort
            return response;
        }
        else if (response.statusCode === 429) {
            // Throttle
            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {
                const retryAfter = response.headers["retry-after"];
                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                    delay = parseInt(retryAfter);
                }
                return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
        }
        if (this.processFunc) {
            checkSignal(_request.#signal);
            try {
                response = await this.processFunc(req, response);
            }
            catch (error) {
                // Something went wrong during processing; throw a 5xx server error
                if (error.throttle == null || typeof (error.stall) !== "number") {
                    response.makeServerError("error in post-processing function", error).assertOk();
                }
                // Throttle
                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                ;
                if (error.stall >= 0) {
                    delay = error.stall;
                }
                return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
        }
        return response;
    }
    /**
     *  Resolves to the response by sending the request.
     */
    send() {
        (0, errors_js_1.assert)(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
        this.#signal = new FetchCancelSignal(this);
        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
    }
    /**
     *  Cancels the inflight response, causing a ``CANCELLED``
     *  error to be rejected from the [[send]].
     */
    cancel() {
        (0, errors_js_1.assert)(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
        const signal = fetchSignals.get(this);
        if (!signal) {
            throw new Error("missing signal; should not happen");
        }
        signal();
    }
    /**
     *  Returns a new [[FetchRequest]] that represents the redirection
     *  to %%location%%.
     */
    redirect(location) {
        // Redirection; for now we only support absolute locations
        const current = this.url.split(":")[0].toLowerCase();
        const target = location.split(":")[0].toLowerCase();
        // Don't allow redirecting:
        // - non-GET requests
        // - downgrading the security (e.g. https => http)
        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
        (0, errors_js_1.assert)(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
        });
        // Create a copy of this request, with a new URL
        const req = new FetchRequest(location);
        req.method = "GET";
        req.allowGzip = this.allowGzip;
        req.timeout = this.timeout;
        req.#headers = Object.assign({}, this.#headers);
        if (this.#body) {
            req.#body = new Uint8Array(this.#body);
        }
        req.#bodyType = this.#bodyType;
        // Do not forward credentials unless on the same domain; only absolute
        //req.allowInsecure = false;
        // paths are currently supported; may want a way to specify to forward?
        //setStore(req.#props, "creds", getStore(this.#pros, "creds"));
        return req;
    }
    /**
     *  Create a new copy of this request.
     */
    clone() {
        const clone = new FetchRequest(this.url);
        // Preserve "default method" (i.e. null)
        clone.#method = this.#method;
        // Preserve "default body" with type, copying the Uint8Array is present
        if (this.#body) {
            clone.#body = this.#body;
        }
        clone.#bodyType = this.#bodyType;
        // Preserve "default headers"
        clone.#headers = Object.assign({}, this.#headers);
        // Credentials is readonly, so we copy internally
        clone.#creds = this.#creds;
        if (this.allowGzip) {
            clone.allowGzip = true;
        }
        clone.timeout = this.timeout;
        if (this.allowInsecureAuthentication) {
            clone.allowInsecureAuthentication = true;
        }
        clone.#preflight = this.#preflight;
        clone.#process = this.#process;
        clone.#retry = this.#retry;
        clone.#throttle = Object.assign({}, this.#throttle);
        clone.#getUrlFunc = this.#getUrlFunc;
        return clone;
    }
    /**
     *  Locks all static configuration for gateways and FetchGetUrlFunc
     *  registration.
     */
    static lockConfig() {
        locked = true;
    }
    /**
     *  Get the current Gateway function for %%scheme%%.
     */
    static getGateway(scheme) {
        return Gateways[scheme.toLowerCase()] || null;
    }
    /**
     *  Use the %%func%% when fetching URIs using %%scheme%%.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGateway(scheme, func) {
        scheme = scheme.toLowerCase();
        if (scheme === "http" || scheme === "https") {
            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
        }
        if (locked) {
            throw new Error("gateways locked");
        }
        Gateways[scheme] = func;
    }
    /**
     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGetUrl(getUrl) {
        if (locked) {
            throw new Error("gateways locked");
        }
        defaultGetUrlFunc = getUrl;
    }
    /**
     *  Creates a getUrl function that fetches content from HTTP and
     *  HTTPS URLs.
     *
     *  The available %%options%% are dependent on the platform
     *  implementation of the default getUrl function.
     *
     *  This is not generally something that is needed, but is useful
     *  when trying to customize simple behaviour when fetching HTTP
     *  content.
     */
    static createGetUrlFunc(options) {
        return (0, geturl_js_1.createGetUrl)(options);
    }
    /**
     *  Creates a function that can "fetch" data URIs.
     *
     *  Note that this is automatically done internally to support
     *  data URIs, so it is not necessary to register it.
     *
     *  This is not generally something that is needed, but may
     *  be useful in a wrapper to perfom custom data URI functionality.
     */
    static createDataGateway() {
        return dataGatewayFunc;
    }
    /**
     *  Creates a function that will fetch IPFS (unvalidated) from
     *  a custom gateway baseUrl.
     *
     *  The default IPFS gateway used internally is
     *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
     */
    static createIpfsGatewayFunc(baseUrl) {
        return getIpfsGatewayFunc(baseUrl);
    }
}
exports.FetchRequest = FetchRequest;
;
/**
 *  The response for a FetchRequest.
 */
class FetchResponse {
    #statusCode;
    #statusMessage;
    #headers;
    #body;
    #request;
    #error;
    toString() {
        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : "null"}>`;
    }
    /**
     *  The response status code.
     */
    get statusCode() { return this.#statusCode; }
    /**
     *  The response status message.
     */
    get statusMessage() { return this.#statusMessage; }
    /**
     *  The response headers. All keys are lower-case.
     */
    get headers() { return Object.assign({}, this.#headers); }
    /**
     *  The response body, or ``null`` if there was no body.
     */
    get body() {
        return (this.#body == null) ? null : new Uint8Array(this.#body);
    }
    /**
     *  The response body as a UTF-8 encoded string, or the empty
     *  string (i.e. ``""``) if there was no body.
     *
     *  An error is thrown if the body is invalid UTF-8 data.
     */
    get bodyText() {
        try {
            return (this.#body == null) ? "" : (0, utf8_js_1.toUtf8String)(this.#body);
        }
        catch (error) {
            (0, errors_js_1.assert)(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                operation: "bodyText", info: { response: this }
            });
        }
    }
    /**
     *  The response body, decoded as JSON.
     *
     *  An error is thrown if the body is invalid JSON-encoded data
     *  or if there was no body.
     */
    get bodyJson() {
        try {
            return JSON.parse(this.bodyText);
        }
        catch (error) {
            (0, errors_js_1.assert)(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                operation: "bodyJson", info: { response: this }
            });
        }
    }
    [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    const key = keys[index++];
                    return {
                        value: [key, headers[key]], done: false
                    };
                }
                return { value: undefined, done: true };
            }
        };
    }
    constructor(statusCode, statusMessage, headers, body, request) {
        this.#statusCode = statusCode;
        this.#statusMessage = statusMessage;
        this.#headers = Object.keys(headers).reduce((accum, k) => {
            accum[k.toLowerCase()] = String(headers[k]);
            return accum;
        }, {});
        this.#body = ((body == null) ? null : new Uint8Array(body));
        this.#request = (request || null);
        this.#error = { message: "" };
    }
    /**
     *  Return a Response with matching headers and body, but with
     *  an error status code (i.e. 599) and %%message%% with an
     *  optional %%error%%.
     */
    makeServerError(message, error) {
        let statusMessage;
        if (!message) {
            message = `${this.statusCode} ${this.statusMessage}`;
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
        }
        else {
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
        }
        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
        response.#error = { message, error };
        return response;
    }
    /**
     *  If called within a [request.processFunc](FetchRequest-processFunc)
     *  call, causes the request to retry as if throttled for %%stall%%
     *  milliseconds.
     */
    throwThrottleError(message, stall) {
        if (stall == null) {
            stall = -1;
        }
        else {
            (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
        }
        const error = new Error(message || "throttling requests");
        (0, properties_js_1.defineProperties)(error, { stall, throttle: true });
        throw error;
    }
    /**
     *  Get the header value for %%key%%, ignoring case.
     */
    getHeader(key) {
        return this.headers[key.toLowerCase()];
    }
    /**
     *  Returns true if the response has a body.
     */
    hasBody() {
        return (this.#body != null);
    }
    /**
     *  The request made for this response.
     */
    get request() { return this.#request; }
    /**
     *  Returns true if this response was a success statusCode.
     */
    ok() {
        return (this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300);
    }
    /**
     *  Throws a ``SERVER_ERROR`` if this response is not ok.
     */
    assertOk() {
        if (this.ok()) {
            return;
        }
        let { message, error } = this.#error;
        if (message === "") {
            message = `server response ${this.statusCode} ${this.statusMessage}`;
        }
        let requestUrl = null;
        if (this.request) {
            requestUrl = this.request.url;
        }
        let responseBody = null;
        try {
            if (this.#body) {
                responseBody = (0, utf8_js_1.toUtf8String)(this.#body);
            }
        }
        catch (e) { }
        (0, errors_js_1.assert)(false, message, "SERVER_ERROR", {
            request: (this.request || "unknown request"), response: this, error,
            info: {
                requestUrl, responseBody,
                responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
        });
    }
}
exports.FetchResponse = FetchResponse;
function getTime() { return (new Date()).getTime(); }
function unpercent(value) {
    return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
        return String.fromCharCode(parseInt(code, 16));
    }));
}
function wait(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
}
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/fixednumber.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/fixednumber.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedNumber = void 0;
/**
 *  The **FixedNumber** class permits using values with decimal places,
 *  using fixed-pont math.
 *
 *  Fixed-point math is still based on integers under-the-hood, but uses an
 *  internal offset to store fractional components below, and each operation
 *  corrects for this after each operation.
 *
 *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]
 */
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const maths_js_1 = __webpack_require__(/*! ./maths.js */ "../node_modules/ethers/lib.commonjs/utils/maths.js");
const properties_js_1 = __webpack_require__(/*! ./properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
const BN_N1 = BigInt(-1);
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_5 = BigInt(5);
const _guard = {};
// Constant to pull zeros from for multipliers
let Zeros = "0000";
while (Zeros.length < 80) {
    Zeros += Zeros;
}
// Returns a string "1" followed by decimal "0"s
function getTens(decimals) {
    let result = Zeros;
    while (result.length < decimals) {
        result += result;
    }
    return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
    const width = BigInt(format.width);
    if (format.signed) {
        const limit = (BN_1 << (width - BN_1));
        (0, errors_js_1.assert)(safeOp == null || (val >= -limit && val < limit), "overflow", "NUMERIC_FAULT", {
            operation: safeOp, fault: "overflow", value: val
        });
        if (val > BN_0) {
            val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);
        }
        else {
            val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);
        }
    }
    else {
        const limit = (BN_1 << width);
        (0, errors_js_1.assert)(safeOp == null || (val >= 0 && val < limit), "overflow", "NUMERIC_FAULT", {
            operation: safeOp, fault: "overflow", value: val
        });
        val = (((val % limit) + limit) % limit) & (limit - BN_1);
    }
    return val;
}
function getFormat(value) {
    if (typeof (value) === "number") {
        value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof (value) === "string") {
        // Parse the format string
        if (value === "fixed") {
            // defaults...
        }
        else if (value === "ufixed") {
            signed = false;
        }
        else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            (0, errors_js_1.assertArgument)(match, "invalid fixed format", "format", value);
            signed = (match[1] !== "u");
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
        }
    }
    else if (value) {
        // Extract the values from the object
        const v = value;
        const check = (key, type, defaultValue) => {
            if (v[key] == null) {
                return defaultValue;
            }
            (0, errors_js_1.assertArgument)(typeof (v[key]) === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
            return v[key];
        };
        signed = check("signed", "boolean", signed);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
    }
    (0, errors_js_1.assertArgument)((width % 8) === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
    (0, errors_js_1.assertArgument)(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
    const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    return { signed, width, decimals, name };
}
function toString(val, decimals) {
    let negative = "";
    if (val < BN_0) {
        negative = "-";
        val *= BN_N1;
    }
    let str = val.toString();
    // No decimal point for whole values
    if (decimals === 0) {
        return (negative + str);
    }
    // Pad out to the whole component (including a whole digit)
    while (str.length <= decimals) {
        str = Zeros + str;
    }
    // Insert the decimal point
    const index = str.length - decimals;
    str = str.substring(0, index) + "." + str.substring(index);
    // Trim the whole component (leaving at least one 0)
    while (str[0] === "0" && str[1] !== ".") {
        str = str.substring(1);
    }
    // Trim the decimal component (leaving at least one 0)
    while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
        str = str.substring(0, str.length - 1);
    }
    return (negative + str);
}
/**
 *  A FixedNumber represents a value over its [[FixedFormat]]
 *  arithmetic field.
 *
 *  A FixedNumber can be used to perform math, losslessly, on
 *  values which have decmial places.
 *
 *  A FixedNumber has a fixed bit-width to store values in, and stores all
 *  values internally by multiplying the value by 10 raised to the power of
 *  %%decimals%%.
 *
 *  If operations are performed that cause a value to grow too high (close to
 *  positive infinity) or too low (close to negative infinity), the value
 *  is said to //overflow//.
 *
 *  For example, an 8-bit signed value, with 0 decimals may only be within
 *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
 *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
 *
 *  Many operation have a normal and //unsafe// variant. The normal variant
 *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
 *  variant will silently allow overflow, corrupting its value value.
 *
 *  If operations are performed that cause a value to become too small
 *  (close to zero), the value loses precison and is said to //underflow//.
 *
 *  For example, an value with 1 decimal place may store a number as small
 *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
 *  into 1 decimal place, so underflow occurs which means precision is lost
 *  and the value becomes ``0``.
 *
 *  Some operations have a normal and //signalling// variant. The normal
 *  variant will silently ignore underflow, while the //signalling// variant
 *  will thow a [[NumericFaultError]] on underflow.
 */
class FixedNumber {
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    format;
    #format;
    // The actual value (accounting for decimals)
    #val;
    // A base-10 value to multiple values by to maintain the magnitude
    #tens;
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    _value;
    // Use this when changing this file to get some typing info,
    // but then switch to any to mask the internal type
    //constructor(guard: any, value: bigint, format: _FixedFormat) {
    /**
     *  @private
     */
    constructor(guard, value, format) {
        (0, errors_js_1.assertPrivate)(guard, _guard, "FixedNumber");
        this.#val = value;
        this.#format = format;
        const _value = toString(value, format.decimals);
        (0, properties_js_1.defineProperties)(this, { format: format.name, _value });
        this.#tens = getTens(format.decimals);
    }
    /**
     *  If true, negative values are permitted, otherwise only
     *  positive values and zero are allowed.
     */
    get signed() { return this.#format.signed; }
    /**
     *  The number of bits available to store the value.
     */
    get width() { return this.#format.width; }
    /**
     *  The number of decimal places in the fixed-point arithment field.
     */
    get decimals() { return this.#format.decimals; }
    /**
     *  The value as an integer, based on the smallest unit the
     *  [[decimals]] allow.
     */
    get value() { return this.#val; }
    #checkFormat(other) {
        (0, errors_js_1.assertArgument)(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
    }
    #checkValue(val, safeOp) {
        /*
                const width = BigInt(this.width);
                if (this.signed) {
                    const limit = (BN_1 << (width - BN_1));
                    assert(safeOp == null || (val >= -limit  && val < limit), "overflow", "NUMERIC_FAULT", {
                        operation: <string>safeOp, fault: "overflow", value: val
                    });
        
                    if (val > BN_0) {
                        val = fromTwos(mask(val, width), width);
                    } else {
                        val = -fromTwos(mask(-val, width), width);
                    }
        
                } else {
                    const masked = mask(val, width);
                    assert(safeOp == null || (val >= 0 && val === masked), "overflow", "NUMERIC_FAULT", {
                        operation: <string>safeOp, fault: "overflow", value: val
                    });
                    val = masked;
                }
        */
        val = checkValue(val, this.#format, safeOp);
        return new FixedNumber(_guard, val, this.#format);
    }
    #add(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue(this.#val + o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%, ignoring overflow.
     */
    addUnsafe(other) { return this.#add(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    add(other) { return this.#add(other, "add"); }
    #sub(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue(this.#val - o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%, ignoring overflow.
     */
    subUnsafe(other) { return this.#sub(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    sub(other) { return this.#sub(other, "sub"); }
    #mul(o, safeOp) {
        this.#checkFormat(o);
        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%, ignoring overflow and underflow (precision loss).
     */
    mulUnsafe(other) { return this.#mul(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    mul(other) { return this.#mul(other, "mul"); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs or if underflow (precision loss) occurs.
     */
    mulSignal(other) {
        this.#checkFormat(other);
        const value = this.#val * other.#val;
        (0, errors_js_1.assert)((value % this.#tens) === BN_0, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal", fault: "underflow", value: this
        });
        return this.#checkValue(value / this.#tens, "mulSignal");
    }
    #div(o, safeOp) {
        (0, errors_js_1.assert)(o.#val !== BN_0, "division by zero", "NUMERIC_FAULT", {
            operation: "div", fault: "divide-by-zero", value: this
        });
        this.#checkFormat(o);
        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    divUnsafe(other) { return this.#div(other); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    div(other) { return this.#div(other, "div"); }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
     *  (precision loss) occurs.
     */
    divSignal(other) {
        (0, errors_js_1.assert)(other.#val !== BN_0, "division by zero", "NUMERIC_FAULT", {
            operation: "div", fault: "divide-by-zero", value: this
        });
        this.#checkFormat(other);
        const value = (this.#val * this.#tens);
        (0, errors_js_1.assert)((value % other.#val) === BN_0, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal", fault: "underflow", value: this
        });
        return this.#checkValue(value / other.#val, "divSignal");
    }
    /**
     *  Returns a comparison result between %%this%% and %%other%%.
     *
     *  This is suitable for use in sorting, where ``-1`` implies %%this%%
     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
     *  both are equal.
     */
    cmp(other) {
        let a = this.value, b = other.value;
        // Coerce a and b to the same magnitude
        const delta = this.decimals - other.decimals;
        if (delta > 0) {
            b *= getTens(delta);
        }
        else if (delta < 0) {
            a *= getTens(-delta);
        }
        // Comnpare
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
    /**
     *  Returns true if %%other%% is equal to %%this%%.
     */
    eq(other) { return this.cmp(other) === 0; }
    /**
     *  Returns true if %%other%% is less than to %%this%%.
     */
    lt(other) { return this.cmp(other) < 0; }
    /**
     *  Returns true if %%other%% is less than or equal to %%this%%.
     */
    lte(other) { return this.cmp(other) <= 0; }
    /**
     *  Returns true if %%other%% is greater than to %%this%%.
     */
    gt(other) { return this.cmp(other) > 0; }
    /**
     *  Returns true if %%other%% is greater than or equal to %%this%%.
     */
    gte(other) { return this.cmp(other) >= 0; }
    /**
     *  Returns a new [[FixedNumber]] which is the largest **integer**
     *  that is less than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    floor() {
        let val = this.#val;
        if (this.#val < BN_0) {
            val -= this.#tens - BN_1;
        }
        val = (this.#val / this.#tens) * this.#tens;
        return this.#checkValue(val, "floor");
    }
    /**
     *  Returns a new [[FixedNumber]] which is the smallest **integer**
     *  that is greater than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    ceiling() {
        let val = this.#val;
        if (this.#val > BN_0) {
            val += this.#tens - BN_1;
        }
        val = (this.#val / this.#tens) * this.#tens;
        return this.#checkValue(val, "ceiling");
    }
    /**
     *  Returns a new [[FixedNumber]] with the decimal component
     *  rounded up on ties at %%decimals%% places.
     */
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // Not enough precision to not already be rounded
        if (decimals >= this.decimals) {
            return this;
        }
        const delta = this.decimals - decimals;
        const bump = BN_5 * getTens(delta - 1);
        let value = this.value + bump;
        const tens = getTens(delta);
        value = (value / tens) * tens;
        checkValue(value, this.#format, "round");
        return new FixedNumber(_guard, value, this.#format);
    }
    /**
     *  Returns true if %%this%% is equal to ``0``.
     */
    isZero() { return (this.#val === BN_0); }
    /**
     *  Returns true if %%this%% is less than ``0``.
     */
    isNegative() { return (this.#val < BN_0); }
    /**
     *  Returns the string representation of %%this%%.
     */
    toString() { return this._value; }
    /**
     *  Returns a float approximation.
     *
     *  Due to IEEE 754 precission (or lack thereof), this function
     *  can only return an approximation and most values will contain
     *  rounding errors.
     */
    toUnsafeFloat() { return parseFloat(this.toString()); }
    /**
     *  Return a new [[FixedNumber]] with the same value but has had
     *  its field set to %%format%%.
     *
     *  This will throw if the value cannot fit into %%format%%.
     */
    toFormat(format) {
        return FixedNumber.fromString(this.toString(), format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% divided by
     *  %%decimal%% places with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
     *  or underflow (precision loss).
     */
    static fromValue(_value, _decimals, _format) {
        const decimals = (_decimals == null) ? 0 : (0, maths_js_1.getNumber)(_decimals);
        const format = getFormat(_format);
        let value = (0, maths_js_1.getBigInt)(_value, "value");
        const delta = decimals - format.decimals;
        if (delta > 0) {
            const tens = getTens(delta);
            (0, errors_js_1.assert)((value % tens) === BN_0, "value loses precision for format", "NUMERIC_FAULT", {
                operation: "fromValue", fault: "underflow", value: _value
            });
            value /= tens;
        }
        else if (delta < 0) {
            value *= getTens(-delta);
        }
        checkValue(value, format, "fromValue");
        return new FixedNumber(_guard, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%%, either due to overflow or underflow (precision loss).
     */
    static fromString(_value, _format) {
        const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        (0, errors_js_1.assertArgument)(match && (match[2].length + match[3].length) > 0, "invalid FixedNumber string value", "value", _value);
        const format = getFormat(_format);
        let whole = (match[2] || "0"), decimal = (match[3] || "");
        // Pad out the decimals
        while (decimal.length < format.decimals) {
            decimal += Zeros;
        }
        // Check precision is safe
        (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString", fault: "underflow", value: _value
        });
        // Remove extra padding
        decimal = decimal.substring(0, format.decimals);
        const value = BigInt(match[1] + whole + decimal);
        checkValue(value, format, "fromString");
        return new FixedNumber(_guard, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] with the big-endian representation
     *  %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%% due to overflow.
     */
    static fromBytes(_value, _format) {
        let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, "value"));
        const format = getFormat(_format);
        if (format.signed) {
            value = (0, maths_js_1.fromTwos)(value, format.width);
        }
        checkValue(value, format, "fromBytes");
        return new FixedNumber(_guard, value, format);
    }
}
exports.FixedNumber = FixedNumber;
//const f1 = FixedNumber.fromString("12.56", "fixed16x2");
//const f2 = FixedNumber.fromString("0.3", "fixed16x2");
//console.log(f1.divSignal(f2));
//const BUMP = FixedNumber.from("0.5");
//# sourceMappingURL=fixednumber.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/geturl.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/geturl.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUrl = exports.createGetUrl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.js");
const http_1 = tslib_1.__importDefault(__webpack_require__(/*! http */ "http"));
const https_1 = tslib_1.__importDefault(__webpack_require__(/*! https */ "https"));
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
/**
 *  @_ignore:
 */
function createGetUrl(options) {
    async function getUrl(req, signal) {
        const protocol = req.url.split(":")[0].toLowerCase();
        (0, errors_js_1.assert)(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
            info: { protocol },
            operation: "request"
        });
        (0, errors_js_1.assert)(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
        });
        const method = req.method;
        const headers = Object.assign({}, req.headers);
        const reqOptions = { method, headers };
        if (options) {
            if (options.agent) {
                reqOptions.agent = options.agent;
            }
        }
        const request = ((protocol === "http") ? http_1.default : https_1.default).request(req.url, reqOptions);
        request.setTimeout(req.timeout);
        const body = req.body;
        if (body) {
            request.write(Buffer.from(body));
        }
        request.end();
        return new Promise((resolve, reject) => {
            // @TODO: Node 15 added AbortSignal; once we drop support for
            // Node14, we can add that in here too
            request.once("response", (resp) => {
                const statusCode = resp.statusCode || 0;
                const statusMessage = resp.statusMessage || "";
                const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {
                    let value = resp.headers[name] || "";
                    if (Array.isArray(value)) {
                        value = value.join(", ");
                    }
                    accum[name] = value;
                    return accum;
                }, {});
                let body = null;
                //resp.setEncoding("utf8");
                resp.on("data", (chunk) => {
                    if (signal) {
                        try {
                            signal.checkSignal();
                        }
                        catch (error) {
                            return reject(error);
                        }
                    }
                    if (body == null) {
                        body = chunk;
                    }
                    else {
                        const newBody = new Uint8Array(body.length + chunk.length);
                        newBody.set(body, 0);
                        newBody.set(chunk, body.length);
                        body = newBody;
                    }
                });
                resp.on("end", () => {
                    if (headers["content-encoding"] === "gzip" && body) {
                        body = (0, data_js_1.getBytes)((0, zlib_1.gunzipSync)(body));
                    }
                    resolve({ statusCode, statusMessage, headers, body });
                });
                resp.on("error", (error) => {
                    //@TODO: Should this just return nornal response with a server error?
                    error.response = { statusCode, statusMessage, headers, body };
                    reject(error);
                });
            });
            request.on("error", (error) => { reject(error); });
        });
    }
    return getUrl;
}
exports.createGetUrl = createGetUrl;
// @TODO: remove in v7; provided for backwards compat
const defaultGetUrl = createGetUrl({});
/**
 *  @_ignore:
 */
async function getUrl(req, signal) {
    return defaultGetUrl(req, signal);
}
exports.getUrl = getUrl;
//# sourceMappingURL=geturl.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  There are many simple utilities required to interact with
 *  Ethereum and to simplify the library, without increasing
 *  the library dependencies for simple functions.
 *
 *  @_section api/utils:Utilities  [about-utils]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;
exports.uuidV4 = exports.Utf8ErrorFuncs = void 0;
var base58_js_1 = __webpack_require__(/*! ./base58.js */ "../node_modules/ethers/lib.commonjs/utils/base58.js");
Object.defineProperty(exports, "decodeBase58", ({ enumerable: true, get: function () { return base58_js_1.decodeBase58; } }));
Object.defineProperty(exports, "encodeBase58", ({ enumerable: true, get: function () { return base58_js_1.encodeBase58; } }));
var base64_js_1 = __webpack_require__(/*! ./base64.js */ "../node_modules/ethers/lib.commonjs/utils/base64.js");
Object.defineProperty(exports, "decodeBase64", ({ enumerable: true, get: function () { return base64_js_1.decodeBase64; } }));
Object.defineProperty(exports, "encodeBase64", ({ enumerable: true, get: function () { return base64_js_1.encodeBase64; } }));
var data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
Object.defineProperty(exports, "getBytes", ({ enumerable: true, get: function () { return data_js_1.getBytes; } }));
Object.defineProperty(exports, "getBytesCopy", ({ enumerable: true, get: function () { return data_js_1.getBytesCopy; } }));
Object.defineProperty(exports, "isHexString", ({ enumerable: true, get: function () { return data_js_1.isHexString; } }));
Object.defineProperty(exports, "isBytesLike", ({ enumerable: true, get: function () { return data_js_1.isBytesLike; } }));
Object.defineProperty(exports, "hexlify", ({ enumerable: true, get: function () { return data_js_1.hexlify; } }));
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return data_js_1.concat; } }));
Object.defineProperty(exports, "dataLength", ({ enumerable: true, get: function () { return data_js_1.dataLength; } }));
Object.defineProperty(exports, "dataSlice", ({ enumerable: true, get: function () { return data_js_1.dataSlice; } }));
Object.defineProperty(exports, "stripZerosLeft", ({ enumerable: true, get: function () { return data_js_1.stripZerosLeft; } }));
Object.defineProperty(exports, "zeroPadValue", ({ enumerable: true, get: function () { return data_js_1.zeroPadValue; } }));
Object.defineProperty(exports, "zeroPadBytes", ({ enumerable: true, get: function () { return data_js_1.zeroPadBytes; } }));
var errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
Object.defineProperty(exports, "isCallException", ({ enumerable: true, get: function () { return errors_js_1.isCallException; } }));
Object.defineProperty(exports, "isError", ({ enumerable: true, get: function () { return errors_js_1.isError; } }));
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return errors_js_1.assert; } }));
Object.defineProperty(exports, "assertArgument", ({ enumerable: true, get: function () { return errors_js_1.assertArgument; } }));
Object.defineProperty(exports, "assertArgumentCount", ({ enumerable: true, get: function () { return errors_js_1.assertArgumentCount; } }));
Object.defineProperty(exports, "assertPrivate", ({ enumerable: true, get: function () { return errors_js_1.assertPrivate; } }));
Object.defineProperty(exports, "assertNormalize", ({ enumerable: true, get: function () { return errors_js_1.assertNormalize; } }));
Object.defineProperty(exports, "makeError", ({ enumerable: true, get: function () { return errors_js_1.makeError; } }));
var events_js_1 = __webpack_require__(/*! ./events.js */ "../node_modules/ethers/lib.commonjs/utils/events.js");
Object.defineProperty(exports, "EventPayload", ({ enumerable: true, get: function () { return events_js_1.EventPayload; } }));
var fetch_js_1 = __webpack_require__(/*! ./fetch.js */ "../node_modules/ethers/lib.commonjs/utils/fetch.js");
Object.defineProperty(exports, "FetchRequest", ({ enumerable: true, get: function () { return fetch_js_1.FetchRequest; } }));
Object.defineProperty(exports, "FetchResponse", ({ enumerable: true, get: function () { return fetch_js_1.FetchResponse; } }));
Object.defineProperty(exports, "FetchCancelSignal", ({ enumerable: true, get: function () { return fetch_js_1.FetchCancelSignal; } }));
var fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ "../node_modules/ethers/lib.commonjs/utils/fixednumber.js");
Object.defineProperty(exports, "FixedNumber", ({ enumerable: true, get: function () { return fixednumber_js_1.FixedNumber; } }));
var maths_js_1 = __webpack_require__(/*! ./maths.js */ "../node_modules/ethers/lib.commonjs/utils/maths.js");
Object.defineProperty(exports, "fromTwos", ({ enumerable: true, get: function () { return maths_js_1.fromTwos; } }));
Object.defineProperty(exports, "toTwos", ({ enumerable: true, get: function () { return maths_js_1.toTwos; } }));
Object.defineProperty(exports, "mask", ({ enumerable: true, get: function () { return maths_js_1.mask; } }));
Object.defineProperty(exports, "getBigInt", ({ enumerable: true, get: function () { return maths_js_1.getBigInt; } }));
Object.defineProperty(exports, "getNumber", ({ enumerable: true, get: function () { return maths_js_1.getNumber; } }));
Object.defineProperty(exports, "getUint", ({ enumerable: true, get: function () { return maths_js_1.getUint; } }));
Object.defineProperty(exports, "toBigInt", ({ enumerable: true, get: function () { return maths_js_1.toBigInt; } }));
Object.defineProperty(exports, "toNumber", ({ enumerable: true, get: function () { return maths_js_1.toNumber; } }));
Object.defineProperty(exports, "toBeHex", ({ enumerable: true, get: function () { return maths_js_1.toBeHex; } }));
Object.defineProperty(exports, "toBeArray", ({ enumerable: true, get: function () { return maths_js_1.toBeArray; } }));
Object.defineProperty(exports, "toQuantity", ({ enumerable: true, get: function () { return maths_js_1.toQuantity; } }));
var properties_js_1 = __webpack_require__(/*! ./properties.js */ "../node_modules/ethers/lib.commonjs/utils/properties.js");
Object.defineProperty(exports, "resolveProperties", ({ enumerable: true, get: function () { return properties_js_1.resolveProperties; } }));
Object.defineProperty(exports, "defineProperties", ({ enumerable: true, get: function () { return properties_js_1.defineProperties; } }));
var rlp_decode_js_1 = __webpack_require__(/*! ./rlp-decode.js */ "../node_modules/ethers/lib.commonjs/utils/rlp-decode.js");
Object.defineProperty(exports, "decodeRlp", ({ enumerable: true, get: function () { return rlp_decode_js_1.decodeRlp; } }));
var rlp_encode_js_1 = __webpack_require__(/*! ./rlp-encode.js */ "../node_modules/ethers/lib.commonjs/utils/rlp-encode.js");
Object.defineProperty(exports, "encodeRlp", ({ enumerable: true, get: function () { return rlp_encode_js_1.encodeRlp; } }));
var units_js_1 = __webpack_require__(/*! ./units.js */ "../node_modules/ethers/lib.commonjs/utils/units.js");
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return units_js_1.formatEther; } }));
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return units_js_1.parseEther; } }));
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return units_js_1.formatUnits; } }));
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return units_js_1.parseUnits; } }));
var utf8_js_1 = __webpack_require__(/*! ./utf8.js */ "../node_modules/ethers/lib.commonjs/utils/utf8.js");
Object.defineProperty(exports, "toUtf8Bytes", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8Bytes; } }));
Object.defineProperty(exports, "toUtf8CodePoints", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8CodePoints; } }));
Object.defineProperty(exports, "toUtf8String", ({ enumerable: true, get: function () { return utf8_js_1.toUtf8String; } }));
Object.defineProperty(exports, "Utf8ErrorFuncs", ({ enumerable: true, get: function () { return utf8_js_1.Utf8ErrorFuncs; } }));
var uuid_js_1 = __webpack_require__(/*! ./uuid.js */ "../node_modules/ethers/lib.commonjs/utils/uuid.js");
Object.defineProperty(exports, "uuidV4", ({ enumerable: true, get: function () { return uuid_js_1.uuidV4; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/maths.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/maths.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;
/**
 *  Some mathematic operations.
 *
 *  @_subsection: api/utils:Math Helpers  [about-maths]
 */
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
// IEEE 754 support 53-bits of mantissa
const maxValue = 0x1fffffffffffff;
/**
 *  Convert %%value%% from a twos-compliment representation of %%width%%
 *  bits to its value.
 *
 *  If the highest bit is ``1``, the result will be negative.
 */
function fromTwos(_value, _width) {
    const value = getUint(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    (0, errors_js_1.assert)((value >> width) === BN_0, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos", fault: "overflow", value: _value
    });
    // Top bit set; treat as a negative value
    if (value >> (width - BN_1)) {
        const mask = (BN_1 << width) - BN_1;
        return -(((~value) & mask) + BN_1);
    }
    return value;
}
exports.fromTwos = fromTwos;
/**
 *  Convert %%value%% to a twos-compliment representation of
 *  %%width%% bits.
 *
 *  The result will always be positive.
 */
function toTwos(_value, _width) {
    let value = getBigInt(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    const limit = (BN_1 << (width - BN_1));
    if (value < BN_0) {
        value = -value;
        (0, errors_js_1.assert)(value <= limit, "too low", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
        const mask = (BN_1 << width) - BN_1;
        return ((~value) & mask) + BN_1;
    }
    else {
        (0, errors_js_1.assert)(value < limit, "too high", "NUMERIC_FAULT", {
            operation: "toTwos", fault: "overflow", value: _value
        });
    }
    return value;
}
exports.toTwos = toTwos;
/**
 *  Mask %%value%% with a bitmask of %%bits%% ones.
 */
function mask(_value, _bits) {
    const value = getUint(_value, "value");
    const bits = BigInt(getNumber(_bits, "bits"));
    return value & ((BN_1 << bits) - BN_1);
}
exports.mask = mask;
/**
 *  Gets a BigInt from %%value%%. If it is an invalid value for
 *  a BigInt, then an ArgumentError will be thrown for %%name%%.
 */
function getBigInt(value, name) {
    switch (typeof (value)) {
        case "bigint": return value;
        case "number":
            (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return BigInt(value);
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                if (value[0] === "-" && value[1] !== "-") {
                    return -BigInt(value.substring(1));
                }
                return BigInt(value);
            }
            catch (e) {
                (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
            }
    }
    (0, errors_js_1.assertArgument)(false, "invalid BigNumberish value", name || "value", value);
}
exports.getBigInt = getBigInt;
/**
 *  Returns %%value%% as a bigint, validating it is valid as a bigint
 *  value and that it is positive.
 */
function getUint(value, name) {
    const result = getBigInt(value, name);
    (0, errors_js_1.assert)(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow", operation: "getUint", value
    });
    return result;
}
exports.getUint = getUint;
const Nibbles = "0123456789abcdef";
/*
 * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
 * is treated as Big Endian data.
 */
function toBigInt(value) {
    if (value instanceof Uint8Array) {
        let result = "0x0";
        for (const v of value) {
            result += Nibbles[v >> 4];
            result += Nibbles[v & 0x0f];
        }
        return BigInt(result);
    }
    return getBigInt(value);
}
exports.toBigInt = toBigInt;
/**
 *  Gets a //number// from %%value%%. If it is an invalid value for
 *  a //number//, then an ArgumentError will be thrown for %%name%%.
 */
function getNumber(value, name) {
    switch (typeof (value)) {
        case "bigint":
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return Number(value);
        case "number":
            (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return value;
        case "string":
            try {
                if (value === "") {
                    throw new Error("empty string");
                }
                return getNumber(BigInt(value), name);
            }
            catch (e) {
                (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || "value", value);
            }
    }
    (0, errors_js_1.assertArgument)(false, "invalid numeric value", name || "value", value);
}
exports.getNumber = getNumber;
/**
 *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
 *  is treated as Big Endian data. Throws if the value is not safe.
 */
function toNumber(value) {
    return getNumber(toBigInt(value));
}
exports.toNumber = toNumber;
/**
 *  Converts %%value%% to a Big Endian hexstring, optionally padded to
 *  %%width%% bytes.
 */
function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
        // Ensure the value is of even length
        if (result.length % 2) {
            result = "0" + result;
        }
    }
    else {
        const width = getNumber(_width, "width");
        (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: _value
        });
        // Pad the value to the required width
        while (result.length < (width * 2)) {
            result = "0" + result;
        }
    }
    return "0x" + result;
}
exports.toBeHex = toBeHex;
/**
 *  Converts %%value%% to a Big Endian Uint8Array.
 */
function toBeArray(_value) {
    const value = getUint(_value, "value");
    if (value === BN_0) {
        return new Uint8Array([]);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
        hex = "0" + hex;
    }
    const result = new Uint8Array(hex.length / 2);
    for (let i = 0; i < result.length; i++) {
        const offset = i * 2;
        result[i] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
}
exports.toBeArray = toBeArray;
/**
 *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
 *
 *  A //Quantity// does not have and leading 0 values unless the value is
 *  the literal value `0x0`. This is most commonly used for JSSON-RPC
 *  numeric values.
 */
function toQuantity(value) {
    let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);
    while (result.startsWith("0")) {
        result = result.substring(1);
    }
    if (result === "") {
        result = "0";
    }
    return "0x" + result;
}
exports.toQuantity = toQuantity;
//# sourceMappingURL=maths.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/properties.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/properties.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 *  Property helper functions.
 *
 *  @_subsection api/utils:Properties  [about-properties]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineProperties = exports.resolveProperties = void 0;
function checkType(value, type, name) {
    const types = type.split("|").map(t => t.trim());
    for (let i = 0; i < types.length; i++) {
        switch (type) {
            case "any":
                return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
                if (typeof (value) === type) {
                    return;
                }
        }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
}
/**
 *  Resolves to a new object that is a copy of %%value%%, but with all
 *  values resolved.
 */
async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
    return results.reduce((accum, v, index) => {
        accum[keys[index]] = v;
        return accum;
    }, {});
}
exports.resolveProperties = resolveProperties;
/**
 *  Assigns the %%values%% to %%target%% as read-only values.
 *
 *  It %%types%% is specified, the values are checked.
 */
function defineProperties(target, values, types) {
    for (let key in values) {
        let value = values[key];
        const type = (types ? types[key] : null);
        if (type) {
            checkType(value, type, key);
        }
        Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
}
exports.defineProperties = defineProperties;
//# sourceMappingURL=properties.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/rlp-decode.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/rlp-decode.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//See: https://github.com/ethereum/wiki/wiki/RLP
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeRlp = void 0;
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const data_js_2 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
function hexlifyByte(value) {
    let result = value.toString(16);
    while (result.length < 2) {
        result = "0" + result;
    }
    return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        (0, errors_js_1.assert)(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
            buffer: data, length, offset
        });
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    (0, errors_js_1.assert)(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: data, length: 0, offset: 1
    });
    const checkOffset = (offset) => {
        (0, errors_js_1.assert)(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: data, length: data.length, offset
        });
    };
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        checkOffset(offset + 1 + lengthLength);
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length);
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        checkOffset(offset + 1 + length);
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        checkOffset(offset + 1 + lengthLength);
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length);
        const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        checkOffset(offset + 1 + length);
        const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlifyByte(data[offset]) };
}
/**
 *  Decodes %%data%% into the structured data it represents.
 */
function decodeRlp(_data) {
    const data = (0, data_js_2.getBytes)(_data, "data");
    const decoded = _decode(data, 0);
    (0, errors_js_1.assertArgument)(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
    return decoded.result;
}
exports.decodeRlp = decodeRlp;
//# sourceMappingURL=rlp-decode.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/rlp-encode.js":
/*!***************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/rlp-encode.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//See: https://github.com/ethereum/wiki/wiki/RLP
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeRlp = void 0;
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    const data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, "object"));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
const nibbles = "0123456789abcdef";
/**
 *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
 */
function encodeRlp(object) {
    let result = "0x";
    for (const v of _encode(object)) {
        result += nibbles[v >> 4];
        result += nibbles[v & 0xf];
    }
    return result;
}
exports.encodeRlp = encodeRlp;
//# sourceMappingURL=rlp-encode.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/units.js":
/*!**********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/units.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;
/**
 *  Most interactions with Ethereum requires integer values, which use
 *  the smallest magnitude unit.
 *
 *  For example, imagine dealing with dollars and cents. Since dollars
 *  are divisible, non-integer values are possible, such as ``$10.77``.
 *  By using the smallest indivisible unit (i.e. cents), the value can
 *  be kept as the integer ``1077``.
 *
 *  When receiving decimal input from the user (as a decimal string),
 *  the value should be converted to an integer and when showing a user
 *  a value, the integer value should be converted to a decimal string.
 *
 *  This creates a clear distinction, between values to be used by code
 *  (integers) and values used for display logic to users (decimals).
 *
 *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,
 *  where each individual unit is called a //wei//.
 *
 *  @_subsection api/utils:Unit Conversion  [about-units]
 */
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
const fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ "../node_modules/ethers/lib.commonjs/utils/fixednumber.js");
const maths_js_1 = __webpack_require__(/*! ./maths.js */ "../node_modules/ethers/lib.commonjs/utils/maths.js");
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether",
];
/**
 *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
 *  places. The %%unit%% may be the number of decimal places or the name of
 *  a unit (e.g. ``"gwei"`` for 9 decimal places).
 *
 */
function formatUnits(value, unit) {
    let decimals = 18;
    if (typeof (unit) === "string") {
        const index = names.indexOf(unit);
        (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index;
    }
    else if (unit != null) {
        decimals = (0, maths_js_1.getNumber)(unit, "unit");
    }
    return fixednumber_js_1.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
exports.formatUnits = formatUnits;
/**
 *  Converts the //decimal string// %%value%% to a BigInt, assuming
 *  %%unit%% decimal places. The %%unit%% may the number of decimal places
 *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
 */
function parseUnits(value, unit) {
    (0, errors_js_1.assertArgument)(typeof (value) === "string", "value must be a string", "value", value);
    let decimals = 18;
    if (typeof (unit) === "string") {
        const index = names.indexOf(unit);
        (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index;
    }
    else if (unit != null) {
        decimals = (0, maths_js_1.getNumber)(unit, "unit");
    }
    return fixednumber_js_1.FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
exports.parseUnits = parseUnits;
/**
 *  Converts %%value%% into a //decimal string// using 18 decimal places.
 */
function formatEther(wei) {
    return formatUnits(wei, 18);
}
exports.formatEther = formatEther;
/**
 *  Converts the //decimal string// %%ether%% to a BigInt, using 18
 *  decimal places.
 */
function parseEther(ether) {
    return parseUnits(ether, 18);
}
exports.parseEther = parseEther;
//# sourceMappingURL=units.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/utf8.js":
/*!*********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/utf8.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;
/**
 *  Using strings in Ethereum (or any security-basd system) requires
 *  additional care. These utilities attempt to mitigate some of the
 *  safety issues as well as provide the ability to recover and analyse
 *  strings.
 *
 *  @_subsection api/utils:Strings and UTF-8  [about-strings]
 */
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
const errors_js_1 = __webpack_require__(/*! ./errors.js */ "../node_modules/ethers/lib.commonjs/utils/errors.js");
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    (0, errors_js_1.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === "OVERRUN") {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === "OVERLONG") {
        (0, errors_js_1.assertArgument)(typeof (badCodepoint) === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
/**
 *  A handful of popular, built-in UTF-8 error handling strategies.
 *
 *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
 *  non-canonical (overlong) codepoints (this is the default)
 *
 *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
 *  and accepts non-canonical (overlong) codepoints
 *
 *  **``"replace"``** - replace any illegal UTF-8 sequence with the
 *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
 *  non-canonical (overlong) codepoints
 *
 *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
 */
exports.Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
    }
    const bytes = (0, data_js_1.getBytes)(_bytes, "bytes");
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
            }
            else {
                i += onError("BAD_PREFIX", i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError("OVERRUN", i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError("MISSING_CONTINUE", i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
/**
 *  Returns the UTF-8 byte representation of %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8Bytes(str, form) {
    (0, errors_js_1.assertArgument)(typeof (str) === "string", "invalid string value", "str", str);
    if (form != null) {
        (0, errors_js_1.assertNormalize)(form);
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            (0, errors_js_1.assertArgument)(i < str.length && ((c2 & 0xfc00) === 0xdc00), "invalid surrogate pair", "str", str);
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return new Uint8Array(result);
}
exports.toUtf8Bytes = toUtf8Bytes;
;
//export 
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
/**
 *  Returns the string represented by the UTF-8 data %%bytes%%.
 *
 *  When %%onError%% function is specified, it is called on UTF-8
 *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
 *  (default: [error](Utf8ErrorFuncs))
 */
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
exports.toUtf8String = toUtf8String;
/**
 *  Returns the UTF-8 code-points for %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8CodePoints(str, form) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}
exports.toUtf8CodePoints = toUtf8CodePoints;
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/utils/uuid.js":
/*!*********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/utils/uuid.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidV4 = void 0;
/**
 *  Explain UUID and link to RFC here.
 *
 *  @_subsection: api/utils:UUID  [about-uuid]
 */
const data_js_1 = __webpack_require__(/*! ./data.js */ "../node_modules/ethers/lib.commonjs/utils/data.js");
/**
 *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.
 *
 *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
 */
function uuidV4(randomBytes) {
    const bytes = (0, data_js_1.getBytes)(randomBytes, "randomBytes");
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    const value = (0, data_js_1.hexlify)(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34),
    ].join("-");
}
exports.uuidV4 = uuidV4;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/base-wallet.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/base-wallet.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseWallet = void 0;
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_3 = __webpack_require__(/*! ../providers/index.js */ "../node_modules/ethers/lib.commonjs/providers/index.js");
const index_js_4 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_5 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  The **BaseWallet** is a stream-lined implementation of a
 *  [[Signer]] that operates with a private key.
 *
 *  It is preferred to use the [[Wallet]] class, as it offers
 *  additional functionality and simplifies loading a variety
 *  of JSON formats, Mnemonic Phrases, etc.
 *
 *  This class may be of use for those attempting to implement
 *  a minimal Signer.
 */
class BaseWallet extends index_js_3.AbstractSigner {
    /**
     *  The wallet address.
     */
    address;
    #signingKey;
    /**
     *  Creates a new BaseWallet for %%privateKey%%, optionally
     *  connected to %%provider%%.
     *
     *  If %%provider%% is not specified, only offline methods can
     *  be used.
     */
    constructor(privateKey, provider) {
        super(provider);
        (0, index_js_5.assertArgument)(privateKey && typeof (privateKey.sign) === "function", "invalid private key", "privateKey", "[ REDACTED ]");
        this.#signingKey = privateKey;
        const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);
        (0, index_js_5.defineProperties)(this, { address });
    }
    // Store private values behind getters to reduce visibility
    // in console.log
    /**
     *  The [[SigningKey]] used for signing payloads.
     */
    get signingKey() { return this.#signingKey; }
    /**
     *  The private key for this wallet.
     */
    get privateKey() { return this.signingKey.privateKey; }
    async getAddress() { return this.address; }
    connect(provider) {
        return new BaseWallet(this.#signingKey, provider);
    }
    async signTransaction(tx) {
        // Replace any Addressable or ENS name with an address
        const { to, from } = await (0, index_js_5.resolveProperties)({
            to: (tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined),
            from: (tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined)
        });
        if (to != null) {
            tx.to = to;
        }
        if (from != null) {
            tx.from = from;
        }
        if (tx.from != null) {
            (0, index_js_5.assertArgument)((0, index_js_1.getAddress)((tx.from)) === this.address, "transaction from address mismatch", "tx.from", tx.from);
            delete tx.from;
        }
        // Build the transaction
        const btx = index_js_4.Transaction.from(tx);
        btx.signature = this.signingKey.sign(btx.unsignedHash);
        return btx.serialized;
    }
    async signMessage(message) {
        return this.signMessageSync(message);
    }
    // @TODO: Add a secialized signTx and signTyped sync that enforces
    // all parameters are known?
    /**
     *  Returns the signature for %%message%% signed with this wallet.
     */
    signMessageSync(message) {
        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
    }
    async signTypedData(domain, types, value) {
        // Populate any ENS names
        const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
            // @TODO: this should use resolveName; addresses don't
            //        need a provider
            (0, index_js_5.assert)(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                operation: "resolveName",
                info: { name }
            });
            const address = await this.provider.resolveName(name);
            (0, index_js_5.assert)(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                value: name
            });
            return address;
        });
        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
    }
}
exports.BaseWallet = BaseWallet;
//# sourceMappingURL=base-wallet.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/hdwallet.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/hdwallet.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;
/**
 *  Explain HD Wallets..
 *
 *  @_subsection: api/wallet:HD Wallets  [hd-wallets]
 */
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../providers/index.js */ "../node_modules/ethers/lib.commonjs/providers/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-en.js");
const base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ "../node_modules/ethers/lib.commonjs/wallet/base-wallet.js");
const mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ "../node_modules/ethers/lib.commonjs/wallet/mnemonic.js");
const json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ "../node_modules/ethers/lib.commonjs/wallet/json-keystore.js");
/**
 *  The default derivation path for Ethereum HD Nodes. (i.e. ``"m/44'/60'/0'/0/0"``)
 */
exports.defaultPath = "m/44'/60'/0'/0/0";
// "Bitcoin seed"
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 0x80000000;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
    let result = "";
    while (value) {
        result = Nibbles[value % 16] + result;
        value = Math.trunc(value / 16);
    }
    while (result.length < length * 2) {
        result = "0" + result;
    }
    return "0x" + result;
}
function encodeBase58Check(_value) {
    const value = (0, index_js_4.getBytes)(_value);
    const check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);
    const bytes = (0, index_js_4.concat)([value, check]);
    return (0, index_js_4.encodeBase58)(bytes);
}
const _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
        (0, index_js_4.assert)(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
            operation: "deriveChild"
        });
        // Data = 0x00 || ser_256(k_par)
        data.set((0, index_js_4.getBytes)(privateKey), 1);
    }
    else {
        // Data = ser_p(point(k_par))
        data.set((0, index_js_4.getBytes)(publicKey));
    }
    // Data += ser_32(i)
    for (let i = 24; i >= 0; i -= 8) {
        data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);
    }
    const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", chainCode, data));
    return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
    const components = path.split("/");
    (0, index_js_4.assertArgument)(components.length > 0, "invalid path", "path", path);
    if (components[0] === "m") {
        (0, index_js_4.assertArgument)(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
        components.shift();
    }
    let result = node;
    for (let i = 0; i < components.length; i++) {
        const component = components[i];
        if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", `path[${i}]`, component);
            result = result.deriveChild(HardenedBit + index);
        }
        else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", `path[${i}]`, component);
            result = result.deriveChild(index);
        }
        else {
            (0, index_js_4.assertArgument)(false, "invalid path component", `path[${i}]`, component);
        }
    }
    return result;
}
/**
 *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived
 *  from an HD Node using the [[link-bip-32]] stantard.
 *
 *  An HD Node forms a hierarchal structure with each HD Node having a
 *  private key and the ability to derive child HD Nodes, defined by
 *  a path indicating the index of each child.
 */
class HDNodeWallet extends base_wallet_js_1.BaseWallet {
    /**
     *  The compressed public key.
     */
    publicKey;
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    fingerprint;
    /**
     *  The parent fingerprint.
     */
    parentFingerprint;
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    mnemonic;
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    chainCode;
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    path;
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    index;
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    depth;
    /**
     *  @private
     */
    constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
        super(signingKey, provider);
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeWallet");
        (0, index_js_4.defineProperties)(this, { publicKey: signingKey.compressedPublicKey });
        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(this.publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(this, {
            parentFingerprint, fingerprint,
            chainCode, path, index, depth
        });
        (0, index_js_4.defineProperties)(this, { mnemonic });
    }
    connect(provider) {
        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
    }
    #account() {
        const account = { address: this.address, privateKey: this.privateKey };
        const m = this.mnemonic;
        if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
            account.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: m.entropy
            };
        }
        return account;
    }
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    async encrypt(password, progressCallback) {
        return await (0, json_keystore_js_1.encryptKeystoreJson)(this.#account(), password, { progressCallback });
    }
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    encryptSync(password) {
        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(this.#account(), password);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpriv`` and can be used to
     *  reconstruct this HD Node to derive its children.
     */
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check((0, index_js_4.concat)([
            "0x0488ADE4", zpad(this.depth, 1), this.parentFingerprint,
            zpad(this.index, 4), this.chainCode,
            (0, index_js_4.concat)(["0x00", this.privateKey])
        ]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
    hasPath() { return (this.path != null); }
    /**
     *  Returns a neutered HD Node, which removes the private details
     *  of an HD Node.
     *
     *  A neutered node has no private key, but can be used to derive
     *  child addresses and other public data about the HD Node.
     */
    neuter() {
        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
    }
    /**
     *  Return the child for %%index%%.
     */
    deriveChild(_index) {
        const index = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
        // Base path
        let path = this.path;
        if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
                path += "'";
            }
        }
        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
        const ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));
        return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
    }
    /**
     *  Return the HDNode for %%path%% from this node.
     */
    derivePath(path) {
        return derivePath(this, path);
    }
    static #fromSeed(_seed, mnemonic) {
        (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), "invalid seed", "seed", "[REDACTED]");
        const seed = (0, index_js_4.getBytes)(_seed, "seed");
        (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
        const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", MasterSecret, seed));
        const signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));
        return new HDNodeWallet(_guard, signingKey, "0x00000000", (0, index_js_4.hexlify)(I.slice(32)), "m", 0, 0, mnemonic, null);
    }
    /**
     *  Creates a new HD Node from %%extendedKey%%.
     *
     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
     *  or full HD Node ([[HDNodeWallet) respectively.
     */
    static fromExtendedKey(extendedKey) {
        const bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact
        (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
        const depth = bytes[4];
        const parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));
        const index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf": {
                const publicKey = (0, index_js_4.hexlify)(key);
                return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
            }
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
                if (key[0] !== 0) {
                    break;
                }
                return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
        }
        (0, index_js_4.assertArgument)(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
    }
    /**
     *  Creates a new random HDNode.
     */
    static createRandom(password, path, wordlist) {
        if (password == null) {
            password = "";
        }
        if (path == null) {
            path = exports.defaultPath;
        }
        if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
        }
        const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);
        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Create an HD Node from %%mnemonic%%.
     */
    static fromMnemonic(mnemonic, path) {
        if (!path) {
            path = exports.defaultPath;
        }
        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a mnemonic %%phrase%%.
     */
    static fromPhrase(phrase, password, path, wordlist) {
        if (password == null) {
            password = "";
        }
        if (path == null) {
            path = exports.defaultPath;
        }
        if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
        }
        const mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);
        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a %%seed%%.
     */
    static fromSeed(seed) {
        return HDNodeWallet.#fromSeed(seed, null);
    }
}
exports.HDNodeWallet = HDNodeWallet;
/**
 *  A **HDNodeVoidWallet** cannot sign, but provides access to
 *  the children nodes of a [[link-bip-32]] HD wallet addresses.
 *
 *  The can be created by using an extended ``xpub`` key to
 *  [[HDNodeWallet_fromExtendedKey]] or by
 *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].
 */
class HDNodeVoidWallet extends index_js_2.VoidSigner {
    /**
     *  The compressed public key.
     */
    publicKey;
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    fingerprint;
    /**
     *  The parent node fingerprint.
     */
    parentFingerprint;
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    chainCode;
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    path;
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    index;
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    depth;
    /**
     *  @private
     */
    constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
        super(address, provider);
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeVoidWallet");
        (0, index_js_4.defineProperties)(this, { publicKey });
        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(this, {
            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth
        });
    }
    connect(provider) {
        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpub`` and can be used to
     *  reconstruct this neutered key to derive its children addresses.
     */
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check((0, index_js_4.concat)([
            "0x0488B21E",
            zpad(this.depth, 1),
            this.parentFingerprint,
            zpad(this.index, 4),
            this.chainCode,
            this.publicKey,
        ]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
    hasPath() { return (this.path != null); }
    /**
     *  Return the child for %%index%%.
     */
    deriveChild(_index) {
        const index = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
        // Base path
        let path = this.path;
        if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
                path += "'";
            }
        }
        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
        const Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);
        const address = (0, index_js_3.computeAddress)(Ki);
        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);
    }
    /**
     *  Return the signer for %%path%% from this node.
     */
    derivePath(path) {
        return derivePath(this, path);
    }
}
exports.HDNodeVoidWallet = HDNodeVoidWallet;
/*
export class HDNodeWalletManager {
    #root: HDNodeWallet;

    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {
        if (password == null) { password = ""; }
        if (path == null) { path = "m/44'/60'/0'/0"; }
        if (locale == null) { locale = LangEn.wordlist(); }
        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);
    }

    getSigner(index?: number): HDNodeWallet {
        return this.#root.deriveChild((index == null) ? 0: index);
    }
}
*/
/**
 *  Returns the [[link-bip-32]] path for the account at %%index%%.
 *
 *  This is the pattern used by wallets like Ledger.
 *
 *  There is also an [alternate pattern](getIndexedAccountPath) used by
 *  some software.
 */
function getAccountPath(_index) {
    const index = (0, index_js_4.getNumber)(_index, "index");
    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
    return `m/44'/60'/${index}'/0/0`;
}
exports.getAccountPath = getAccountPath;
/**
 *  Returns the path using an alternative pattern for deriving accounts,
 *  at %%index%%.
 *
 *  This derivation path uses the //index// component rather than the
 *  //account// component to derive sequential accounts.
 *
 *  This is the pattern used by wallets like MetaMask.
 */
function getIndexedAccountPath(_index) {
    const index = (0, index_js_4.getNumber)(_index, "index");
    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
    return `m/44'/60'/0'/0/${index}`;
}
exports.getIndexedAccountPath = getIndexedAccountPath;
//# sourceMappingURL=hdwallet.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  When interacting with Ethereum, it is necessary to use a private
 *  key authenticate actions by signing a payload.
 *
 *  Wallets are the simplest way to expose the concept of an
 *  //Externally Owner Account// (EOA) as it wraps a private key
 *  and supports high-level methods to sign common types of interaction
 *  and send transactions.
 *
 *  The class most developers will want to use is [[Wallet]], which
 *  can load a private key directly or from any common wallet format.
 *
 *  The [[HDNodeWallet]] can be used when it is necessary to access
 *  low-level details of how an HD wallets are derived, exported
 *  or imported.
 *
 *  @_section: api/wallet:Wallets  [about-wallets]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;
var base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ "../node_modules/ethers/lib.commonjs/wallet/base-wallet.js");
Object.defineProperty(exports, "BaseWallet", ({ enumerable: true, get: function () { return base_wallet_js_1.BaseWallet; } }));
var hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ "../node_modules/ethers/lib.commonjs/wallet/hdwallet.js");
Object.defineProperty(exports, "defaultPath", ({ enumerable: true, get: function () { return hdwallet_js_1.defaultPath; } }));
Object.defineProperty(exports, "getAccountPath", ({ enumerable: true, get: function () { return hdwallet_js_1.getAccountPath; } }));
Object.defineProperty(exports, "getIndexedAccountPath", ({ enumerable: true, get: function () { return hdwallet_js_1.getIndexedAccountPath; } }));
Object.defineProperty(exports, "HDNodeWallet", ({ enumerable: true, get: function () { return hdwallet_js_1.HDNodeWallet; } }));
Object.defineProperty(exports, "HDNodeVoidWallet", ({ enumerable: true, get: function () { return hdwallet_js_1.HDNodeVoidWallet; } }));
var json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ "../node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js");
Object.defineProperty(exports, "isCrowdsaleJson", ({ enumerable: true, get: function () { return json_crowdsale_js_1.isCrowdsaleJson; } }));
Object.defineProperty(exports, "decryptCrowdsaleJson", ({ enumerable: true, get: function () { return json_crowdsale_js_1.decryptCrowdsaleJson; } }));
var json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ "../node_modules/ethers/lib.commonjs/wallet/json-keystore.js");
Object.defineProperty(exports, "isKeystoreJson", ({ enumerable: true, get: function () { return json_keystore_js_1.isKeystoreJson; } }));
Object.defineProperty(exports, "decryptKeystoreJsonSync", ({ enumerable: true, get: function () { return json_keystore_js_1.decryptKeystoreJsonSync; } }));
Object.defineProperty(exports, "decryptKeystoreJson", ({ enumerable: true, get: function () { return json_keystore_js_1.decryptKeystoreJson; } }));
Object.defineProperty(exports, "encryptKeystoreJson", ({ enumerable: true, get: function () { return json_keystore_js_1.encryptKeystoreJson; } }));
Object.defineProperty(exports, "encryptKeystoreJsonSync", ({ enumerable: true, get: function () { return json_keystore_js_1.encryptKeystoreJsonSync; } }));
var mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ "../node_modules/ethers/lib.commonjs/wallet/mnemonic.js");
Object.defineProperty(exports, "Mnemonic", ({ enumerable: true, get: function () { return mnemonic_js_1.Mnemonic; } }));
var wallet_js_1 = __webpack_require__(/*! ./wallet.js */ "../node_modules/ethers/lib.commonjs/wallet/wallet.js");
Object.defineProperty(exports, "Wallet", ({ enumerable: true, get: function () { return wallet_js_1.Wallet; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js":
/*!********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;
const aes_js_1 = __webpack_require__(/*! aes-js */ "../node_modules/aes-js/lib.commonjs/index.js");
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/ethers/lib.commonjs/wallet/utils.js");
/**
 *  Returns true if %%json%% is a valid JSON Crowdsale wallet.
 */
function isCrowdsaleJson(json) {
    try {
        const data = JSON.parse(json);
        if (data.encseed) {
            return true;
        }
    }
    catch (error) { }
    return false;
}
exports.isCrowdsaleJson = isCrowdsaleJson;
// See: https://github.com/ethereum/pyethsaletool
/**
 *  Before Ethereum launched, it was necessary to create a wallet
 *  format for backers to use, which would be used to receive ether
 *  as a reward for contributing to the project.
 *
 *  The [[link-crowdsale]] format is now obsolete, but it is still
 *  useful to support and the additional code is fairly trivial as
 *  all the primitives required are used through core portions of
 *  the library.
 */
function decryptCrowdsaleJson(json, _password) {
    const data = JSON.parse(json);
    const password = (0, utils_js_1.getPassword)(_password);
    // Ethereum Address
    const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, "ethaddr:string!"));
    // Encrypted Seed
    const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, "encseed:string!"));
    (0, index_js_4.assertArgument)(encseed && (encseed.length % 16) === 0, "invalid encseed", "json", json);
    const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    const aesCbc = new aes_js_1.CBC(key, iv);
    const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    let seedHex = "";
    for (let i = 0; i < seed.length; i++) {
        seedHex += String.fromCharCode(seed[i]);
    }
    return { address, privateKey: (0, index_js_3.id)(seedHex) };
}
exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
//# sourceMappingURL=json-crowdsale.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/json-keystore.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/json-keystore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  The JSON Wallet formats allow a simple way to store the private
 *  keys needed in Ethereum along with related information and allows
 *  for extensible forms of encryption.
 *
 *  These utilities facilitate decrypting and encrypting the most common
 *  JSON Wallet formats.
 *
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;
const aes_js_1 = __webpack_require__(/*! aes-js */ "../node_modules/aes-js/lib.commonjs/index.js");
const index_js_1 = __webpack_require__(/*! ../address/index.js */ "../node_modules/ethers/lib.commonjs/address/index.js");
const index_js_2 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_3 = __webpack_require__(/*! ../transaction/index.js */ "../node_modules/ethers/lib.commonjs/transaction/index.js");
const index_js_4 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../node_modules/ethers/lib.commonjs/wallet/utils.js");
const _version_js_1 = __webpack_require__(/*! ../_version.js */ "../node_modules/ethers/lib.commonjs/_version.js");
const defaultPath = "m/44'/60'/0'/0/0";
/**
 *  Returns true if %%json%% is a valid JSON Keystore Wallet.
 */
function isKeystoreJson(json) {
    try {
        const data = JSON.parse(json);
        const version = ((data.version != null) ? parseInt(data.version) : 0);
        if (version === 3) {
            return true;
        }
    }
    catch (error) { }
    return false;
}
exports.isKeystoreJson = isKeystoreJson;
function decrypt(data, key, ciphertext) {
    const cipher = (0, utils_js_1.spelunk)(data, "crypto.cipher:string");
    if (cipher === "aes-128-ctr") {
        const iv = (0, utils_js_1.spelunk)(data, "crypto.cipherparams.iv:data!");
        const aesCtr = new aes_js_1.CTR(key, iv);
        return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));
    }
    (0, index_js_4.assert)(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
        operation: "decrypt"
    });
}
function getAccount(data, _key) {
    const key = (0, index_js_4.getBytes)(_key);
    const ciphertext = (0, utils_js_1.spelunk)(data, "crypto.ciphertext:data!");
    const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);
    (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
    const address = (0, index_js_3.computeAddress)(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (!check.startsWith("0x")) {
            check = "0x" + check;
        }
        (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, "keystore address/privateKey mismatch", "address", data.address);
    }
    const account = { address, privateKey };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    const version = (0, utils_js_1.spelunk)(data, "x-ethers.version:string");
    if (version === "0.1") {
        const mnemonicKey = key.slice(32, 64);
        const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCiphertext:data!");
        const mnemonicIv = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCounter:data!");
        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
        account.mnemonic = {
            path: ((0, utils_js_1.spelunk)(data, "x-ethers.path:string") || defaultPath),
            locale: ((0, utils_js_1.spelunk)(data, "x-ethers.locale:string") || "en"),
            entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
        };
    }
    return account;
}
function getDecryptKdfParams(data) {
    const kdf = (0, utils_js_1.spelunk)(data, "crypto.kdf:string");
    if (kdf && typeof (kdf) === "string") {
        if (kdf.toLowerCase() === "scrypt") {
            const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
            const N = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.n:int!");
            const r = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.r:int!");
            const p = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.p:int!");
            // Make sure N is a power of 2
            (0, index_js_4.assertArgument)(N > 0 && (N & (N - 1)) === 0, "invalid kdf.N", "kdf.N", N);
            (0, index_js_4.assertArgument)(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
            const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
            (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
            return { name: "scrypt", salt, N, r, p, dkLen: 64 };
        }
        else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
            const prf = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.prf:string!");
            const algorithm = prf.split("-").pop();
            (0, index_js_4.assertArgument)(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
            const count = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.c:int!");
            const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
            (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
            return { name: "pbkdf2", salt, count, dkLen, algorithm };
        }
    }
    (0, index_js_4.assertArgument)(false, "unsupported key-derivation function", "kdf", kdf);
}
/**
 *  Returns the account details for the JSON Keystore Wallet %%json%%
 *  using %%password%%.
 *
 *  It is preferred to use the [async version](decryptKeystoreJson)
 *  instead, which allows a [[ProgressCallback]] to keep the user informed
 *  as to the decryption status.
 *
 *  This method will block the event loop (freezing all UI) until decryption
 *  is complete, which can take quite some time, depending on the wallet
 *  paramters and platform.
 */
function decryptKeystoreJsonSync(json, _password) {
    const data = JSON.parse(json);
    const password = (0, utils_js_1.getPassword)(_password);
    const params = getDecryptKdfParams(data);
    if (params.name === "pbkdf2") {
        const { salt, count, dkLen, algorithm } = params;
        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);
        return getAccount(data, key);
    }
    (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
    const { salt, N, r, p, dkLen } = params;
    const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);
    return getAccount(data, key);
}
exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
function stall(duration) {
    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });
}
/**
 *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the
 *  %%password%%.
 *
 *  If provided, %%progress%% will be called periodically during the
 *  decrpytion to provide feedback, and if the function returns
 *  ``false`` will halt decryption.
 *
 *  The %%progressCallback%% will **always** receive ``0`` before
 *  decryption begins and ``1`` when complete.
 */
async function decryptKeystoreJson(json, _password, progress) {
    const data = JSON.parse(json);
    const password = (0, utils_js_1.getPassword)(_password);
    const params = getDecryptKdfParams(data);
    if (params.name === "pbkdf2") {
        if (progress) {
            progress(0);
            await stall(0);
        }
        const { salt, count, dkLen, algorithm } = params;
        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);
        if (progress) {
            progress(1);
            await stall(0);
        }
        return getAccount(data, key);
    }
    (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
    const { salt, N, r, p, dkLen } = params;
    const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);
    return getAccount(data, key);
}
exports.decryptKeystoreJson = decryptKeystoreJson;
function getEncryptKdfParams(options) {
    // Check/generate the salt
    const salt = (options.salt != null) ? (0, index_js_4.getBytes)(options.salt, "options.salt") : (0, index_js_2.randomBytes)(32);
    // Override the scrypt password-based key derivation function parameters
    let N = (1 << 17), r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) {
            N = options.scrypt.N;
        }
        if (options.scrypt.r) {
            r = options.scrypt.r;
        }
        if (options.scrypt.p) {
            p = options.scrypt.p;
        }
    }
    (0, index_js_4.assertArgument)(typeof (N) === "number" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N);
    (0, index_js_4.assertArgument)(typeof (r) === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
    (0, index_js_4.assertArgument)(typeof (p) === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
    return { name: "scrypt", dkLen: 32, salt, N, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
    const privateKey = (0, index_js_4.getBytes)(account.privateKey, "privateKey");
    // Override initialization vector
    const iv = (options.iv != null) ? (0, index_js_4.getBytes)(options.iv, "options.iv") : (0, index_js_2.randomBytes)(16);
    (0, index_js_4.assertArgument)(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
    // Override the uuid
    const uuidRandom = (options.uuid != null) ? (0, index_js_4.getBytes)(options.uuid, "options.uuid") : (0, index_js_2.randomBytes)(16);
    (0, index_js_4.assertArgument)(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
    // This will be used to encrypt the wallet (as per Web3 secret storage)
    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    const derivedKey = key.slice(0, 16);
    const macPrefix = key.slice(16, 32);
    // Encrypt the private key
    const aesCtr = new aes_js_1.CTR(derivedKey, iv);
    const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));
    // Compute the message authentication code, used to check the password
    const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));
    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
    const data = {
        address: account.address.substring(2).toLowerCase(),
        id: (0, index_js_4.uuidV4)(uuidRandom),
        version: 3,
        Crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
                iv: (0, index_js_4.hexlify)(iv).substring(2),
            },
            ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),
            kdf: "scrypt",
            kdfparams: {
                salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),
                n: kdf.N,
                dklen: 32,
                p: kdf.p,
                r: kdf.r
            },
            mac: mac.substring(2)
        }
    };
    // If we have a mnemonic, encrypt it into the JSON wallet
    if (account.mnemonic) {
        const client = (options.client != null) ? options.client : `ethers/${_version_js_1.version}`;
        const path = account.mnemonic.path || defaultPath;
        const locale = account.mnemonic.locale || "en";
        const mnemonicKey = key.slice(32, 64);
        const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, "account.mnemonic.entropy");
        const mnemonicIv = (0, index_js_2.randomBytes)(16);
        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
        const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));
        const now = new Date();
        const timestamp = (now.getUTCFullYear() + "-" +
            (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + "-" +
            (0, utils_js_1.zpad)(now.getUTCDate(), 2) + "T" +
            (0, utils_js_1.zpad)(now.getUTCHours(), 2) + "-" +
            (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + "-" +
            (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + ".0Z");
        const gethFilename = ("UTC--" + timestamp + "--" + data.address);
        data["x-ethers"] = {
            client, gethFilename, path, locale,
            mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),
            mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),
            version: "0.1"
        };
    }
    return JSON.stringify(data);
}
/**
 *  Return the JSON Keystore Wallet for %%account%% encrypted with
 *  %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used. Any provided [[ProgressCallback]] is ignord.
 */
function encryptKeystoreJsonSync(account, password, options) {
    if (options == null) {
        options = {};
    }
    const passwordBytes = (0, utils_js_1.getPassword)(password);
    const kdf = getEncryptKdfParams(options);
    const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
}
exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
/**
 *  Resolved to the JSON Keystore Wallet for %%account%% encrypted
 *  with %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used and provide a [[ProgressCallback]] to receive periodic updates
 *  on the completion status..
 */
async function encryptKeystoreJson(account, password, options) {
    if (options == null) {
        options = {};
    }
    const passwordBytes = (0, utils_js_1.getPassword)(password);
    const kdf = getEncryptKdfParams(options);
    const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
}
exports.encryptKeystoreJson = encryptKeystoreJson;
//# sourceMappingURL=json-keystore.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/mnemonic.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/mnemonic.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mnemonic = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-en.js");
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
    return ((1 << bits) - 1) << (8 - bits) & 0xff;
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
    return ((1 << bits) - 1) & 0xff;
}
function mnemonicToEntropy(mnemonic, wordlist) {
    (0, index_js_2.assertNormalize)("NFKD");
    if (wordlist == null) {
        wordlist = lang_en_js_1.LangEn.wordlist();
    }
    const words = wordlist.split(mnemonic);
    (0, index_js_2.assertArgument)((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
    let offset = 0;
    for (let i = 0; i < words.length; i++) {
        let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
        for (let bit = 0; bit < 11; bit++) {
            if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));
            }
            offset++;
        }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
    return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
    (0, index_js_2.assertArgument)((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
    if (wordlist == null) {
        wordlist = lang_en_js_1.LangEn.wordlist();
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i++) {
        // Consume the whole byte (with still more to go)
        if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i];
            remainingBits -= 8;
            // This byte will complete an 11-bit index
        }
        else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
            // Start the next word
            indices.push(entropy[i] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
        }
    }
    // Compute the checksum bits
    const checksumBits = entropy.length / 4;
    const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));
    return wordlist.join(indices.map((index) => wordlist.getWord(index)));
}
const _guard = {};
/**
 *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]
 *  seeds and convert between phrases and entropy.
 */
class Mnemonic {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    phrase;
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    password;
    /**
     *  The wordlist for this mnemonic.
     */
    wordlist;
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    entropy;
    /**
     *  @private
     */
    constructor(guard, entropy, phrase, password, wordlist) {
        if (password == null) {
            password = "";
        }
        if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
        }
        (0, index_js_2.assertPrivate)(guard, _guard, "Mnemonic");
        (0, index_js_2.defineProperties)(this, { phrase, password, wordlist, entropy });
    }
    /**
     *  Returns the seed for the mnemonic.
     */
    computeSeed() {
        const salt = (0, index_js_2.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
    }
    /**
     *  Creates a new Mnemonic for the %%phrase%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
    static fromPhrase(phrase, password, wordlist) {
        // Normalize the case and space; throws if invalid
        const entropy = mnemonicToEntropy(phrase, wordlist);
        phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);
        return new Mnemonic(_guard, entropy, phrase, password, wordlist);
    }
    /**
     *  Create a new **Mnemonic** from the %%entropy%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
    static fromEntropy(_entropy, password, wordlist) {
        const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        const phrase = entropyToMnemonic(entropy, wordlist);
        return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);
    }
    /**
     *  Returns the phrase for %%mnemonic%%.
     */
    static entropyToPhrase(_entropy, wordlist) {
        const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        return entropyToMnemonic(entropy, wordlist);
    }
    /**
     *  Returns the entropy for %%phrase%%.
     */
    static phraseToEntropy(phrase, wordlist) {
        return mnemonicToEntropy(phrase, wordlist);
    }
    /**
     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
     *
     *  This checks all the provided words belong to the %%wordlist%%,
     *  that the length is valid and the checksum is correct.
     */
    static isValidMnemonic(phrase, wordlist) {
        try {
            mnemonicToEntropy(phrase, wordlist);
            return true;
        }
        catch (error) { }
        return false;
    }
}
exports.Mnemonic = Mnemonic;
//# sourceMappingURL=mnemonic.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/utils.js":
/*!***********************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 *  @_ignore
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
function looseArrayify(hexString) {
    if (typeof (hexString) === "string" && !hexString.startsWith("0x")) {
        hexString = "0x" + hexString;
    }
    return (0, index_js_1.getBytesCopy)(hexString);
}
exports.looseArrayify = looseArrayify;
function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
        value = '0' + value;
    }
    return value;
}
exports.zpad = zpad;
function getPassword(password) {
    if (typeof (password) === 'string') {
        return (0, index_js_1.toUtf8Bytes)(password, "NFKC");
    }
    return (0, index_js_1.getBytesCopy)(password);
}
exports.getPassword = getPassword;
function spelunk(object, _path) {
    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
    (0, index_js_1.assertArgument)(match != null, "invalid path", "path", _path);
    const path = match[1];
    const type = match[3];
    const reqd = (match[4] === "!");
    let cur = object;
    for (const comp of path.toLowerCase().split('.')) {
        // Search for a child object with a case-insensitive matching key
        if (Array.isArray(cur)) {
            if (!comp.match(/^[0-9]+$/)) {
                break;
            }
            cur = cur[parseInt(comp)];
        }
        else if (typeof (cur) === "object") {
            let found = null;
            for (const key in cur) {
                if (key.toLowerCase() === comp) {
                    found = cur[key];
                    break;
                }
            }
            cur = found;
        }
        else {
            cur = null;
        }
        if (cur == null) {
            break;
        }
    }
    (0, index_js_1.assertArgument)(!reqd || cur != null, "missing required value", "path", path);
    if (type && cur != null) {
        if (type === "int") {
            if (typeof (cur) === "string" && cur.match(/^-?[0-9]+$/)) {
                return parseInt(cur);
            }
            else if (Number.isSafeInteger(cur)) {
                return cur;
            }
        }
        if (type === "number") {
            if (typeof (cur) === "string" && cur.match(/^-?[0-9.]*$/)) {
                return parseFloat(cur);
            }
        }
        if (type === "data") {
            if (typeof (cur) === "string") {
                return looseArrayify(cur);
            }
        }
        if (type === "array" && Array.isArray(cur)) {
            return cur;
        }
        if (type === typeof (cur)) {
            return cur;
        }
        (0, index_js_1.assertArgument)(false, `wrong type found for ${type} `, "path", path);
    }
    return cur;
}
exports.spelunk = spelunk;
/*
export function follow(object: any, path: string): null | string {
    let currentChild = object;

    for (const comp of path.toLowerCase().split('/')) {

        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
             if (key.toLowerCase() === comp) {
                 matchingChild = currentChild[key];
                 break;
             }
        }

        if (matchingChild === null) { return null; }

        currentChild = matchingChild;
    }

    return currentChild;
}

// "path/to/something:type!"
export function followRequired(data: any, path: string): string {
    const value = follow(data, path);
    if (value != null) { return value; }
    return logger.throwArgumentError("invalid value", `data:${ path }`,
    JSON.stringify(data));
}
*/
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
/*
export function uuidV4(randomBytes: BytesLike): string {
    const bytes = getBytes(randomBytes, "randomBytes");

    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;

    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;

    const value = hexlify(bytes);

    return [
       value.substring(2, 10),
       value.substring(10, 14),
       value.substring(14, 18),
       value.substring(18, 22),
       value.substring(22, 34),
    ].join("-");
}
*/
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wallet/wallet.js":
/*!************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wallet/wallet.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wallet = void 0;
const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ "../node_modules/ethers/lib.commonjs/crypto/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ "../node_modules/ethers/lib.commonjs/wallet/base-wallet.js");
const hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ "../node_modules/ethers/lib.commonjs/wallet/hdwallet.js");
const json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ "../node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js");
const json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ "../node_modules/ethers/lib.commonjs/wallet/json-keystore.js");
const mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ "../node_modules/ethers/lib.commonjs/wallet/mnemonic.js");
function stall(duration) {
    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });
}
/**
 *  A **Wallet** manages a single private key which is used to sign
 *  transactions, messages and other common payloads.
 *
 *  This class is generally the main entry point for developers
 *  that wish to use a private key directly, as it can create
 *  instances from a large variety of common sources, including
 *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON
 *  wallets.
 */
class Wallet extends base_wallet_js_1.BaseWallet {
    /**
     *  Create a new wallet for the private %%key%%, optionally connected
     *  to %%provider%%.
     */
    constructor(key, provider) {
        if (typeof (key) === "string" && !key.startsWith("0x")) {
            key = "0x" + key;
        }
        let signingKey = (typeof (key) === "string") ? new index_js_1.SigningKey(key) : key;
        super(signingKey, provider);
    }
    connect(provider) {
        return new Wallet(this.signingKey, provider);
    }
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    async encrypt(password, progressCallback) {
        const account = { address: this.address, privateKey: this.privateKey };
        return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, { progressCallback });
    }
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    encryptSync(password) {
        const account = { address: this.address, privateKey: this.privateKey };
        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);
    }
    static #fromAccount(account) {
        (0, index_js_2.assertArgument)(account, "invalid JSON wallet", "json", "[ REDACTED ]");
        if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
            const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);
            const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {
                return wallet;
            }
            console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
        }
        const wallet = new Wallet(account.privateKey);
        (0, index_js_2.assertArgument)(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
        return wallet;
    }
    /**
     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
     *  with %%password%%.
     *
     *  If %%progress%% is provided, it is called periodically during
     *  decryption so that any UI can be updated.
     */
    static async fromEncryptedJson(json, password, progress) {
        let account = null;
        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
            account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);
        }
        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
            if (progress) {
                progress(0);
                await stall(0);
            }
            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
            if (progress) {
                progress(1);
                await stall(0);
            }
        }
        return Wallet.#fromAccount(account);
    }
    /**
     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
     *
     *  The [[fromEncryptedJson]] method is preferred, as this method
     *  will lock up and freeze the UI during decryption, which may take
     *  some time.
     */
    static fromEncryptedJsonSync(json, password) {
        let account = null;
        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
            account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);
        }
        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
        }
        else {
            (0, index_js_2.assertArgument)(false, "invalid JSON wallet", "json", "[ REDACTED ]");
        }
        return Wallet.#fromAccount(account);
    }
    /**
     *  Creates a new random [[HDNodeWallet]] using the available
     *  [cryptographic random source](randomBytes).
     *
     *  If there is no crytographic random source, this will throw.
     */
    static createRandom(provider) {
        const wallet = hdwallet_js_1.HDNodeWallet.createRandom();
        if (provider) {
            return wallet.connect(provider);
        }
        return wallet;
    }
    /**
     *  Creates a [[HDNodeWallet]] for %%phrase%%.
     */
    static fromPhrase(phrase, provider) {
        const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);
        if (provider) {
            return wallet.connect(provider);
        }
        return wallet;
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/bit-reader.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/bit-reader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeBits = void 0;
const Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
/**
 *  @_ignore
 */
function decodeBits(width, data) {
    const maxValue = (1 << width) - 1;
    const result = [];
    let accum = 0, bits = 0, flood = 0;
    for (let i = 0; i < data.length; i++) {
        // Accumulate 6 bits of data
        accum = ((accum << 6) | Base64.indexOf(data[i]));
        bits += 6;
        // While we have enough for a word...
        while (bits >= width) {
            // ...read the word
            const value = (accum >> (bits - width));
            accum &= (1 << (bits - width)) - 1;
            bits -= width;
            // A value of 0 indicates we exceeded maxValue, it
            // floods over into the next value
            if (value === 0) {
                flood += maxValue;
            }
            else {
                result.push(value + flood);
                flood = 0;
            }
        }
    }
    return result;
}
exports.decodeBits = decodeBits;
//# sourceMappingURL=bit-reader.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/decode-owl.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/decode-owl.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeOwl = exports.decode = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words, sep) {
    let initial = 97;
    return words.reduce((accum, word) => {
        if (word === sep) {
            initial++;
        }
        else if (word.match(Word)) {
            accum.push(String.fromCharCode(initial) + word);
        }
        else {
            initial = 97;
            accum.push(word);
        }
        return accum;
    }, []);
}
/**
 *  @_ignore
 */
function decode(data, subs) {
    // Replace all the substitutions with their expanded form
    for (let i = subsChrs.length - 1; i >= 0; i--) {
        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
    }
    // Get all tle clumps; each suffix, first-increment and second-increment
    const clumps = [];
    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
        if (semi) {
            for (let i = parseInt(semi); i >= 0; i--) {
                clumps.push(";");
            }
        }
        else {
            clumps.push(item.toLowerCase());
        }
        return "";
    });
    /* c8 ignore start */
    if (leftover) {
        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
    }
    /* c8 ignore stop */
    return unfold(unfold(clumps, ";"), ":");
}
exports.decode = decode;
/**
 *  @_ignore
 */
function decodeOwl(data) {
    (0, index_js_1.assertArgument)(data[0] === "0", "unsupported auwl data", "data", data);
    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
exports.decodeOwl = decodeOwl;
//# sourceMappingURL=decode-owl.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/decode-owla.js":
/*!********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/decode-owla.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeOwlA = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const bit_reader_js_1 = __webpack_require__(/*! ./bit-reader.js */ "../node_modules/ethers/lib.commonjs/wordlists/bit-reader.js");
const decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/decode-owl.js");
/**
 *  @_ignore
 */
function decodeOwlA(data, accents) {
    let words = (0, decode_owl_js_1.decodeOwl)(data).join(",");
    // Inject the accents
    accents.split(/,/g).forEach((accent) => {
        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
        (0, index_js_1.assertArgument)(match !== null, "internal error parsing accents", "accents", accents);
        let posOffset = 0;
        const positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);
        const charCode = parseInt(match[2]);
        const regex = new RegExp(`([${match[1]}])`, "g");
        words = words.replace(regex, (all, letter) => {
            const rem = --positions[posOffset];
            if (rem === 0) {
                letter = String.fromCharCode(letter.charCodeAt(0), charCode);
                posOffset++;
            }
            return letter;
        });
    });
    return words.split(",");
}
exports.decodeOwlA = decodeOwlA;
//# sourceMappingURL=decode-owla.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;
/**
 *  A Wordlist is a set of 2048 words used to encode private keys
 *  (or other binary data) that is easier for humans to write down,
 *  transcribe and dictate.
 *
 *  The [[link-bip-39]] standard includes several checksum bits,
 *  depending on the size of the mnemonic phrase.
 *
 *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For
 *  most purposes 12 word mnemonics should be used, as including
 *  additional words increases the difficulty and potential for
 *  mistakes and does not offer any effective improvement on security.
 *
 *  There are a variety of [[link-bip39-wordlists]] for different
 *  languages, but for maximal compatibility, the
 *  [English Wordlist](LangEn) is recommended.
 *
 *  @_section: api/wordlists:Wordlists [about-wordlists]
 */
var wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js");
Object.defineProperty(exports, "Wordlist", ({ enumerable: true, get: function () { return wordlist_js_1.Wordlist; } }));
var lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-en.js");
Object.defineProperty(exports, "LangEn", ({ enumerable: true, get: function () { return lang_en_js_1.LangEn; } }));
var wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
Object.defineProperty(exports, "WordlistOwl", ({ enumerable: true, get: function () { return wordlist_owl_js_1.WordlistOwl; } }));
var wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js");
Object.defineProperty(exports, "WordlistOwlA", ({ enumerable: true, get: function () { return wordlist_owla_js_1.WordlistOwlA; } }));
var wordlists_js_1 = __webpack_require__(/*! ./wordlists.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlists.js");
Object.defineProperty(exports, "wordlists", ({ enumerable: true, get: function () { return wordlists_js_1.wordlists; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-cz.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-cz.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangCz = void 0;
const wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
const words = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
const checksum = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
let wordlist = null;
/**
 *  The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangCz extends wordlist_owl_js_1.WordlistOwl {
    /**
     *  Creates a new instance of the Czech language Wordlist.
     *
     *  Using the constructor should be unnecessary, instead use the
     *  [[wordlist]] singleton method.
     *
     *  @_ignore:
     */
    constructor() { super("cz", words, checksum); }
    /**
     *  Returns a singleton instance of a ``LangCz``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangCz();
        }
        return wordlist;
    }
}
exports.LangCz = LangCz;
//# sourceMappingURL=lang-cz.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-en.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-en.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangEn = void 0;
const wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
/**
 *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangEn extends wordlist_owl_js_1.WordlistOwl {
    /**
     *  Creates a new instance of the English language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEn]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("en", words, checksum); }
    /**
     *  Returns a singleton instance of a ``LangEn``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangEn();
        }
        return wordlist;
    }
}
exports.LangEn = LangEn;
//# sourceMappingURL=lang-en.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-es.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-es.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangEs = void 0;
const wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js");
const words = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
const accents = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
const checksum = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
let wordlist = null;
/**
 *  The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangEs extends wordlist_owla_js_1.WordlistOwlA {
    /**
     *  Creates a new instance of the Spanish language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEs]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("es", words, accents, checksum); }
    /**
     *  Returns a singleton instance of a ``LangEs``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangEs();
        }
        return wordlist;
    }
}
exports.LangEs = LangEs;
//# sourceMappingURL=lang-es.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-fr.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-fr.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangFr = void 0;
const wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js");
const words = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
const accents = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
const checksum = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
let wordlist = null;
/**
 *  The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangFr extends wordlist_owla_js_1.WordlistOwlA {
    /**
     *  Creates a new instance of the French language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langFr]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("fr", words, accents, checksum); }
    /**
     *  Returns a singleton instance of a ``LangFr``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangFr();
        }
        return wordlist;
    }
}
exports.LangFr = LangFr;
//# sourceMappingURL=lang-fr.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-it.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-it.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangIt = void 0;
const wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
const words = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
const checksum = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
let wordlist = null;
/**
 *  The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangIt extends wordlist_owl_js_1.WordlistOwl {
    /**
     *  Creates a new instance of the Italian language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langIt]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("it", words, checksum); }
    /**
     *  Returns a singleton instance of a ``LangIt``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangIt();
        }
        return wordlist;
    }
}
exports.LangIt = LangIt;
//# sourceMappingURL=lang-it.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-ja.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-ja.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangJa = void 0;
const index_js_1 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js");
const data = [
    // 4-kana words
    "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
    // 5-kana words
    "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
    // 6-kana words
    "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
    // 7-kana words
    "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
    // 8-kana words
    "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
    // 9-kana words
    "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
    // 10-kana words
    "IJBEJqXZJ"
];
// Maps each character into its kana value (the index)
const mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
let _wordlist = null;
function hex(word) {
    return (0, index_js_2.hexlify)((0, index_js_2.toUtf8Bytes)(word));
}
const KiYoKu = "0xe3818de38284e3818f";
const KyoKu = "0xe3818de38283e3818f";
function toString(data) {
    return (0, index_js_2.toUtf8String)(new Uint8Array(data));
}
function loadWords() {
    if (_wordlist !== null) {
        return _wordlist;
    }
    const wordlist = [];
    // Transforms for normalizing (sort is a not quite UTF-8)
    const transform = {};
    // Delete the diacritic marks
    transform[toString([227, 130, 154])] = false;
    transform[toString([227, 130, 153])] = false;
    // Some simple transforms that sort out most of the order
    transform[toString([227, 130, 133])] = toString([227, 130, 134]);
    transform[toString([227, 129, 163])] = toString([227, 129, 164]);
    transform[toString([227, 130, 131])] = toString([227, 130, 132]);
    transform[toString([227, 130, 135])] = toString([227, 130, 136]);
    // Normalize words using the transform
    function normalize(word) {
        let result = "";
        for (let i = 0; i < word.length; i++) {
            let kana = word[i];
            const target = transform[kana];
            if (target === false) {
                continue;
            }
            if (target) {
                kana = target;
            }
            result += kana;
        }
        return result;
    }
    // Sort how the Japanese list is sorted
    function sortJapanese(a, b) {
        a = normalize(a);
        b = normalize(b);
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
    // Load all the words
    for (let length = 3; length <= 9; length++) {
        const d = data[length - 3];
        for (let offset = 0; offset < d.length; offset += length) {
            const word = [];
            for (let i = 0; i < length; i++) {
                const k = mapping.indexOf(d[offset + i]);
                word.push(227);
                word.push((k & 0x40) ? 130 : 129);
                word.push((k & 0x3f) + 128);
            }
            wordlist.push(toString(word));
        }
    }
    wordlist.sort(sortJapanese);
    // For some reason kyoku and kiyoku are flipped in node (!!).
    // The order SHOULD be:
    //   - kyoku
    //   - kiyoku
    // This should ignore "if", but that doesn't work here??
    /* c8 ignore start */
    if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
        const tmp = wordlist[442];
        wordlist[442] = wordlist[443];
        wordlist[443] = tmp;
    }
    /* c8 ignore stop */
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    const checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
        throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
    }
    /* c8 ignore stop */
    _wordlist = wordlist;
    return wordlist;
}
let wordlist = null;
/**
 *  The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangJa extends wordlist_js_1.Wordlist {
    /**
     *  Creates a new instance of the Japanese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langJa]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("ja"); }
    getWord(index) {
        const words = loadWords();
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords().indexOf(word);
    }
    split(phrase) {
        //logger.assertNormalize();
        return phrase.split(/(?:\u3000| )+/g);
    }
    join(words) {
        return words.join("\u3000");
    }
    /**
     *  Returns a singleton instance of a ``LangJa``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangJa();
        }
        return wordlist;
    }
}
exports.LangJa = LangJa;
//# sourceMappingURL=lang-ja.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-ko.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-ko.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangKo = void 0;
const index_js_1 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js");
const data = [
    "OYAa",
    "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@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!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
    "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
    "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
    "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
    "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
    "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
];
const codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
function getHangul(code) {
    if (code >= 40) {
        code = code + 168 - 40;
    }
    else if (code >= 19) {
        code = code + 97 - 19;
    }
    return (0, index_js_2.toUtf8String)(new Uint8Array([225, (code >> 6) + 132, (code & 0x3f) + 128]));
}
let _wordlist = null;
function loadWords() {
    if (_wordlist != null) {
        return _wordlist;
    }
    const wordlist = [];
    data.forEach((data, length) => {
        length += 4;
        for (let i = 0; i < data.length; i += length) {
            let word = "";
            for (let j = 0; j < length; j++) {
                word += getHangul(codes.indexOf(data[i + j]));
            }
            wordlist.push(word);
        }
    });
    wordlist.sort();
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    const checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
        throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
    }
    /* c8 ignore stop */
    _wordlist = wordlist;
    return wordlist;
}
let wordlist = null;
/**
 *  The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangKo extends wordlist_js_1.Wordlist {
    /**
     *  Creates a new instance of the Korean language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langKo]] should suffice.
     *
     *  @_ignore:
     */
    constructor() {
        super("ko");
    }
    getWord(index) {
        const words = loadWords();
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords().indexOf(word);
    }
    /**
     *  Returns a singleton instance of a ``LangKo``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangKo();
        }
        return wordlist;
    }
}
exports.LangKo = LangKo;
//# sourceMappingURL=lang-ko.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-pt.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-pt.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangPt = void 0;
const wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
const words = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
const checksum = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
let wordlist = null;
/**
 *  The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangPt extends wordlist_owl_js_1.WordlistOwl {
    /**
     *  Creates a new instance of the Portuguese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langPt]] should suffice.
     *
     *  @_ignore:
     */
    constructor() { super("pt", words, checksum); }
    /**
     *  Returns a singleton instance of a ``LangPt``, creating it
     *  if this is the first time being called.
     */
    static wordlist() {
        if (wordlist == null) {
            wordlist = new LangPt();
        }
        return wordlist;
    }
}
exports.LangPt = LangPt;
//# sourceMappingURL=lang-pt.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/lang-zh.js":
/*!****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/lang-zh.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangZh = void 0;
const index_js_1 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js");
const data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
const deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
const _wordlist = {
    zh_cn: null,
    zh_tw: null
};
const Checks = {
    zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
    zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
};
const codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
function loadWords(locale) {
    if (_wordlist[locale] != null) {
        return _wordlist[locale];
    }
    const wordlist = [];
    let deltaOffset = 0;
    for (let i = 0; i < 2048; i++) {
        const s = style.indexOf(data[i * 3]);
        const bytes = [
            228 + (s >> 2),
            128 + codes.indexOf(data[i * 3 + 1]),
            128 + codes.indexOf(data[i * 3 + 2]),
        ];
        if (locale === "zh_tw") {
            const common = s % 4;
            for (let i = common; i < 3; i++) {
                bytes[i] = codes.indexOf(deltaData[deltaOffset++]) + ((i == 0) ? 228 : 128);
            }
        }
        wordlist.push((0, index_js_2.toUtf8String)(new Uint8Array(bytes)));
    }
    // Verify the computed list matches the official list
    const checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== Checks[locale]) {
        throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);
    }
    /* c8 ignore stop */
    _wordlist[locale] = wordlist;
    return wordlist;
}
const wordlists = {};
/**
 *  The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for
 *  [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
class LangZh extends wordlist_js_1.Wordlist {
    /**
     *  Creates a new instance of the Chinese language Wordlist for
     *  the %%dialect%%, either ``"cn"`` or ``"tw"`` for simplified
     *  or traditional, respectively.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langZhCn]] and [[langZhTw]] should suffice.
     *
     *  @_ignore:
     */
    constructor(dialect) { super("zh_" + dialect); }
    getWord(index) {
        const words = loadWords(this.locale);
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return loadWords(this.locale).indexOf(word);
    }
    split(phrase) {
        phrase = phrase.replace(/(?:\u3000| )+/g, "");
        return phrase.split("");
    }
    /**
     *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,
     *  creating it if this is the first time being called.
     *
     *  Use the %%dialect%% ``"cn"`` or ``"tw"`` for simplified or
     *  traditional, respectively.
     */
    static wordlist(dialect) {
        if (wordlists[dialect] == null) {
            wordlists[dialect] = new LangZh(dialect);
        }
        return wordlists[dialect];
    }
}
exports.LangZh = LangZh;
//# sourceMappingURL=lang-zh.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js":
/*!*********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Use the encode-latin.js script to create the necessary
// data files to be consumed by this class
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WordlistOwl = void 0;
const index_js_1 = __webpack_require__(/*! ../hash/index.js */ "../node_modules/ethers/lib.commonjs/hash/index.js");
const index_js_2 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
const decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/decode-owl.js");
const wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js");
/**
 *  An OWL format Wordlist is an encoding method that exploits
 *  the general locality of alphabetically sorted words to
 *  achieve a simple but effective means of compression.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on ASCII-7 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
class WordlistOwl extends wordlist_js_1.Wordlist {
    #data;
    #checksum;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
     *  and validated against the %%checksum%%.
     */
    constructor(locale, data, checksum) {
        super(locale);
        this.#data = data;
        this.#checksum = checksum;
        this.#words = null;
    }
    /**
     *  The OWL-encoded data.
     */
    get _data() { return this.#data; }
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords() {
        return (0, decode_owl_js_1.decodeOwl)(this.#data);
    }
    #words;
    #loadWords() {
        if (this.#words == null) {
            const words = this._decodeWords();
            // Verify the computed list matches the official list
            const checksum = (0, index_js_1.id)(words.join("\n") + "\n");
            /* c8 ignore start */
            if (checksum !== this.#checksum) {
                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
            }
            /* c8 ignore stop */
            this.#words = words;
        }
        return this.#words;
    }
    getWord(index) {
        const words = this.#loadWords();
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
        return words[index];
    }
    getWordIndex(word) {
        return this.#loadWords().indexOf(word);
    }
}
exports.WordlistOwl = WordlistOwl;
//# sourceMappingURL=wordlist-owl.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WordlistOwlA = void 0;
const wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ "../node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js");
const decode_owla_js_1 = __webpack_require__(/*! ./decode-owla.js */ "../node_modules/ethers/lib.commonjs/wordlists/decode-owla.js");
/**
 *  An OWL-A format Wordlist extends the OWL format to add an
 *  overlay onto an OWL format Wordlist to support diacritic
 *  marks.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on latin-1 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
class WordlistOwlA extends wordlist_owl_js_1.WordlistOwl {
    #accent;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
     *  and %%accent%% data and validated against the %%checksum%%.
     */
    constructor(locale, data, accent, checksum) {
        super(locale, data, checksum);
        this.#accent = accent;
    }
    /**
     *  The OWLA-encoded accent data.
     */
    get _accent() { return this.#accent; }
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords() {
        return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);
    }
}
exports.WordlistOwlA = WordlistOwlA;
//# sourceMappingURL=wordlist-owla.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/wordlist.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/wordlist.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wordlist = void 0;
const index_js_1 = __webpack_require__(/*! ../utils/index.js */ "../node_modules/ethers/lib.commonjs/utils/index.js");
/**
 *  A Wordlist represents a collection of language-specific
 *  words used to encode and devoce [[link-bip-39]] encoded data
 *  by mapping words to 11-bit values and vice versa.
 */
class Wordlist {
    locale;
    /**
     *  Creates a new Wordlist instance.
     *
     *  Sub-classes MUST call this if they provide their own constructor,
     *  passing in the locale string of the language.
     *
     *  Generally there is no need to create instances of a Wordlist,
     *  since each language-specific Wordlist creates an instance and
     *  there is no state kept internally, so they are safe to share.
     */
    constructor(locale) {
        (0, index_js_1.defineProperties)(this, { locale });
    }
    /**
     *  Sub-classes may override this to provide a language-specific
     *  method for spliting %%phrase%% into individual words.
     *
     *  By default, %%phrase%% is split using any sequences of
     *  white-space as defined by regular expressions (i.e. ``/\s+/``).
     */
    split(phrase) {
        return phrase.toLowerCase().split(/\s+/g);
    }
    /**
     *  Sub-classes may override this to provider a language-specific
     *  method for joining %%words%% into a phrase.
     *
     *  By default, %%words%% are joined by a single space.
     */
    join(words) {
        return words.join(" ");
    }
}
exports.Wordlist = Wordlist;
//# sourceMappingURL=wordlist.js.map

/***/ }),

/***/ "../node_modules/ethers/lib.commonjs/wordlists/wordlists.js":
/*!******************************************************************!*\
  !*** ../node_modules/ethers/lib.commonjs/wordlists/wordlists.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wordlists = void 0;
const lang_cz_js_1 = __webpack_require__(/*! ./lang-cz.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-cz.js");
const lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-en.js");
const lang_es_js_1 = __webpack_require__(/*! ./lang-es.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-es.js");
const lang_fr_js_1 = __webpack_require__(/*! ./lang-fr.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-fr.js");
const lang_ja_js_1 = __webpack_require__(/*! ./lang-ja.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-ja.js");
const lang_ko_js_1 = __webpack_require__(/*! ./lang-ko.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-ko.js");
const lang_it_js_1 = __webpack_require__(/*! ./lang-it.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-it.js");
const lang_pt_js_1 = __webpack_require__(/*! ./lang-pt.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-pt.js");
const lang_zh_js_1 = __webpack_require__(/*! ./lang-zh.js */ "../node_modules/ethers/lib.commonjs/wordlists/lang-zh.js");
/**
 *  The available Wordlists by their
 *  [ISO 639-1 Language Code](link-wiki-iso639).
 *
 *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),
 *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),
 *  [zh_cn](LangZh), [zh_tw](LangZh))
 *
 *  The dist files (in the ``/dist`` folder) have had all languages
 *  except English stripped out, which reduces the library size by
 *  about 80kb. If required, they are available by importing the
 *  included ``wordlists-extra.min.js`` file.
 */
exports.wordlists = {
    cz: lang_cz_js_1.LangCz.wordlist(),
    en: lang_en_js_1.LangEn.wordlist(),
    es: lang_es_js_1.LangEs.wordlist(),
    fr: lang_fr_js_1.LangFr.wordlist(),
    it: lang_it_js_1.LangIt.wordlist(),
    pt: lang_pt_js_1.LangPt.wordlist(),
    ja: lang_ja_js_1.LangJa.wordlist(),
    ko: lang_ko_js_1.LangKo.wordlist(),
    zh_cn: lang_zh_js_1.LangZh.wordlist("cn"),
    zh_tw: lang_zh_js_1.LangZh.wordlist("tw"),
};
//# sourceMappingURL=wordlists.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtCQUFrQjtBQUMzRSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDLFFBQVE7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSxZQUFZLEdBQUcsOEJBQThCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBdUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUF1RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFNBQVM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBNEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxPQUFPLFNBQVMsT0FBTyxjQUFjLGFBQWEsY0FBYyxnQkFBZ0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILGVBQWU7QUFDbEk7QUFDQTtBQUNBLCtIQUErSCxlQUFlO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7Ozs7Ozs7Ozs7QUNqU2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLFdBQVcsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLG9DQUFvQyxHQUFHLDRCQUE0QixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRywrQkFBK0IsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0I7QUFDOW1DLDZCQUE2QixtQkFBTyxDQUFDLGtHQUF3QjtBQUM3RCxvREFBbUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDOUksdURBQXNELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQ3BKLDJCQUEyQixtQkFBTyxDQUFDLDhGQUFzQjtBQUN6RCxrREFBaUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDeEksOENBQTZDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ2hJLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM3Qyx1REFBc0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDNUksNEJBQTRCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQzNELHNEQUFxRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNqSix3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbkQsK0NBQThDLEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQy9ILDJEQUEwRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUN2SixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsK0JBQStCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2pFLGdEQUErQyxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUN4SSwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDekQsaURBQWdELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3RJLGlEQUFnRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN0SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDOUgsd0RBQXVELEVBQUUscUNBQXFDLHFEQUFxRCxFQUFDO0FBQ3BKLGdFQUErRCxFQUFFLHFDQUFxQyw2REFBNkQsRUFBQztBQUNwSyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUMzQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDL0csMkNBQTBDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ25ILHVDQUFzQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMzRyxzREFBcUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDekksdURBQXNELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQzNJLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCw2QkFBNkIsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDN0Qsb0RBQW1ELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQzlJLDRCQUE0QixtQkFBTyxDQUFDLGdHQUF1QjtBQUMzRCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLGlEQUFnRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN2SSw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDM0QsbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLDRCQUE0QixtQkFBTyxDQUFDLGdHQUF1QjtBQUMzRCxtREFBa0QsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDM0kseUJBQXlCLG1CQUFPLENBQUMsMEZBQW9CO0FBQ3JELGdEQUErQyxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNsSSwrQkFBK0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDakUsc0RBQXFELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3BKLCtCQUErQixtQkFBTyxDQUFDLHNHQUEwQjtBQUNqRSxzREFBcUQsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDcEosOEJBQThCLG1CQUFPLENBQUMsb0dBQXlCO0FBQy9ELHFEQUFvRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUNqSixtREFBa0QsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDN0ksMkJBQTJCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ3pELGtEQUFpRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN4SSwyREFBMEQsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDMUosMkJBQTJCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ3pELGtEQUFpRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN4SSw4QkFBOEIsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDL0QscURBQW9ELEVBQUUscUNBQXFDLHFEQUFxRCxFQUFDO0FBQ2pKLGdDQUFnQyxtQkFBTyxDQUFDLG9HQUF5QixHQUFHO0FBQ3BFLHFEQUFvRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUNqSiwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDekQsa0RBQWlELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3hJLDhCQUE4QixtQkFBTyxDQUFDLG9HQUF5QjtBQUMvRCxxREFBb0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDakosMkJBQTJCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ3pELG9EQUFtRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM1SSx5REFBd0QsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDdEosMkRBQTBELEVBQUUscUNBQXFDLHdEQUF3RCxFQUFDO0FBQzFKLHlEQUF3RCxFQUFFLHFDQUFxQyxzREFBc0QsRUFBQztBQUN0Sjs7Ozs7Ozs7Ozs7QUNqRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLG1CQUFtQixtQkFBTyxDQUFDLHlGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsNkJBQTZCLG1CQUFPLENBQUMsOEZBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsOEJBQThCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNEJBQTRCLHNCQUFzQiwwQkFBMEI7QUFDcks7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RSxnQ0FBZ0MsZUFBZTtBQUMvQyxnQ0FBZ0MsZUFBZTtBQUMvQywrQkFBK0IsZUFBZTtBQUM5QywrQkFBK0IsZ0JBQWdCO0FBQy9DLHVDQUF1QyxzQkFBc0I7QUFDN0Qsb0NBQW9DLG1CQUFtQjtBQUN2RCxpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkNBQTZDO0FBQzdDLDhDQUE4QztBQUM5QyxnQ0FBZ0MsZUFBZTtBQUMvQyx3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDLDZCQUE2QixlQUFlO0FBQzVDLDhCQUE4QjtBQUM5QixrQ0FBa0MsZUFBZTtBQUNqRCx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBDQUEwQztBQUMxQyxnREFBZ0Q7QUFDaEQsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTs7Ozs7Ozs7Ozs7QUM5V2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcsNEJBQTRCLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3ZJLHdCQUF3QixtQkFBTyxDQUFDLHVGQUF3QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUUsd0JBQXdCO0FBQ3hCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixLQUFLO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2TmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdGQUF3RixjQUFjO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixNQUFNLE9BQU87QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7Ozs7Ozs7Ozs7O0FDdEphO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFnQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBYztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsR0FBRyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7Ozs7Ozs7Ozs7QUN4SWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQSw4QkFBOEI7QUFDOUIsaUNBQWlDLHVDQUF1QztBQUN4RTtBQUNBO0FBQ0EscUNBQXFDLHdDQUF3QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7OztBQ3RHYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdHQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixHQUFHLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7Ozs7Ozs7Ozs7O0FDckdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdHQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7Ozs7Ozs7Ozs7QUN6QmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHVCQUF1QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQXNCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsK0JBQStCLG1CQUFPLENBQUMsa0dBQXdCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLDhGQUFzQjtBQUMzRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxHQUFHLE1BQU07QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVCxtREFBbUQsWUFBWTtBQUMvRCxrQkFBa0Isa0JBQWtCLGNBQWMsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBa0Q7QUFDL0U7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBa0U7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5RUFBeUU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLDhEQUE4RCxFQUFFLEdBQUcsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQXVEO0FBQ3hGLDhFQUE4RSxtQkFBbUI7QUFDakc7QUFDQTtBQUNBLGlDQUFpQyx3RUFBd0U7QUFDekcsZ0ZBQWdGLG1CQUFtQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBZ0U7QUFDckcscUhBQXFILDJCQUEyQixVQUFVO0FBQzFKO0FBQ0E7QUFDQSxxQ0FBcUMsOERBQThEO0FBQ25HLGtGQUFrRiwyQkFBMkIsVUFBVTtBQUN2SDtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9DQUFvQztBQUN6RSxrRkFBa0YsMkJBQTJCLFVBQVU7QUFDdkg7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUhBQXFIO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsWUFBWSxrQkFBa0IsNEJBQTRCLEdBQUc7QUFDckcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGdFQUFnRSxxQkFBcUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0NBQXdDO0FBQy9FO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCw4QkFBOEI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkgsZ0JBQWdCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7Ozs7Ozs7Ozs7QUMxakJhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsK0JBQStCLG1CQUFPLENBQUMsa0dBQXdCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUIsa0JBQWtCLEdBQUcscUJBQXFCLGlCQUFpQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlGQUF5RixtQkFBbUI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCLHdCQUF3QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLCtCQUErQiwwQ0FBMEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxLQUFLLFFBQVE7QUFDMUY7QUFDQTtBQUNBLHFFQUFxRSxPQUFPLEtBQUssUUFBUTtBQUN6RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOzs7Ozs7Ozs7OztBQ3RtQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdHQUF1QjtBQUM3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsb0RBQW9EO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCLE1BQU0sVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7Ozs7Ozs7Ozs7QUM1TWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw2QkFBNkIsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7Ozs7Ozs7Ozs7QUNwRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLDBCQUEwQixHQUFHLHFCQUFxQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDJFQUFrQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLGtHQUF3QjtBQUMvRCw2QkFBNkIsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsc0dBQTBCO0FBQ25FLGdDQUFnQyxtQkFBTyxDQUFDLG9HQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQSwwQ0FBMEMsT0FBTyxHQUFHLGVBQWU7QUFDbkU7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQjtBQUMzRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsQ0FBdUQ7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLDBKQUEwSixPQUFPO0FBQ2pLO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQztBQUM1RTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQztBQUNqRjtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEU7QUFDQSxzRkFBc0YsK0NBQStDLDJCQUEyQjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0NBQWtDO0FBQy9FLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLHlEQUF5RCxRQUFRLGlCQUFpQjtBQUNsRix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRiw2SEFBNkgsNENBQTRDLFNBQVM7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsSUFBSTtBQUNyRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtR0FBbUcscUJBQXFCLFNBQVM7QUFDakk7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHFCQUFxQixTQUFTO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQkFBcUI7QUFDcEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGFBQWE7QUFDYjtBQUNBLHdGQUF3RixnQkFBZ0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGlGQUFpRiwrQ0FBK0MsbUJBQW1CO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QyxrRUFBa0UsK0NBQStDLDJCQUEyQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeDdCYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdHQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixTQUFTLGNBQWM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7Ozs7Ozs7Ozs7O0FDNUdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFnQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBYztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixHQUFHLE1BQU07QUFDL0Y7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOzs7Ozs7Ozs7OztBQ2xLYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLDZCQUE2QixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QjtBQUNuSiwrQkFBK0IsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLDhCQUE4QixtQkFBTyxDQUFDLGdHQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJLDJCQUEyQjtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQixxQkFBcUIsVUFBVTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7Ozs7Ozs7Ozs7QUNwVGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTLEdBQUc7QUFDcEMsNkJBQTZCLG1CQUFPLENBQUMsOEZBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7Ozs7Ozs7Ozs7QUMvRWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxlQUFlO0FBQzlILFdBQVcsaUJBQWlCO0FBQzVCLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUxBQXVMO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUdBQW1HO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0ksb0NBQW9DO0FBQzFLO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGVBQWU7QUFDZjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxnREFBZ0QsdUVBQXVFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUyxHQUFHLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkIsTUFBTSwwQkFB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QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqaEJhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxvQkFBb0I7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaURBQU87QUFDL0IsdUNBQXVDLG1CQUFPLENBQUMsa0JBQU07QUFDckQsd0NBQXdDLG1CQUFPLENBQUMsb0JBQU87QUFDdkQsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxTQUFTO0FBQzlHLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0M7QUFDeEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQTBDO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYiw2Q0FBNkMsZ0JBQWdCO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDbkdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDL2pDLGNBQWMsR0FBRyxzQkFBc0I7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWE7QUFDdkMsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUN2QyxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILGdCQUFnQixtQkFBTyxDQUFDLG9FQUFXO0FBQ25DLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SCwyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csMENBQXlDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzdHLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsa0RBQWlELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzdILGdEQUErQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN6SCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWE7QUFDdkMsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLDJDQUEwQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNqSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSxpREFBZ0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDN0gsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUN2QyxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVk7QUFDckMsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCxxREFBb0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDcEksdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ2pELCtDQUE4QyxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUM5SCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBWTtBQUNyQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLHdDQUF1QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMxRyw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILHNCQUFzQixtQkFBTyxDQUFDLGdGQUFpQjtBQUMvQyxxREFBb0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDekksb0RBQW1ELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3ZJLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFpQjtBQUMvQyw2Q0FBNEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDekgsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQy9DLDZDQUE0QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUN6SCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBWTtBQUNyQywrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCw4Q0FBNkMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdEgsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVc7QUFDbkMsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsa0RBQWlELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzdILGdCQUFnQixtQkFBTyxDQUFDLG9FQUFXO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3Rzs7Ozs7Ozs7Ozs7QUM3RWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsY0FBYyxHQUFHLGdCQUFnQjtBQUMzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0VBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsVUFBVTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsT0FBTztBQUMzRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7QUNwT2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBDQUEwQztBQUN2RjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOzs7Ozs7Ozs7OztBQzFEYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDbEZhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDcERhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsc0VBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHNCQUFzQjtBQUNsRjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7Ozs7Ozs7Ozs7O0FDekZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0VBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWE7QUFDekM7QUFDQSwwRUFBMEUsU0FBUyxFQUFFLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7Ozs7Ozs7Ozs7O0FDbE9hO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0VBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7Ozs7Ozs7Ozs7QUNqQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMscUZBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLHlGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7OztBQ3hHYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBdUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMseUZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDZFQUFlO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLHVGQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0pBQWdKLFdBQVc7QUFDM0o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkNBQTJDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGtCQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDBCQUEwQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwQkFBMEI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EsNkJBQTZCO0FBQzdCOzs7Ozs7Ozs7OztBQ3pmYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsNkJBQTZCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCO0FBQ3pZLHVCQUF1QixtQkFBTyxDQUFDLG1GQUFrQjtBQUNqRCw4Q0FBNkMsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDNUgsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWU7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILGtEQUFpRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNqSSx5REFBd0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDL0ksZ0RBQStDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzdILG9EQUFtRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUNySSwwQkFBMEIsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDdkQsbURBQWtELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3pJLHdEQUF1RCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNuSix5QkFBeUIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDckQsa0RBQWlELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ3RJLDJEQUEwRCxFQUFFLHFDQUFxQyxzREFBc0QsRUFBQztBQUN4Six1REFBc0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDaEosdURBQXNELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ2hKLDJEQUEwRCxFQUFFLHFDQUFxQyxzREFBc0QsRUFBQztBQUN4SixvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUMzQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckgsa0JBQWtCLG1CQUFPLENBQUMseUVBQWE7QUFDdkMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HOzs7Ozs7Ozs7OztBQzFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyx1QkFBdUI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsNERBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1Qjs7Ozs7Ozs7Ozs7QUMzRGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRywrQkFBK0IsR0FBRyxzQkFBc0I7QUFDdEosaUJBQWlCLG1CQUFPLENBQUMsNERBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsUUFBUTtBQUNyRyxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxzQ0FBc0MsbUJBQW1CLFlBQVksY0FBYztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLFFBQVE7QUFDckcsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7Ozs7Ozs7Ozs7O0FDdFNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywrRUFBb0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLHlGQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHFGQUFxRixFQUFFO0FBQ3ZGLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUNBQXFDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7Ozs7Ozs7Ozs7QUN4S2E7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxxQkFBcUI7QUFDNUUsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMseUJBQXlCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDZFQUFlO0FBQzdDLDRCQUE0QixtQkFBTyxDQUFDLHlGQUFxQjtBQUN6RCwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsNkVBQWU7QUFDN0M7QUFDQSxzQ0FBc0MsbUJBQW1CLFlBQVksY0FBYztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzRkFBc0Ysa0JBQWtCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7Ozs7Ozs7OztBQ25KYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7Ozs7Ozs7Ozs7O0FDbkNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGNBQWM7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7Ozs7Ozs7Ozs7QUMzRGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7OztBQy9CYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDM0MsNENBQTJDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3JILG1CQUFtQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3pDLDBDQUF5QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNoSCx3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbkQsK0NBQThDLEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQy9ILHlCQUF5QixtQkFBTyxDQUFDLDBGQUFvQjtBQUNyRCxnREFBK0MsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDbEkscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzdDLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SDs7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDBCQUEwQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNyRCx1SUFBdUksa0NBQWtDLGlCQUFpQiw4QkFBOEIsOEJBQThCLHVOQUF1TixrQkFBa0IsV0FBVyxtVUFBbVUsbUJBQW1CLDJFQUEyRSxzTEFBc0wseUtBQXlLLDZGQUE2Riw0TEFBNEwsMk9BQTJPLHdCQUF3QixxRUFBcUUsb0RBQW9ELE9BQU8sR0FBRyx5WUFBeVksNkVBQTZFLDhGQUE4Riw0REFBNEQsMEhBQTBILHVCQUF1Qiw2Q0FBNkMsZ0ZBQWdGLHFGQUFxRiwwREFBMEQsa0JBQWtCLDJJQUEySSx3QkFBd0IsMkJBQTJCLHFGQUFxRixtRkFBbUYsb0JBQW9CLGdJQUFnSSxxS0FBcUssZ0NBQWdDLGlPQUFpTyxpQkFBaUIsZ0dBQWdHLHlTQUF5UywyZEFBMmQsa0RBQWtELDBKQUEwSixzSEFBc0gsbUJBQW1CLG1WQUFtVixvREFBb0QsZ0pBQWdKLDhJQUE4SSxzREFBc0Qsa2FBQWthLHNEQUFzRCxnQkFBZ0IscUhBQXFILG1DQUFtQyxrQ0FBa0MsMEJBQTBCLHNHQUFzRywrREFBK0QsaUNBQWlDLGtQQUFrUDtBQUNqMk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7Ozs7Ozs7Ozs7QUNsQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDBCQUEwQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNyRCxrUEFBa1AsZ01BQWdNLDhNQUE4TSxpRkFBaUYsb0JBQW9CLHlRQUF5USxhQUFhLFVBQVUsWUFBWSxtREFBbUQsZUFBZSx3RkFBd0YsNERBQTRELFVBQVUseUJBQXlCLGk0QkFBaTRCLDRCQUE0QiwyQ0FBMkMsMGRBQTBkLGNBQWMsb0xBQW9MLHdDQUF3Qyw2QkFBNkIsdU5BQXVOLHlqQkFBeWpCLGdIQUFnSCxvQ0FBb0MsY0FBYyxnQkFBZ0IsME9BQTBPLHNVQUFzVSx5REFBeUQsc0lBQXNJLE9BQU8saUpBQWlKLG1NQUFtTSxRQUFRLE1BQU0sd1hBQXdYLDBDQUEwQyxrQkFBa0IsNEJBQTRCLDhGQUE4RixzVUFBc1UsNkJBQTZCO0FBQzkxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7Ozs7Ozs7OztBQ2xDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMkJBQTJCLG1CQUFPLENBQUMsMEZBQW9CO0FBQ3ZELCtxQkFBK3FCLHlKQUF5SixNQUFNLHFCQUFxQiw2REFBNkQsd0RBQXdELHFCQUFxQiwwQkFBMEIsMEZBQTBGLGlKQUFpSiwyRkFBMkYsYUFBYSxVQUFVLDZHQUE2RyxpRUFBaUUsNEVBQTRFLG9GQUFvRiw4UEFBOFAsNkdBQTZHLHdSQUF3UixrQ0FBa0MsbUVBQW1FLHdLQUF3SyxnQ0FBZ0MsY0FBYywwV0FBMFcsOENBQThDLHdFQUF3RSxhQUFhLHVDQUF1QyxvQ0FBb0MsNkpBQTZKLEdBQUcsR0FBRyxxTUFBcU0scU5BQXFOLHNSQUFzUixtSEFBbUgsdUZBQXVGLGtCQUFrQixpTkFBaU4saUNBQWlDLGtHQUFrRyxxRUFBcUUsbUVBQW1FLHdCQUF3QixvRkFBb0YsR0FBRyx5SkFBeUosSUFBSSxrQkFBa0Isa0lBQWtJLGdKQUFnSixvQkFBb0IsMENBQTBDLG1NQUFtTSx5TEFBeUwsK0ZBQStGO0FBQzV2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDbkNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCwyQkFBMkIsbUJBQU8sQ0FBQywwRkFBb0I7QUFDdkQsK0VBQStFLHdHQUF3RyxvSEFBb0gsbU1BQW1NLHVDQUF1QyxJQUFJLCtGQUErRiw2SUFBNkkscVFBQXFRLGtDQUFrQyw2UEFBNlAsaUNBQWlDLDhEQUE4RCxrWUFBa1ksR0FBRyxnUUFBZ1EsSUFBSSxRQUFRLCtIQUErSCxnQkFBZ0Isa0ZBQWtGLCtFQUErRSwyREFBMkQsd0lBQXdJLDJEQUEyRCxrQkFBa0IsNlZBQTZWLDZCQUE2QixzQkFBc0IsMlVBQTJVLCtGQUErRixxQkFBcUIsVUFBVSx1TkFBdU4sMkNBQTJDLHNCQUFzQixXQUFXLDJGQUEyRixvUkFBb1IseUJBQXlCLHlDQUF5QywrTkFBK04sbVRBQW1ULHlLQUF5SywyQkFBMkIsd0RBQXdELDJJQUEySSwwQ0FBMEMsTUFBTSxvQ0FBb0MsdU5BQXVOLGdWQUFnVix5SEFBeUgscUVBQXFFLHNCQUFzQixVQUFVLHNCQUFzQix1S0FBdUssOEdBQThHLHVEQUF1RCxnT0FBZ08sOEZBQThGLHFEQUFxRCxpQ0FBaUMsMkNBQTJDLGtKQUFrSiwwTEFBMEwsZ1FBQWdRLDZDQUE2QyxvQkFBb0IsdUZBQXVGO0FBQzczTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDbkNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCwwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDckQsc0pBQXNKLHVLQUF1Syw2Q0FBNkMsK0JBQStCLGNBQWMsMkpBQTJKLDBJQUEwSSxrRUFBa0UsdURBQXVELEVBQUUsb0pBQW9KLGtDQUFrQyx5RUFBeUUsdUZBQXVGLHdCQUF3Qiw2QkFBNkIsc0dBQXNHLDZDQUE2QyxzUEFBc1AsV0FBVyw4RkFBOEYsb0NBQW9DLDBUQUEwVCxrREFBa0Qsb0JBQW9CLHNFQUFzRSxHQUFHLHNQQUFzUCwyRUFBMkUsa0NBQWtDLHdMQUF3TCwwRkFBMEYsMkNBQTJDLDZNQUE2TSxvRkFBb0YsaUJBQWlCLDhFQUE4RSxnSEFBZ0gsZ0NBQWdDLHNEQUFzRCxnTEFBZ0wsT0FBTyx1UUFBdVEsb2dCQUFvZ0Isd0hBQXdILElBQUksdWZBQXVmLHVCQUF1QixxSkFBcUosUUFBUSxvTUFBb00sbUJBQW1CLDJJQUEySSxHQUFHLGdJQUFnSSxPQUFPLHdMQUF3TCwyRUFBMkUseUJBQXlCLG1KQUFtSiwrSEFBK0gsMllBQTJZLDBUQUEwVCw4Q0FBOEMsNE9BQTRPLDRFQUE0RSwyQkFBMkIsa0VBQWtFLGdGQUFnRiwrRUFBK0U7QUFDajdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDbENhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7Ozs7Ozs7OztBQzdKYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE1BQU07QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDNUZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCwwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDckQsOExBQThMLDhHQUE4RywrQkFBK0Isb2dCQUFvZ0Isa0hBQWtILDRCQUE0QixrQkFBa0IsME9BQTBPLDJLQUEySywyR0FBMkcsZ0JBQWdCLHFFQUFxRSwrQ0FBK0MscUVBQXFFLGlHQUFpRyxjQUFjLGlGQUFpRiwwQkFBMEIsNkJBQTZCLDhEQUE4RCwwSkFBMEosb0hBQW9ILDBEQUEwRCw4UUFBOFEsd05BQXdOLHFCQUFxQixxU0FBcVMsT0FBTyxnWUFBZ1ksd0hBQXdILHNFQUFzRSw2VEFBNlQsVUFBVSwySUFBMkksaUhBQWlILE9BQU8sc0NBQXNDLDZFQUE2RSxxQ0FBcUMsa0pBQWtKLHFRQUFxUSw0RUFBNEUsOEtBQThLLDRCQUE0Qix3RkFBd0YscU5BQXFOLHNIQUFzSCw0UEFBNFAsR0FBRyxxREFBcUQsMEJBQTBCLGdGQUFnRiw2REFBNkQsZ01BQWdNLG1DQUFtQyxPQUFPLG9FQUFvRSxtQ0FBbUMsbUNBQW1DLEdBQUcsa0dBQWtHLHlVQUF5VSx1SUFBdUkseUNBQXlDLHNNQUFzTSx5Q0FBeUMsc0NBQXNDLGdEQUFnRCx1REFBdUQ7QUFDcnZPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDbENhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFlO0FBQzdDLGVBQWUsa0VBQWtFLE1BQU0scUVBQXFFLCtEQUErRCx1Q0FBdUMsU0FBUyw4RUFBOEUsU0FBUyx3QkFBd0IsZUFBZSxzREFBc0Qsd0JBQXdCLE1BQU0sbURBQW1ELGtCQUFrQixxQkFBcUIsU0FBUyxtREFBbUQsTUFBTSxHQUFHLHFCQUFxQiw4QkFBOEIsR0FBRyxTQUFTLEdBQUcscUJBQXFCLHNHQUFzRyxHQUFHLDJFQUEyRSxlQUFlLFNBQVMsMkJBQTJCLHdCQUF3QixNQUFNLGVBQWUsZUFBZSxHQUFHLG9DQUFvQyxlQUFlLEdBQUcsTUFBTSx3QkFBd0IsTUFBTSxNQUFNLEdBQUcsU0FBUyxHQUFHLGtCQUFrQixrQkFBa0Isd0VBQXdFLGtCQUFrQiwyRUFBMkUsU0FBUyxzREFBc0QsR0FBRyxlQUFlLFNBQVMsd0JBQXdCLGVBQWUsTUFBTSxZQUFZLGtCQUFrQiw4QkFBOEIsR0FBRyxZQUFZLGtCQUFrQixHQUFHLEdBQUcsR0FBRyxvQ0FBb0MsOEJBQThCLEdBQUcsdUZBQXVGLE1BQU0sWUFBWSxlQUFlLE1BQU0sMENBQTBDLFNBQVMsR0FBRywyQkFBMkIsaUNBQWlDLGVBQWUsK0RBQStELGtCQUFrQixTQUFTLEdBQUcsR0FBRyxzREFBc0QscUJBQXFCLFlBQVksZUFBZSxTQUFTLE1BQU0sTUFBTSxvQ0FBb0Msb0NBQW9DLGtCQUFrQixHQUFHLGlDQUFpQywwQ0FBMEMsd0JBQXdCLHdCQUF3Qix1Q0FBdUMsd0JBQXdCLHdCQUF3QixHQUFHLGlDQUFpQyxlQUFlLDhCQUE4QixHQUFHLEdBQUcsTUFBTSxNQUFNLEdBQUcsU0FBUyxTQUFTLE1BQU0sR0FBRyxHQUFHLDZDQUE2QyxNQUFNLE1BQU0sZUFBZSxTQUFTLGtCQUFrQixxQkFBcUIsTUFBTSxHQUFHLFNBQVMsR0FBRyxHQUFHLE1BQU0sOEJBQThCLFlBQVksd0JBQXdCLGVBQWUsdUNBQXVDLGtCQUFrQiwwQ0FBMEMsR0FBRyxZQUFZLDZGQUE2RixlQUFlLFNBQVMsZUFBZSwyQkFBMkIsU0FBUyxHQUFHLHdCQUF3QixHQUFHLEdBQUcsTUFBTSxNQUFNLDREQUE0RCxrQkFBa0IscUJBQXFCLDhCQUE4QiwyQkFBMkIsTUFBTSxrQkFBa0IsOEJBQThCLFNBQVMsZUFBZSxZQUFZLEdBQUcsU0FBUyw4QkFBOEIsR0FBRyxTQUFTLE1BQU0sTUFBTSxHQUFHLFlBQVksTUFBTSxlQUFlLFNBQVMsMkJBQTJCLGdEQUFnRCxHQUFHLE1BQU0sR0FBRyxxQkFBcUIsK0RBQStELE1BQU0sR0FBRyxTQUFTLFlBQVksMkJBQTJCLGdEQUFnRCxTQUFTLEdBQUcsaUNBQWlDLFNBQVMsR0FBRyxNQUFNLE1BQU0sNkNBQTZDLE1BQU0sR0FBRyx1Q0FBdUMscUJBQXFCLHFCQUFxQixNQUFNLEdBQUcscUJBQXFCLE1BQU0sTUFBTSxvQ0FBb0MsU0FBUyx3QkFBd0Isd0JBQXdCLFlBQVksZUFBZSxTQUFTLHdCQUF3QixZQUFZLGlDQUFpQyxHQUFHLGVBQWUscUJBQXFCLEdBQUcsK0RBQStELFNBQVMsa0JBQWtCLFlBQVksMkJBQTJCLGVBQWUsR0FBRyxNQUFNLGVBQWUsOEJBQThCLFNBQVMsR0FBRyxzREFBc0QsR0FBRyxxQkFBcUIsR0FBRyxHQUFHLEdBQUcsWUFBWSxNQUFNLFNBQVMsb0NBQW9DLFNBQVMsTUFBTSx3QkFBd0IsR0FBRyx3QkFBd0Isa0JBQWtCLEdBQUcsNkNBQTZDLE1BQU0sTUFBTSxZQUFZLGVBQWUsR0FBRyxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsU0FBUyxNQUFNLE1BQU0sU0FBUyxZQUFZLFNBQVMsR0FBRyxxQkFBcUIsWUFBWSxNQUFNLEdBQUcsTUFBTSxNQUFNLEdBQUcsOEJBQThCLEdBQUcsR0FBRyxNQUFNLE1BQU0sMkJBQTJCLGtCQUFrQixHQUFHLE1BQU0sU0FBUyxNQUFNLE1BQU0sWUFBWSxxQkFBcUIsZUFBZSxNQUFNLEdBQUcsd0JBQXdCLEdBQUcsU0FBUyxHQUFHLHFCQUFxQixNQUFNLG9DQUFvQyxNQUFNLDJCQUEyQix3QkFBd0IsMENBQTBDLEdBQUcsNkZBQTZGLFlBQVksR0FBRyxHQUFHLHFCQUFxQixNQUFNLEdBQUcsTUFBTSxrQkFBa0IsZUFBZSxHQUFHLFlBQVksOEJBQThCLGVBQWUsd0JBQXdCLDJCQUEyQixZQUFZLCtEQUErRCxtREFBbUQsWUFBWSxZQUFZLCtEQUErRCxpQ0FBaUMsR0FBRyxrQkFBa0IsTUFBTSxTQUFTLFlBQVkscUVBQXFFLEdBQUcsU0FBUyxTQUFTLEdBQUcsWUFBWSxlQUFlLHFCQUFxQixNQUFNLHdCQUF3QixNQUFNLGVBQWUsZUFBZSxlQUFlLFlBQVksTUFBTSxNQUFNLGtCQUFrQixvQ0FBb0M7QUFDemdNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGtHQUFrRyxNQUFNO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDL0ZhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFtQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7O0FDckVhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiwwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDckQseUJBQXlCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOzs7Ozs7Ozs7OztBQ3ZDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7Ozs7Ozs7Ozs7QUM3Q2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O1VDckNBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmhlbml4anMvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2ZoZW5peGpzLy4vc3JjL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2wvRUlQNzEyLnRzIiwid2VicGFjazovL2ZoZW5peGpzLy4vc3JjL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2wvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi9zcmMvZXh0ZW5zaW9ucy9hY2Nlc3NfY29udHJvbC9wZXJtaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi9zcmMvc2RrL2NvbnN0cy50cyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uL3NyYy9zZGsvZW5jcnlwdC50cyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uL3NyYy9zZGsvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi9zcmMvc2RrL3NlYWxpbmcudHMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi9zcmMvc2RrL3R5cGVzLnRzIiwid2VicGFjazovL2ZoZW5peGpzLy4vc3JjL3Nkay91dGlscy50cyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uL3NyYy9zZGsvdmFsaWRhdGlvbi50cyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uL25vZGVfbW9kdWxlcy8ucG5wbS90d2VldG5hY2wtdXRpbEAwLjE1LjEvbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC11dGlsL25hY2wtdXRpbC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uL25vZGVfbW9kdWxlcy8ucG5wbS90d2VldG5hY2xAMS4wLjMvbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcGJrZGYyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zY3J5cHQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgY29tbW9uanMgXCJidWZmZXJ1dGlsXCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgY29tbW9uanMgXCJub2RlLXRmaGVcIiIsIndlYnBhY2s6Ly9maGVuaXhqcy9leHRlcm5hbCBjb21tb25qcyBcInV0Zi04LXZhbGlkYXRlXCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImJ1ZmZlclwiIiwid2VicGFjazovL2ZoZW5peGpzL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly9maGVuaXhqcy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImh0dHBcIiIsIndlYnBhY2s6Ly9maGVuaXhqcy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly9maGVuaXhqcy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibmV0XCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6Y3J5cHRvXCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInN0cmVhbVwiIiwid2VicGFjazovL2ZoZW5peGpzL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ0bHNcIiIsIndlYnBhY2s6Ly9maGVuaXhqcy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXJsXCIiLCJ3ZWJwYWNrOi8vZmhlbml4anMvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInpsaWJcIiIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9hZXMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1jYmMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1jZmIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1jdHIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1lY2IuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1vZmIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9wYWRkaW5nLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL192ZXJzaW9uLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9hYmktY29kZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2J5dGVzMzIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9hcnJheS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9ieXRlcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvbnVsbC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL251bWJlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3R1cGxlLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9mcmFnbWVudHMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2luZGV4LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL3R5cGVkLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FkZHJlc3MvYWRkcmVzcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NoZWNrcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9oYXNoZXMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29uc3RhbnRzL2luZGV4LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9udW1iZXJzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9zdHJpbmdzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnRyYWN0L2NvbnRyYWN0LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnRyYWN0L2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29udHJhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29udHJhY3Qvd3JhcHBlcnMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL2NyeXB0by5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaG1hYy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL2tlY2Nhay5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcGJrZGYyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2NyeXB0LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zaGEyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2V0aGVycy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2lkLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9tZXNzYWdlLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvbmFtZWhhc2guanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9zb2xpZGl0eS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL3R5cGVkLWRhdGEuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2NvbW11bml0eS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2luZGV4LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9uZXR3b3JrLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWFsY2hlbXkuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWFua3IuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWNoYWluc3RhY2suanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWNsb3VkZmxhcmUuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWV0aGVyc2Nhbi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWluZnVyYS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1qc29ucnBjLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1wb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLXF1aWNrbm9kZS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci13ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zaWduZXItbm9uY2VtYW5hZ2VyLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zdWJzY3JpYmVyLXBvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3dzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNTguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvYmFzZTY0LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvZXJyb3JzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9mZXRjaC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9maXhlZG51bWJlci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9nZXR1cmwuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvbWF0aHMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZGVjb2RlLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3JscC1lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvdW5pdHMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvdXRmOC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dWlkLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9iYXNlLXdhbGxldC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaGR3YWxsZXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L2luZGV4LmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9qc29uLWNyb3dkc2FsZS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvbW5lbW9uaWMuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L3V0aWxzLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC93YWxsZXQuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2JpdC1yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2RlY29kZS1vd2wuanMiLCJ3ZWJwYWNrOi8vZmhlbml4anMvLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2RlY29kZS1vd2xhLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1jei5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lbi5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lcy5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1mci5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1pdC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1qYS5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1rby5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1wdC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy16aC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy93b3JkbGlzdC1vd2xhLmpzIiwid2VicGFjazovL2ZoZW5peGpzLy4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy93b3JkbGlzdC5qcyIsIndlYnBhY2s6Ly9maGVuaXhqcy8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3RzLmpzIiwid2VicGFjazovL2ZoZW5peGpzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ZoZW5peGpzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9maGVuaXhqcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2ZoZW5peGpzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZmhlbml4anMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9maGVuaXhqcy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vZmhlbml4anMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZoZW5peGpzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZoZW5peGpzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgKCkgPT4ge1xucmV0dXJuICIsImV4cG9ydCB0eXBlIEVJUDcxMlR5cGUgPSB7IG5hbWU6IHN0cmluZzsgdHlwZTogc3RyaW5nIH07XG5leHBvcnQgdHlwZSBFSVA3MTJUeXBlcyA9IFJlY29yZDxzdHJpbmcsIEVJUDcxMlR5cGVbXT47XG5leHBvcnQgdHlwZSBFSVA3MTJNZXNzYWdlID0gUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbmV4cG9ydCB0eXBlIEVJUDcxMkRvbWFpbiA9IHtcbiAgY2hhaW5JZDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIHZlcmlmeWluZ0NvbnRyYWN0OiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEVJUDcxMiA9IHtcbiAgZG9tYWluOiBFSVA3MTJEb21haW47XG4gIG1lc3NhZ2U6IEVJUDcxMk1lc3NhZ2U7XG4gIHByaW1hcnlUeXBlOiBzdHJpbmc7XG4gIHR5cGVzOiBFSVA3MTJUeXBlcztcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9wZXJtaXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0VJUDcxMlwiO1xuIiwiaW1wb3J0IHsgaXNBZGRyZXNzIH0gZnJvbSBcIi4uLy4uLy4uL3Nkay91dGlsc1wiO1xuaW1wb3J0IHtcbiAgZGV0ZXJtaW5lUmVxdWVzdE1ldGhvZCxcbiAgZGV0ZXJtaW5lUmVxdWVzdFNpZ25lcixcbiAgU3VwcG9ydGVkUHJvdmlkZXIsXG59IGZyb20gXCIuLi8uLi8uLi9zZGsvdHlwZXNcIjtcbmltcG9ydCB7IEVJUDcxMiwgRUlQNzEyRG9tYWluLCBFSVA3MTJNZXNzYWdlLCBFSVA3MTJUeXBlcyB9IGZyb20gXCIuLi9FSVA3MTJcIjtcbmltcG9ydCB7IEdlbmVyYXRlU2VhbGluZ0tleSwgU2VhbGluZ0tleSB9IGZyb20gXCIuLi8uLi8uLi9zZGsvc2VhbGluZ1wiO1xuXG5jb25zdCBQRVJNSVRfUFJFRklYID0gXCJGaGVuaXhfc2F2ZWRfcGVybWl0X1wiO1xuXG5leHBvcnQgdHlwZSBQZXJtaXNzaW9uID0ge1xuICBzaWduYXR1cmU6IHN0cmluZztcbiAgcHVibGljS2V5OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBwZXJtaXQgd2l0aCBjcnlwdG9ncmFwaGljIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCB0eXBlIFBlcm1pdCA9IHtcbiAgLyoqXG4gICAqIFRoZSBFdGhlcmV1bSBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVybWl0LlxuICAgKi9cbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzZWFsaW5nIGtleSBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byBzZWFsIG9yIHVuc2VhbCBkYXRhIHJlbGF0ZWQgdG8gdGhlIHBlcm1pdC5cbiAgICovXG4gIHNlYWxpbmdLZXk6IFNlYWxpbmdLZXk7XG5cbiAgLyoqXG4gICAqIEEgY3J5cHRvZ3JhcGhpYyBzaWduYXR1cmUgcHJvdmluZyB0aGUgYXV0aGVudGljaXR5IGFuZCBpbnRlZ3JpdHkgb2YgdGhlIHBlcm1pdC5cbiAgICovXG4gIHNpZ25hdHVyZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcml2YXRlIGtleSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBzaWduYXR1cmUuXG4gICAqL1xuICBwdWJsaWNLZXk6IHN0cmluZztcbn07XG5cbnR5cGUgU2VyaWFsaXplZFBlcm1pdCA9IHtcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHNlYWxpbmdLZXk6IHtcbiAgICBwcml2YXRlS2V5OiBzdHJpbmc7XG4gICAgcHVibGljS2V5OiBzdHJpbmc7XG4gIH07XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufTtcblxuY29uc3QgcGFyc2VQZXJtaXQgPSAoc2F2ZWRQZXJtaXQ6IHN0cmluZyk6IFBlcm1pdCA9PiB7XG4gIGNvbnN0IG8gPSBKU09OLnBhcnNlKHNhdmVkUGVybWl0KSBhcyBTZXJpYWxpemVkUGVybWl0O1xuICBpZiAobykge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IG8uY29udHJhY3RBZGRyZXNzLFxuICAgICAgc2VhbGluZ0tleTogbmV3IFNlYWxpbmdLZXkoXG4gICAgICAgIG8uc2VhbGluZ0tleS5wcml2YXRlS2V5LFxuICAgICAgICBvLnNlYWxpbmdLZXkucHVibGljS2V5LFxuICAgICAgKSxcbiAgICAgIHNpZ25hdHVyZTogby5zaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXk6IGAweCR7by5zZWFsaW5nS2V5LnB1YmxpY0tleX1gLFxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcGVybWl0YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UGVybWl0ID0gYXN5bmMgKFxuICBjb250cmFjdDogc3RyaW5nLFxuICBwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXG4gIGF1dG9HZW5lcmF0ZTogYm9vbGVhbiA9IHRydWUsXG4pOiBQcm9taXNlPFBlcm1pdCB8IG51bGw+ID0+IHtcbiAgaXNBZGRyZXNzKGNvbnRyYWN0KTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBwcm92aWRlcmApO1xuICB9XG5cbiAgY29uc3QgZ2V0U2lnbmVyID0gZGV0ZXJtaW5lUmVxdWVzdFNpZ25lcihwcm92aWRlcik7XG4gIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcihwcm92aWRlcik7XG5cbiAgbGV0IHNhdmVkUGVybWl0ID0gbnVsbDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgIHNhdmVkUGVybWl0ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgYCR7UEVSTUlUX1BSRUZJWH0ke2NvbnRyYWN0fV8ke2F3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCl9YCxcbiAgICApO1xuICAgIGlmICghc2F2ZWRQZXJtaXQpIHtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIHNhdmVkUGVybWl0ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2F2ZWRQZXJtaXQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHBhcnNlUGVybWl0KHNhdmVkUGVybWl0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXV0b0dlbmVyYXRlID8gZ2VuZXJhdGVQZXJtaXQoY29udHJhY3QsIHByb3ZpZGVyKSA6IG51bGw7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWxsUGVybWl0cyA9ICgpOiBNYXA8c3RyaW5nLCBQZXJtaXQ+ID0+IHtcbiAgY29uc3QgcGVybWl0czogTWFwPHN0cmluZywgUGVybWl0PiA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbmRvdy5sb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICBpZiAoa2V5ICYmIGtleS5pbmNsdWRlcyhQRVJNSVRfUFJFRklYKSkge1xuICAgICAgY29uc3QgY29udHJhY3QgPSBrZXkucmVwbGFjZShQRVJNSVRfUFJFRklYLCBcIlwiKTtcblxuICAgICAgLy8gTm90IHN1cmUgaWYgbmVlZGVkLCBjb2RlIHBsYWNlaG9sZGVyOlxuICAgICAgLy8gY29uc3Qgbm9QcmVmaXhQZXJtaXQgPSBrZXkucmVwbGFjZShQRVJNSVRfUFJFRklYLCBcIlwiKTtcbiAgICAgIC8vIGxldCBjb250cmFjdCA9IFwiXCI7XG4gICAgICAvLyBpZiAobm9QcmVmaXhQZXJtaXQuaW5jbHVkZXMoXCJfXCIpKSB7XG4gICAgICAvLyAgIGNvbnN0IHRtcCA9IG5vUHJlZml4UGVybWl0LnNwbGl0KFwiX1wiKTtcbiAgICAgIC8vICAgY29udHJhY3QgPSB0bXBbMF07XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBjb250cmFjdCA9IG5vUHJlZml4UGVybWl0O1xuICAgICAgLy8gfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwZXJtaXQgPSBwYXJzZVBlcm1pdCh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSEpO1xuICAgICAgICBwZXJtaXRzLnNldChjb250cmFjdCwgcGVybWl0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBlcm1pdHM7XG59O1xuXG5pbnRlcmZhY2UgU2lnbmVyUHVibGljU2lnbmVkVHlwZWREYXRhIHtcbiAgc2lnblR5cGVkRGF0YShkb21haW46IG9iamVjdCwgdHlwZXM6IG9iamVjdCwgdmFsdWU6IG9iamVjdCk6IFByb21pc2U8c3RyaW5nPjtcbiAgZ2V0QWRkcmVzcygpOiBQcm9taXNlPHN0cmluZz47XG59XG5pbnRlcmZhY2UgU2lnbmVyUHJpdmF0ZVNpZ25lZFR5cGVkRGF0YSB7XG4gIF9zaWduVHlwZWREYXRhKGRvbWFpbjogb2JqZWN0LCB0eXBlczogb2JqZWN0LCB2YWx1ZTogb2JqZWN0KTogUHJvbWlzZTxzdHJpbmc+O1xuICBnZXRBZGRyZXNzKCk6IFByb21pc2U8c3RyaW5nPjtcbn1cblxuZXhwb3J0IHR5cGUgUGVybWl0U2lnbmVyID1cbiAgfCBTaWduZXJQcml2YXRlU2lnbmVkVHlwZWREYXRhXG4gIHwgU2lnbmVyUHVibGljU2lnbmVkVHlwZWREYXRhO1xuXG5jb25zdCBzaWduID0gYXN5bmMgKFxuICBzaWduZXI6IFBlcm1pdFNpZ25lcixcbiAgZG9tYWluOiBFSVA3MTJEb21haW4sXG4gIHR5cGVzOiBFSVA3MTJUeXBlcyxcbiAgdmFsdWU6IEVJUDcxMk1lc3NhZ2UsXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBpZiAoXG4gICAgXCJfc2lnblR5cGVkRGF0YVwiIGluIHNpZ25lciAmJlxuICAgIHR5cGVvZiBzaWduZXIuX3NpZ25UeXBlZERhdGEgPT0gXCJmdW5jdGlvblwiXG4gICkge1xuICAgIHJldHVybiBhd2FpdCBzaWduZXIuX3NpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKFxuICAgIFwic2lnblR5cGVkRGF0YVwiIGluIHNpZ25lciAmJlxuICAgIHR5cGVvZiBzaWduZXIuc2lnblR5cGVkRGF0YSA9PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzaWduZXJcIik7XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVQZXJtaXQgPSBhc3luYyAoXG4gIGNvbnRyYWN0OiBzdHJpbmcsXG4gIHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcixcbiAgY3VzdG9tU2lnbmVyPzogUGVybWl0U2lnbmVyLFxuKTogUHJvbWlzZTxQZXJtaXQ+ID0+IHtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3RNZXRob2QgPSBkZXRlcm1pbmVSZXF1ZXN0TWV0aG9kKHByb3ZpZGVyKTtcblxuICBsZXQgc2lnbmVyOiBQZXJtaXRTaWduZXI7XG4gIGlmICghY3VzdG9tU2lnbmVyKSB7XG4gICAgY29uc3QgZ2V0U2lnbmVyID0gZGV0ZXJtaW5lUmVxdWVzdFNpZ25lcihwcm92aWRlcik7XG4gICAgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKHByb3ZpZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBzaWduZXIgPSBjdXN0b21TaWduZXI7XG4gIH1cblxuICBjb25zdCBjaGFpbklkID0gYXdhaXQgcmVxdWVzdE1ldGhvZChwcm92aWRlciwgXCJldGhfY2hhaW5JZFwiLCBbXSk7XG5cbiAgY29uc3Qga2V5cGFpciA9IGF3YWl0IEdlbmVyYXRlU2VhbGluZ0tleSgpO1xuICBjb25zdCBtc2dQYXJhbXM6IEVJUDcxMiA9IHtcbiAgICB0eXBlczoge1xuICAgICAgLy8gVGhpcyByZWZlcnMgdG8gdGhlIGRvbWFpbiB0aGUgY29udHJhY3QgaXMgaG9zdGVkIG9uLlxuICAgICAgRUlQNzEyRG9tYWluOiBbXG4gICAgICAgIHsgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICB7IG5hbWU6IFwiY2hhaW5JZFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICB7IG5hbWU6IFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIF0sXG4gICAgICAvLyBSZWZlciB0byBwcmltYXJ5VHlwZS5cbiAgICAgIFBlcm1pc3Npb25lZDogW3sgbmFtZTogXCJwdWJsaWNLZXlcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgfSxcbiAgICAvLyBUaGlzIGRlZmluZXMgdGhlIG1lc3NhZ2UgeW91J3JlIHByb3Bvc2luZyB0aGUgdXNlciB0byBzaWduLCBpcyBkYXBwLXNwZWNpZmljLCBhbmQgY29udGFpbnNcbiAgICAvLyBhbnl0aGluZyB5b3Ugd2FudC4gVGhlcmUgYXJlIG5vIHJlcXVpcmVkIGZpZWxkcy4gQmUgYXMgZXhwbGljaXQgYXMgcG9zc2libGUgd2hlbiBidWlsZGluZyBvdXRcbiAgICAvLyB0aGUgbWVzc2FnZSBzY2hlbWEuXG4gICAgLy8gVGhpcyByZWZlcnMgdG8gdGhlIGtleXMgb2YgdGhlIGZvbGxvd2luZyB0eXBlcyBvYmplY3QuXG4gICAgcHJpbWFyeVR5cGU6IFwiUGVybWlzc2lvbmVkXCIsXG4gICAgZG9tYWluOiB7XG4gICAgICAvLyBHaXZlIGEgdXNlci1mcmllbmRseSBuYW1lIHRvIHRoZSBzcGVjaWZpYyBjb250cmFjdCB5b3UncmUgc2lnbmluZyBmb3IuXG4gICAgICBuYW1lOiBcIkZoZW5peCBQZXJtaXNzaW9uXCIsIC8vIHBhcmFtcy5uYW1lXG4gICAgICAvLyBUaGlzIGlkZW50aWZpZXMgdGhlIGxhdGVzdCB2ZXJzaW9uLlxuICAgICAgdmVyc2lvbjogXCIxLjBcIiwgLy9wYXJhbXMudmVyc2lvbiB8fFxuICAgICAgLy8gVGhpcyBkZWZpbmVzIHRoZSBuZXR3b3JrLCBpbiB0aGlzIGNhc2UsIE1haW5uZXQuXG4gICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgLy8gLy8gQWRkIGEgdmVyaWZ5aW5nIGNvbnRyYWN0IHRvIG1ha2Ugc3VyZSB5b3UncmUgZXN0YWJsaXNoaW5nIGNvbnRyYWN0cyB3aXRoIHRoZSBwcm9wZXIgZW50aXR5LlxuICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGNvbnRyYWN0LCAvL3BhcmFtcy52ZXJpZnlpbmdDb250cmFjdCxcbiAgICB9LFxuICAgIG1lc3NhZ2U6IHtcbiAgICAgIHB1YmxpY0tleTogYDB4JHtrZXlwYWlyLnB1YmxpY0tleX1gLFxuICAgIH0sXG4gIH07XG5cbiAgY29uc3QgbXNnU2lnID0gYXdhaXQgc2lnbihcbiAgICBzaWduZXIsXG4gICAgbXNnUGFyYW1zLmRvbWFpbixcbiAgICB7IFBlcm1pc3Npb25lZDogbXNnUGFyYW1zLnR5cGVzLlBlcm1pc3Npb25lZCB9LFxuICAgIG1zZ1BhcmFtcy5tZXNzYWdlLFxuICApO1xuXG4gIGNvbnN0IHBlcm1pdDogUGVybWl0ID0ge1xuICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgc2VhbGluZ0tleToga2V5cGFpcixcbiAgICBzaWduYXR1cmU6IG1zZ1NpZyxcbiAgICBwdWJsaWNLZXk6IGAweCR7a2V5cGFpci5wdWJsaWNLZXl9YCxcbiAgICAvL3Blcm1pdDogbXNnUGFyYW1zLFxuICAgIC8vbXNnU2lnXG4gIH07XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAvLyBTZWFsaW5nIGtleSBpcyBhIGNsYXNzLCBhbmQgd2lsbCBpbmNsdWRlIG1ldGhvZHMgaW4gdGhlIEpTT05cbiAgICBjb25zdCBzZXJpYWxpemVkOiBTZXJpYWxpemVkUGVybWl0ID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBwZXJtaXQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgc2VhbGluZ0tleToge1xuICAgICAgICBwdWJsaWNLZXk6IHBlcm1pdC5zZWFsaW5nS2V5LnB1YmxpY0tleSxcbiAgICAgICAgcHJpdmF0ZUtleTogcGVybWl0LnNlYWxpbmdLZXkucHJpdmF0ZUtleSxcbiAgICAgIH0sXG4gICAgICBzaWduYXR1cmU6IHBlcm1pdC5zaWduYXR1cmUsXG4gICAgfTtcblxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgIGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1fJHthd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpfWAsXG4gICAgICBKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBwZXJtaXQ7XG59O1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlUGVybWl0ID0gKGNvbnRyYWN0OiBzdHJpbmcsIGFjY291bnQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBpZiAoIWFjY291bnQpIHtcbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1gKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYCR7UEVSTUlUX1BSRUZJWH0ke2NvbnRyYWN0fV8ke2FjY291bnR9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQZXJtaXRGcm9tTG9jYWxzdG9yYWdlID0gKFxuICBjb250cmFjdDogc3RyaW5nLFxuICBhY2NvdW50OiBzdHJpbmcsXG4pOiBQZXJtaXQgfCB1bmRlZmluZWQgPT4ge1xuICBsZXQgc2F2ZWRQZXJtaXQgPSB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICBzYXZlZFBlcm1pdCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgIGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1fJHthY2NvdW50fWAsXG4gICAgKTtcbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIHNhdmVkUGVybWl0ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2F2ZWRQZXJtaXQgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgIGAke1BFUk1JVF9QUkVGSVh9JHtjb250cmFjdH1fJHthY2NvdW50fWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2F2ZWRQZXJtaXQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlUGVybWl0KHNhdmVkUGVybWl0KTtcbn07XG4iLCIvLyBmb3IgbW9iaWxlXG4vLyBpZiAodHlwZW9mIEJpZ0ludCA9PT0gXCJ1bmRlZmluZWRcIikge1xuLy8gICBnbG9iYWwuQmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuLy8gfVxuXG5leHBvcnQgeyBGaGVuaXhDbGllbnQgfSBmcm9tIFwiLi9zZGsvaW5kZXhcIjtcblxuZXhwb3J0IHtcbiAgQ29udHJhY3RQZXJtaXRzLFxuICBJbnN0YW5jZVBhcmFtcyxcbiAgU3VwcG9ydGVkUHJvdmlkZXIsXG4gIEVuY3J5cHRpb25UeXBlcyxcbiAgSGFyZGhhdEV0aGVyc1Byb3ZpZGVyLFxuICBFdGhlcnNQcm92aWRlcixcbiAgRW5jcnlwdGVkVWludDY0LFxuICBFbmNyeXB0ZWRVaW50MTI4LFxuICBFbmNyeXB0ZWRVaW50MjU2LFxuICBFbmNyeXB0ZWRVaW50MzIsXG4gIEVuY3J5cHRlZFVpbnQxNixcbiAgRW5jcnlwdGVkVWludDgsXG4gIEVuY3J5cHRlZEJvb2wsXG4gIEVuY3J5cHRlZE51bWJlcixcbiAgRW5jcnlwdGVkQWRkcmVzcyxcbn0gZnJvbSBcIi4vc2RrL3R5cGVzXCI7XG5cbmV4cG9ydCAqIGZyb20gXCIuL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2xcIjtcblxuZXhwb3J0IHsgU2VhbGluZ0tleSwgR2VuZXJhdGVTZWFsaW5nS2V5IH0gZnJvbSBcIi4vc2RrL3NlYWxpbmdcIjtcbiIsImV4cG9ydCBjb25zdCBNQVhfVUlOVDggPSAyNTU7XG5leHBvcnQgY29uc3QgTUFYX1VJTlQxNiA9IDY1NTM1O1xuZXhwb3J0IGNvbnN0IE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1O1xuZXhwb3J0IGNvbnN0IEZoZU9wc0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MFwiO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIX01JTiA9IDE1XzAwMDtcbiIsImltcG9ydCB7XG4gIFRmaGVDb21wYWN0UHVibGljS2V5LFxuICBDb21wYWN0RmhlQm9vbExpc3QsXG4gIENvbXBhY3RGaGVVaW50OExpc3QsXG4gIENvbXBhY3RGaGVVaW50MTZMaXN0LFxuICBDb21wYWN0RmhlVWludDMyTGlzdCxcbiAgQ29tcGFjdEZoZVVpbnQ2NExpc3QsXG4gIENvbXBhY3RGaGVVaW50MTI4LFxuICBDb21wYWN0RmhlVWludDE2MCxcbiAgQ29tcGFjdEZoZVVpbnQyNTYsXG59IGZyb20gXCJub2RlLXRmaGVcIjtcbmltcG9ydCB7XG4gIEVuY3J5cHRlZE51bWJlcixcbiAgRW5jcnlwdGVkVWludDE2LFxuICBFbmNyeXB0ZWRVaW50MzIsXG4gIEVuY3J5cHRlZFVpbnQ4LFxuICBFbmNyeXB0ZWRCb29sLFxuICBFbmNyeXB0ZWRVaW50NjQsXG4gIEVuY3J5cHRlZFVpbnQxMjgsXG4gIEVuY3J5cHRlZFVpbnQyNTYsXG4gIEVuY3J5cHRlZEFkZHJlc3MsXG4gIEVuY3J5cHRpb25UeXBlcyxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGZyb21IZXhTdHJpbmcsIHRvQmlnSW50IH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuLyoqXG4gKiBFbmNyeXB0cyBhIFVpbnQ4IHZhbHVlIHVzaW5nIFRGSEUgKEZhc3QgRnVsbHkgSG9tb21vcnBoaWMgRW5jcnlwdGlvbiBvdmVyIHRoZSBUb3J1cykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVGhlIEJvb2xlYW4gdmFsdWUgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSB7VGZoZUNvbXBhY3RQdWJsaWNLZXl9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHVzZWQgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgdG8gZW5jcnlwdCB0aGUgdmFsdWUgb24uXG4gKiBAcmV0dXJucyB7RW5jcnlwdGVkQm9vbH0gLSBUaGUgZW5jcnlwdGVkIHZhbHVlIHNlcmlhbGl6ZWQgYXMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY3J5cHRfYm9vbCA9IChcbiAgdmFsdWU6IGJvb2xlYW4sXG4gIHB1YmxpY0tleTogVGZoZUNvbXBhY3RQdWJsaWNLZXksXG4gIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCxcbik6IEVuY3J5cHRlZEJvb2wgPT4ge1xuICBjb25zdCBlbmNyeXB0ZWQgPSBDb21wYWN0RmhlQm9vbExpc3QuZW5jcnlwdF93aXRoX2NvbXBhY3RfcHVibGljX2tleShcbiAgICBbdmFsdWVdLFxuICAgIHB1YmxpY0tleSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBlbmNyeXB0ZWQuc2VyaWFsaXplKCksXG4gICAgc2VjdXJpdHlab25lLFxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNyeXB0cyBhIFVpbnQ4IHZhbHVlIHVzaW5nIFRGSEUgKEZhc3QgRnVsbHkgSG9tb21vcnBoaWMgRW5jcnlwdGlvbiBvdmVyIHRoZSBUb3J1cykuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgVWludDggdmFsdWUgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSB7VGZoZUNvbXBhY3RQdWJsaWNLZXl9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHVzZWQgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgdG8gZW5jcnlwdCB0aGUgdmFsdWUgb24uXG4gKiBAcmV0dXJucyB7RW5jcnlwdGVkVWludDh9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0X3VpbnQ4ID0gKFxuICB2YWx1ZTogbnVtYmVyLFxuICBwdWJsaWNLZXk6IFRmaGVDb21wYWN0UHVibGljS2V5LFxuICBzZWN1cml0eVpvbmU6IG51bWJlciA9IDAsXG4pOiBFbmNyeXB0ZWRVaW50OCA9PiB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShbdmFsdWVdKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gQ29tcGFjdEZoZVVpbnQ4TGlzdC5lbmNyeXB0X3dpdGhfY29tcGFjdF9wdWJsaWNfa2V5KFxuICAgIHVpbnQ4QXJyYXksXG4gICAgcHVibGljS2V5LFxuICApO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGVuY3J5cHRlZC5zZXJpYWxpemUoKSxcbiAgICBzZWN1cml0eVpvbmUsXG4gIH07XG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGEgVWludDE2IHZhbHVlIHVzaW5nIFRGSEUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgVWludDE2IHZhbHVlIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ge1RmaGVDb21wYWN0UHVibGljS2V5fSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB1c2VkIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIHRvIGVuY3J5cHQgdGhlIHZhbHVlIG9uLlxuICogQHJldHVybnMge0VuY3J5cHRlZFVpbnQxNn0gLSBUaGUgZW5jcnlwdGVkIHZhbHVlIHNlcmlhbGl6ZWQgYXMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY3J5cHRfdWludDE2ID0gKFxuICB2YWx1ZTogbnVtYmVyLFxuICBwdWJsaWNLZXk6IFRmaGVDb21wYWN0UHVibGljS2V5LFxuICBzZWN1cml0eVpvbmU6IG51bWJlciA9IDAsXG4pOiBFbmNyeXB0ZWRVaW50MTYgPT4ge1xuICBjb25zdCB1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbdmFsdWVdKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gQ29tcGFjdEZoZVVpbnQxNkxpc3QuZW5jcnlwdF93aXRoX2NvbXBhY3RfcHVibGljX2tleShcbiAgICB1aW50MTZBcnJheSxcbiAgICBwdWJsaWNLZXksXG4gICk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZW5jcnlwdGVkLnNlcmlhbGl6ZSgpLFxuICAgIHNlY3VyaXR5Wm9uZSxcbiAgfTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBVaW50MzIgdmFsdWUgdXNpbmcgVEZIRS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBVaW50MzIgdmFsdWUgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSB7VGZoZUNvbXBhY3RQdWJsaWNLZXl9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHVzZWQgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgdG8gZW5jcnlwdCB0aGUgdmFsdWUgb24uXG4gKiBAcmV0dXJucyB7RW5jcnlwdGVkVWludDMyfSAtIFRoZSBlbmNyeXB0ZWQgdmFsdWUgc2VyaWFsaXplZCBhcyBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY29uc3QgZW5jcnlwdF91aW50MzIgPSAoXG4gIHZhbHVlOiBudW1iZXIsXG4gIHB1YmxpY0tleTogVGZoZUNvbXBhY3RQdWJsaWNLZXksXG4gIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCxcbik6IEVuY3J5cHRlZFVpbnQzMiA9PiB7XG4gIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KFt2YWx1ZV0pO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBDb21wYWN0RmhlVWludDMyTGlzdC5lbmNyeXB0X3dpdGhfY29tcGFjdF9wdWJsaWNfa2V5KFxuICAgIHVpbnQzMkFycmF5LFxuICAgIHB1YmxpY0tleSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBlbmNyeXB0ZWQuc2VyaWFsaXplKCksXG4gICAgc2VjdXJpdHlab25lLFxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNyeXB0cyBhIFVpbnQ2NCB2YWx1ZSB1c2luZyBURkhFLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIFVpbnQ2NCB2YWx1ZSB0byBlbmNyeXB0LlxuICogQHBhcmFtIHtUZmhlQ29tcGFjdFB1YmxpY0tleX0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdXNlZCBmb3IgZW5jcnlwdGlvbi5cbiAqIEBwYXJhbSBzZWN1cml0eVpvbmUgLSBUaGUgc2VjdXJpdHkgem9uZSB0byBlbmNyeXB0IHRoZSB2YWx1ZSBvbi5cbiAqIEByZXR1cm5zIHtFbmNyeXB0ZWRVaW50NjR9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0X3VpbnQ2NCA9IChcbiAgdmFsdWU6IGJpZ2ludCB8IHN0cmluZyxcbiAgcHVibGljS2V5OiBUZmhlQ29tcGFjdFB1YmxpY0tleSxcbiAgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwLFxuKTogRW5jcnlwdGVkVWludDY0ID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbHVlID0gdG9CaWdJbnQoZnJvbUhleFN0cmluZyh2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdmFsdWUgYXMgYmlnaW50O1xuICB9XG4gIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KFt2YWx1ZV0pO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBDb21wYWN0RmhlVWludDY0TGlzdC5lbmNyeXB0X3dpdGhfY29tcGFjdF9wdWJsaWNfa2V5KFxuICAgIHVpbnQzMkFycmF5LFxuICAgIHB1YmxpY0tleSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBlbmNyeXB0ZWQuc2VyaWFsaXplKCksXG4gICAgc2VjdXJpdHlab25lLFxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNyeXB0cyBhIFVpbnQxMjggdmFsdWUgdXNpbmcgVEZIRS5cbiAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZSAtIFRoZSBVaW50MTI4IHZhbHVlIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ge1RmaGVDb21wYWN0UHVibGljS2V5fSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB1c2VkIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIHRvIGVuY3J5cHQgdGhlIHZhbHVlIG9uLlxuICogQHJldHVybnMge0VuY3J5cHRlZFVpbnQxMjh9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0X3VpbnQxMjggPSAoXG4gIHZhbHVlOiBiaWdpbnQgfCBzdHJpbmcsXG4gIHB1YmxpY0tleTogVGZoZUNvbXBhY3RQdWJsaWNLZXksXG4gIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCxcbik6IEVuY3J5cHRlZFVpbnQxMjggPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFsdWUgPSB0b0JpZ0ludChmcm9tSGV4U3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB2YWx1ZSBhcyBiaWdpbnQ7XG4gIH1cblxuICBjb25zdCBlbmNyeXB0ZWQgPSBDb21wYWN0RmhlVWludDEyOC5lbmNyeXB0X3dpdGhfY29tcGFjdF9wdWJsaWNfa2V5KFxuICAgIHZhbHVlLFxuICAgIHB1YmxpY0tleSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBlbmNyeXB0ZWQuc2VyaWFsaXplKCksXG4gICAgc2VjdXJpdHlab25lLFxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNyeXB0cyBhIFVpbnQyNTYgdmFsdWUgdXNpbmcgVEZIRS5cbiAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZSAtIFRoZSBVaW50MjU2IHZhbHVlIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ge1RmaGVDb21wYWN0UHVibGljS2V5fSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB1c2VkIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIHRvIGVuY3J5cHQgdGhlIHZhbHVlIG9uLlxuICogQHJldHVybnMge0VuY3J5cHRlZFVpbnQyNTZ9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0X3VpbnQyNTYgPSAoXG4gIHZhbHVlOiBiaWdpbnQgfCBzdHJpbmcsXG4gIHB1YmxpY0tleTogVGZoZUNvbXBhY3RQdWJsaWNLZXksXG4gIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCxcbik6IEVuY3J5cHRlZFVpbnQyNTYgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFsdWUgPSB0b0JpZ0ludChmcm9tSGV4U3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB2YWx1ZSBhcyBiaWdpbnQ7XG4gIH1cblxuICBjb25zdCBlbmNyeXB0ZWQgPSBDb21wYWN0RmhlVWludDI1Ni5lbmNyeXB0X3dpdGhfY29tcGFjdF9wdWJsaWNfa2V5KFxuICAgIHZhbHVlLFxuICAgIHB1YmxpY0tleSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBlbmNyeXB0ZWQuc2VyaWFsaXplKCksXG4gICAgc2VjdXJpdHlab25lLFxuICB9O1xufTtcbi8qKlxuICogRW5jcnlwdHMgYSBBZGRyZXNzIHZhbHVlIHVzaW5nIFRGSEUuXG4gKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgLSBUaGUgQWRkcmVzcyAoVWludDE2MCkgdmFsdWUgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSB7VGZoZUNvbXBhY3RQdWJsaWNLZXl9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHVzZWQgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgdG8gZW5jcnlwdCB0aGUgYWRkcmVzcyBvbi5cbiAqIEByZXR1cm5zIHtFbmNyeXB0ZWRBZGRyZXNzfSAtIFRoZSBlbmNyeXB0ZWQgdmFsdWUgc2VyaWFsaXplZCBhcyBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY29uc3QgZW5jcnlwdF9hZGRyZXNzID0gKFxuICB2YWx1ZTogYmlnaW50IHwgc3RyaW5nLFxuICBwdWJsaWNLZXk6IFRmaGVDb21wYWN0UHVibGljS2V5LFxuICBzZWN1cml0eVpvbmU6IG51bWJlciA9IDAsXG4pOiBFbmNyeXB0ZWRBZGRyZXNzID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbHVlID0gdG9CaWdJbnQoZnJvbUhleFN0cmluZyh2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdmFsdWUgYXMgYmlnaW50O1xuICB9XG5cbiAgY29uc3QgZW5jcnlwdGVkID0gQ29tcGFjdEZoZVVpbnQxNjAuZW5jcnlwdF93aXRoX2NvbXBhY3RfcHVibGljX2tleShcbiAgICB2YWx1ZSxcbiAgICBwdWJsaWNLZXksXG4gICk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZW5jcnlwdGVkLnNlcmlhbGl6ZSgpLFxuICAgIHNlY3VyaXR5Wm9uZSxcbiAgfTtcbn07XG4vKipcbiAqIEVuY3J5cHRzIGEgbnVtZXJpYyB2YWx1ZSB1c2luZyBURkhFIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGVuY3J5cHRpb24gdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1lcmljIHZhbHVlIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ge1RmaGVDb21wYWN0UHVibGljS2V5fSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB1c2VkIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIHtFbmNyeXB0aW9uVHlwZXN9IHR5cGUgLSBUaGUgZW5jcnlwdGlvbiB0eXBlICh1aW50OCwgdWludDE2LCB1aW50MzIpLlxuICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIHRvIGVuY3J5cHQgdGhlIHZhbHVlIG9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gaW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY3J5cHQgPSAoXG4gIHZhbHVlOiBudW1iZXIsXG4gIHB1YmxpY0tleTogVGZoZUNvbXBhY3RQdWJsaWNLZXksXG4gIHR5cGU6IEVuY3J5cHRpb25UeXBlcyA9IEVuY3J5cHRpb25UeXBlcy51aW50OCxcbiAgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwLFxuKTogRW5jcnlwdGVkTnVtYmVyID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBFbmNyeXB0aW9uVHlwZXMuYm9vbDpcbiAgICAgIHJldHVybiBlbmNyeXB0X2Jvb2woISF2YWx1ZSwgcHVibGljS2V5LCBzZWN1cml0eVpvbmUpO1xuICAgIGNhc2UgRW5jcnlwdGlvblR5cGVzLnVpbnQ4OlxuICAgICAgcmV0dXJuIGVuY3J5cHRfdWludDgodmFsdWUsIHB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgICBjYXNlIEVuY3J5cHRpb25UeXBlcy51aW50MTY6XG4gICAgICByZXR1cm4gZW5jcnlwdF91aW50MTYodmFsdWUsIHB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgICBjYXNlIEVuY3J5cHRpb25UeXBlcy51aW50MzI6XG4gICAgICByZXR1cm4gZW5jcnlwdF91aW50MzIodmFsdWUsIHB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgICBjYXNlIEVuY3J5cHRpb25UeXBlcy51aW50NjQ6XG4gICAgICByZXR1cm4gZW5jcnlwdF91aW50NjQodmFsdWUudG9TdHJpbmcoMTYpLCBwdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gICAgY2FzZSBFbmNyeXB0aW9uVHlwZXMudWludDEyODpcbiAgICAgIHJldHVybiBlbmNyeXB0X3VpbnQxMjgodmFsdWUudG9TdHJpbmcoMTYpLCBwdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gICAgY2FzZSBFbmNyeXB0aW9uVHlwZXMudWludDI1NjpcbiAgICAgIHJldHVybiBlbmNyeXB0X3VpbnQyNTYodmFsdWUudG9TdHJpbmcoMTYpLCBwdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gICAgY2FzZSBFbmNyeXB0aW9uVHlwZXMuYWRkcmVzczpcbiAgICAgIHJldHVybiBlbmNyeXB0X2FkZHJlc3ModmFsdWUudG9TdHJpbmcoMTYpLCBwdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZVwiKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IFRmaGVDb21wYWN0UHVibGljS2V5IH0gZnJvbSBcIm5vZGUtdGZoZVwiO1xuaW1wb3J0IHtmcm9tSGV4U3RyaW5nLCBpc0FkZHJlc3MsIHRvQUJJRW5jb2RlZFVpbnQzMiwgVmFsaWRhdGVVaW50SW5SYW5nZX0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIENvbnRyYWN0UGVybWl0cyxcbiAgZGV0ZXJtaW5lUmVxdWVzdE1ldGhvZCxcbiAgRW5jcnlwdGVkQWRkcmVzcyxcbiAgRW5jcnlwdGVkQm9vbCxcbiAgRW5jcnlwdGVkTnVtYmVyLFxuICBFbmNyeXB0ZWRVaW50MTI4LFxuICBFbmNyeXB0ZWRVaW50MTYsXG4gIEVuY3J5cHRlZFVpbnQyNTYsXG4gIEVuY3J5cHRlZFVpbnQzMixcbiAgRW5jcnlwdGVkVWludDY0LFxuICBFbmNyeXB0ZWRVaW50OCxcbiAgRW5jcnlwdGlvblR5cGVzLFxuICBJbnN0YW5jZVBhcmFtcyxcbiAgU3VwcG9ydGVkUHJvdmlkZXIsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmltcG9ydCB7XG4gIGdlbmVyYXRlUGVybWl0LFxuICBnZXRQZXJtaXRGcm9tTG9jYWxzdG9yYWdlLFxuICBQZXJtaXNzaW9uLFxuICBQZXJtaXQsXG4gIFBlcm1pdFNpZ25lcixcbn0gZnJvbSBcIi4uL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2xcIjtcblxuaW1wb3J0IHtcbiAgRmhlT3BzQWRkcmVzcyxcbiAgTUFYX1VJTlQxNixcbiAgTUFYX1VJTlQzMixcbiAgTUFYX1VJTlQ4LFxuICBQVUJMSUNfS0VZX0xFTkdUSF9NSU4sXG59IGZyb20gXCIuL2NvbnN0c1wiO1xuaW1wb3J0ICogYXMgdGZoZUVuY3J5cHQgZnJvbSBcIi4vZW5jcnlwdFwiO1xuaW1wb3J0IHtcbiAgaXNCaWdJbnRPckhleFN0cmluZyxcbiAgaXNOdW1iZXIsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzU3RyaW5nLFxufSBmcm9tIFwiLi92YWxpZGF0aW9uXCI7XG5cbi8qKlxuICogVGhlIEZoZW5peENsaWVudCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXRpZXMgdG8gaW50ZXJhY3Qgd2l0aCBhIEZIRSAoRnVsbHkgSG9tb21vcnBoaWMgRW5jcnlwdGlvbikgc3lzdGVtLlxuICogSXQgaW5jbHVkZXMgbWV0aG9kcyBmb3IgZW5jcnlwdGlvbiwgdW5zZWFsaW5nLCBhbmQgbWFuYWdpbmcgcGVybWl0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZoZW5peENsaWVudCB7XG4gIHByaXZhdGUgcGVybWl0czogQ29udHJhY3RQZXJtaXRzID0ge307XG4gIHByaXZhdGUgZGVmYXVsdFNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMDtcbiAgcHVibGljIGZoZVB1YmxpY0tleXM6IEFycmF5PFByb21pc2U8VGZoZUNvbXBhY3RQdWJsaWNLZXkgfCB1bmRlZmluZWQ+PiA9IFtdO1xuICBwcm90ZWN0ZWQgcHJvdmlkZXI6IFN1cHBvcnRlZFByb3ZpZGVyO1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBGaGVuaXhDbGllbnQuXG4gICAqIEluaXRpYWxpemVzIHRoZSBmaGV2bSBsaWJyYXJ5IGlmIG5lZWRlZCBhbmQgcmV0cmlldmVzIHRoZSBwdWJsaWMga2V5IGZvciBlbmNyeXB0aW9uIGZyb20gdGhlIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0ge0luc3RhbmNlUGFyYW1zfSBwYXJhbXMgLSBQYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgdGhlIGNsaWVudC5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwYXJhbXM6IEluc3RhbmNlUGFyYW1zKSB7XG4gICAgaXNQbGFpbk9iamVjdChwYXJhbXMpO1xuXG4gICAgLy8gaWYgKHBhcmFtcz8ucHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcGFyYW1zLnByb3ZpZGVyID0gbmV3IEpzb25ScGNQcm92aWRlcihcImh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVwiKTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCB7IHByb3ZpZGVyLCBpZ25vcmVFcnJvcnMgfSA9IHBhcmFtcztcblxuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlciE7XG5cbiAgICAvLyBpbiBtb3N0IGNhc2VzIHdlIHdpbGwgd2FudCB0byBpbml0IHRoZSBmaGV2bSBsaWJyYXJ5IC0gZXhjZXB0IGlmIHRoaXMgaXMgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLCBpbiB3aGljaFxuICAgIC8vIGNhc2UgdGhpcyBzaG91bGQgYmUgY2FsbGVkIHdpdGggaW5pdFNkayA9IGZhbHNlICh0ZXN0cywgZm9yIGluc3RhbmNlKVxuXG4vLy8vLy8vLy8vLy8vLy8vL1xuICAgIHRoaXMuZmhlUHVibGljS2V5c1t0aGlzLmRlZmF1bHRTZWN1cml0eVpvbmVdID0gRmhlbml4Q2xpZW50LmdldEZoZUtleUZyb21Qcm92aWRlcih0aGlzLnByb3ZpZGVyKS5jYXRjaChcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZUVycm9ycykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBpbml0aWFsaXplIGZoZW5peGpzIC0gaXMgdGhlIG5ldHdvcmsgRkhFLWVuYWJsZWQ/ICR7ZXJyfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy9cbi8vLy8vLy9cbi8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vL1xuLy8vLy9cbi8vLy8vLy8vLy8vLy8vXG4gIH1cblxuICAvLyBFbmNyeXB0aW9uIE1ldGhvZHNcbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgVWludDggdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgVWludDggdmFsdWUgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIGZvciB3aGljaCB0byBlbmNyeXB0IHRoZSB2YWx1ZSAoZGVmYXVsdCAwKS5cbiAgICogQHJldHVybnMge0VuY3J5cHRlZEJvb2x9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIEVuY3J5cHRlZFVpbnQ4LiBVc2UgdGhlIC5kYXRhIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgVWludDhBcnJheS5cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRfYm9vbCh2YWx1ZTogYm9vbGVhbiwgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwKTogUHJvbWlzZTxFbmNyeXB0ZWRCb29sPiB7XG4gICAgY29uc3QgZmhlUHVibGljS2V5ID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5KHNlY3VyaXR5Wm9uZSk7XG4gICAgcmV0dXJuIHRmaGVFbmNyeXB0LmVuY3J5cHRfYm9vbCh2YWx1ZSwgZmhlUHVibGljS2V5LCBzZWN1cml0eVpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgVWludDggdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgVWludDggdmFsdWUgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIGZvciB3aGljaCB0byBlbmNyeXB0IHRoZSB2YWx1ZSAoZGVmYXVsdCAwKS5cbiAgICogQHJldHVybnMge0VuY3J5cHRlZFVpbnQ4fSAtIFRoZSBlbmNyeXB0ZWQgdmFsdWUgc2VyaWFsaXplZCBhcyBFbmNyeXB0ZWRVaW50OC4gVXNlIHRoZSAuZGF0YSBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0X3VpbnQ4KHZhbHVlOiBudW1iZXIsIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCk6IFByb21pc2U8RW5jcnlwdGVkVWludDg+IHtcbiAgICBpc051bWJlcih2YWx1ZSk7XG5cbiAgICBjb25zdCBmaGVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLl9nZXRQdWJsaWNLZXkoc2VjdXJpdHlab25lKTtcbiAgICBWYWxpZGF0ZVVpbnRJblJhbmdlKHZhbHVlLCBNQVhfVUlOVDgsIDApO1xuXG4gICAgcmV0dXJuIHRmaGVFbmNyeXB0LmVuY3J5cHRfdWludDgodmFsdWUsIGZoZVB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldFB1YmxpY0tleShzZWN1cml0eVpvbmU6IG51bWJlcikge1xuICAgIGxldCBmaGVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLmZoZVB1YmxpY0tleXNbc2VjdXJpdHlab25lXTtcbiAgICBpZiAoIWZoZVB1YmxpY0tleSkge1xuICAgICAgdGhpcy5maGVQdWJsaWNLZXlzW3NlY3VyaXR5Wm9uZV0gPSBGaGVuaXhDbGllbnQuZ2V0RmhlS2V5RnJvbVByb3ZpZGVyKHRoaXMucHJvdmlkZXIsIHNlY3VyaXR5Wm9uZSk7XG4gICAgICBmaGVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLmZoZVB1YmxpY0tleXNbc2VjdXJpdHlab25lXTtcbiAgICAgIGlmICghZmhlUHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHVibGljIGtleSBmb3Igc2VjdXJpdHkgem9uZSAke3NlY3VyaXR5Wm9uZX0gc29tZWhvdyBub3QgaW5pdGlhbGl6ZWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZoZVB1YmxpY0tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyBhIFVpbnQxNiB2YWx1ZSB1c2luZyB0aGUgc3RvcmVkIHB1YmxpYyBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBVaW50MTYgdmFsdWUgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIGZvciB3aGljaCB0byBlbmNyeXB0IHRoZSB2YWx1ZSAoZGVmYXVsdCAwKS5cbiAgICogQHJldHVybnMge0VuY3J5cHRlZFVpbnQxNn0gLSBUaGUgZW5jcnlwdGVkIHZhbHVlIHNlcmlhbGl6ZWQgYXMgRW5jcnlwdGVkVWludDE2LiBVc2UgdGhlIC5kYXRhIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgVWludDhBcnJheS5cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRfdWludDE2KHZhbHVlOiBudW1iZXIsIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCk6IFByb21pc2U8RW5jcnlwdGVkVWludDE2PiB7XG4gICAgaXNOdW1iZXIodmFsdWUpO1xuXG4gICAgY29uc3QgZmhlUHVibGljS2V5ID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5KHNlY3VyaXR5Wm9uZSk7XG4gICAgVmFsaWRhdGVVaW50SW5SYW5nZSh2YWx1ZSwgTUFYX1VJTlQxNiwgMCk7XG4gICAgcmV0dXJuIHRmaGVFbmNyeXB0LmVuY3J5cHRfdWludDE2KHZhbHVlLCBmaGVQdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdHMgYSBVaW50MzIgdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgVWludDMyIHZhbHVlIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSBzZWN1cml0eVpvbmUgLSBUaGUgc2VjdXJpdHkgem9uZSBmb3Igd2hpY2ggdG8gZW5jcnlwdCB0aGUgdmFsdWUgKGRlZmF1bHQgMCkuXG4gICAqIEByZXR1cm5zIHtFbmNyeXB0ZWRVaW50MzJ9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIEVuY3J5cHRlZFVpbnQzMi4gVXNlIHRoZSAuZGF0YSBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0X3VpbnQzMih2YWx1ZTogbnVtYmVyLCBzZWN1cml0eVpvbmU6IG51bWJlciA9IDApOiBQcm9taXNlPEVuY3J5cHRlZFVpbnQzMj4ge1xuICAgIGlzTnVtYmVyKHZhbHVlKTtcblxuICAgIGNvbnN0IGZoZVB1YmxpY0tleSA9IGF3YWl0IHRoaXMuX2dldFB1YmxpY0tleShzZWN1cml0eVpvbmUpO1xuXG4gICAgVmFsaWRhdGVVaW50SW5SYW5nZSh2YWx1ZSwgTUFYX1VJTlQzMiwgMCk7XG4gICAgcmV0dXJuIHRmaGVFbmNyeXB0LmVuY3J5cHRfdWludDMyKHZhbHVlLCBmaGVQdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdHMgYSBVaW50NjQgdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge2JpZ2ludCB8IHN0cmluZ30gdmFsdWUgLSBUaGUgVWludDMyIHZhbHVlIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSBzZWN1cml0eVpvbmUgLSBUaGUgc2VjdXJpdHkgem9uZSBmb3Igd2hpY2ggdG8gZW5jcnlwdCB0aGUgdmFsdWUgKGRlZmF1bHQgMCkuXG4gICAqIEByZXR1cm5zIHtFbmNyeXB0ZWRVaW50NjR9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIEVuY3J5cHRlZFVpbnQ2NC4gVXNlIHRoZSAuZGF0YSBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0X3VpbnQ2NCh2YWx1ZTogYmlnaW50IHwgc3RyaW5nLCBzZWN1cml0eVpvbmU6IG51bWJlciA9IDApOiBQcm9taXNlPEVuY3J5cHRlZFVpbnQ2ND4ge1xuICAgIGlzQmlnSW50T3JIZXhTdHJpbmcodmFsdWUpO1xuXG4gICAgY29uc3QgZmhlUHVibGljS2V5ID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5KHNlY3VyaXR5Wm9uZSk7XG5cbiAgICAvLyBWYWxpZGF0ZVVpbnRJblJhbmdlKHZhbHVlLCBNQVhfVUlOVDY0LCAwKTtcbiAgICByZXR1cm4gdGZoZUVuY3J5cHQuZW5jcnlwdF91aW50NjQodmFsdWUsIGZoZVB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyBhIFVpbnQxMjggdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge2JpZ2ludCB8IHN0cmluZ30gdmFsdWUgLSBUaGUgVWludDEyOCB2YWx1ZSB0byBlbmNyeXB0LlxuICAgKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgZm9yIHdoaWNoIHRvIGVuY3J5cHQgdGhlIHZhbHVlIChkZWZhdWx0IDApLlxuICAgKiBAcmV0dXJucyB7RW5jcnlwdGVkVWludDEyOH0gLSBUaGUgZW5jcnlwdGVkIHZhbHVlIHNlcmlhbGl6ZWQgYXMgRW5jcnlwdGVkVWludDEyOC4gVXNlIHRoZSAuZGF0YSBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0X3VpbnQxMjgodmFsdWU6IGJpZ2ludCB8IHN0cmluZywgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwKTogUHJvbWlzZTxFbmNyeXB0ZWRVaW50MTI4PiB7XG4gICAgaXNCaWdJbnRPckhleFN0cmluZyh2YWx1ZSk7XG5cbiAgICBjb25zdCBmaGVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLl9nZXRQdWJsaWNLZXkoc2VjdXJpdHlab25lKTtcblxuICAgIC8vIFZhbGlkYXRlVWludEluUmFuZ2UodmFsdWUsIE1BWF9VSU5UNjQsIDApO1xuICAgIHJldHVybiB0ZmhlRW5jcnlwdC5lbmNyeXB0X3VpbnQxMjgodmFsdWUsIGZoZVB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyBhIFVpbnQyNTYgdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge2JpZ2ludCB8IHN0cmluZ30gdmFsdWUgLSBUaGUgVWludDI1NiB2YWx1ZSB0byBlbmNyeXB0LlxuICAgKiBAcGFyYW0gc2VjdXJpdHlab25lIC0gVGhlIHNlY3VyaXR5IHpvbmUgZm9yIHdoaWNoIHRvIGVuY3J5cHQgdGhlIHZhbHVlIChkZWZhdWx0IDApLlxuICAgKiBAcmV0dXJucyB7RW5jcnlwdGVkVWludDI1Nn0gLSBUaGUgZW5jcnlwdGVkIHZhbHVlIHNlcmlhbGl6ZWQgYXMgRW5jcnlwdGVkVWludDI1Ni4gVXNlIHRoZSAuZGF0YSBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0X3VpbnQyNTYodmFsdWU6IGJpZ2ludCB8IHN0cmluZywgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwKTogUHJvbWlzZTxFbmNyeXB0ZWRVaW50MjU2PiB7XG4gICAgaXNCaWdJbnRPckhleFN0cmluZyh2YWx1ZSk7XG5cbiAgICBjb25zdCBmaGVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLl9nZXRQdWJsaWNLZXkoc2VjdXJpdHlab25lKTtcblxuICAgIC8vIFZhbGlkYXRlVWludEluUmFuZ2UodmFsdWUsIE1BWF9VSU5UNjQsIDApO1xuICAgIHJldHVybiB0ZmhlRW5jcnlwdC5lbmNyeXB0X3VpbnQyNTYodmFsdWUsIGZoZVB1YmxpY0tleSwgc2VjdXJpdHlab25lKTtcbiAgfVxuICAvKipcbiAgICogRW5jcnlwdHMgYW4gQWRkcmVzcyAoVWludDE2MCkgdmFsdWUgdXNpbmcgdGhlIHN0b3JlZCBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge2JpZ2ludCB8IHN0cmluZ30gdmFsdWUgLSBUaGUgQWRkcmVzcyAoVWludDE2MCkgdmFsdWUgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNlY3VyaXR5Wm9uZSAtIFRoZSBzZWN1cml0eSB6b25lIGZvciB3aGljaCB0byBlbmNyeXB0IHRoZSB2YWx1ZSAoZGVmYXVsdCAwKS5cbiAgICogQHJldHVybnMge0VuY3J5cHRlZEFkZHJlc3N9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIEVuY3J5cHRlZEFkZHJlc3MuIFVzZSB0aGUgLmRhdGEgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBVaW50OEFycmF5LlxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdF9hZGRyZXNzKHZhbHVlOiBiaWdpbnQgfCBzdHJpbmcsIHNlY3VyaXR5Wm9uZTogbnVtYmVyID0gMCk6IFByb21pc2U8RW5jcnlwdGVkQWRkcmVzcz4ge1xuICAgIGlzQmlnSW50T3JIZXhTdHJpbmcodmFsdWUpO1xuXG4gICAgY29uc3QgZmhlUHVibGljS2V5ID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5KHNlY3VyaXR5Wm9uZSk7XG5cbiAgICAvLyBWYWxpZGF0ZVVpbnRJblJhbmdlKHZhbHVlLCBNQVhfVUlOVDY0LCAwKTtcbiAgICByZXR1cm4gdGZoZUVuY3J5cHQuZW5jcnlwdF9hZGRyZXNzKHZhbHVlLCBmaGVQdWJsaWNLZXksIHNlY3VyaXR5Wm9uZSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgbnVtZXJpYyB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBlbmNyeXB0aW9uIHR5cGUgb3IgdGhlIG1vc3QgZWZmaWNpZW50IG9uZSBiYXNlZCBvbiB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1lcmljIHZhbHVlIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSB7RW5jcnlwdGlvblR5cGVzfSB0eXBlIC0gT3B0aW9uYWwuIFRoZSBlbmNyeXB0aW9uIHR5cGUgKHVpbnQ4LCB1aW50MTYsIHVpbnQzMikuXG4gICAqIEBwYXJhbSBzZWN1cml0eVpvbmUgLSBUaGUgc2VjdXJpdHkgem9uZSBmb3Igd2hpY2ggdG8gZW5jcnlwdCB0aGUgdmFsdWUgKGRlZmF1bHQgMCkuXG4gICAqIEByZXR1cm5zIHtFbmNyeXB0ZWROdW1iZXJ9IC0gVGhlIGVuY3J5cHRlZCB2YWx1ZSBzZXJpYWxpemVkIGFzIFVpbnQ4QXJyYXkuIFVzZSB0aGUgLmRhdGEgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBVaW50OEFycmF5LlxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdChcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIHR5cGU/OiBFbmNyeXB0aW9uVHlwZXMsXG4gICAgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwXG4gICk6IFByb21pc2U8RW5jcnlwdGVkTnVtYmVyPiB7XG4gICAgaXNOdW1iZXIodmFsdWUpO1xuXG4gICAgbGV0IG91dHB1dFNpemUgPSB0eXBlO1xuXG4gICAgY29uc3QgZmhlUHVibGljS2V5ID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5KHNlY3VyaXR5Wm9uZSk7XG5cbiAgICAvLyBjaG9vc2UgdGhlIG1vc3QgZWZmaWNpZW50IGNpcGhlcnRleHQgc2l6ZSBpZiBub3Qgc2VsZWN0ZWRcbiAgICBpZiAoIW91dHB1dFNpemUpIHtcbiAgICAgIGlmICh2YWx1ZSA8IE1BWF9VSU5UOCkge1xuICAgICAgICBvdXRwdXRTaXplID0gRW5jcnlwdGlvblR5cGVzLnVpbnQ4O1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IE1BWF9VSU5UMTYpIHtcbiAgICAgICAgb3V0cHV0U2l6ZSA9IEVuY3J5cHRpb25UeXBlcy51aW50MTY7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgTUFYX1VJTlQzMikge1xuICAgICAgICBvdXRwdXRTaXplID0gRW5jcnlwdGlvblR5cGVzLnVpbnQzMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5jcnlwdGlvbiBpbnB1dCBtdXN0IGJlIHNtYWxsZXIgdGhhbiAke01BWF9VSU5UMzJ9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChvdXRwdXRTaXplKSB7XG4gICAgICBjYXNlIEVuY3J5cHRpb25UeXBlcy51aW50ODpcbiAgICAgICAgVmFsaWRhdGVVaW50SW5SYW5nZSh2YWx1ZSwgTUFYX1VJTlQ4LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVuY3J5cHRpb25UeXBlcy51aW50MTY6XG4gICAgICAgIFZhbGlkYXRlVWludEluUmFuZ2UodmFsdWUsIE1BWF9VSU5UMTYsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRW5jcnlwdGlvblR5cGVzLnVpbnQzMjpcbiAgICAgICAgVmFsaWRhdGVVaW50SW5SYW5nZSh2YWx1ZSwgTUFYX1VJTlQzMiwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICByZXR1cm4gdGZoZUVuY3J5cHQuZW5jcnlwdCh2YWx1ZSwgZmhlUHVibGljS2V5LCB0eXBlLCBzZWN1cml0eVpvbmUpO1xuICB9XG5cbiAgLy8gVW5zZWFsaW5nIE1ldGhvZFxuXG4gIC8qKlxuICAgKiBVbnNlYWxzIGFuIGVuY3J5cHRlZCBtZXNzYWdlIHVzaW5nIHRoZSBzdG9yZWQgcGVybWl0IGZvciBhIHNwZWNpZmljIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaXBoZXJ0ZXh0IC0gVGhlIGVuY3J5cHRlZCBtZXNzYWdlIHRvIHVuc2VhbC5cbiAgICogQHJldHVybnMgYmlnaW50IC0gVGhlIHVuc2VhbGVkIG1lc3NhZ2UuXG4gICAqL1xuICB1bnNlYWwoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIGNpcGhlcnRleHQ6IHN0cmluZyk6IGJpZ2ludCB7XG4gICAgaXNBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgaXNTdHJpbmcoY2lwaGVydGV4dCk7XG5cbiAgICBpZiAoIXRoaXMuaGFzUGVybWl0KGNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBrZXlwYWlyIGZvciAke2NvbnRyYWN0QWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wZXJtaXRzW2NvbnRyYWN0QWRkcmVzc10uc2VhbGluZ0tleS51bnNlYWwoY2lwaGVydGV4dCk7XG4gIH1cblxuICAvLyBQZXJtaXQgTWFuYWdlbWVudCBNZXRob2RzXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBlcm1pdCBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzLiBBbHNvIHNhdmVzIHRoZSBwZXJtaXQgdG8gbG9jYWxzdG9yYWdlIChpZiBhdmFpbGFibGUpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QuXG4gICAqIEBwYXJhbSB7U3VwcG9ydGVkUHJvdmlkZXJ9IHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIGZyb20gd2hpY2ggdG8gc2lnbiB0aGUgcGVybWl0IC0gbXVzdCBjb250YWluZXIgYSBzaWduZXIuXG4gICAqIEBwYXJhbSBzaWduZXIgLSB0aGUgc2lnbmVyIHRvIHVzZSB0byBzaWduIHRoZSBwZXJtaXQgaWYgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nIChlLmcuIGhhcmRoYXQpXG4gICAqIEByZXR1cm5zIFBlcm1pdCAtIFRoZSBwZXJtaXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb250cmFjdCBhZGRyZXNzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcHJvdmlkZXIgZG9lcyBub3QgY29udGFpbiBhIHNpZ25lciwgb3IgaWYgYSBwcm92aWRlciBpcyBub3Qgc2V0XG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVBlcm1pdChcbiAgICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICBwcm92aWRlcj86IFN1cHBvcnRlZFByb3ZpZGVyLFxuICAgIHNpZ25lcj86IFBlcm1pdFNpZ25lcixcbiAgKSB7XG4gICAgaWYgKCFwcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yIGdldHRpbmcgcHJvdmlkZXJcIik7XG4gICAgfVxuXG4gICAgY29uc3QgcGVybWl0ID0gYXdhaXQgZ2VuZXJhdGVQZXJtaXQoXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcm92aWRlciB8fCB0aGlzLnByb3ZpZGVyISxcbiAgICAgIHNpZ25lcixcbiAgICApO1xuICAgIHRoaXMuc3RvcmVQZXJtaXQocGVybWl0KTtcbiAgICByZXR1cm4gcGVybWl0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc3RvcmVkIHBlcm1pdCBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCAtIFRoZSBhZGRyZXNzIG9mIHRoZSB1c2VyIGFjY291bnQuXG4gICAqIEByZXR1cm5zIHtQZXJtaXR9IC0gVGhlIHBlcm1pdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAqL1xuICBnZXRQZXJtaXQoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIGFjY291bnQ6IHN0cmluZyk6IFBlcm1pdCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgZnJvbUxzID0gZ2V0UGVybWl0RnJvbUxvY2Fsc3RvcmFnZShjb250cmFjdEFkZHJlc3MsIGFjY291bnQpO1xuICAgIGlmIChmcm9tTHMpIHtcbiAgICAgIHRoaXMucGVybWl0c1tjb250cmFjdEFkZHJlc3NdID0gZnJvbUxzO1xuICAgICAgcmV0dXJuIGZyb21McztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFzUGVybWl0KGNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGVybWl0c1tjb250cmFjdEFkZHJlc3NdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHBlcm1pdCBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzLiBXaWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgcGVybWl0IGZvciB0aGUgc2FtZSBjb250cmFjdCBhZGRyZXNzLlxuICAgKiBEb2VzIG5vdCBzdG9yZSB0aGUgcGVybWl0IGluIGxvY2Fsc3RvcmFnZSAoc2hvdWxkIGl0PylcbiAgICogQHBhcmFtIHtQZXJtaXR9IHBlcm1pdCAtIFRoZSBwZXJtaXQgdG8gc3RvcmUuXG4gICAqL1xuICBzdG9yZVBlcm1pdChwZXJtaXQ6IFBlcm1pdCkge1xuICAgIHRoaXMucGVybWl0c1twZXJtaXQuY29udHJhY3RBZGRyZXNzXSA9IHBlcm1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3RvcmVkIHBlcm1pdCBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0LlxuICAgKi9cbiAgcmVtb3ZlUGVybWl0KGNvbnRyYWN0QWRkcmVzczogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuaGFzUGVybWl0KGNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlcm1pdHNbY29udHJhY3RBZGRyZXNzXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgcGVybWl0IGV4aXN0cyBmb3IgYSBzcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIGEgcGVybWl0IGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzUGVybWl0KGNvbnRyYWN0QWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0c1tjb250cmFjdEFkZHJlc3NdICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgYWxsIHN0b3JlZCBwZXJtaXRzLlxuICAgKiBAcmV0dXJucyB7Q29udHJhY3RQZXJtaXRzfSAtIEFsbCBzdG9yZWQgcGVybWl0cy5cbiAgICovXG4gIGV4cG9ydFBlcm1pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0cztcbiAgfVxuXG4gIGV4dHJhY3RQZXJtaXRQZXJtaXNzaW9uKHBlcm1pdDogUGVybWl0KTogUGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hdHVyZTogcGVybWl0LnNpZ25hdHVyZSxcbiAgICAgIHB1YmxpY0tleTogcGVybWl0LnB1YmxpY0tleSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIEZIRSBwdWJsaWMga2V5IGZyb20gdGhlIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0ge1N1cHBvcnRlZFByb3ZpZGVyfSBwcm92aWRlciAtIFRoZSBwcm92aWRlciBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBrZXkuXG4gICAqIEBwYXJhbSBzZWN1cml0eVpvbmUgLSBUaGUgc2VjdXJpdHkgem9uZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGtleSAoZGVmYXVsdCAwKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8VGZoZUNvbXBhY3RQdWJsaWNLZXk+fSAtIFRoZSByZXRyaWV2ZWQgcHVibGljIGtleS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGdldEZoZUtleUZyb21Qcm92aWRlcihcbiAgICBwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXG4gICAgc2VjdXJpdHlab25lOiBudW1iZXIgPSAwLFxuICApOiBQcm9taXNlPFRmaGVDb21wYWN0UHVibGljS2V5PiB7XG4gICAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IGRldGVybWluZVJlcXVlc3RNZXRob2QocHJvdmlkZXIpO1xuXG4gICAgY29uc3QgY2hhaW5JZFAgPSByZXF1ZXN0TWV0aG9kKHByb3ZpZGVyLCBcImV0aF9jaGFpbklkXCIpLmNhdGNoKFxuICAgICAgKGVycjogRXJyb3IpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIHdoaWxlIHJlcXVlc3RpbmcgY2hhaW5JZCBmcm9tIHByb3ZpZGVyOiAke2Vycn1gKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGZ1bmNTaWcgPSBcIjB4MWIxYjQ4NGVcIiAvLyBjYXN0IHNpZyBcImdldE5ldHdvcmtQdWJsaWNLZXkoaW50MzIpXCJcbiAgICBjb25zdCBjYWxsRGF0YSA9IGZ1bmNTaWcgKyB0b0FCSUVuY29kZWRVaW50MzIoc2VjdXJpdHlab25lKTtcbiAgICBjb25zdCBjYWxsUGFyYW1zID0gW3sgdG86IEZoZU9wc0FkZHJlc3MsIGRhdGE6IGNhbGxEYXRhIH0sIFwibGF0ZXN0XCJdO1xuXG4gICAgY29uc3QgcHVibGljS2V5UCA9IHJlcXVlc3RNZXRob2QocHJvdmlkZXIsIFwiZXRoX2NhbGxcIiwgY2FsbFBhcmFtcykuY2F0Y2goXG4gICAgICAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgRXJyb3Igd2hpbGUgcmVxdWVzdGluZyBuZXR3b3JrIHB1YmxpYyBrZXkgZnJvbSBwcm92aWRlciBmb3Igc2VjdXJpdHkgem9uZSAke1xuICAgICAgICAgICAgc2VjdXJpdHlab25lXG4gICAgICAgICAgfTogJHtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGVycilcbiAgICAgICAgICB9YCxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IFtjaGFpbklkLCBwdWJsaWNLZXldID0gYXdhaXQgUHJvbWlzZS5hbGwoW2NoYWluSWRQLCBwdWJsaWNLZXlQXSk7XG5cbiAgICBjb25zdCBjaGFpbklkTnVtOiBudW1iZXIgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgaWYgKGlzTmFOKGNoYWluSWROdW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGByZWNlaXZlZCBub24taGV4IG51bWJlciBmcm9tIGNoYWluSWQgcmVxdWVzdDogXCIke2NoYWluSWR9XCJgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHB1YmxpY0tleSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXNpbmcgcHVibGljS2V5IGZyb20gcHJvdmlkZXI6IGV4cGVjdGVkIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA8IFBVQkxJQ19LRVlfTEVOR1RIX01JTikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJyb3IgaW5pdGlhbGl6aW5nIGZoZW5peGpzOyBnb3Qgc2hvcnRlciB0aGFuIGV4cGVjdGVkIHB1YmxpYyBrZXk6ICR7cHVibGljS2V5Lmxlbmd0aH1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmID0gZnJvbUhleFN0cmluZyhwdWJsaWNLZXkuc2xpY2UoMTMwKSk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFRmaGVDb21wYWN0UHVibGljS2V5LmRlc2VyaWFsaXplKGJ1ZmYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJyb3IgZGVzZXJpYWxpemluZyBwdWJsaWMga2V5OiBkaWQgeW91IGluaXRpYWxpemUgZmhlbml4LmpzIHdpdGggXCJpbml0Rmhldm0oKVwiPyAke2Vycn1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGZyb21IZXhTdHJpbmcsIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvSGV4U3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIG5hY2wgZnJvbSBcInR3ZWV0bmFjbFwiO1xuaW1wb3J0ICogYXMgbmFjbFV0aWwgZnJvbSBcInR3ZWV0bmFjbC11dGlsXCI7XG5pbXBvcnQgeyBpc0JpZ0ludE9yTnVtYmVyLCBpc1N0cmluZyB9IGZyb20gXCIuL3ZhbGlkYXRpb25cIjtcblxuY29uc3QgUFJJVkFURV9LRVlfTEVOR1RIID0gNjQ7XG5jb25zdCBQVUJMSUNfS0VZX0xFTkdUSCA9IDY0O1xuXG4vLyBUaGlzIHN0cnVjdHVyZSBoYXMgYmVlbiBjbG9uZWQgZnJvbSBtZXRhbWFzaydzIHNpZ25pbmcgdXRpbCwgd2hpY2ggaXMgbGljZW5zZWQgdW5kZXJcbi8vIElTQywgYSBjb3B5IG9mIHdoaWNoIGNhbiBiZSBmb3VuZCBpbiB0aGUgL2xpY2Vuc2VzIGZvbGRlclxuZXhwb3J0IHR5cGUgRXRoRW5jcnlwdGVkRGF0YSA9IHtcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBub25jZTogc3RyaW5nO1xuICBlcGhlbVB1YmxpY0tleTogc3RyaW5nO1xuICBjaXBoZXJ0ZXh0OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgU2VhbGluZ0tleSB3aGljaCBwcm92aWRlcyBjcnlwdG9ncmFwaGljIHNlYWxpbmcgKGVuY3J5cHRpb24pXG4gKiBhbmQgdW5zZWFsaW5nIChkZWNyeXB0aW9uKSBjYXBhYmlsaXRpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWFsaW5nS2V5IHtcbiAgLyoqXG4gICAqIFRoZSBwcml2YXRlIGtleSB1c2VkIGZvciBkZWNyeXB0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZUtleTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgdXNlZCBmb3IgZW5jcnlwdGlvbi5cbiAgICovXG4gIHB1YmxpY0tleTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgU2VhbGluZ0tleSBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdXNlZCBmb3IgZGVjcnlwdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHVzZWQgZm9yIGVuY3J5cHRpb24uXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQga2V5cyBsZW5ndGhzIGRvIG5vdCBtYXRjaFxuICAgKiAgICAgICAgIHRoZSByZXF1aXJlZCBsZW5ndGhzIGZvciBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXk6IHN0cmluZywgcHVibGljS2V5OiBzdHJpbmcpIHtcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IFBSSVZBVEVfS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcml2YXRlIGtleSBtdXN0IGJlIG9mIGxlbmd0aCAke1BSSVZBVEVfS0VZX0xFTkdUSH1gKTtcbiAgICB9XG5cbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJpdmF0ZSBrZXkgbXVzdCBiZSBvZiBsZW5ndGggJHtQVUJMSUNfS0VZX0xFTkdUSH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc2VhbHMgKGRlY3J5cHRzKSB0aGUgcHJvdmlkZWQgY2lwaGVydGV4dCB1c2luZyB0aGUgaW5zdGFuY2UncyBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBjaXBoZXJ0ZXh0IC0gVGhlIGVuY3J5cHRlZCBkYXRhIHRvIGJlIGRlY3J5cHRlZC5cbiAgICogQHJldHVybnMgQmlnSW50IC0gVGhlIGRlY3J5cHRlZCBtZXNzYWdlIGFzIGEgYmlnaW50LlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlY3J5cHRpb24gcHJvY2VzcyBmYWlscy5cbiAgICovXG4gIHVuc2VhbCA9IChjaXBoZXJ0ZXh0OiBzdHJpbmcgfCBVaW50OEFycmF5KTogYmlnaW50ID0+IHtcbiAgICBsZXQgcGFyc2VkRGF0YTogRXRoRW5jcnlwdGVkRGF0YSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGNpcGhlcnRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gaWdub3JlIGVycm9yc1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZERhdGEpIHtcbiAgICAgIGNvbnN0IHRvRGVjcnlwdCA9XG4gICAgICAgIHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiID8gZnJvbUhleFN0cmluZyhjaXBoZXJ0ZXh0KSA6IGNpcGhlcnRleHQ7XG5cbiAgICAgIC8vIGRlY29kZSBqc29uIHN0cnVjdHVyZSB0aGF0IGdldHMgcmV0dXJuZWQgZnJvbSB0aGUgY2hhaW5cbiAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBCdWZmZXIuZnJvbSh0b0RlY3J5cHQpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VkRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHNlYWxlZCBkYXRhXCIpO1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIGRlY3J5cHRpb24gcGFyYW1ldGVyc1xuICAgIGNvbnN0IG5vbmNlID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KHBhcnNlZERhdGEubm9uY2UpO1xuICAgIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KHBhcnNlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgIGNvbnN0IGRhdGFUb0RlY3J5cHQgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQocGFyc2VkRGF0YS5jaXBoZXJ0ZXh0KTtcbiAgICAvLyBjYWxsIHRoZSBuYWNsIGJveCBmdW5jdGlvbiB0byBkZWNyeXB0IHRoZSBkYXRhXG4gICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oXG4gICAgICBkYXRhVG9EZWNyeXB0LFxuICAgICAgbm9uY2UsXG4gICAgICBlcGhlbVB1YmxpY0tleSxcbiAgICAgIGZyb21IZXhTdHJpbmcodGhpcy5wcml2YXRlS2V5KSxcbiAgICApO1xuXG4gICAgaWYgKCFkZWNyeXB0ZWRNZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCBtZXNzYWdlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0b0JpZ0ludChkZWNyeXB0ZWRNZXNzYWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2VhbHMgKGVuY3J5cHRzKSB0aGUgcHJvdmlkZWQgbWVzc2FnZSBmb3IgYSByZWNlaXZlciB3aXRoIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtiaWdpbnQgfCBudW1iZXJ9IHZhbHVlIC0gVGhlIG1lc3NhZ2UgdG8gYmUgZW5jcnlwdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIGludGVuZGVkIHJlY2lwaWVudC5cbiAgICogQHJldHVybnMgc3RyaW5nIC0gVGhlIGVuY3J5cHRlZCBtZXNzYWdlIGluIGhleGFkZWNpbWFsIGZvcm1hdC5cbiAgICogQHN0YXRpY1xuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHByb3ZpZGVkIHB1YmxpY0tleSBvciB2YWx1ZSBkbyBub3QgbWVldCBkZWZpbmVkIHByZWNvbmRpdGlvbnMuXG4gICAqL1xuICBzdGF0aWMgc2VhbCA9ICh2YWx1ZTogYmlnaW50IHwgbnVtYmVyLCBwdWJsaWNLZXk6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaXNTdHJpbmcocHVibGljS2V5KTtcbiAgICBpc0JpZ0ludE9yTnVtYmVyKHZhbHVlKTtcblxuICAgIC8vIGdlbmVyYXRlIGVwaGVtZXJhbCBrZXlwYWlyXG4gICAgY29uc3QgZXBoZW1lcmFsS2V5UGFpciA9IG5hY2wuYm94LmtleVBhaXIoKTtcblxuICAgIGNvbnN0IG5vbmNlID0gbmFjbC5yYW5kb21CeXRlcyhuYWNsLmJveC5ub25jZUxlbmd0aCk7XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3goXG4gICAgICB0b0JlQXJyYXkodmFsdWUpLFxuICAgICAgbm9uY2UsXG4gICAgICBmcm9tSGV4U3RyaW5nKHB1YmxpY0tleSksXG4gICAgICBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSxcbiAgICApO1xuXG4gICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgdmVyc2lvbjogXCJ4MjU1MTkteHNhbHNhMjAtcG9seTEzMDVcIixcbiAgICAgIG5vbmNlOiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQobm9uY2UpLFxuICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICBjaXBoZXJ0ZXh0OiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgfTtcblxuICAgIC8vIG1pbWlja2luZyBlbmNvZGluZyBmcm9tIHRoZSBjaGFpblxuICAgIHJldHVybiB0b0hleFN0cmluZyhCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShvdXRwdXQpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZ2VuZXJhdGVzIGEgbmV3IFNlYWxpbmdLZXkuXG4gKiBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlICduYWNsJyBsaWJyYXJ5IHRvIGNyZWF0ZSBhIG5ldyBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFpciBmb3Igc2VhbGluZyBwdXJwb3Nlcy5cbiAqIEEgc2VhbGluZyBrZXkgaXMgdXNlZCB0byBlbmNyeXB0IGRhdGEgc3VjaCB0aGF0IGl0IGNhbiBvbmx5IGJlIHVuc2VhbGVkIChkZWNyeXB0ZWQpIGJ5IHRoZSBvd25lciBvZiB0aGUgY29ycmVzcG9uZGluZyBwcml2YXRlIGtleS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFNlYWxpbmdLZXk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IFNlYWxpbmdLZXkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGhleGFkZWNpbWFsIHN0cmluZ3Mgb2YgdGhlIHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXlzLlxuICovXG5leHBvcnQgY29uc3QgR2VuZXJhdGVTZWFsaW5nS2V5ID0gYXN5bmMgKCk6IFByb21pc2U8U2VhbGluZ0tleT4gPT4ge1xuICBjb25zdCBzb2RpdW1LZXlwYWlyID0gbmFjbC5ib3gua2V5UGFpcigpO1xuXG4gIHJldHVybiBuZXcgU2VhbGluZ0tleShcbiAgICB0b0hleFN0cmluZyhzb2RpdW1LZXlwYWlyLnNlY3JldEtleSksXG4gICAgdG9IZXhTdHJpbmcoc29kaXVtS2V5cGFpci5wdWJsaWNLZXkpLFxuICApO1xufTtcbiIsImltcG9ydCB7IEVpcDExOTNQcm92aWRlciwgQnJvd3NlclByb3ZpZGVyIH0gZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgUGVybWl0IH0gZnJvbSBcIi4uL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2xcIjtcblxuZXhwb3J0IHsgUGVybWl0U2lnbmVyIH0gZnJvbSBcIi4uL2V4dGVuc2lvbnMvYWNjZXNzX2NvbnRyb2xcIjtcblxuLyoqXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGEgbWFwcGluZyBvZiBjb250cmFjdCBhZGRyZXNzZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwZXJtaXRzLlxuICogRWFjaCBrZXkgaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MsIGFuZCBlYWNoIHZhbHVlIGlzIGEgUGVybWl0IG9iamVjdC5cbiAqL1xuZXhwb3J0IHR5cGUgQ29udHJhY3RQZXJtaXRzID0gUmVjb3JkPHN0cmluZywgUGVybWl0PjtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgZW5jcnlwdGlvbiB0eXBlcy5cbiAqIHVpbnQ4LCB1aW50MTYsIGFuZCB1aW50MzIgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgc2l6ZXMgb2YgaW50ZWdlcnMgdGhhdCBjYW4gYmUgZW5jcnlwdGVkLlxuICovXG5leHBvcnQgZW51bSBFbmNyeXB0aW9uVHlwZXMge1xuICBib29sID0gXCJib29sXCIsXG4gIHVpbnQ4ID0gXCJ1aW50OFwiLFxuICB1aW50MTYgPSBcInVpbnQxNlwiLFxuICB1aW50MzIgPSBcInVpbnQzMlwiLFxuICB1aW50NjQgPSBcInVpbnQ2NFwiLFxuICB1aW50MTI4ID0gXCJ1aW50MTI4XCIsXG4gIHVpbnQyNTYgPSBcInVpbnQyNTZcIixcbiAgYWRkcmVzcyA9IFwiYWRkcmVzc1wiLFxufVxuXG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgdGhlIHNpZ25hdHVyZSBmb3IgYSBwZXJtaXQuXG4gKiBDb250YWlucyBhIHB1YmxpYyBrZXkgYW5kIGEgc2lnbmF0dXJlIHN0cmluZy5cbiAqL1xuZXhwb3J0IHR5cGUgUGVybWl0U2lnbmF0dXJlID0ge1xuICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXk7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBwYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgYW4gaW5zdGFuY2UuXG4gKiBwcm92aWRlciBpcyBhbiBvcHRpb25hbCBTdXBwb3J0ZWRQcm92aWRlciBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnMuXG4gKiBpbml0U2RrIGlzIGFuIG9wdGlvbmFsIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGluaXRpYWxpemUgdGhlIFNESy5cbiAqL1xuZXhwb3J0IHR5cGUgSW5zdGFuY2VQYXJhbXMgPSB7XG4gIHByb3ZpZGVyPzogU3VwcG9ydGVkUHJvdmlkZXI7XG4gIGluaXRTZGs/OiBib29sZWFuO1xuICBpZ25vcmVFcnJvcnM/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGEgcGFpciBvZiBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB1c2VkIGZvciBhIGNvbnRyYWN0LCBhbG9uZyB3aXRoIGFuIG9wdGlvbmFsIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ29udHJhY3RLZXlwYWlyID0ge1xuICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXk7XG4gIHNpZ25hdHVyZT86IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV0aGVyc1Byb3ZpZGVyIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHNlbmQobWV0aG9kOiBzdHJpbmcsIHBhcmFtcz86IEFycmF5PGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxhbnk+O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgZ2V0U2lnbmVyKCk6IFByb21pc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIGEgSGFyZGhhdEV0aGVyc1Byb3ZpZGVyLCBzaW1pbGFyIHRvIEV0aGVyc1Byb3ZpZGVyIGJ1dCBmb3IgSGFyZGhhdCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXJkaGF0RXRoZXJzUHJvdmlkZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc2VuZChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogQXJyYXk8YW55PiB8IHVuZGVmaW5lZCk6IFByb21pc2U8YW55PjtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGdldFNpZ25lcigpOiBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBhIFlldEFub3RoZXJIYXJkaGF0RXRoZXJzUHJvdmlkZXIsIHNpbWlsYXIgdG8gSGFyZGhhdEV0aGVyc1Byb3ZpZGVyIGJ1dCBmb3IgdGhlIGxhdGVzdCBAbm9taWNsYWJzL2hhcmRoYXQtZXRoZXJzIHZlcnNpb24gKHYyLjIuMykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgWWV0QW5vdGhlckhhcmRoYXRFdGhlcnNQcm92aWRlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzZW5kKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IEFycmF5PGFueT4pOiBQcm9taXNlPGFueT47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBnZXRTaWduZXIoYWRkcmVzc09ySW5kZXg/OiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogQSB0eXBlIHJlcHJlc2VudGluZyBhIHN1cHBvcnRlZCBwcm92aWRlci5cbiAqIENhbiBiZSBvbmUgb2YgQnJvd3NlclByb3ZpZGVyLCBFaXAxMTkzUHJvdmlkZXIsIEV0aGVyc1Byb3ZpZGVyLCBvciBIYXJkaGF0RXRoZXJzUHJvdmlkZXIuXG4gKi9cbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFByb3ZpZGVyID1cbiAgfCBCcm93c2VyUHJvdmlkZXJcbiAgfCBFaXAxMTkzUHJvdmlkZXJcbiAgfCBFdGhlcnNQcm92aWRlclxuICB8IEhhcmRoYXRFdGhlcnNQcm92aWRlclxuICB8IFlldEFub3RoZXJIYXJkaGF0RXRoZXJzUHJvdmlkZXI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcmVxdWVzdCBtZXRob2QgZm9yIGEgZ2l2ZW4gcHJvdmlkZXIuXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVyIGhhcyBhICdyZXF1ZXN0JyBtZXRob2QgdHlwaWNhbCBmb3IgRWlwMTE5M1Byb3ZpZGVycywgb3IgYSAnc2VuZCcgbWV0aG9kIGZvciBvdGhlcnMuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgbmVpdGhlciBtZXRob2QgaXMgZm91bmQuXG4gKiBAcGFyYW0ge1N1cHBvcnRlZFByb3ZpZGVyfSBwcm92aWRlciAtIFRoZSBwcm92aWRlciB0byBkZXRlcm1pbmUgdGhlIHJlcXVlc3QgbWV0aG9kIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBUaGUgZGV0ZXJtaW5lZCByZXF1ZXN0IGZ1bmN0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0TWV0aG9kKHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcik6IEZ1bmN0aW9uIHtcbiAgLy8gdW5pZnkgcHJvdmlkZXIgaW50ZXJmYWNlOiBlaXAtMTE5My1jb21wYXRpYmxlIHByb3ZpZGVycyBzdWNoIGFzIG1ldGFtYXNrJ3MgZXhwb3NlIFwicmVxdWVzdFwiLFxuICAvLyB3aGlsZSBldGhlcnMnIGFuZCBoYXJkaGF0J3MgbWF5IGV4cG9zZSBhIHNsaWdodGx5IGRpZmZlcmVudCBcInNlbmRcIiwgdG8gaXNzdWUgUlBDIGNhbGxzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgaWYgKFwicmVxdWVzdFwiIGluIHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlci5yZXF1ZXN0ID09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiAocDogU3VwcG9ydGVkUHJvdmlkZXIsIG1ldGhvZDogc3RyaW5nLCBwYXJhbXM/OiBhbnlbXSkgPT5cbiAgICAgIChwIGFzIEVpcDExOTNQcm92aWRlcikucmVxdWVzdCh7IG1ldGhvZCwgcGFyYW1zIH0pO1xuICB9IGVsc2UgaWYgKFwic2VuZFwiIGluIHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlci5zZW5kID09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiAocDogU3VwcG9ydGVkUHJvdmlkZXIsIG1ldGhvZDogc3RyaW5nLCBwYXJhbXM/OiBhbnlbXSkgPT5cbiAgICAgIChwIGFzIEV0aGVyc1Byb3ZpZGVyKS5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlJlY2VpdmVkIHVuc3VwcG9ydGVkIHByb3ZpZGVyLiAnc2VuZCcgb3IgJ3JlcXVlc3QnIG1ldGhvZCBub3QgZm91bmRcIixcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcmVxdWVzdCBzaWduZXIgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gcHJvdmlkZXIuXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVyIGhhcyBhICdnZXRTaWduZXInIG1ldGhvZCBhbmQgcmV0dXJucyBpdCBpZiBhdmFpbGFibGUuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gJ2dldFNpZ25lcicgbWV0aG9kIGlzIGZvdW5kLlxuICogQHBhcmFtIHtTdXBwb3J0ZWRQcm92aWRlcn0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgdG8gZGV0ZXJtaW5lIHRoZSByZXF1ZXN0IHNpZ25lciBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIGRldGVybWluZWQgcmVxdWVzdCBzaWduZXIgZnVuY3Rpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZVJlcXVlc3RTaWduZXIocHJvdmlkZXI6IFN1cHBvcnRlZFByb3ZpZGVyKTogRnVuY3Rpb24ge1xuICBpZiAoXCJnZXRTaWduZXJcIiBpbiBwcm92aWRlciAmJiB0eXBlb2YgcHJvdmlkZXIuZ2V0U2lnbmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAocDogU3VwcG9ydGVkUHJvdmlkZXIpID0+IChwIGFzIEV0aGVyc1Byb3ZpZGVyKS5nZXRTaWduZXIoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgcHJvdmlkZXIgY2Fubm90IGdldCBhIHNpZ25lclwiKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZE51bWJlciB7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIHNlY3VyaXR5Wm9uZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZEJvb2wgZXh0ZW5kcyBFbmNyeXB0ZWROdW1iZXIge31cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdGVkVWludDggZXh0ZW5kcyBFbmNyeXB0ZWROdW1iZXIge31cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdGVkVWludDE2IGV4dGVuZHMgRW5jcnlwdGVkTnVtYmVyIHt9XG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZFVpbnQzMiBleHRlbmRzIEVuY3J5cHRlZE51bWJlciB7fVxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWRVaW50NjQgZXh0ZW5kcyBFbmNyeXB0ZWROdW1iZXIge31cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdGVkVWludDEyOCBleHRlbmRzIEVuY3J5cHRlZE51bWJlciB7fVxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWRVaW50MjU2IGV4dGVuZHMgRW5jcnlwdGVkTnVtYmVyIHt9XG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZEFkZHJlc3MgZXh0ZW5kcyBFbmNyeXB0ZWROdW1iZXIge31cbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXJcIjtcblxuaW1wb3J0IHtcbiAgdG9CaWdJbnQgYXMgZXRoZXJzVG9CaWdJbnQsXG4gIHRvQmVBcnJheSBhcyBldGhlcnNUb0JlQXJyYXksXG4gIGlzQWRkcmVzcyBhcyBldGhlcnNJc0FkZHJlc3MsXG59IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSBcIi4vdmFsaWRhdGlvblwiO1xuXG5leHBvcnQgY29uc3QgVmFsaWRhdGVVaW50SW5SYW5nZSA9IChcbiAgdmFsdWU6IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIG1pbjogbnVtYmVyLFxuKTogdm9pZCA9PiB7XG4gIGlzTnVtYmVyKHZhbHVlKTtcblxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmFsdWUgb3V0IG9mIHJhbmdlOiAke21heH0gLSAke21pbn0sIHRyeSBhIGRpZmZlcmVudCB1aW50IHR5cGVgLFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmcm9tSGV4U3RyaW5nID0gKGhleFN0cmluZzogc3RyaW5nKTogVWludDhBcnJheSA9PiB7XG4gIGNvbnN0IGNsZWFuU3RyaW5nID0gaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEgPyBgMCR7aGV4U3RyaW5nfWAgOiBoZXhTdHJpbmc7XG4gIGNvbnN0IGFyciA9IGNsZWFuU3RyaW5nLnJlcGxhY2UoL14weC8sIFwiXCIpLm1hdGNoKC8uezEsMn0vZyk7XG4gIGlmICghYXJyKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvSGV4U3RyaW5nID0gKGJ5dGVzOiBVaW50OEFycmF5KSA9PlxuICBieXRlcy5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcblxuZXhwb3J0IGNvbnN0IG51bWJlclRvQnl0ZXMgPSAodWludDMyVmFsdWU6IG51bWJlcikgPT4ge1xuICBjb25zdCBieXRlQXJyYXlMZW5ndGggPSBNYXRoLmNlaWwoTWF0aC5sb2cyKHVpbnQzMlZhbHVlICsgMSkgLyA4KTtcbiAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5TGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gYnl0ZUFycmF5TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBieXRlQXJyYXlbaV0gPSB1aW50MzJWYWx1ZSAmIDB4ZmY7XG4gICAgdWludDMyVmFsdWUgPj49IDg7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufTtcblxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9OdW1iZXIgPSBmdW5jdGlvbiAoYnl0ZUFycmF5OiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgaWYgKCFieXRlQXJyYXkgfHwgYnl0ZUFycmF5Py5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYnl0ZUFycmF5KTtcbiAgY29uc3QgcmVzdWx0ID0gYnVmZmVyLnJlYWRVSW50QkUoMCwgbGVuZ3RoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgcmV0dXJuIGV0aGVyc1RvQmlnSW50KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQmVBcnJheSh2YWx1ZTogYmlnaW50IHwgbnVtYmVyKTogVWludDhBcnJheSB7XG4gIHJldHVybiBldGhlcnNUb0JlQXJyYXkodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3M6IHN0cmluZykge1xuICBpZiAoIWV0aGVyc0lzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IGlzIG5vdCB2YWxpZCBFVk0gYWRkcmVzc2ApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FCSUVuY29kZWRVaW50MzIodmFsdWU6IG51bWJlcikge1xuICAvLyBFbnN1cmUgdGhlIG51bWJlciBpcyBhIHZhbGlkIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyXG4gIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAweEZGRkZGRkZGKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ051bWJlciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMl4zMiAtIDEuJyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgYW5kIHBhZCBpdCB0byA2NCBjaGFyYWN0ZXJzICgzMiBieXRlcylcbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbiIsImZ1bmN0aW9uIGFzc2VydElzKGlzOiBib29sZWFuLCBleHBlY3RlZDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikge1xuICBpZiAoIWlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIHZhbHVlIHdoaWNoIGlzIFxcYCR7ZXhwZWN0ZWR9XFxgLCByZWNlaXZlZCB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYC5gLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiB1bmtub3duKSB7XG4gIGNvbnN0IGlzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xuXG4gIGFzc2VydElzKGlzLCBcInN0cmluZ1wiLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiB1bmtub3duKSB7XG4gIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqL2Jsb2IvbWFpbi9pbmRleC5qc1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXG4gIGNvbnN0IGlzID1cbiAgICAocHJvdG90eXBlID09PSBudWxsIHx8XG4gICAgICBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJlxuICAgICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJlxuICAgICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcblxuICBhc3NlcnRJcyhpcywgXCJwbGFpbiBvYmplY3RcIiwgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCaWdJbnRPckhleFN0cmluZyh2YWx1ZTogdW5rbm93bikge1xuICBjb25zdCBpcyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG5cbiAgYXNzZXJ0SXMoaXMsIFwiYmlnaW50IG9yIGhleCBzdHJpbmdcIiwgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IHVua25vd24pIHtcbiAgY29uc3QgaXMgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2YWx1ZSk7XG5cbiAgYXNzZXJ0SXMoaXMsIFwibnVtYmVyXCIsIHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmlnSW50T3JOdW1iZXIodmFsdWU6IHVua25vd24pIHtcbiAgY29uc3QgaXMgPSB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCI7XG5cbiAgaWYgKCFpcykge1xuICAgIHRyeSB7XG4gICAgICBpc051bWJlcih2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsdWUgJHt2YWx1ZX0gaXMgbm90IGEgbnVtYmVyIG9yIGJpZ2ludDogJHt0eXBlb2YgdmFsdWV9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvLyBXcml0dGVuIGluIDIwMTQtMjAxNiBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuKGZ1bmN0aW9uKHJvb3QsIGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICBlbHNlIGlmIChyb290Lm5hY2wpIHJvb3QubmFjbC51dGlsID0gZigpO1xuICBlbHNlIHtcbiAgICByb290Lm5hY2wgPSB7fTtcbiAgICByb290Lm5hY2wudXRpbCA9IGYoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0ge307XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVCYXNlNjQocykge1xuICAgIGlmICghKC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kLy50ZXN0KHMpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZycpO1xuICAgIH1cbiAgfVxuXG4gIHV0aWwuZGVjb2RlVVRGOCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBzdHJpbmcnKTtcbiAgICB2YXIgaSwgZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSksIGIgPSBuZXcgVWludDhBcnJheShkLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGQubGVuZ3RoOyBpKyspIGJbaV0gPSBkLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGI7XG4gIH07XG5cbiAgdXRpbC5lbmNvZGVVVEY4ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIGksIHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pKTtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzLmpvaW4oJycpKSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBhdG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanNcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgLy8gTm9kZSB2NiBhbmQgbGF0ZXJcbiAgICAgIHV0aWwuZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24gKGFycikgeyAvLyB2NiBhbmQgbGF0ZXJcbiAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICB9O1xuXG4gICAgICB1dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhbGlkYXRlQmFzZTY0KHMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpLCAwKSk7XG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUgZWFybGllciB0aGFuIHY2XG4gICAgICB1dGlsLmVuY29kZUJhc2U2NCA9IGZ1bmN0aW9uIChhcnIpIHsgLy8gdjYgYW5kIGxhdGVyXG4gICAgICAgIHJldHVybiAobmV3IEJ1ZmZlcihhcnIpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICB9O1xuXG4gICAgICB1dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFsaWRhdGVCYXNlNjQocyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuZXcgQnVmZmVyKHMsICdiYXNlNjQnKSwgMCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2Vyc1xuXG4gICAgdXRpbC5lbmNvZGVCYXNlNjQgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciBpLCBzID0gW10sIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGFycltpXSkpO1xuICAgICAgcmV0dXJuIGJ0b2Eocy5qb2luKCcnKSk7XG4gICAgfTtcblxuICAgIHV0aWwuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFsaWRhdGVCYXNlNjQocyk7XG4gICAgICB2YXIgaSwgZCA9IGF0b2IocyksIGIgPSBuZXcgVWludDhBcnJheShkLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykgYltpXSA9IGQuY2hhckNvZGVBdChpKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH07XG5cbiAgfVxuXG4gIHJldHVybiB1dGlsO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBleHBvcnRzLmdldEhhc2ggPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIpO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gKDAsIGhtYWNfMS5obWFjKShoYXNoLCBrZXksICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzOiB1dGlsc18xLnJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnRzLmdldEhhc2ggPSBnZXRIYXNoO1xuZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gKDAsIHdlaWVyc3RyYXNzX2pzXzEud2VpZXJzdHJhc3MpKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBjcmVhdGVDdXJ2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSBleHBvcnRzLndOQUYgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgICgwLCBtb2R1bGFyX2pzXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLigwLCBtb2R1bGFyX2pzXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGV4cG9ydHMuaXNvZ2VueU1hcCA9IGV4cG9ydHMuaGFzaF90b19maWVsZCA9IGV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94bWQgPSB2b2lkIDA7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKGRzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xufVxuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IGV4cGFuZF9tZXNzYWdlX3htZDtcbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwYW5kX21lc3NhZ2VfeG9mO1xuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gaGFzaF90b19maWVsZDtcbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcEhhc2hUb0ZpZWxkID0gZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZXhwb3J0cy5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZXhwb3J0cy5oYXNoVG9Qcml2YXRlU2NhbGFyID0gZXhwb3J0cy5GcFNxcnRFdmVuID0gZXhwb3J0cy5GcFNxcnRPZGQgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5uTGVuZ3RoID0gZXhwb3J0cy5GcElzU3F1YXJlID0gZXhwb3J0cy5GcERpdiA9IGV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IGV4cG9ydHMuRnBQb3cgPSBleHBvcnRzLnZhbGlkYXRlRmllbGQgPSBleHBvcnRzLmlzTmVnYXRpdmVMRSA9IGV4cG9ydHMuRnBTcXJ0ID0gZXhwb3J0cy50b25lbGxpU2hhbmtzID0gZXhwb3J0cy5pbnZlcnQgPSBleHBvcnRzLnBvdzIgPSBleHBvcnRzLnBvdyA9IGV4cG9ydHMubW9kID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5leHBvcnRzLm1vZCA9IG1vZDtcbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cgPSBwb3c7XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cyID0gcG93Mjtcbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9uZWxsaVNoYW5rcyA9IHRvbmVsbGlTaGFua3M7XG5mdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5jb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBpc05lZ2F0aXZlTEU7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShmaWVsZCwgb3B0cyk7XG59XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5mdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuLy8gQ1VSVkUubiBsZW5ndGhzXG5mdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6ICgwLCB1dGlsc19qc18xLmJpdE1hc2spKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkobnVtLCBCWVRFUykgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGJ5dGVzKSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG5leHBvcnRzLkZwU3FydEV2ZW4gPSBGcFNxcnRFdmVuO1xuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGhhc2gpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG5leHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBoYXNoVG9Qcml2YXRlU2NhbGFyO1xuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5mdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbmV4cG9ydHMuZ2V0RmllbGRCeXRlc0xlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGg7XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoa2V5KSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShyZWR1Y2VkLCBmaWVsZExlbikgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBtYXBIYXNoVG9GaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGV4cG9ydHMuYml0TWFzayA9IGV4cG9ydHMuYml0U2V0ID0gZXhwb3J0cy5iaXRHZXQgPSBleHBvcnRzLmJpdExlbiA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmVxdWFsQnl0ZXMgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy5lbnN1cmVCeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBleHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IGV4cG9ydHMuYnl0ZXNUb051bWJlckxFID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gbnVtYmVyVG9IZXhVbnBhZGRlZDtcbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG5leHBvcnRzLm51bWJlclRvVmFyQnl0ZXNCRSA9IG51bWJlclRvVmFyQnl0ZXNCRTtcbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuZXhwb3J0cy5iaXRHZXQgPSBiaXRHZXQ7XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG5leHBvcnRzLmJpdFNldCA9IGJpdFNldDtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IGV4cG9ydHMud2VpZXJzdHJhc3MgPSBleHBvcnRzLndlaWVyc3RyYXNzUG9pbnRzID0gZXhwb3J0cy5ERVIgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuY29uc3QgbW9kID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0ID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBjdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBleHBvcnRzLkRFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSB3ZWllcnN0cmFzc1BvaW50cztcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gZXhwb3J0cy5ERVIudG9TaWcoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG5leHBvcnRzLndlaWVyc3RyYXNzID0gd2VpZXJzdHJhc3M7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG5leHBvcnRzLlNXVUZwU3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW87XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC91dGlscy5qc1wiKTtcbmNvbnN0IGhhc2hfdG9fY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIik7XG5jb25zdCBfc2hvcnR3X3V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hvcnR3X3V0aWxzLmpzXCIpO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9ICgwLCBtb2R1bGFyX2pzXzEucG93MikodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSAoMCwgbW9kdWxhcl9qc18xLkZpZWxkKShzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSAoMCwgX3Nob3J0d191dGlsc19qc18xLmNyZWF0ZUN1cnZlKSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTZfMS5zaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSAoMCwgc2hhMjU2XzEuc2hhMjU2KShVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeCgoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnNjaG5vcnIgPSAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkU6IHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2Q6IG1vZHVsYXJfanNfMS5tb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmlzb2dlbnlNYXApKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nl8xLnNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9ICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm91dHB1dCA9IGV4cG9ydHMuZXhpc3RzID0gZXhwb3J0cy5oYXNoID0gZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuYm9vbCA9IGV4cG9ydHMubnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEub3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZDVMID0gZXhwb3J0cy5hZGQ1SCA9IGV4cG9ydHMuYWRkNEggPSBleHBvcnRzLmFkZDRMID0gZXhwb3J0cy5hZGQzSCA9IGV4cG9ydHMuYWRkM0wgPSBleHBvcnRzLmFkZCA9IGV4cG9ydHMucm90bEJMID0gZXhwb3J0cy5yb3RsQkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RyMzJMID0gZXhwb3J0cy5yb3RyMzJIID0gZXhwb3J0cy5yb3RyQkwgPSBleHBvcnRzLnJvdHJCSCA9IGV4cG9ydHMucm90clNMID0gZXhwb3J0cy5yb3RyU0ggPSBleHBvcnRzLnNoclNMID0gZXhwb3J0cy5zaHJTSCA9IGV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNwbGl0ID0gZXhwb3J0cy5mcm9tQmlnID0gdm9pZCAwO1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5leHBvcnRzLnNoclNIID0gc2hyU0g7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnNoclNMID0gc2hyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdHJTSCA9IHJvdHJTSDtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnJvdHJTTCA9IHJvdHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuZXhwb3J0cy5yb3RyQkggPSByb3RyQkg7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90ckJMID0gcm90ckJMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5leHBvcnRzLnJvdHIzMkggPSByb3RyMzJIO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuZXhwb3J0cy5hZGQzTCA9IGFkZDNMO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDNIID0gYWRkM0g7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmV4cG9ydHMuYWRkNEwgPSBhZGQ0TDtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ0SCA9IGFkZDRIO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmV4cG9ydHMuYWRkNUwgPSBhZGQ1TDtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ1SCA9IGFkZDVIO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuY29uc3QgbmMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5leHBvcnRzLmNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuaGFzaCkoaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYmtkZjJBc3luYyA9IGV4cG9ydHMucGJrZGYyID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IGhtYWNfanNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuaGFzaCkoaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCB1dGlsc19qc18xLmNoZWNrT3B0cykoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoYyk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGRrTGVuKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjX2pzXzEuaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgIHUuZmlsbCgwKTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKi9cbmZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbmFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX2pzXzEuYXN5bmNMb29wKShjIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0cy5wYmtkZjJBc3luYyA9IHBia2RmMkFzeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLlJJUEVNRDE2MCA9IHZvaWQgMDtcbmNvbnN0IF9zaGEyX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hhMi5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG5jb25zdCBSaG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKF8sIGkpID0+IGkpO1xuY29uc3QgUGkgPSAvKiBAX19QVVJFX18gKi8gSWQubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KTtcbmxldCBpZHhMID0gW0lkXTtcbmxldCBpZHhSID0gW1BpXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAobGV0IGogb2YgW2lkeEwsIGlkeFJdKVxuICAgICAgICBqLnB1c2goaltpXS5tYXAoKGspID0+IFJob1trXSkpO1xuY29uc3Qgc2hpZnRzID0gLyogQF9fUFVSRV9fICovIFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUiA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IEtsID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDUwYTI4YmU2LCAweDVjNGRkMTI0LCAweDZkNzAzZWYzLCAweDdhNmQ3NmU5LCAweDAwMDAwMDAwLFxuXSk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAod29yZCA+Pj4gKDMyIC0gc2hpZnQpKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMSlcbiAgICAgICAgcmV0dXJuICh4ICYgeSkgfCAofnggJiB6KTtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB4IF4gKHkgfCB+eik7XG59XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IEJVRiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5oMCA9IDB4Njc0NTIzMDEgfCAwO1xuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IDB4MTAzMjU0NzYgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcbiAgICB9XG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xuICAgICAgICB0aGlzLmgxID0gaDEgfCAwO1xuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gaDQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgQlVGW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsW2dyb3VwXSwgaGJyID0gS3JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMW2dyb3VwXSwgc3IgPSBzaGlmdHNSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZbcmxbaV1dICsgaGJsLCBzbFtpXSkgKyBlbCkgfCAwO1xuICAgICAgICAgICAgICAgIGFsID0gZWwsIGVsID0gZGwsIGRsID0gcm90bChjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxvb3BzIGFyZSAxMCUgZmFzdGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IChyb3RsKGFyICsgZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9IHJvdGwoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIEJVRi5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUklQRU1EMTYwID0gUklQRU1EMTYwO1xuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NyeXB0QXN5bmMgPSBleHBvcnRzLnNjcnlwdCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBzaGEyNTZfanNfMSA9IHJlcXVpcmUoXCIuL3NoYTI1Ni5qc1wiKTtcbmNvbnN0IHBia2RmMl9qc18xID0gcmVxdWlyZShcIi4vcGJrZGYyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUkZDIDc5MTQgU2NyeXB0IEtERlxuLy8gTGVmdCByb3RhdGUgZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG4vLyBUaGUgbWFpbiBTY3J5cHQgbG9vcDogdXNlcyBTYWxzYSBleHRlbnNpdmVseS5cbi8vIFNpeCB2ZXJzaW9ucyBvZiB0aGUgZnVuY3Rpb24gd2VyZSB0cmllZCwgdGhpcyBpcyB0aGUgZmFzdGVzdCBvbmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFhvckFuZFNhbHNhKHByZXYsIHBpLCBpbnB1dCwgaWksIG91dCwgb2kpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NyLnlwLnRvL3NhbHNhMjAuaHRtbFxuICAgIC8vIFhvciBibG9ja3NcbiAgICBsZXQgeTAwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA2ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDcgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwOCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA5ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTE1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gICAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMywgeDA0ID0geTA0LCB4MDUgPSB5MDUsIHgwNiA9IHkwNiwgeDA3ID0geTA3LCB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgICAvLyBNYWluIGxvb3AgKHNhbHNhKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHgwNCBePSByb3RsKHgwMCArIHgxMiB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwNSArIHgwMSB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwMyBePSByb3RsKHgxNSArIHgxMSB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgwMSBePSByb3RsKHgwMCArIHgwMyB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgxMSBePSByb3RsKHgxMCArIHgwOSB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgxMiBePSByb3RsKHgxNSArIHgxNCB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dHB1dCAoc2Fsc2EpXG4gICAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuZnVuY3Rpb24gQmxvY2tNaXgoaW5wdXQsIGlpLCBvdXQsIG9pLCByKSB7XG4gICAgLy8gVGhlIGJsb2NrIEIgaXMgciAxMjgtYnl0ZSBjaHVua3MgKHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgMnIgNjQtYnl0ZSBjaHVua3MpXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XG4gICAgbGV0IHRhaWwgPSBvaSArIDE2ICogcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgICAgIC8vIFdlIHdyaXRlIG9kZCAmIGV2ZW4gWWkgYXQgc2FtZSB0aW1lLiBFdmVuOiAwYlhYWFhYMCBPZGQ6ICAwYlhYWFhYMVxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgdGFpbCArPSAxNjsgLy8gRmlyc3QgaXRlcmF0aW9uIG92ZXJ3cml0ZXMgdG1wIHZhbHVlIGluIHRhaWxcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcbiAgICB9XG59XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgX29wdHMpIHtcbiAgICAvLyBNYXhtZW0gLSAxR0IrMUtCIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoTik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKHIpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShwKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoZGtMZW4pO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShhc3luY1RpY2spO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShtYXhtZW0pO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZ3Jlc3NDYiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xuICAgIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcbiAgICBpZiAoTiA8PSAxIHx8IChOICYgKE4gLSAxKSkgIT09IDAgfHwgTiA+PSAyICoqIChibG9ja1NpemUgLyA4KSB8fCBOID4gMiAqKiAzMikge1xuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxuICAgICAgICAvLyBUaGVyZSBpcyBubyBKUyBlbmdpbmVzIHRoYXQgYWxsb3dzIGFsb2NhdGUgbW9yZSB0aGFuIDRHQiBwZXIgc2luZ2xlIFVpbnQ4QXJyYXkgZm9yIG5vdywgYnV0IGNhbiBjaGFuZ2UgaW4gZnV0dXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogTiBtdXN0IGJlIGxhcmdlciB0aGFuIDEsIGEgcG93ZXIgb2YgMiwgbGVzcyB0aGFuIDJeKDEyOCAqIHIgLyA4KSBhbmQgbGVzcyB0aGFuIDJeMzInKTtcbiAgICB9XG4gICAgaWYgKHAgPCAwIHx8IHAgPiAoKDIgKiogMzIgLSAxKSAqIDMyKSAvIGJsb2NrU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKCgyXjMyIC0gMSkgKiAzMikgLyAoMTI4ICogciknKTtcbiAgICB9XG4gICAgaWYgKGRrTGVuIDwgMCB8fCBka0xlbiA+ICgyICoqIDMyIC0gMSkgKiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogZGtMZW4gc2hvdWxkIGJlIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgyXjMyIC0gMSkgKiAzMicpO1xuICAgIH1cbiAgICBjb25zdCBtZW1Vc2VkID0gYmxvY2tTaXplICogKE4gKyBwKTtcbiAgICBpZiAobWVtVXNlZCA+IG1heG1lbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xuICAgIH1cbiAgICAvLyBbQjAuLi5CcOKIkjFdIOKGkCBQQktERjJITUFDLVNIQTI1NihQYXNzcGhyYXNlLCBTYWx0LCAxLCBibG9ja1NpemUqUGFyYWxsZWxpemF0aW9uRmFjdG9yKVxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XG4gICAgY29uc3QgQiA9ICgwLCBwYmtkZjJfanNfMS5wYmtkZjIpKHNoYTI1Nl9qc18xLnNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShCKTtcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxuICAgIGNvbnN0IFYgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSAqIE4pKTtcbiAgICBjb25zdCB0bXAgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gKDAsIHBia2RmMl9qc18xLnBia2RmMikoc2hhMjU2X2pzXzEuc2hhMjU2LCBwYXNzd29yZCwgQiwgeyBjOiAxLCBka0xlbiB9KTtcbiAgICBCLmZpbGwoMCk7XG4gICAgVi5maWxsKDApO1xuICAgIHRtcC5maWxsKDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3NcbiAqIEBwYXJhbSBzYWx0IC0gc2FsdFxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXG4gKiAtIGBOYCBpcyBjcHUvbWVtIHdvcmsgZmFjdG9yIChwb3dlciBvZiAyIGUuZy4gMioqMTgpXG4gKiAtIGByYCBpcyBibG9jayBzaXplICg4IGlzIGNvbW1vbiksIGZpbmUtdHVuZXMgc2VxdWVudGlhbCBtZW1vcnkgcmVhZCBzaXplIGFuZCBwZXJmb3JtYW5jZVxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXG4gKiAtIGBka0xlbmAgaXMgb3V0cHV0IGtleSBsZW5ndGggaW4gYnl0ZXMgZS5nLiAzMi5cbiAqIC0gYGFzeW5jVGlja2AgLSAoZGVmYXVsdDogMTApIG1heCB0aW1lIGluIG1zIGZvciB3aGljaCBhc3luYyBmdW5jdGlvbiBjYW4gYmxvY2sgZXhlY3V0aW9uXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XG4gKiAtIGBvblByb2dyZXNzYCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgZXhlY3V0ZWQgZm9yIHByb2dyZXNzIHJlcG9ydFxuICogQHJldHVybnMgRGVyaXZlZCBrZXlcbiAqL1xuZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuZXhwb3J0cy5zY3J5cHQgPSBzY3J5cHQ7XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBhd2FpdCAoMCwgdXRpbHNfanNfMS5hc3luY0xvb3ApKE4gLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX2pzXzEuYXN5bmNMb29wKShOLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuZXhwb3J0cy5zY3J5cHRBc3luYyA9IHNjcnlwdEFzeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IHZvaWQgMDtcbmNvbnN0IF9zaGEyX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hhMi5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfc2hhMl9qc18xLlNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnRzLnNoYTIyNCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBleHBvcnRzLnNoYWtlMTI4ID0gZXhwb3J0cy5rZWNjYWtfNTEyID0gZXhwb3J0cy5rZWNjYWtfMzg0ID0gZXhwb3J0cy5rZWNjYWtfMjU2ID0gZXhwb3J0cy5rZWNjYWtfMjI0ID0gZXhwb3J0cy5zaGEzXzUxMiA9IGV4cG9ydHMuc2hhM18zODQgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5zaGEzXzIyNCA9IGV4cG9ydHMuS2VjY2FrID0gZXhwb3J0cy5rZWNjYWtQID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IF91NjRfanNfMSA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gKDAsIF91NjRfanNfMS5zcGxpdCkoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyAoMCwgX3U2NF9qc18xLnJvdGxCSCkoaCwgbCwgcykgOiAoMCwgX3U2NF9qc18xLnJvdGxTSCkoaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X2pzXzEucm90bEJMKShoLCBsLCBzKSA6ICgwLCBfdTY0X2pzXzEucm90bFNMKShoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydHMua2VjY2FrUCA9IGtlY2Nha1A7XG5jbGFzcyBLZWNjYWsgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5vdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLktlY2NhayA9IEtlY2NhaztcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydHMuc2hhM18yMjQgPSBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLnNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLnNoYTNfNTEyID0gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzIyNCA9IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzM4NCA9IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0cy5zaGFrZTEyOCA9IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb246IG1lc3NhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcbiAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBsaXN0ZW5lcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGNiKGVycik7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fbWFza2VkICYmXG4gICAgICAgICh0aGlzLl9tYXNrWzBdIHwgdGhpcy5fbWFza1sxXSB8IHRoaXMuX21hc2tbMl0gfCB0aGlzLl9tYXNrWzNdKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykgcmV0dXJuIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gY2IoXG4gICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXIgPSB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gICAgICBpZiAoZXIpIHJldHVybiBjYihlcik7XG5cbiAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Zpbikge1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIHBheWxvYWQgbGVuZ3RoIDEnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ0xPU0VfQ09ERSdcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmID0gZGF0YS5zbGljZSgyKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDkpIHtcbiAgICAgIHRoaXMuZW1pdCgncGluZycsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG5cbi8qKlxuICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZml4IFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBhZGQgYSBkZWZhdWx0IHByZWZpeCB0b1xuICogICAgIGBtZXNzYWdlYFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JDb2RlIFRoZSBleHBvc2VkIGVycm9yIGNvZGVcbiAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgKTtcblxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGVycm9yKTtcbiAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICByZXR1cm4gZXJyO1xufVxuIiwiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJebmV0fHRscyRcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuXG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICByc3YxICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1tcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICAgICAgOiAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgIF1cbiAgICAgICkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgcmVhZE9ubHksXG4gICAgICAgIHJzdjFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICByc3YxOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjgoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDE1MCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9LFxuICAgIHRva2VuQ2hhcnNcbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzfGh0dHBzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPVxuICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fFxuICAgICAgcmVxLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0JyB8fFxuICAgICAgIWtleSB8fFxuICAgICAgIWtleVJlZ2V4LnRlc3Qoa2V5KSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRQcm90b2NvbCA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRQcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgdGhpcy5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2hlbiBwcmVjb25kaXRpb25zIGFyZSBub3QgZnVsZmlsbGVkLlxuICpcbiAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XG4gICAgaGVhZGVycyA9IHtcbiAgICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcsXG4gICAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9O1xuXG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICAgJ1xcclxcblxcclxcbicgK1xuICAgICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgc29ja2V0LmRlc3Ryb3koKTtcbn1cbiIsIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXlJlYWRhYmxlJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxuICBrTGlzdGVuZXIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHtcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XG59ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSBFTVBUWV9CVUZGRVI7XG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb3RvY29sID0gJyc7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG5cbiAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwO1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZGlyZWN0cyA9IDA7XG5cbiAgICAgIGlmIChwcm90b2NvbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGRldmlhdGVzIGZyb20gdGhlIFdIQVRXRyBpbnRlcmZhY2Ugc2luY2Ugd3MgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgKiByZXF1aXJlZCBkZWZhdWx0IFwiYmxvYlwiIHR5cGUgKGluc3RlYWQgd2UgZGVmaW5lIGEgY3VzdG9tIFwibm9kZWJ1ZmZlclwiXG4gICAqIHR5cGUpLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcblxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICByZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRXJyb3IpO1xuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xuICAgIHJlY2VpdmVyLm9uKCdwb25nJywgcmVjZWl2ZXJPblBvbmcpO1xuXG4gICAgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vXG4gICAgLy8gU3BlY2lmeSBhIHRpbWVvdXQgZm9yIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSB0byBjb21wbGV0ZS5cbiAgICAvL1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3kuYmluZCh0aGlzLl9zb2NrZXQpLFxuICAgICAgY2xvc2VUaW1lb3V0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcbiAgICogICAgIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnaXNQYXVzZWQnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0KGhhbmRsZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdHJ1ZSxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBjcmVhdGVDb25uZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxuICAgIGhvc3RuYW1lOiB1bmRlZmluZWQsXG4gICAgcHJvdG9jb2w6IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgbWV0aG9kOiB1bmRlZmluZWQsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgICB3ZWJzb2NrZXQuX3VybCA9IGFkZHJlc3MuaHJlZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzO1xuICB9XG5cbiAgY29uc3QgaXNTZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3c3M6JztcbiAgY29uc3QgaXNVbml4U29ja2V0ID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVSTE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc1VuaXhTb2NrZXQpIHtcbiAgICBpbnZhbGlkVVJMTWVzc2FnZSA9XG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNVbml4U29ja2V0ICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVVJMTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVVJMTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVSTE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVSTE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IGdldCA9IGlzU2VjdXJlID8gaHR0cHMuZ2V0IDogaHR0cC5nZXQ7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID0gaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdDtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0JyxcbiAgICAuLi5vcHRzLmhlYWRlcnNcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8XG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xuICAgIH1cblxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdCA9IHBhcnNlZFVybC5ob3N0O1xuXG4gICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnM7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHVzZXIgcHJvdmlkZWQgb3B0aW9ucyBzbyB0aGF0IGhlYWRlcnMgY2FuIGJlIGNoYW5nZWRcbiAgICAgIC8vIHdpdGhvdXQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgIC8vXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7fSB9O1xuXG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhvc3QgIT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0KSB7XG4gICAgICAvL1xuICAgICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIGRyb3AgdGhlIGZvbGxvd2luZyBoZWFkZXJzLiBUaGVzZVxuICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAvL1xuICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG4gICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgbWFrZSB0aGUgZmlyc3QgYEF1dGhvcml6YXRpb25gIGhlYWRlciB3aW4uXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcbiAgICAvLyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9XG4gICAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgdXBncmFkZWBcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAoIXdlYnNvY2tldC5pc1BhdXNlZCkgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgICAvL1xuICAgIC8vIE9uIE5vZGUuanMgPCAxNC4wLjAgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIHN5bmNocm9ub3VzbHkuIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxuICAgIC8vXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhd2Vic29ja2V0Ll9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSBUaGUgcmVhZGFibGUgc3RyZWFtXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtKSB7XG4gIHN0cmVhbS5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVydXRpbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlLXRmaGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRmLTgtdmFsaWRhdGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiemxpYlwiKTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxudmFyIENPTVBSRVNTRUQkMSA9ICdBRUVVZHdtZ0RTOEJ4UUtLQVA0Qk9nRGpBVEFBbmdEVUFJTUFvQUJvQU9BQWFnQ09BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdUFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHZ0FlQUJNQUdBVWhCZThCRnhSRU44c0Yyd0M1QUs1SEFXOEFyUWtEelFDdWh6YzNOemNCUDY4TkVmTUFCUWRIQnV3NUJWOEZZQUE5TXprSTlyNFpCZzdReVFBV0E5Q2VPd0xOQ2pjQ2pxa0NodUEvbG0rUkFzWFRBb1A2QVNmbkVRRHl0UUZKQWpXVkNrZVhBT3NBNmdvZEFCL2N3ZEFVRTBXbEJDTi9BUVVDUVJqRkQvTVJCakh4RFFTSmJ3MGpCelVBc3dCeG1lK3RuSWNBWXdhYkF5c0c4UUFqQUVNTW14Y0RxZ1BLUXlEWENNTXhBN2tVUXdEM05YT3JBS21GSUFBZkJDMEQzeDRCSlFEQkdkVUZBaEVnVkQ4Sm53bVFKaU5XWVV6cmcwb0FHd0FVQUIwQUZuTmNBQ2tBRmdCUDloM2dQZnNET1dES25lWTJDaGdsWDFVRFlEMzBBQnNBRkFBZEFCWnpJR1JBbndERDh3QWpBRUVNelJiRHFnTUIyc0FGWXdYcUF0Q25Bc1M0QXdwVUpLUnRGSHNhZFV6OUFNTVZid0xwQUJNMU5KRVgwWmtDZ1lNQkV5TUF4UlZ2QXVrQUV6VUJVRkF0bVV3U0F5NERCVEVSMzNFZnRRSGZTd0I1TXhKL0Fqa1dLUUx6TDhFL2N3QkI2UUg5TFFEUER0TzlBU05yaVFDNURRQU5Bd0NLMjFFRkk5MXpId0NvTDlrQnFRY0hCd2NIS3pVRG93QnZBUW9oUHZVM2ZBUWdId0N5QWM4Q0tRTUE1ek1TZXpyN1VMZ0ZtRHAvTHpWUUJnRUdBaThGWVFWZ3Q4QUZjVHRsUWhwQ1dFbWZlNXRtWjZJQUV4c0R6UTh0K1g4ckJLdFRBbHRiQW4wanN5OEJsNnV0UFdNRFRSOEVpMmtSQU5rREJyTkhOeXNEQnpFQ1FXVUFjd0ZwSjNrQWl5VWhBSjBCVWI4QUwzRWZBYmZOQXo4MUtVc0ZXd0YzWVFadEFtMEErVkVmQXpFSkRRQlJTUUN6QVFCbEFIc0FNNzBHRC92M0laV0hCd0FSS1FBeEFMc2pUd0haQWVNUEV6bVhnSUh3QUJJQUdRQThBRVVBUUR0M2dkdklFR2NRWkFrR1RSRk1kRUlWRXdLMEQ2NEw3UkVkRE5rcTA5UGdBRFN4Qi9NRFd3ZnpBMXNEV3dmekIvTURXd2Z6QTFzRFd3TmJBMXNjRXZBaTI4Z1FadzlRQkhVRmxnV1RCTjRJaXlaUkVZa0hNQWphVkJWMEpoeFBBMDBCQkNNdFNTUTdtek1USlVwTUZFMExDQVEyU215dmZVQURUekd6VlAyUXFnUFRNbGM1ZEFrR0hua1NxQUF5RDNza05iMU9obnBQY2FnS1UwKzJ0WWRKYWs1dkFzWTZzRUFBQ2lrSm0yL0RkMVlHUlJBZko2a1Erd3czQWJrQlB3M3hTOXdFOVFZL0JNMGZnUmtkRDlHVm9BaXBMZUVNOFNibkxxV0FYaVA1S29jRjhVdjRQT0VMVVZGc0QxMExhUW5uT21lQlVnTWxBUkVpandyaERUMEljUkQzQ3MxdkRla1JTUWM5QTlsSm5nQ3BCd1VMRlIwNUZia21GR0t3Q3cwNWV3Yi9Hdm9Ma3lhekV5MTdBQVhYR2lVR1VRRXRHd01BMHk3cmhiUmFOVndnVDJNR0J3c3BJOHNVckZBa0RTbEF1M2hNR2g4SEdTV3RBcFZEZEVxTFVUb2VseUg2UEVFTmFpNFhVWUFIK1R3SkdWTUxoVHlpUnE5RkVoSFdQcEU5VENKTlREQUVPWU1zTXllUENkTVBpUXk5ZkhZQlhRa2xDYlVNZFJNMUVSczN5UWc5QngweGx5Z25HUWdsUnBsZ25nVDdvd1AzRTlVRER3VkRDVVVIRndPNUhERVRNaFV0QlJHQktOc0M5emJaTHJjQ2sxYUVBUnNGenc4cEgrTVFWRWZrRHUwSW53SnBBNGNsN3dBeEZTVUFHeUtmQ0VkbkFHT1AzRk1KTHM4SXkycHdJM2dEYXhUclpSRjNCNVVPV3dlckhEY1Z3eHpsY014ZUQ0WU1LS2V6Q1Y4QmVRbWRBV01FNXdnTk5WK01wQ0JGWjFlTFhCaWZJR1ZCUTE0QUFqVU1hUldqUk1HSGZBS1BEMjhTSHdFNUFYY0hQUTBGQW5zUjhSRnZFSmtJNzRZSU5ia3ovRG9wQkZNaGh5QVZDaXNEVTJ6U0N5c20vUXo4YlFHbkVtWURFRFJCZC9KbnIyQzZLQmdCQngweXlVRmtJZlVMbGsvUkRLQWF4UmhHVkRJWjZBZkRBL2NhOXlmdVFWc0dBd09uQnhjNlVUUHlCTUVMYlFpUENVTUFUUTZuR3dmYkdHNEtkWXpVQVRXUEFidWRBMXVWaHdKemt3WTdCdzhBYXcrTEJYM3BBQ0VDcXdpbkFBa0Ewd05iQUQwQ3NRZWhBQjBBaVVVQlFRTXJNd0VsNlFLVEE1Y0lOYzhCbVRNQjl5MEVIOGNNR1FEN08yNU9Bc08xQW9CdVpxWUY0VndDa2dKTk9RRlJLUVFKVWt0VkE3TjE1UURmQUU4R0YrTkxBUm12VHM4ZTUwY0I0M012QU1zQS93QUpPUWNKUlFIUkFmZHhBTHNCWXdzMUNhYTN1UUZSN1MwQWh3QVpid0hiQW8wQTRRQTVBSVAxQVZjQVVRVmQvUVhYQWxOTkFSVTFIQzliWlFHL0F5TUJOd0VSQUgwR3o1R3B6UXNqQkhFSDF3SVFIeFhsQXU4eUI3a0ZBeUxqRTlGQ3lRSzk0bGtBTWhvS1BBcXJDcXBnWDJRM0NqVjJQVlFBRWgrc1Bzcy9VZ1ZWTzFjN1hEdFhPMXc3Vnp0Y08xYzdYRHRYTzF3RG04UG13K1lLY0Y5SlllOE1xZzNZUk13NlRSUGZZRlZnTmhQTUxic1V4UlhTSlZvWlFSckFKd2tsNkZVTkR3Z3QxMlkwQ0RBMGVSZkFBRU1wYklORlk0b2VOQXBQSE90VGxWVDhMUjhBdFV1bU03TU5zQnNaUkVRRlMzWHhZaTRXRWdvbUFtU0ZBbUpHWDFHekFWODNKQUtoK3dKb25BSm1EUUtmaURnZkR3Sm1Qd0ptS2dSeUJJTURmeGNEZnBZNUNqbDdHem1HT2ljbkFtd2hBakk2T0E0Q2Jjc0NiYkx6amdNM2Ewa3ZBV3NBNGdEbEFFNEpCNXdNa1FFQ0Q4WUFFYmtDZHpNQ2RxWkRBbmxQUndKNHZpRmczMFd5UnZjQ2ZFTUNlc3dDZlEwQ2ZQUklCRWlCWnlnQUx4bEpYRXBmR1J0SzBBTFJCUUxRMEVzckE0aFRBNGZxUk1tUk5nTHlwVjBIQXdPeVM5Sk1NU2tIMDAxUVRiTUNpME1DaXR6Rkh3c2hSMnNKdXdLT093S09ZRVNiaFFLTzNRS09ZSHhSdUZNNUFRNVMyRlNKQXBQL0FwTVFBTzBBSUZVaVZiTlYxQW9zSHltWmlqTGxlR3BGUHowQ2w2TUM3N1pZSmF3QVhTa0NscE1DbG9DZ0FLMVpzRm9OaFZFQVB3S1d1UUtXVWx4SVhOVUNtYzhDbVdoY3psMExIUUtjbnpuR09xRUNuQm9DbjU4Q25yeU9BQ0VUTlM0VEFwMzFBcDZXQUxsQllUaGg4d0tlMXdLZ2NnR3RBcDZqSXdLZVVxbGp6R1FyS1M4Q0o3TUNKb0lDb1A4Q29GRGJBcVl6QXFYU0FxZ0RBSUVDcC9ab2dHaTFBQWROYWlCcTFRS3M1d0tzc2dLdGF3S3RCZ0pYSVFKVjRBS3g1ZHNESDFKc213S3l3UkVDc3V3YmJPUnRaMjFNWXdNbDBRSzJZRDlEYnBRREtVa0N1R0lDdVVzWkFya3VlM0E2Y09VQ3ZSMERMYllETWhVQ3ZveHlCZ016ZFFLK0huTW1jMU1Ddzg4Q3d3aHpoblJQT1VsMDVBTThxd0VEUEo0RFBjTUN4WUFDeGtzQ3hoU05Bc2h0VlFMSVNBTEpVd0xKTWdKa29RTGQxbmg5WlhpeWVTbEwxQU1ZcDJjR0FtSDRHZmVWS0hzUFhwWmV2eFVDejI4Q3ozQXpUMWZXOXhlakFNcXhBczkzQVMzdUEwNFdmazhKQXR3ckF0dU9BdEpUQTFKZ0ExTmpBUVVEVlpDQWpVTUV6eHJ4WkVsNUE0TFNnNUVDMnNzQzJlS0VGSVJOcDBBRGhxa0FNd05rRW9aMVhmMEFXUUxmYVFMZXZIZDdBdUl6N1JnQjh6UXJBZlNmQWZMV2l3THI5d0xwZEgwREF1cjlBdXJvQVAxTEFiMEM3bzBDNjZDV3JwY0hBdTVEQTRYa21IMXc1SEdsQXZNSEFHMERqaHFabHdMM0Z3T1JjZ09TaXdMM25BTDUzUUw0YXBvZ21xKy9PNXNpQTUySEF2NytBUjhBUFo4Z0FaKzNBd1dSQTZadUE2YmRBTlhKQXdadW9ZeWlDUTBEREUwQkV3RWpCM0VHWmIxckNRQy9CRy9ERlk4ZXR4RUFHM2s5QUNjRE54SlJBNDJEQVdjckpRQ004d0FsQU9hbkM2T1ZDTHNHSTZmSkJnQ3ZCUm5EQnZFbFJVWUZGb0FGY0Q5R1NETkNLVUs4WDNrWlg4UUFsczBGT2dDUVZDR2J3VHN1WURvWnV0Y09OeGpPR0pISi9nVmZCV0FGWHdWZ0JXc0ZZQVZmQldBRlh3VmdCVjhGWUFWZkJXQk9IUWpmalc4S0Nnb0tiRjd4TXdUUkE3a0dOOFBEQU1NRXI4TUE3MGd4RnJvRlRqNXhQbmhDUjBLK1gzMC9YL0FBV0JrenN3Q05Cc3h6ekFTbTcwYUNSUzRyRERNZUx6NDlmblhmY3NINUdjb3NjUUZ6MTNZNEh3Vm5CWExKeWNuQUNOZFJZd2dJQ0FxRVhvV1R4Z0E3UDRrQUN4YlpCdTIxS3cwQWpNc1RBd2tWQU9WdEpVVXNKMUpDdVVMRVNVQXJYeTlnUGk5QUt3bkpSUVlLVEQ5TFBvQStpVDU0UG5rQ2tVTEVVVXBEWDlOV1YzSlZFalFBYzF3M0EzSUJFM1luWCtnN1FpTUpiNk1LYWlzelJDVXVRck5DeERQTUNjd0VYOUVXSnpZUkVCRUVCd0lIS242bDMzSkNOVklmeWJQSnRBbHR5ZFBVQ21oQlp3L3RFS3NaQUpPVkpVMUNMUnV4YlVIT1FBbzdQMHMrZUVKSEhBOFNKVlJQZEdNME5WcnB2Qm9LaGZVbE0wSkhIR1VRVWhFV08xeExTajhNTzB1Y05BcUpJelZDUnh2OUVGc3FLeUE0T1FnTmoybndaZ3A1Wk5GZ0UyQTFLM1lIUzJBaFFRb2pKbUM3RGdwekdHMVdZRlVaQ1FZSFpPOWdIV0NkWUlWZ3UyQlRZSmx3Rmg4R3ZSYmNYYkc4WWd0REhyTUJ3elBWeVFvbkhRZ2tDeVlCZ1FKMEFqYzRuVnFJQXdHU0NzQlBJZ0RzSzNTV0V0SVZCYTVOOGdHakFvK2tWd1ZJWndEL0FFVVNDRHdlWDRJVHJSUXNKOEszVHdCWEZEd0VBQjBUdnpWY0F0b1RTMjBSSXdEZ1ZnWjlCQkltWWdBNUFMNENvaThMRm5lek9rQ25JUUZqQVk0S0JBUGg5UmNHc2daU0JzRUFKY3Rkc1dJUnUya1RrUXN0Unc3REFjTUJLZ3BQQkdJR01EQXdLQ1luS1RRYUxnNEFLUlNWQUZ3Q2RsK1lVWjBKZGljRkQzbFBBZHQxRjlaWktDR3h1RTN5QnhrRlZHY0Evd0JGRWdpQ0J3QU9MSFFTanhPdFFEZzF6N2RlRlJNQVo4UVRBR3RLYjFBcElpUEhBRGtBdmdLaUx5MURGdFlDbUJpREFsRERXTkIwZW83ZnBhTU8vYUVWUlJ2MEFURVFaQklPRHlNRUFjOEpRaENiRFJnekZENFRBRU1BdTlZQkNnQ3NBT2tBbTVJM0FCd0FZeHZPTm5SK01oWEpBeGdLUXl4TDIra2tKaE1iaFFLREJNa1NzdkYwQUQ5Qk5RNnVRQzdXcVNRSHd4RUFFRUl1MWhraEFIMno0aVFQd3lKUEhOV3BkeVlCUlNwbkpBTHpvQkFFVlBQc0gyME14QTBDQ0VRS1JnQUZ5QXRGQWxNTnd3akVEVVFKUkFyRUx0YXBNZzdERFpnSkl3K1RHdWtFSXd2REZrTUFxQXRERU1NTUJoaW9lK1FBTzNNTVJBQUNyZ25FQlNQWTlRMEZEbmJTQm9NQUI4TVNZeGtTeEFFSkFQSUpBQUI4RldNT0Z0TWMvSGNYd3hoREFDN0RBdk9vd3dBZXd3SmRLREtIQUFIREFBTHJGVVFWd3dBYnd5dnpwV01Xdjh3QS9BQnBBeSsrYmNZRFVLUEQwS2hEQ3dLbUoxTUFBbU1BNStVWnd4QWFnd2lwQlJML2VBRGZ3NmZER09NQ0dzT2prM2w2QndPcG80c0FFc01PR3hNQUE1c0FiY01PQUF2RHAwTUpHa01Ed2dpcG5OSVBBd2ZJcVVNR0FPR0RBQVB6QUJYREFBY0RBQW5EQUdtVEFCckRBQTdEQ2hqRGpuRVdBd0FCWXdBT2N3QXVVeVlBQnNNQUY4TUlLUUFOVWdDNnd5NEFBOE1BRHFNcTh3Q3lZZ0FjSXdBQjh3cXBBQVhPQ3gwVjR3QUhvd0JDd3dFS0FHbkRBQXVEQUIzREFBakRDYWtBQmRJQWJxY1ozUUNaQ0NrQUJkSUFBQUZEQUFmakFCMmpDQ2tBQnFJQUNZTUFHek1BYlNNQTVzT0lBQWhqQUFoREFCVERCQWtwQUFiU0FPT1RBQWxEQzZrT3pQdG5BQWREQUc2a1FGQUFUd0FLd3d3QUEwTUFDYlVEUHdBSEl3QVpnd0FDRTZjREFBb2pBQXBEQUFvRHAvTUd3d0FKSXdBREV3QVFRd2dBRkVNQUVYTUFENU1BRGZNQURjTUFHUk1PRmlNQUZVTUFicU1XdXdIREFNSUFFME1MQUdrekVnRGhVd0FDUXdBRVdnQVhnd1VqQUFiWUFCakRCU1lCZ3pCYUFFRk5BTGNRQnhVTWVnQXdNbmdCckEwSVpnSjBLeFFIQlJFUGQxTjBaektSSndhSUhBWnFOVDREcVFxOEJ3bmdBQjREQXd0MkFYNTZUMW9jS1FOWEFoMUdBVFFHQzN0T3hZTmFna2dBTVFBNUNRQURBUUVBV3hMakFJT1lOQUV6QUg3dEZSazZUZ2xTQUY4TkFBbFlBUStTMUFDQVF3UW9yUUJpQU40ZEFKMXdQeWVUQU5WenVRRFgzQUllRU1wOWV5TWdYaVVBRWRrQmtKaXpLbHRiVlZBYVJNcVJBQUVBaHlRL1NERXo2Qm1mVndCNkFURXNPQ2xLSVJjRE9GMEUvODMyQUZOdDVBQnlBbmtDUnhHQ09zOTROalhkQXdJTkdCb25EQndQQUxXMkF3SUNBZ0FBQUFBQUFBWURCUU1EQVJyVUF3QXRBQUFBQWdFR0JnWUdCZ1lGQlFVRkJRVUVCUVlIQ0FrRUJRVUZCUVFBQUFJQ0FBQUFJZ0NOQUpBQWxUMEE2Z0M3QU53QXBFUUF3Z0N5QUswQXFBRHVBS1lBMmdDakFPY0JDQUVEQU1jQWdRQmlBTklBMUFFREFONEE4Z0NRQUtrQk1RRHFBTjhBM0FzQkNROHlPOXJhMnRxOHh1TFQxdFJKT0IwQlVnRmNOVTBCV2dGcEFXZ0JXd0ZNVVVsTGJoTUJVeHNORUFzNlBoTU9BQ2NVS3kwdk1qNUFRRU5EUTBSRkZFWUdKRmRYVjFkWldWaFpMMXBiWFZ4Y0kyTm5aMlpvWnlwc2JuWjFlSGg0ZUhoNGVucDZlbnA2ZW5wNmVucDhmSDE4ZTJJQVJQSUFTUUNhQUhnQU1nQm0rQUNPQUZjQVZ3QTNBbmJ2QUlzQUJmajRBR1FBay9JQW53QlBBR0lBWlAvL3NBQ0ZBSVVBYVFCV0FMRUFKQUMyQUlNQ1FBSkRBUHdBNXdEK0FQNEE2QUQvQU9rQTZRRG9BT1lBTHdKN0FWRUJRQUUrQVZRQlBnRStBVDRCT1FFNEFUZ0JPQUVjQVZnWEFERVFDQUVBVXg4U0hnc2RIaFlBamdDV0FLWUFVUUJxSUFJeEFIWUFid0NYQXhVREp6SURJVWxHVHpFQWtRSlBBTWNDVndLa0FNQUNsZ0tXQXBZQ2xnS1dBcFlDaXdLV0FwWUNsZ0tXQXBZQ2xnS1ZBcFVDbUFLZ0FwY0NsZ0tXQXBRQ2xBS1VBcFFDa2dLVkFuVUIxQUtYQXA4Q2xnS1dBcFVlQUlFVEJRRCtEUU9mQW1FQ09oOEJWQmc5QXVJWkVqTWJBVTQvRzFXWkFYdXNSQUZwWVFFRkEwRlBBUVlBbVRFZUlKZHlBREZvQUhFQU5nQ1JBNXpNay9DMmpHSU53ak1XeWdJWkNhWGRmRElMQkNzNWRBRTdZblFCdWdEbGhvaUhob2lHaVlxS2hvdU9qSWFOa0k2SWo0cVFpcEdHa29hVGhwU1NsWWFXaHBlS21JYVpocHFHbTRhY2k1MlFub3FmaHVJQzRYVHBBdDkwQUlwMExIU29BSXNBZEhRRVF3UkFCRUlFUlFSREJFa0VSZ1JCQkVjRVNRUklCRVFFUmdSSkFKNXVkQUNyQTQ5MEFMeHVBUTEwQU5GWmRIUUExM1FDRkhRQS9tSjBBUDRCSVFEK0FQd0EvQUQ5QVB3RGhHWjAzQVNNSzIzSEFQNEEvQUQ4QVAwQS9DUjBkQUNSWW5RQS9nQ1JBU0VBL2dDUkF2UUEvZ0NSQTRSbWROd0VqQ3R0eHlSMEFQOWlkQUVoQVA0QS9nRDhBUHdBL1FEOEFQOEEvQUQ4QVAwQS9BT0VablRjQkl3cmJjY2tkSFFBa1dKMEFTRUEvZ0NSQVA0QWtRTDBBUDRBa1FPRVpuVGNCSXdyYmNja2RBSkxBVDUwQWxJQlFYUUNVOGwwZEFKZmRIUURwZ0wwQTZZRHBnT25BNmNEcHdPbkE0Um1kTndFakN0dHh5UjBkQUNSWW5RQklRT21BSkVEcGdDUkF2UURwZ0NSQTRSbWROd0VqQ3R0eHlSMEJEaDBBSkVFT1FDUkRwVTVkU2dDQURSMDNnVjJDd0FyZEFFRkFNNWlDblIwQUYxaUFBWWNPZ3AwZEFDUkNuUUFYQUVJd1daMENuUm1kSFFBa1daMENuUm1kRVhnQUZGMDNncDBkRVkwdGxUMnUzU09BUVR3c2N3aGpaWktyaFljQlNmRnA5WE5iS2lWRE9EMmIrY3BlNC9aMTdtUW5idHp6aGFlUXRFMkdHajBJRE5UalJVU3lUeHh3L1JQSFcvK3ZTN2QxTmZSdDl6OVFQWmc0WDdRRmZoQ25rdmdOUElJdE9zQzJlVjZoUGFublpOSGxaOXhyd1pYSU1PbHUzalNvUVNxNzhXRWp3TGp3MUVMU2xGMWFCdmZ6d2s1Wlg3QVV2UXpqUFFLYkR1UStzbTR3Tk9wNEE2QWRWdVJTMHQxeS9EWnBnNFI2bTdGTmpNOUhndlc3Qmk4OHphTWpPbzZsTTh3dEJCZGo4TFA0eWx2M3pDWFBoZWJNS0pjMDY2bzlzRjcxb0ZXLzhKWHU4NkhKYndESUQ1bHp3NUdXTFIvTGhUMFFxbnAySlF4TlpOZmNiTEl6UHkrWXlwcVJtL2xCbUdtZXgrODIrUGlzeFV1bVNlSmtBTElUNnJKZXp4TUgrQ1RKbVF0dDV1d1RWYkwzcHRtakRVUXpsU0l2V2k4VGw3bmcxTnB1Um4xTmc0bjE0UWMrM0lpbDdPd2t2TldvZ0xTUGtuM3BpaElGeXR5SUdtTWhPZTNuMXRXc3VNeTlCZEt5cUY0WjN2MlNnZ2dUTDlLVnZNWFBuQ2JSZStvT3VGRlAzSGVqQkcvdzlndm1mTll2ZzZKdVdpYTJsY1NTTjF1SWpCa3R6b0lhek9IUEpaN2tLSFB6OG1SV1ZkVzNsQThXR0Y5ZFFGNkJtNjczYm9vdjNCVVdEVTJKTmNhaFIyM0d0ZkhLTE96L3ZpWityWW5aRmFJem5YTzY3Q1lFSjFmWHVUUnBaaFlaa0tlNTR4ZW9hZ2tOR0xzK05UWkhFMHJYNDUvWHZRMlJHQURYNnZjQXZkeElVQlYyN3d4R20yempabzRYM0lMZ0Fsck9GaGV1WjZ3dHN2YUlqNHlMWTdxcWF3bGxpYUljcnoyRytjM3ZzY0FuQ2tDdU16TW1adk1mdTlsTHdUdmZYKzNjVlN5UGROOVp3Z0RaaGZqUmdOSmNMaUo2N2I5eHg4Skhzd3ByYmlFM3Y5VXBob3RBUElnblhWSU41S21NYzBwaVhoYzZjQ2hQbk4rTVJoRzlhZHRkdHRRVFR3U0lwbDhJNC9qLy9kM3N6MTMyNnFUQlRwUFJNL0hnaDNrenFFWHM4WkFrNEVyUWhOTzhoenJRMERMa1dNQS9OKzkxdG4yTWRPSm5XQzJGQ1plaGtRcnd6d2JLT2podlpzYk05NVFvZUw5c2tZeU1mNHNyVlBWSlNnZzdwT0xVdHIvbjllVDk5b2U5bkx0RlJwakE5b2tWMktqOGg5azVIYUMwb2l2UkQ4VnlYa0o4MXRjZDRmSE5YUENmbG9JUWFzeHN1TzE4LzQ2ZFIyamd1bC9VSWV0Mkcwa1J2bnlPTk1LaEhzNkoyNkZFb3FTcWQrcmZZamVFR3dIV1ZEcFgxZmgxakJCY0tHTXFSZXBqdTlZMDBtRFZIQytYZGlqL2o0NHJLZnZmakdpbk5zMWpPLzBGM2pCODNYQ0RJTk4vSEI4NGF4bFArM0Uva2xrdFJvK3ZsM1UvYWl5TUpiSW9kRTFYU3NEbjZVQXpJb010VU9iWTIray80Z1kvbCtBa1pKNVNqMnZRcmt5TG0zRm94amhEWCszMVVYQkZmOVhyQUgzMWZGcW9CbURFWnZodnZwblo4N04rb1pFdTdVOU8vbm5rK1FXajN4OHV5b1JiRW5mK081VU1yOWkwbkhQMzhJRjVBdnpyQlc4WVdCVVIwbUlBekl2bmRRcTlOM3YvSnRvM2FQalBYVVBsOEFTZFBQeUFwN2pFTmY4Yms3Vk1NOW9sOVhHbWxCbWVETXVHcXQrV3p1TDZDWEF4WGpJaENQTTV2QUNjaGdNSi84WEJHTE8vRDFpc1Z2R2h3d0hIcjFETGFJNW1uMkpyL2IxcFVEOTB1Y2lEYVM4Y1hORHpDV3ZObVQvUGhRZTVlOG5Ubm5ua3Q4RHMvU0lqaWJjdW0vZnFEaEtvcHhBWThBa1NyUG4rSUdERUtPTytVM1hPUDZkakZzMkg1Tjkrb3JoT2FoaVFrNUtuRVVXYStDemtWemhwOGJNSFJiZzgxcWhqalh1SUtiSGpTTFNJQktXcW9ja0d0S2luWSt6NC9SZEJVRjZwY2MzSm1ubHhWY05nckk0U0V6S1VaU3djRDJRQ3l4ekt2ZStnQW1nNlp1U1JrcFBGYTZtZlRodTdMSk51M0g1SzQydUNwTnZQQXNvZWRvbEtWL0xIZS9lSitCYmFHNU1HME5hU0dWUFJVbU5GTUZGU1NwWEVjWHdiVmg3VUVUT1padG9WTlJHT0liYmtpZzNNY0V0UjY4Y0cwUlpBb0pldldZbzdEZy9sWjFDUXpibFdlVXZWSG1yOGZZNE5xZDlKSmlIL3pFWDI0bUp2aUg2MGZBeUZyMEEzYzRiQzFqM3laVTYwVmdKeFhuOEpnSlhMVUlzaUJubUttTVl6Kzd5QlFGQnZxYjJlWW51VzU5am9aQmY1Ni93WHZXSVI0Ujh3VG1WODBpMW1aeStTNCtCVUVTK2h6amswdVhwQy8vL3ovSWxxSFoxbW9uemxYcDhhQ2ZoR0tNdGk3M0ZJMUtiTDFxNklLTzRmdUJ1WjU5Z2Fnam41eFU3OW11TXBIWGc2UytlK2dETS9VOUJLTEhibDlsNm84Y3pRS2w0UlVrSkppcWZ0UUcyaTNCTWcvVFFsVVlGa0pEWUJPT3ZBdWdZdXpZU0RuWmJERGQvYVNkOXgwT2U2RitiSmNIZmw5K2dwNkw1L1RnQStCZEZGb3ZiZkNyUTQwczV2TVB3ODg2NnBOWDh6eUZHZUZXZHhJcFBWcDlSZzFVUE9WRmJGWnJ2YUZxL1lBekhRZ3FNV3BhaE1ZZnFIcG13WGZITDEva3BZbUd1SEZ3VDU1bVF1MGR5bGZOdXEyT3EwaFRNQ1B3cWZ4bnVCSVBMWGZjaTRZMUFOeSsxQ1VpcFF4bGQvaXpWaDE2V3lHMlEwQ1FROU5xdEFueDFIQ0h3RGo3c1l4T1NCMHdvcFpTbk96eFFPY0V4bXhyVlRGMkJrT3RoVnBHZnVoYUdFQ2ZDSnBKS3BqbmloWSt4T1QyUUp4TjYxKzlLNlFTcXR2MlNocjgySTNqZ0pycUJnMHdFTEZaUGp2SHB2elR0YUpuTEs2VmI5N1luOTMza29PL3NhTjdmc2p3Tkt6cDRsMmxKVngyb3JqQ0d6Qy80Wkw0ekN2ZXI2YVFZdEM1c2RveWNodUZFNnVmT2lvZytWV2k1VURrYm12bXRhaC8zYUFyRUJJaTM5czVJTFVubEZMZ2lsY0d1ejlDUXNoRVk3Zncyb3VvSUxBWVBWVC9neUFJcTNURkFJd1ZzbCtrdGtSei9xR2ZuQ0RHcm01Z3NsL2w5UWR2Q1dHc2pQejNkVTdYdXFLZmRVcnIvNlhJZ2pwNHJleTZBSkJtQ21VSk1qSVRIVmRGYjVtMXArZExNQ0w4dDU1ekQ0MmNtZnRtTEVKQzBEYTA0WWlSQ1ZVQkxMYThEMDcxL041VUJOQlhEaDBMRnNtaFYvNUI1RXhPQjRqM1dWRy9TM2xmSzVvK1Y2RUxIdnk2UlI5bjRhYytWc0s0VkU0eXBoUHZWK2tHOUZlZ1RCSDRaUlhMMkh5dFVIQ2R1SmF6Qi9LeWtqZmV0WXhPWFRMd3MyNjdhR09kK0krSmhLUC8vK1ZuWG1TOTBPRC9qdkxjVnUwYXN5cWN1WU4xbVNiNlhUbENrcXYxdmlnWlBJWXdORi96cFdjVDFHUi82YUVJUmpraDB5aGc0TFhKZmFHb2JZSlRZNEpJNThLaUFLZ21tZ0FLV2RsNW5ZQ2VMcWF2UkpHUU51WXVadFpGR3grSWtJNHc0TlMyeHdiZXROTXVuT2pCdS9obUtDSS93N3RmaWl5VWQvLzRyYlRlV3Q0aXpCWThZdkdJTjZ2eUtZbVAvOFg4d0hLQ2VOK1dSY0tNNzArdFhLTkd5ZXZVOUgyRGc1QnNsam5UZjhZYnNKMVRtTXM3NENlMlhsSGlzbGVndWh5ZWc0NHJRT0hadXcvNkhUa2hubnVySzJkNjJxNnlTNzIxMFNzQUlhUitqWE1RQStzdmtyTHBzVVkrRjMwVXc4OXVPZEdBUjZ2bzRGSU1FMEVmVlZlSFR1NmVLaWNmaFNxT2VYSmhiZnRjZDA4c1dFbk5VTDFDOWZucHJUZ2Q4M0lNdXQ4b25WVUYwaHZxelpmSGR1UGpiandFWEljb1lteStQNnRjSlpIbWVPdjZWcnZFZGtIREplY2pIdUhlV0FOZTc5Vkc2NjJxVGpBL0hDdnVtVnYzcUwrTHJPY3BxR3BzMlpHd1FkRko3UFU0aXV5UmxCcndmTyt4blB5cjQ3czJjWFZiV3pBeXpuRGlCR2pDTTNrc3hqanFNNjJHRTlDOGY1VTM4a0IzVmp0YWJLcC9uUmR2TUVTUEdERzkwYldSTEF0MVFrNUR5THVhelJSMVl6ZEMxYytoWlh2QVdWOHhBNzJTNEE4QjY3dmpWaGJiYTNNTW9wMjkzRmVFWHBlN3pJdE1XckpHL0xPSDlCeU9YbVluTkpmam1mdVg5S2JycGdMT2JhNG5aK2ZsOEdiZHYvaWh2KzZ3RkdLSENZclZ3bWhGQzBKM1YyYm4ydElCMXdDYzFDU1QzZDNYMk95eGhndVhjczRzbTY3OVVuZ3pvZnVTZUJld01GSmJvSVFIYlVoL20ySmhXMmhHOURJdkcydDd5Wkl6S0JUejl3QnRuTkMrMnBDUlloU0l1UTFqOHhzejVWdnFueVVJdGh2dW95eXU3Zk5JcmcvS1FVVm1HUWFxa3Faay9WeDViMzMvZ3NFczh5WDdTQzFKK05WNGljejZidklFN0M1RzZNY0JhSThyVmc1NnE1UUJKV3huLzg3UTFzUEs0K3NRYThmTFU1Z1hvNHBhYXE0Y09jUTR3UjBWQkhQR2pLaCtVbFBDYkExbkxYeUVVWDQ1cVo4SjcvTG40RlBKRTJUZHpEMFo4TUxTTlFpeWtNTW1TeU9DaUZmeTg0UnE2MGVtWUIydkQwOUtqWXdzb0lwZURjQkRURWxCYlh4TkQ3MnloZDlwQy8xQ01pZC81SFVNdkFMMjdPdGNJSkR6TktwUlBOcVBPcHl0MmFQR3o5UVdJczloUTlMaVg1czhtOWhqVFV1L2Y3TXlJYXRqamQrdFNmUTN1Zlp4UHBtSmhUYUJ0WnRLTFVjZk9DVXFBRHVPK1FvSDhCOXY2VStQMEhWMUdMUW10b05GVGIzczc0aXZaZ2pFUzBxZksrOFJkR2dCYmNDTVN5OGVCdmg5OCtldDFLSUZxU2UxS1FQeVhVTEJNVHNJWW55c0l3aVpCSllkSTIwdnNlVit3dUprY3FHZW1laEtqYUFiOUw1N3habTNnMnpYMGJaMnhrL2ZVK2JDbzdUbG5iVzdKdUYxWWRVUm8vMkd3N1ZjbERHMVc3TE90YXMyTFg0dXBpZlovMjNyenBzblkvQUxmUmdyY1dQNWhZbVY5VnhWT1FBMWZadnA5RjJVTlUrN2Q3eFJ5Vm01d2lMcDMvMGRsVjd2ZHcxUE1pWnJiREFZeklWcUVqUlkyWVUwM3NKaFBubHdJUGNaVUc1bHRMNlM4WEN4VTFlWVM1Y2pyMzR2ZUJtWEF2eTd5TjRaakFySUcwZGZELzVVcEJObFgxWlBveEpPd3lxUmkzd1FXdE96ZDRvTktoMExrb1RtOGN3cWdJZktocXFHT2h3bzcxSSt6WG5NZW1UdjJCMkFVekFCV3lGenRHZ0dVTGpERHpXWXdKVVZCVGpLQ241SzJRR01LMUNRVDdTenppT2pvK0JoQW1xQmp6dWMzeFl5bTJlZWRHZU9JUkpWeVR3RHczN2lDTWU0ZzVWYm5zYjVaQmR4T0FuTVQ3SFU0REhweFdHdVE3R2VpWTMwQ3BidnpzczU1KzVLbTFZc2JENWVhM05JOVFOWUlYb2w1YXBnU3U5ZFo4Zjh4UzVkdEhwaWRvNUJjbER1TFdZNGxoaWswdGJKYTA3eUpoSDBCT3lFdXQvR1JiWVRTNlJmaVRZV0dNQ2tOcGZTSGk3SHZkaVRnbEVWSEtaWGFWaGV6SDRra1hpSXZLb3BZQWxQdXNmdHBFNGE1SVp3dncxeC9lTHZvREloL3pwbzlGaVFJbnNUYjJTQWtLSFY0MlhZQmpwSkRnNDM3NFhpVmIzd3M0cU0wczllU1E1SHpzTVU0T1pKS3VvcEZqQk0rZEFaRWw4UlVNeDV1VTJONDg2S3IxNDF0VnNHUWZHak9SWU1DSkFNc3hFTGVOVDRSbVdqUmNwZFRHQndjeDZYTjlkcldxUG1KemNyR3JINCtEUmM3K24xdzNrUFp3dTBCa05yNmhRcnFnbzdKVEI5QTVrZEovSDdQNGNXQk13c211aXhBekpCM3lyUXBuR0lxOTBseEFYTHpEQ2RuMUxQaWJzUnQ3ckhOamdRQmtsUmdQWjh2VGJqWGRnWHJUV1FzSzVNZHJYWFFWUHAwUmlucTNmcnpaS0owcUQ2UWhjNDBWekFyYVVYbG9iMWd2a2hLM3ZwbUhnSTZGUmxRWk54NmVScWtwMHp5NEFRbFg4MTNmQVB0TDNqTVJhaXRHRkZqbzB6bUVybG9DK2grWVlkVlE2azRGL2VweEFvRjBCbXFFb0tOVHQ2ajR2UVpOUTJCb3FGOVZqNTNUT0lvTm1EaXU5WHAxNVJrSWdRSUdjb0xwZm9JYmVuenBHVUF0cUZKcDVXK0xMbngzOGpIZUVDVEovbmF2S1kxTldmTjBzWTFUOC9wQjhrSUgzRFUzRFgrdTZXM1l3cHlwQk1ZT2hiU3hHanE4NFJaODRmV0pvdzhweUhxbjRTLzlKMTVFY0NNc1hxcmZ3eWQ5bWhpdTMrckVvOXBQcG9Ka2RacUhqcmE0TnZ6Rnd1VGhOS3k2aGFvL1NsTHczWkFEVWNVcDN3M1NSVmZXMnJobDgwek9nVFluS0UwSHMycXAxSjZIM3hxUHFJa3ZVRFJNRkRZeVJic0ZJM005TUV5b3ZQazhybHc3LzBhODFjRFZMbUJzUjJ6ZTJwQnVLYjIzZmJlWkMwdVhvSXZEcHBmVHdJRHhrMU9xMmRHZXNHYytvSlhXSkxHa09oYTNDWCtEVW56Z0FwOUhHSDlSc1BaTjYzSG40Uk1BNWVTVmhQSE8rOVJjUmIvSU9ndFczMVYxUTVJUEd0b3hQakMrTUVKYlZsSU1ZQURkOWFIWVdVSVFLb3B1UE9IbW9xU2t1Ym5BS256Z0tIcWdJT2ZXNVJkQWdvdE42Qk4rTzJaWUhrdWVtTG52UThVOVRIVnJTMVJ0TG1LYmNDN1BlZURzWXpudnF6ZWc2VkNOd21yMFl5eDF3bkxqeVQ4NEJaejNFSnlDcHREM3lldWVBeURXSXMwTDJxcy9WUTNIVXlxZnJqYTBWMUxkRHpxQWlrZVd1VjRzYzdSTElCNjlqRUlCakNreVplZG9VSHFDck92U2hWenlkNzNPZHJKVzBoUE91UXYycU9vSERjOXhWYjZZdTZ1cTNYcXAyWmFINDZBN2x6ZXZieFFFbWZyenZBWVNKdVo0V0RrMUh6M1FYMUxWZGlVSzBFdmxBR0FZbEczTWQzMHI3ZGNQTjYzeXFCQ0lqMjVwcnB2WlAwbkk0K0VnV29GRzk1VjU5NkN1clhwS1JCR1JqUWxIQ3Z5NUliL2lXOG5aSld3ckVUM21nZDZtRWhmUDRLQ3VhTGpvcFdzN2grTWRYRmRJdjhkSFFKZ2cxeGkxZVlxQjB1RFlqeHdWbXJpMFN2NVhLdXQvb25xYXBDK0ZRaUMyQzFsdllKOU1WY282eURZc1MzQUFOVWZNdHZ0YllJMmhmd1phdGlTc25vVWVNWmQzNEdWamtNTUtBK1huakpwWGdSVzJTSFRacGxWb3dQbUpzdlh5NnczY2ZPMUFLMmR2dFpFS1RrQy9UWTlMRmlLSENHMERuck1RZEdtMmx6bEJITTlpRVl5bkgyVWNWTWhVRWpzYzBvREJUZ28yWlNRMWd6a0FIZVdlQlhZRmpZTHV1Zjh5elRDeTcvUkZSODFXRGpYTWJxMkJPSDVkVVJueG82b2l2bXhMM2NLektJbmxaa0QzMW52cEhCOUtrN0dmY2ZFMXQrMVY2NGI5THRnZUpHbHBSRnhRQ0FxV0o1RG9ZNzdza2k4Z3NPRU9yMnV5d1phb08vTkdhMFgweTFwTlFIQmkzYjJTVUdOcGNaeERUN3JMYkJmMUZTblE4Z3V4R1czVyszNkJXMGdCamU0RE96NkJhNlNWazB4aUtndCtxMkpPRnlyNFNZZm51K0ljMVFaWUl1d0hCcmd6cjZVdk9jU0N6UFRPbzdENklDNElTZVM3emtsNGgrMlZvZUhwbkcvdVdSMyt5c05nUGNPSVhRYnYwbjRtcjNCd1FjZEtKeGdQU2V5dVAvejFKamc0ZTluVXZvWGVncVFWSUUzMEVIeDVHSHYrRkFWVU5Ub3dZREpneUZoZjVJdmxZbUVxUmlmNitXTjFNa0VKbURjUUlUeDlGWDIzYTRteHkxQVFSc09ITy8rZUltWDlsOEVNSkkzb1BXelZYeFNPZUhVMWRVV1lyMnVBQTdBTWIrdkFFWlNiVTNxb2I5aWJDeVhleXBFTXBaNjg2M282UVBxbHFHSFprdVdBQlNUVk5kNGNPaDlodjNxRXBTeDJaeS9ESk1QNmNJdEVtaUJKNVBGcVFuREVJdDNOckEzQ09sT1NnejQzRDdncE5GTko1TUJoNG9GemhEUGlnbEMyeXBzTlU0SVN5d1kyZXJreWIxTkMzUWgvSWZXajBlRGdaSTQvbG44V1BmQnNUM21lVGpxMVVxdDFFN1psL3FmdHFreDZhTTlLdWVNQ2VrU25NcmNIajFDcVRXV3pFelBzWkdjRGUzVWU0V3MrWEZZVnhOYk9GRjhlemt2UUdSNlpPdE9MVTJsUUVuTUJTdHg0N3ZFNlBiN0FZTUJSajJPT2ZaWGZpc2pKbnBUZlNOam82c1o2cVN2TnhaTm1EZVM3R2szeVl5Q2sxSHRLTjJVbmhNSWpPWFV6QXFEdjkwbHg5Ty9xL0FUMVpNbml0NVhRZTl3bVF4bkUvV1NIMENxWjkvMkh5K1NmbXBlZzhSd3NISTVaOGtDOEgyOTNtL0xIVlZNL0JBN0hhVEpZZzVFbms3TS94V3BxMDE5MkFDZkJhaTJMQS9xckNqQ3I2RGgxQklNek1YSU5CbVg5Nk1KNUhuMm54bG4vUlhQRmh3SHhVbVNWMEVWMlYwam04Ni9keHh1WVNVMVc3c1ZrRWJOOUV6a0cwUUZ3UGh5SEt5YjN0K0ZqNVdvVVVURXJjYXpFL042RVc2THZwMGQvL1NEUGo3RVY5VWRKTitBbW5mM1d3azNBMFNsSjlaMDB5dlhaN24zejcwRzQ3SGZzb3c4V3ExSlhjZnduQStZeGE1bUZzZ1Y0NjRLS1A0VDMxd3FJZ3pGUGQzZUNlM2o1b3J5NWZCRjJoZ0NGeVZGckx6STllZXROWHZNN29RcXlGZ0RvNENUcC9oRFY5Tk1YOUpESFEvbnlIVEx2WkxOTEY2ZnRuMk94akdtOCtQcU93aHhuUEhXaXBrRS84d2J0eXJpODBTcjdwTU5rUUdNZm80WllLOU9jQ0M0RVNWRkZiTE1Jdmx4U29ScVdpZTB3eHFuTGZjTFNYTVNwTU1RRUpZRFZPYllzWElRTnY0VEdOd2pxMWt2VDFVT2tpY1RyRzNJYUJaM1hkU2NTM3U4c2dlWlBWcE9Ma2JpRjk0MEZqYkNlTlJJTk52RGJkMDFFUEJyVENQcG0xMm00M3plMWJCQjU5SWE2T3ZobnVyL052eDNJeHdTV29sKzNIMnFmQ0pSOGRmNmFRZjR2NldpT054a0srSXFUNHBLUXJaSy9McGxnREkvUEpaYk9lcDhkdGJWN29DcjZDZ2ZwV2E4TmN6T2tQeDgxaVNIYnNOaFZTSkJPdHJMSU1yTDMxTEs5VHFIcUFiQUhlMFJMbW1WODA2a1JMRExORWhVRUpmbTl1MHN4cGtMOTNaZ2Q2cncrdHFCZlRNaTU5eHFYSExYU0h3U2JTQmwwRUswK2xvRUNPUHRybCsvbnNhRmUxOTdkaTR5VWdvZTRqS29BSkRYYzZER0RqclFPb0ZEV1pKOUhYd3Q4eERyUVArN2FSd1dLV0kxR0Y4czhPNEt6eFdCQmN3bmwzdm5sMU9lejNvaDZFYTF2alI3L3o3RERUckZ0cVUyVy9LQUV6QXVYRE5aN01ZNzNNRjIxNmR6ZFNiV21VcDRsY203a2VKZldhTUhndXQ5eDVDOW1qNjZaMGxKK3loc2pWdnlpV3JmazFselBPVGRoRzE1WTdnUWxYdGFjdkk3cXYvWE5Tc2NEd3FrZ3dIVC9nVXNENXlCN0xkUlJ2SnhRR1lJTm45aFRwb2RLRlZTVFBydEd2eVF3K0hsUkZYSWtvZEVyQUd1OUl5MVlwZlNQYzNqa0ZoNUNYM2xQeHY3YXFqRS9KQWZUSXBFakdiL0g3TU8wZTJ2c1ZpU1cxcWEvTG1pNC9uNERFSTNnN2xZcmNhbnNwRGZFcEtrZFYxT2pTTE95MEJDVXFWb0VDYUI1NXZzMDZyWGw0anFtTHNQc0ZNLzd2WUowdnJCaERDbS8wMEEvSDgxbDF1ZWtKLzZMbWwzSGI5K05LaUxxQVRKbURweXpmWVpGSHVtRWpDNjYyTDBCd2t4aTdFOVU0Y1FBMFhNVkR1TVlBSWVMTVBnUWFNVk9kOGZtdDVTZmxGSWZ1Qm9zemVBdzdvdzVnWFBFMlkveUJjLzdqRXhBUlVmL0J4SUhRQkY1U24zaTYxdzR6NXhKZEN5TzFGMVgzKzNheCtKU3ZNZVo3UzZRU0twMUZwL3NqWXo2WitWZ0NaemliR2VFb3VqcnlmTXVsSDdSYWk1a0FmdDllYmNXNTBEeUpyMnVvMno5N21UV0l1NDVZc1NuTlNNcnJOVXVHMVhzWUJ0RDlURFl6UWZmS0I4N3ZXYmtNNEViUEFGZ29CVjRHUVMrdnRGRFVxT0ZBb2kxblR0bUlPdmczOE40aFQyU244cjhjbG1CQ1hzcEJsTUJZVG5ycUZKR0JUM3daT3pBeUpEcmU5ZEhINyt4N3FhYUtET0I0VVFBTEQ1ZWNTMERFNG9idWJRRWl1SlowRXBCVnBMdVljY2U4QWE0UFlkL1Y0RExEQUpCWUtRUENXVGNyRWFaNUhZYkppMTFHZDZoakdvbTFpaTE4VkhZbkcyOE5LcGt6MlVLVlB4bGhZU3A4dVpyMzY3aU9tb3k3enN4ZWhXOXd6Y3kyekcwYTgwUEJNQ1JRTWIzMmhuYUhlT1I4Zm5ORHpaaGFOWWhrT2REc0JVWjNsb0RNYTFZUDB1UzBjalVQM2IvNkRCbHFtWk9lTkFCRHNMbDVCSTVRSnVwczh1eEF1V0pka1VCL3BPNlpheDZ0c2c3Zk41bWpqRGdNR25nTytEUGNLcWlISURiRklHdWR4dFBUSXlEaTlTRk1LQkRjZmRHUVJ2NDFxMUFxbXhna1ZmSk1uUDh3L0JjN045L1RSNkM3bUdPYkZxRmtJRW9tOHNLaTJ4WXFKTFRDSEs3Y3h6YVp2cU9EbzIyYzN3aXNCQ1A0SGVBZ2NSYk5QQXNCa05SaFNtRDQ4ZEh1cGRCUnc0bUl2dFM1b2VGNnplVDFLTUN5aE1ubWhwa0ZBR1duR3Njb05rd3ZROFpNNWxFL3ZnVEhGWUw5OU91TnhkRkJ4VEVEZDV2MnFMUjh5OVdrWHNXZ0c2a1pObmRGRytwTy9VQWtPQ2lwcUloTDNocTdjUlNkckNxN1loVXNUb2NFY25hRmE2blZraG5TZVJZVUExWU8wejVpdEY5U2x5M1ZseFlEdzIzOVRKSkg2ZjNFVWZZTzVsYjdiY0ZjejhCcDdPbzhRbW5zVUhPei9mYWdWVUJ0S0V3MWlUODhqK2FLa3Y4Y3NjS05rTXhqWXI4MzQ0RDFrRm9aNy90ZDFXNkxDTllONTk0MzAxdFVHUm1GakF6ZVJnNXZ5b00xRjYrYkpaL1E1NGpOL2s4U0ZkM0R4UFRZYUFVc2l2c0JmZ1RuN014OEgyU3BQdDRHT2RZUm5FSk9INmpITTJwNlNnQjBneklScTZmSHhHTW1TbXFhUENtbGZ3eGl1bG9hVklpdExHTjh3aWUyQ0RXaGt6TG9DSmNPRGg3S0lPQXFiSEV2WGRVeGFTNFRUVHMwN0NsemovNkdtVnM5a2laRGVyTXhFbmhVQjZRUVBsY2Zxa0c5ODgyUnFIb0xpSEdCb0hmUXVYSXNBRzhHVEF0YW8yS1Z3Um52dmFtOGpvMWUzMTJHUUFLV0VhNHNVVkVBTUc0RzZja2NPTkR3UmNnMWUyRDMrb2hYZ1k0VUFXRjh3SEtRTXJTbnpDZ2ZGcHN4aCthSFhNR3RQUXJvUWFzUlk0VTZVZEcwcnoxVmpia2EwTWVrT0dSWlFFdnFRRmx4c2VGb3I4eldGZ0hlazN2MjkrV3FONmdhSzVnWk9UT01aenBRSUMxMjAxTGtNQ1hpbGQzdldYU2M1VVg5eGNGWWZiUlB6R0ZhMUZEY1BmUEIvalVFcS9GZUd0NDE5Q0kzWW1CbFZvSHNhNEtkY3dRUDVaU3dISGhGSjcvUGgvUmFwLzR2bUc5MWVEd1BQMGxEZkNEUkNMc3pUcWZ6TTcxeHBtaUtpMkh3UzRXbHF2R053dHZ3RjVEcXBuNktUcThheDAwVU1Qa3hEY1pyRUVFc0l2SGlVWFhFcGhkYjRHQjRGeW1sUHdCejRHcGVycXE1cFc3VFE2L3lOUmhXOFZUNU5odVAwdWRseG80Z0lMcTVaeEFaazhaR2gzZzRDcXhKbFBLWTdBUXh1cGZVY1ZwV1Q1Vkl0cDErMzBVcW95UDR3V3NSbzNvbFJSZ2tXWloyWk42VkMzT1pGZVhCOE5iblVyU2Rpa05wdEQxUWlHdUtrcjhFbVNSL0FLOVJ3K0ZGM3M1dXd1UGJ2SEdpUGVGT1ZpbHRNSzdBVWFPc3E5K3g5Y25kazNpSkVFNUxLWlJsV0piS09ad2VST3ptUE5WUGtqRTNLL1R5QTU3UnM2OFRrWjNNUjhha0twbTdjRmpualBkL0Rka1dqZ1lvS0hTcjVXdTVzc29CWVU0YWNSczVnMkRIeFVtZHE4VlhPWFJidW5EOFFOMExoZ2tzc2dhaGNkb1lzTnZ1WEdVSy9LWEQvN29GYitWR2RocUluMDJ2ZXVNNWJMdWRKT2MyS3kwR01hRzRXL3hXQnhJSmNMN3lsaUpPWE9weDBBa0JxVWd6bERjem1MVDRpSUxYRHh4dFJSMW9aYTJKV0ZnaUFiNDNvYnJKbkcvVFpDMktTSzJ3cU96UlpUWGF2WlpGTWIxZjNiWHZWYU5hSzgyOHc5VE82MTBnazhKTmYzZ01mRVR6WFhzYmN2UkdDRzlKV1FaNitjRFBxYzQ0NjZZbzJSY0tIK1BJTGVLT3F0bmxiSW5SM01tQmVHRzNGSDEweXpreWJ1cUVDMkhTUXdwQTBBbjdkOSs3M0JrRFVUbTMwYlptb1AvUkdiZ0ZOK0dyQ09mQURncXIwV2JJMWExb2twRm1zOGlIWXc5aG0welV2bEVNaXZCUnhNb2RyYkpKKzkvcDNqVWRRUTlCQ3RRZHhuT0dyVDVkelJVbXcwNTkzL21iUlNkQmcwblJ2UlpNNS9FMTZtN1pIbURFdFdod3ZmZFpDWjhKOE0xMlcweVJNc3pYYW1XZlFUd0laNGF5WWt0cm5zY1F1V3I4aWRwM1BqVDJlRi9qbXRkaElmY3BNbmIrSWZaWTJGZWJXNlVZL0FLM2pQNHUzVHU0ekU0cWxuUWdMRmJNMTlFQklzTmY3S2hqZGJxUS9ENnlpRGIrTmxFaTJTS0QraXZYVlVLOGliMG9CbzM2NmdYa1I4WnhHanBKSURjRWdaUGE5VGNZZTBUSWJpUGwvclBVUUR1M1hCSjlYL0dOcTNGQVVzS3NsbDU3RHphR01yamNUK2djdHArOU1MWVhDcStzcVA4MWVWUTByOWx0K2djUWZaYkFDUmJFanZsTXNrenRaRzhnYkM4UW45dHQyNlE3eTduRHJiWnEvTEV6N2tSNkpjNnBnM045clZYOFk1TUpyR2xNTDlwOWxVNGpiVGtLcUN2ZWVaVUpqSEIwM20yS1JLUjJUeXRvRmtUWE9MZzdrZVUxczFsclBNUUpwb09LTHVBQUMreTFIbEp1Y1U2eXNCNWhzWGh2U1BQTHE1SjdKdG5xSEtaNHZZakM0Vnk4MTUzUVkrNjc4MHhEdUdBUnNHYk9zMVdxekgwUVM3NjVyblNLRWJiS2xrTzhvSS9WRHdVZDBpczEzdEtwcUlMdTFtREpGTnkvaUpBV2N2RGdqeHZ1c0lUK1BHejNTVC9KOXI5TXRmZDBqcGFHZWlMWUlxWGM3RGlIU1M4VGNqRlZrc2k2NlBFa3hXMXo2dWpiTExVR05OWW56T1dwSDhCWkdLNGJDSzdpUitNYkl2OG5jREF6MXU0U3ROM3ZUVHpld3I5SVFqazl3eEZ4bis2TjFkZEtzMHZmZkppUzA4TjNhNEcxU1ZybFo5N1EvTSs4RzlmZTVBUDZkOS9RcTRXUm5PUlZob2ZQSUtFZENyM2xsc3BVZkUwb0tJSVlvQnlCUlBoK2JYMUhMUzNKV0dKUmhJdkUxYVc0TlRkOGVQaTRaK2tYYitaOHNuWWZTTmNxaWpoQWdWc3g0UkNNNTRjWFVpWWtqZUJtbUM0YWpPSHJDaG9FTHNjSkpDNys5ampNanc1QmFnWktsZ1JNaVNOWXo3aDd2dlpJb1FxYnRRbXNwYzBjVWsxRy83M2lYdFNwUk9sNXd0TGdRaTBtVzJFeDhpM1dVTGhjZ2d4NkUxTE1WSFVzZGM5R0hJMVBIM1UyS28wUHlHZG45S2RWT0xtN0ZQQnVpMGk5YTBIcEE2ME1zZXdWRTR6OENBdDVkNDAxR3Y2elhsSVQ1WWJpdDFWSUEwRkNzN3d0dllyZXJ1MWZVeVczb0xBWi8rYVRuWnJPY1lSTlZBOHNwb1J0bFJvV2Zsc1JDbEZjZ3prcWlIT3JmMC9TVncrRXBWYUZsSjBnNEt4cTFNTU9taVFkcE1OcHRlOGxNTVFxbTZjSUZYbG5HYmZKbGx5c0tEaSswSkpNb3RrcWdJeE9TUWdVOWRuL2xXa2VWZjhuVW0zaXdYMk5sM1dEdzlpNkFVSzN2QkFiWlpyY0pwRFEvTjY0QVZ3alQwN0plZjMwR1NTbXROdTJXbFc3WW95VzJGbFdmWkZRVXdrODY3RWRMWUtrOVZHNkpnRW5CaUJ4a1k3TE1vNFlMUUpKbEFvOWwvb1R2SmtTQVJERi9YdHlBek04TzJ0M2VUL2lYYTZ3RE4zV2V3Tm1RSGRQZnN4Q2hVL0t0TEcyTW44aTRacUtkU2xJYUJaYWR4Sm1SelZTL280eUE2NVJUU1ZpcTYwb2EzOTVMcXcwcHpZNFNpcHdFMFNYWHNLVitHWnJhR1Nrci9SVzA4d1BSdnF2U1VrWUJNQTlsUHg0bTI0YXorSUhtQ2JYQSswZmF4VFJFOXd1R2VPMDZESVhhNlFsS0ozcHVJeWl1QVZmUHI3MzZ2em8ycEJpclMrVnhlbDNUTW0zSktoejlvMlpvUnZhRlZwSWt5a2IwSGNtNG9IRkJNY05TTmo3LzRHSnQ0M29nb25ZMlZnNG5zRFFJV3hBY29ycFhBQ3pnQnFRUGpZc0UvVlVwWHB3Tk1hbkVydTROd01DRlBrWHZNb3F2b2VMTjNxeXUvTjFlV0VIdHRNRDY1djE5bC8wa0gybVIzNWl2L0ZJK3lqb0hKOWdQTXo2N2FmM01xL0JvV1hxdTNycGhpV01YVmttblBTRWtwR3BVSTJoMU1UaGlkZUdGRU9LNllaSFB3WXpNQnZwTkM3K1pIeFBiN2VwZmVmR3lJQjRKek85RFRORVluRExWVkhkUXl2T0VWZWZyazZVdjVrVFFZVllXV2RxcmRjSWw3eWxqd3dJV2RmUS95KzJRQjNlUi9xeFlPYnVZeUI0Z1RibzJpbjRQemFyVTFzTzluRVRrbWo5L0FveERBK0pNM0dNcVF0SlI0anRkdUh0bm9DTHhkMWdRVXNjSFJCL01vUllJRXNQMnBEWjlLdkhndGxrMWlUYldXYkhob2h3RkVZWDd5NTFmVVYybnVVbW5vVWNxbldJUUFBZ2w5TFRWWCtCYzBRR05FaENoeEhSNFlqZkU1MVBVZEdmc1NGRTZjazdCTDMvaFRmOWpMcTRHMUlhZklOeE9MS2VBdE83cXV1bFl2SDVZT0JjK3pYN0NyTWdXblc0Ny9qZlJzV25KallZb0U3eE1mV1YySE4yaXlJcUxJJztcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTk3NGI2Zjg1NDFmYzI5ZDkxOWJjODUxMThhZjBhNDQwMTU4NTFmYWI1MzQzZjg2NzljYjMxYmUyYmRiMjA5ZVxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbmZ1bmN0aW9uIGluaXQkMSgpIHtcclxuXHQvL2NvbnNvbGUudGltZSgnbmYnKTtcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQpO1xyXG5cdFNISUZURURfUkFOSyA9IG5ldyBNYXAocmVhZF9zb3J0ZWRfYXJyYXlzKHIpLmZsYXRNYXAoKHYsIGkpID0+IHYubWFwKHggPT4gW3gsIChpKzEpIDw8IDI0XSkpKTsgLy8gcHJlLXNoaWZ0ZWRcclxuXHRFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcblx0REVDT01QID0gbmV3IE1hcCgpO1xyXG5cdFJFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRmb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRcdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRsZXQgW2EsIGJdID0gY3BzO1xyXG5cdFx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRidWNrZXQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1Y2tldC5zZXQoYiwgY3ApO1xyXG5cdFx0fVxyXG5cdFx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG5cdH1cclxuXHQvL2NvbnNvbGUudGltZUVuZCgnbmYnKTtcclxuXHQvLyAyMDIzMDkwNTogMTFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0aWYgKCFTSElGVEVEX1JBTkspIGluaXQkMSgpO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFTU9KSV9MSVNULm1hcCh4ID0+IHguc2xpY2UoKSk7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHModG9rZW5zX2Zyb21fc3RyKGV4cGxvZGVfY3AobGFiZWwpLCBuZiwgZmlsdGVyX2ZlMGYpLmZsYXQoKSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KG5hbWUsIG5mYywgZmlsdGVyX2ZlMGYpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgbGFiZWxzID0gc3BsaXQobmFtZSwgbmZjLCB4ID0+IHgpOyAvLyBlbW9qaSBub3QgZXhwb3NlZFxyXG5cdGZvciAobGV0IHt0eXBlLCBvdXRwdXQsIGVycm9yfSBvZiBsYWJlbHMpIHtcclxuXHRcdGlmIChlcnJvcikgYnJlYWs7IC8vIGZsYXR0ZW4gd2lsbCB0aHJvd1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgYXJyYXlfcmVwbGFjZShvdXRwdXQsIDB4M0JFLCAweDM5RSk7XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlfcmVwbGFjZSh2LCBhLCBiKSB7XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgbmV4dCA9IHYuaW5kZXhPZihhLCBwcmV2KTtcclxuXHRcdGlmIChuZXh0IDwgMCkgYnJlYWs7XHJcblx0XHR2W25leHRdID0gYjsgXHJcblx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0LCA2MykpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydHMuZW5zX2JlYXV0aWZ5ID0gZW5zX2JlYXV0aWZ5O1xuZXhwb3J0cy5lbnNfZW1vamkgPSBlbnNfZW1vamk7XG5leHBvcnRzLmVuc19ub3JtYWxpemUgPSBlbnNfbm9ybWFsaXplO1xuZXhwb3J0cy5lbnNfbm9ybWFsaXplX2ZyYWdtZW50ID0gZW5zX25vcm1hbGl6ZV9mcmFnbWVudDtcbmV4cG9ydHMuZW5zX3NwbGl0ID0gZW5zX3NwbGl0O1xuZXhwb3J0cy5lbnNfdG9rZW5pemUgPSBlbnNfdG9rZW5pemU7XG5leHBvcnRzLmlzX2NvbWJpbmluZ19tYXJrID0gaXNfY29tYmluaW5nX21hcms7XG5leHBvcnRzLm5mYyA9IG5mYztcbmV4cG9ydHMubmZkID0gbmZkO1xuZXhwb3J0cy5zYWZlX3N0cl9mcm9tX2NwcyA9IHNhZmVfc3RyX2Zyb21fY3BzO1xuZXhwb3J0cy5zaG91bGRfZXNjYXBlID0gc2hvdWxkX2VzY2FwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohIE1JVCBMaWNlbnNlLiBDb3B5cmlnaHQgMjAxNS0yMDIyIFJpY2hhcmQgTW9vcmUgPG1lQHJpY21vby5jb20+LiBTZWUgTElDRU5TRS50eHQuICovXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0FFU19rZXksIF9BRVNfS2QsIF9BRVNfS2U7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFFUyA9IHZvaWQgMDtcbi8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuY29uc3QgbnVtYmVyT2ZSb3VuZHMgPSB7IDE2OiAxMCwgMjQ6IDEyLCAzMjogMTQgfTtcbi8vIFJvdW5kIGNvbnN0YW50IHdvcmRzXG5jb25zdCByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuLy8gUy1ib3ggYW5kIEludmVyc2UgUy1ib3ggKFMgaXMgZm9yIFN1YnN0aXR1dGlvbilcbmNvbnN0IFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5jb25zdCBTaSA9IFsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZW5jcnlwdGlvblxuY29uc3QgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5jb25zdCBUMiA9IFsweGE1YzY2MzYzLCAweDg0Zjg3YzdjLCAweDk5ZWU3Nzc3LCAweDhkZjY3YjdiLCAweDBkZmZmMmYyLCAweGJkZDY2YjZiLCAweGIxZGU2ZjZmLCAweDU0OTFjNWM1LCAweDUwNjAzMDMwLCAweDAzMDIwMTAxLCAweGE5Y2U2NzY3LCAweDdkNTYyYjJiLCAweDE5ZTdmZWZlLCAweDYyYjVkN2Q3LCAweGU2NGRhYmFiLCAweDlhZWM3Njc2LCAweDQ1OGZjYWNhLCAweDlkMWY4MjgyLCAweDQwODljOWM5LCAweDg3ZmE3ZDdkLCAweDE1ZWZmYWZhLCAweGViYjI1OTU5LCAweGM5OGU0NzQ3LCAweDBiZmJmMGYwLCAweGVjNDFhZGFkLCAweDY3YjNkNGQ0LCAweGZkNWZhMmEyLCAweGVhNDVhZmFmLCAweGJmMjM5YzljLCAweGY3NTNhNGE0LCAweDk2ZTQ3MjcyLCAweDViOWJjMGMwLCAweGMyNzViN2I3LCAweDFjZTFmZGZkLCAweGFlM2Q5MzkzLCAweDZhNGMyNjI2LCAweDVhNmMzNjM2LCAweDQxN2UzZjNmLCAweDAyZjVmN2Y3LCAweDRmODNjY2NjLCAweDVjNjgzNDM0LCAweGY0NTFhNWE1LCAweDM0ZDFlNWU1LCAweDA4ZjlmMWYxLCAweDkzZTI3MTcxLCAweDczYWJkOGQ4LCAweDUzNjIzMTMxLCAweDNmMmExNTE1LCAweDBjMDgwNDA0LCAweDUyOTVjN2M3LCAweDY1NDYyMzIzLCAweDVlOWRjM2MzLCAweDI4MzAxODE4LCAweGExMzc5Njk2LCAweDBmMGEwNTA1LCAweGI1MmY5YTlhLCAweDA5MGUwNzA3LCAweDM2MjQxMjEyLCAweDliMWI4MDgwLCAweDNkZGZlMmUyLCAweDI2Y2RlYmViLCAweDY5NGUyNzI3LCAweGNkN2ZiMmIyLCAweDlmZWE3NTc1LCAweDFiMTIwOTA5LCAweDllMWQ4MzgzLCAweDc0NTgyYzJjLCAweDJlMzQxYTFhLCAweDJkMzYxYjFiLCAweGIyZGM2ZTZlLCAweGVlYjQ1YTVhLCAweGZiNWJhMGEwLCAweGY2YTQ1MjUyLCAweDRkNzYzYjNiLCAweDYxYjdkNmQ2LCAweGNlN2RiM2IzLCAweDdiNTIyOTI5LCAweDNlZGRlM2UzLCAweDcxNWUyZjJmLCAweDk3MTM4NDg0LCAweGY1YTY1MzUzLCAweDY4YjlkMWQxLCAweDAwMDAwMDAwLCAweDJjYzFlZGVkLCAweDYwNDAyMDIwLCAweDFmZTNmY2ZjLCAweGM4NzliMWIxLCAweGVkYjY1YjViLCAweGJlZDQ2YTZhLCAweDQ2OGRjYmNiLCAweGQ5NjdiZWJlLCAweDRiNzIzOTM5LCAweGRlOTQ0YTRhLCAweGQ0OTg0YzRjLCAweGU4YjA1ODU4LCAweDRhODVjZmNmLCAweDZiYmJkMGQwLCAweDJhYzVlZmVmLCAweGU1NGZhYWFhLCAweDE2ZWRmYmZiLCAweGM1ODY0MzQzLCAweGQ3OWE0ZDRkLCAweDU1NjYzMzMzLCAweDk0MTE4NTg1LCAweGNmOGE0NTQ1LCAweDEwZTlmOWY5LCAweDA2MDQwMjAyLCAweDgxZmU3ZjdmLCAweGYwYTA1MDUwLCAweDQ0NzgzYzNjLCAweGJhMjU5ZjlmLCAweGUzNGJhOGE4LCAweGYzYTI1MTUxLCAweGZlNWRhM2EzLCAweGMwODA0MDQwLCAweDhhMDU4ZjhmLCAweGFkM2Y5MjkyLCAweGJjMjE5ZDlkLCAweDQ4NzAzODM4LCAweDA0ZjFmNWY1LCAweGRmNjNiY2JjLCAweGMxNzdiNmI2LCAweDc1YWZkYWRhLCAweDYzNDIyMTIxLCAweDMwMjAxMDEwLCAweDFhZTVmZmZmLCAweDBlZmRmM2YzLCAweDZkYmZkMmQyLCAweDRjODFjZGNkLCAweDE0MTgwYzBjLCAweDM1MjYxMzEzLCAweDJmYzNlY2VjLCAweGUxYmU1ZjVmLCAweGEyMzU5Nzk3LCAweGNjODg0NDQ0LCAweDM5MmUxNzE3LCAweDU3OTNjNGM0LCAweGYyNTVhN2E3LCAweDgyZmM3ZTdlLCAweDQ3N2EzZDNkLCAweGFjYzg2NDY0LCAweGU3YmE1ZDVkLCAweDJiMzIxOTE5LCAweDk1ZTY3MzczLCAweGEwYzA2MDYwLCAweDk4MTk4MTgxLCAweGQxOWU0ZjRmLCAweDdmYTNkY2RjLCAweDY2NDQyMjIyLCAweDdlNTQyYTJhLCAweGFiM2I5MDkwLCAweDgzMGI4ODg4LCAweGNhOGM0NjQ2LCAweDI5YzdlZWVlLCAweGQzNmJiOGI4LCAweDNjMjgxNDE0LCAweDc5YTdkZWRlLCAweGUyYmM1ZTVlLCAweDFkMTYwYjBiLCAweDc2YWRkYmRiLCAweDNiZGJlMGUwLCAweDU2NjQzMjMyLCAweDRlNzQzYTNhLCAweDFlMTQwYTBhLCAweGRiOTI0OTQ5LCAweDBhMGMwNjA2LCAweDZjNDgyNDI0LCAweGU0Yjg1YzVjLCAweDVkOWZjMmMyLCAweDZlYmRkM2QzLCAweGVmNDNhY2FjLCAweGE2YzQ2MjYyLCAweGE4Mzk5MTkxLCAweGE0MzE5NTk1LCAweDM3ZDNlNGU0LCAweDhiZjI3OTc5LCAweDMyZDVlN2U3LCAweDQzOGJjOGM4LCAweDU5NmUzNzM3LCAweGI3ZGE2ZDZkLCAweDhjMDE4ZDhkLCAweDY0YjFkNWQ1LCAweGQyOWM0ZTRlLCAweGUwNDlhOWE5LCAweGI0ZDg2YzZjLCAweGZhYWM1NjU2LCAweDA3ZjNmNGY0LCAweDI1Y2ZlYWVhLCAweGFmY2E2NTY1LCAweDhlZjQ3YTdhLCAweGU5NDdhZWFlLCAweDE4MTAwODA4LCAweGQ1NmZiYWJhLCAweDg4ZjA3ODc4LCAweDZmNGEyNTI1LCAweDcyNWMyZTJlLCAweDI0MzgxYzFjLCAweGYxNTdhNmE2LCAweGM3NzNiNGI0LCAweDUxOTdjNmM2LCAweDIzY2JlOGU4LCAweDdjYTFkZGRkLCAweDljZTg3NDc0LCAweDIxM2UxZjFmLCAweGRkOTY0YjRiLCAweGRjNjFiZGJkLCAweDg2MGQ4YjhiLCAweDg1MGY4YThhLCAweDkwZTA3MDcwLCAweDQyN2MzZTNlLCAweGM0NzFiNWI1LCAweGFhY2M2NjY2LCAweGQ4OTA0ODQ4LCAweDA1MDYwMzAzLCAweDAxZjdmNmY2LCAweDEyMWMwZTBlLCAweGEzYzI2MTYxLCAweDVmNmEzNTM1LCAweGY5YWU1NzU3LCAweGQwNjliOWI5LCAweDkxMTc4Njg2LCAweDU4OTljMWMxLCAweDI3M2ExZDFkLCAweGI5Mjc5ZTllLCAweDM4ZDllMWUxLCAweDEzZWJmOGY4LCAweGIzMmI5ODk4LCAweDMzMjIxMTExLCAweGJiZDI2OTY5LCAweDcwYTlkOWQ5LCAweDg5MDc4ZThlLCAweGE3MzM5NDk0LCAweGI2MmQ5YjliLCAweDIyM2MxZTFlLCAweDkyMTU4Nzg3LCAweDIwYzllOWU5LCAweDQ5ODdjZWNlLCAweGZmYWE1NTU1LCAweDc4NTAyODI4LCAweDdhYTVkZmRmLCAweDhmMDM4YzhjLCAweGY4NTlhMWExLCAweDgwMDk4OTg5LCAweDE3MWEwZDBkLCAweGRhNjViZmJmLCAweDMxZDdlNmU2LCAweGM2ODQ0MjQyLCAweGI4ZDA2ODY4LCAweGMzODI0MTQxLCAweGIwMjk5OTk5LCAweDc3NWEyZDJkLCAweDExMWUwZjBmLCAweGNiN2JiMGIwLCAweGZjYTg1NDU0LCAweGQ2NmRiYmJiLCAweDNhMmMxNjE2XTtcbmNvbnN0IFQzID0gWzB4NjNhNWM2NjMsIDB4N2M4NGY4N2MsIDB4Nzc5OWVlNzcsIDB4N2I4ZGY2N2IsIDB4ZjIwZGZmZjIsIDB4NmJiZGQ2NmIsIDB4NmZiMWRlNmYsIDB4YzU1NDkxYzUsIDB4MzA1MDYwMzAsIDB4MDEwMzAyMDEsIDB4NjdhOWNlNjcsIDB4MmI3ZDU2MmIsIDB4ZmUxOWU3ZmUsIDB4ZDc2MmI1ZDcsIDB4YWJlNjRkYWIsIDB4NzY5YWVjNzYsIDB4Y2E0NThmY2EsIDB4ODI5ZDFmODIsIDB4Yzk0MDg5YzksIDB4N2Q4N2ZhN2QsIDB4ZmExNWVmZmEsIDB4NTllYmIyNTksIDB4NDdjOThlNDcsIDB4ZjAwYmZiZjAsIDB4YWRlYzQxYWQsIDB4ZDQ2N2IzZDQsIDB4YTJmZDVmYTIsIDB4YWZlYTQ1YWYsIDB4OWNiZjIzOWMsIDB4YTRmNzUzYTQsIDB4NzI5NmU0NzIsIDB4YzA1YjliYzAsIDB4YjdjMjc1YjcsIDB4ZmQxY2UxZmQsIDB4OTNhZTNkOTMsIDB4MjY2YTRjMjYsIDB4MzY1YTZjMzYsIDB4M2Y0MTdlM2YsIDB4ZjcwMmY1ZjcsIDB4Y2M0ZjgzY2MsIDB4MzQ1YzY4MzQsIDB4YTVmNDUxYTUsIDB4ZTUzNGQxZTUsIDB4ZjEwOGY5ZjEsIDB4NzE5M2UyNzEsIDB4ZDg3M2FiZDgsIDB4MzE1MzYyMzEsIDB4MTUzZjJhMTUsIDB4MDQwYzA4MDQsIDB4Yzc1Mjk1YzcsIDB4MjM2NTQ2MjMsIDB4YzM1ZTlkYzMsIDB4MTgyODMwMTgsIDB4OTZhMTM3OTYsIDB4MDUwZjBhMDUsIDB4OWFiNTJmOWEsIDB4MDcwOTBlMDcsIDB4MTIzNjI0MTIsIDB4ODA5YjFiODAsIDB4ZTIzZGRmZTIsIDB4ZWIyNmNkZWIsIDB4Mjc2OTRlMjcsIDB4YjJjZDdmYjIsIDB4NzU5ZmVhNzUsIDB4MDkxYjEyMDksIDB4ODM5ZTFkODMsIDB4MmM3NDU4MmMsIDB4MWEyZTM0MWEsIDB4MWIyZDM2MWIsIDB4NmViMmRjNmUsIDB4NWFlZWI0NWEsIDB4YTBmYjViYTAsIDB4NTJmNmE0NTIsIDB4M2I0ZDc2M2IsIDB4ZDY2MWI3ZDYsIDB4YjNjZTdkYjMsIDB4Mjk3YjUyMjksIDB4ZTMzZWRkZTMsIDB4MmY3MTVlMmYsIDB4ODQ5NzEzODQsIDB4NTNmNWE2NTMsIDB4ZDE2OGI5ZDEsIDB4MDAwMDAwMDAsIDB4ZWQyY2MxZWQsIDB4MjA2MDQwMjAsIDB4ZmMxZmUzZmMsIDB4YjFjODc5YjEsIDB4NWJlZGI2NWIsIDB4NmFiZWQ0NmEsIDB4Y2I0NjhkY2IsIDB4YmVkOTY3YmUsIDB4Mzk0YjcyMzksIDB4NGFkZTk0NGEsIDB4NGNkNDk4NGMsIDB4NThlOGIwNTgsIDB4Y2Y0YTg1Y2YsIDB4ZDA2YmJiZDAsIDB4ZWYyYWM1ZWYsIDB4YWFlNTRmYWEsIDB4ZmIxNmVkZmIsIDB4NDNjNTg2NDMsIDB4NGRkNzlhNGQsIDB4MzM1NTY2MzMsIDB4ODU5NDExODUsIDB4NDVjZjhhNDUsIDB4ZjkxMGU5ZjksIDB4MDIwNjA0MDIsIDB4N2Y4MWZlN2YsIDB4NTBmMGEwNTAsIDB4M2M0NDc4M2MsIDB4OWZiYTI1OWYsIDB4YThlMzRiYTgsIDB4NTFmM2EyNTEsIDB4YTNmZTVkYTMsIDB4NDBjMDgwNDAsIDB4OGY4YTA1OGYsIDB4OTJhZDNmOTIsIDB4OWRiYzIxOWQsIDB4Mzg0ODcwMzgsIDB4ZjUwNGYxZjUsIDB4YmNkZjYzYmMsIDB4YjZjMTc3YjYsIDB4ZGE3NWFmZGEsIDB4MjE2MzQyMjEsIDB4MTAzMDIwMTAsIDB4ZmYxYWU1ZmYsIDB4ZjMwZWZkZjMsIDB4ZDI2ZGJmZDIsIDB4Y2Q0YzgxY2QsIDB4MGMxNDE4MGMsIDB4MTMzNTI2MTMsIDB4ZWMyZmMzZWMsIDB4NWZlMWJlNWYsIDB4OTdhMjM1OTcsIDB4NDRjYzg4NDQsIDB4MTczOTJlMTcsIDB4YzQ1NzkzYzQsIDB4YTdmMjU1YTcsIDB4N2U4MmZjN2UsIDB4M2Q0NzdhM2QsIDB4NjRhY2M4NjQsIDB4NWRlN2JhNWQsIDB4MTkyYjMyMTksIDB4NzM5NWU2NzMsIDB4NjBhMGMwNjAsIDB4ODE5ODE5ODEsIDB4NGZkMTllNGYsIDB4ZGM3ZmEzZGMsIDB4MjI2NjQ0MjIsIDB4MmE3ZTU0MmEsIDB4OTBhYjNiOTAsIDB4ODg4MzBiODgsIDB4NDZjYThjNDYsIDB4ZWUyOWM3ZWUsIDB4YjhkMzZiYjgsIDB4MTQzYzI4MTQsIDB4ZGU3OWE3ZGUsIDB4NWVlMmJjNWUsIDB4MGIxZDE2MGIsIDB4ZGI3NmFkZGIsIDB4ZTAzYmRiZTAsIDB4MzI1NjY0MzIsIDB4M2E0ZTc0M2EsIDB4MGExZTE0MGEsIDB4NDlkYjkyNDksIDB4MDYwYTBjMDYsIDB4MjQ2YzQ4MjQsIDB4NWNlNGI4NWMsIDB4YzI1ZDlmYzIsIDB4ZDM2ZWJkZDMsIDB4YWNlZjQzYWMsIDB4NjJhNmM0NjIsIDB4OTFhODM5OTEsIDB4OTVhNDMxOTUsIDB4ZTQzN2QzZTQsIDB4Nzk4YmYyNzksIDB4ZTczMmQ1ZTcsIDB4Yzg0MzhiYzgsIDB4Mzc1OTZlMzcsIDB4NmRiN2RhNmQsIDB4OGQ4YzAxOGQsIDB4ZDU2NGIxZDUsIDB4NGVkMjljNGUsIDB4YTllMDQ5YTksIDB4NmNiNGQ4NmMsIDB4NTZmYWFjNTYsIDB4ZjQwN2YzZjQsIDB4ZWEyNWNmZWEsIDB4NjVhZmNhNjUsIDB4N2E4ZWY0N2EsIDB4YWVlOTQ3YWUsIDB4MDgxODEwMDgsIDB4YmFkNTZmYmEsIDB4Nzg4OGYwNzgsIDB4MjU2ZjRhMjUsIDB4MmU3MjVjMmUsIDB4MWMyNDM4MWMsIDB4YTZmMTU3YTYsIDB4YjRjNzczYjQsIDB4YzY1MTk3YzYsIDB4ZTgyM2NiZTgsIDB4ZGQ3Y2ExZGQsIDB4NzQ5Y2U4NzQsIDB4MWYyMTNlMWYsIDB4NGJkZDk2NGIsIDB4YmRkYzYxYmQsIDB4OGI4NjBkOGIsIDB4OGE4NTBmOGEsIDB4NzA5MGUwNzAsIDB4M2U0MjdjM2UsIDB4YjVjNDcxYjUsIDB4NjZhYWNjNjYsIDB4NDhkODkwNDgsIDB4MDMwNTA2MDMsIDB4ZjYwMWY3ZjYsIDB4MGUxMjFjMGUsIDB4NjFhM2MyNjEsIDB4MzU1ZjZhMzUsIDB4NTdmOWFlNTcsIDB4YjlkMDY5YjksIDB4ODY5MTE3ODYsIDB4YzE1ODk5YzEsIDB4MWQyNzNhMWQsIDB4OWViOTI3OWUsIDB4ZTEzOGQ5ZTEsIDB4ZjgxM2ViZjgsIDB4OThiMzJiOTgsIDB4MTEzMzIyMTEsIDB4NjliYmQyNjksIDB4ZDk3MGE5ZDksIDB4OGU4OTA3OGUsIDB4OTRhNzMzOTQsIDB4OWJiNjJkOWIsIDB4MWUyMjNjMWUsIDB4ODc5MjE1ODcsIDB4ZTkyMGM5ZTksIDB4Y2U0OTg3Y2UsIDB4NTVmZmFhNTUsIDB4Mjg3ODUwMjgsIDB4ZGY3YWE1ZGYsIDB4OGM4ZjAzOGMsIDB4YTFmODU5YTEsIDB4ODk4MDA5ODksIDB4MGQxNzFhMGQsIDB4YmZkYTY1YmYsIDB4ZTYzMWQ3ZTYsIDB4NDJjNjg0NDIsIDB4NjhiOGQwNjgsIDB4NDFjMzgyNDEsIDB4OTliMDI5OTksIDB4MmQ3NzVhMmQsIDB4MGYxMTFlMGYsIDB4YjBjYjdiYjAsIDB4NTRmY2E4NTQsIDB4YmJkNjZkYmIsIDB4MTYzYTJjMTZdO1xuY29uc3QgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb25cbmNvbnN0IFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuY29uc3QgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XG5jb25zdCBUNyA9IFsweGE3NTA1MWY0LCAweDY1NTM3ZTQxLCAweGE0YzMxYTE3LCAweDVlOTYzYTI3LCAweDZiY2IzYmFiLCAweDQ1ZjExZjlkLCAweDU4YWJhY2ZhLCAweDAzOTM0YmUzLCAweGZhNTUyMDMwLCAweDZkZjZhZDc2LCAweDc2OTE4OGNjLCAweDRjMjVmNTAyLCAweGQ3ZmM0ZmU1LCAweGNiZDdjNTJhLCAweDQ0ODAyNjM1LCAweGEzOGZiNTYyLCAweDVhNDlkZWIxLCAweDFiNjcyNWJhLCAweDBlOTg0NWVhLCAweGMwZTE1ZGZlLCAweDc1MDJjMzJmLCAweGYwMTI4MTRjLCAweDk3YTM4ZDQ2LCAweGY5YzY2YmQzLCAweDVmZTcwMzhmLCAweDljOTUxNTkyLCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDgzMmRkNGJlLCAweDIxZDM1ODc0LCAweDY5Mjk0OWUwLCAweGM4NDQ4ZWM5LCAweDg5NmE3NWMyLCAweDc5NzhmNDhlLCAweDNlNmI5OTU4LCAweDcxZGQyN2I5LCAweDRmYjZiZWUxLCAweGFkMTdmMDg4LCAweGFjNjZjOTIwLCAweDNhYjQ3ZGNlLCAweDRhMTg2M2RmLCAweDMxODJlNTFhLCAweDMzNjA5NzUxLCAweDdmNDU2MjUzLCAweDc3ZTBiMTY0LCAweGFlODRiYjZiLCAweGEwMWNmZTgxLCAweDJiOTRmOTA4LCAweDY4NTg3MDQ4LCAweGZkMTk4ZjQ1LCAweDZjODc5NGRlLCAweGY4Yjc1MjdiLCAweGQzMjNhYjczLCAweDAyZTI3MjRiLCAweDhmNTdlMzFmLCAweGFiMmE2NjU1LCAweDI4MDdiMmViLCAweGMyMDMyZmI1LCAweDdiOWE4NmM1LCAweDA4YTVkMzM3LCAweDg3ZjIzMDI4LCAweGE1YjIyM2JmLCAweDZhYmEwMjAzLCAweDgyNWNlZDE2LCAweDFjMmI4YWNmLCAweGI0OTJhNzc5LCAweGYyZjBmMzA3LCAweGUyYTE0ZTY5LCAweGY0Y2Q2NWRhLCAweGJlZDUwNjA1LCAweDYyMWZkMTM0LCAweGZlOGFjNGE2LCAweDUzOWQzNDJlLCAweDU1YTBhMmYzLCAweGUxMzIwNThhLCAweGViNzVhNGY2LCAweGVjMzkwYjgzLCAweGVmYWE0MDYwLCAweDlmMDY1ZTcxLCAweDEwNTFiZDZlLCAweDhhZjkzZTIxLCAweDA2M2Q5NmRkLCAweDA1YWVkZDNlLCAweGJkNDY0ZGU2LCAweDhkYjU5MTU0LCAweDVkMDU3MWM0LCAweGQ0NmYwNDA2LCAweDE1ZmY2MDUwLCAweGZiMjQxOTk4LCAweGU5OTdkNmJkLCAweDQzY2M4OTQwLCAweDllNzc2N2Q5LCAweDQyYmRiMGU4LCAweDhiODgwNzg5LCAweDViMzhlNzE5LCAweGVlZGI3OWM4LCAweDBhNDdhMTdjLCAweDBmZTk3YzQyLCAweDFlYzlmODg0LCAweDAwMDAwMDAwLCAweDg2ODMwOTgwLCAweGVkNDgzMjJiLCAweDcwYWMxZTExLCAweDcyNGU2YzVhLCAweGZmZmJmZDBlLCAweDM4NTYwZjg1LCAweGQ1MWUzZGFlLCAweDM5MjczNjJkLCAweGQ5NjQwYTBmLCAweGE2MjE2ODVjLCAweDU0ZDE5YjViLCAweDJlM2EyNDM2LCAweDY3YjEwYzBhLCAweGU3MGY5MzU3LCAweDk2ZDJiNGVlLCAweDkxOWUxYjliLCAweGM1NGY4MGMwLCAweDIwYTI2MWRjLCAweDRiNjk1YTc3LCAweDFhMTYxYzEyLCAweGJhMGFlMjkzLCAweDJhZTVjMGEwLCAweGUwNDMzYzIyLCAweDE3MWQxMjFiLCAweDBkMGIwZTA5LCAweGM3YWRmMjhiLCAweGE4YjkyZGI2LCAweGE5YzgxNDFlLCAweDE5ODU1N2YxLCAweDA3NGNhZjc1LCAweGRkYmJlZTk5LCAweDYwZmRhMzdmLCAweDI2OWZmNzAxLCAweGY1YmM1YzcyLCAweDNiYzU0NDY2LCAweDdlMzQ1YmZiLCAweDI5NzY4YjQzLCAweGM2ZGNjYjIzLCAweGZjNjhiNmVkLCAweGYxNjNiOGU0LCAweGRjY2FkNzMxLCAweDg1MTA0MjYzLCAweDIyNDAxMzk3LCAweDExMjA4NGM2LCAweDI0N2Q4NTRhLCAweDNkZjhkMmJiLCAweDMyMTFhZWY5LCAweGExNmRjNzI5LCAweDJmNGIxZDllLCAweDMwZjNkY2IyLCAweDUyZWMwZDg2LCAweGUzZDA3N2MxLCAweDE2NmMyYmIzLCAweGI5OTlhOTcwLCAweDQ4ZmExMTk0LCAweDY0MjI0N2U5LCAweDhjYzRhOGZjLCAweDNmMWFhMGYwLCAweDJjZDg1NjdkLCAweDkwZWYyMjMzLCAweDRlYzc4NzQ5LCAweGQxYzFkOTM4LCAweGEyZmU4Y2NhLCAweDBiMzY5OGQ0LCAweDgxY2ZhNmY1LCAweGRlMjhhNTdhLCAweDhlMjZkYWI3LCAweGJmYTQzZmFkLCAweDlkZTQyYzNhLCAweDkyMGQ1MDc4LCAweGNjOWI2YTVmLCAweDQ2NjI1NDdlLCAweDEzYzJmNjhkLCAweGI4ZTg5MGQ4LCAweGY3NWUyZTM5LCAweGFmZjU4MmMzLCAweDgwYmU5ZjVkLCAweDkzN2M2OWQwLCAweDJkYTk2ZmQ1LCAweDEyYjNjZjI1LCAweDk5M2JjOGFjLCAweDdkYTcxMDE4LCAweDYzNmVlODljLCAweGJiN2JkYjNiLCAweDc4MDljZDI2LCAweDE4ZjQ2ZTU5LCAweGI3MDFlYzlhLCAweDlhYTg4MzRmLCAweDZlNjVlNjk1LCAweGU2N2VhYWZmLCAweGNmMDgyMWJjLCAweGU4ZTZlZjE1LCAweDliZDliYWU3LCAweDM2Y2U0YTZmLCAweDA5ZDRlYTlmLCAweDdjZDYyOWIwLCAweGIyYWYzMWE0LCAweDIzMzEyYTNmLCAweDk0MzBjNmE1LCAweDY2YzAzNWEyLCAweGJjMzc3NDRlLCAweGNhYTZmYzgyLCAweGQwYjBlMDkwLCAweGQ4MTUzM2E3LCAweDk4NGFmMTA0LCAweGRhZjc0MWVjLCAweDUwMGU3ZmNkLCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGIwNGQ0M2VmLCAweDRkNTRjY2FhLCAweDA0ZGZlNDk2LCAweGI1ZTM5ZWQxLCAweDg4MWI0YzZhLCAweDFmYjhjMTJjLCAweDUxN2Y0NjY1LCAweGVhMDQ5ZDVlLCAweDM1NWQwMThjLCAweDc0NzNmYTg3LCAweDQxMmVmYjBiLCAweDFkNWFiMzY3LCAweGQyNTI5MmRiLCAweDU2MzNlOTEwLCAweDQ3MTM2ZGQ2LCAweDYxOGM5YWQ3LCAweDBjN2EzN2ExLCAweDE0OGU1OWY4LCAweDNjODllYjEzLCAweDI3ZWVjZWE5LCAweGM5MzViNzYxLCAweGU1ZWRlMTFjLCAweGIxM2M3YTQ3LCAweGRmNTk5Y2QyLCAweDczM2Y1NWYyLCAweGNlNzkxODE0LCAweDM3YmY3M2M3LCAweGNkZWE1M2Y3LCAweGFhNWI1ZmZkLCAweDZmMTRkZjNkLCAweGRiODY3ODQ0LCAweGYzODFjYWFmLCAweGM0M2ViOTY4LCAweDM0MmMzODI0LCAweDQwNWZjMmEzLCAweGMzNzIxNjFkLCAweDI1MGNiY2UyLCAweDQ5OGIyODNjLCAweDk1NDFmZjBkLCAweDAxNzEzOWE4LCAweGIzZGUwODBjLCAweGU0OWNkOGI0LCAweGMxOTA2NDU2LCAweDg0NjE3YmNiLCAweGI2NzBkNTMyLCAweDVjNzQ0ODZjLCAweDU3NDJkMGI4XTtcbmNvbnN0IFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uIGtleSBleHBhbnNpb25cbmNvbnN0IFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuY29uc3QgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG5jb25zdCBVMyA9IFsweDAwMDAwMDAwLCAweDBkMGIwZTA5LCAweDFhMTYxYzEyLCAweDE3MWQxMjFiLCAweDM0MmMzODI0LCAweDM5MjczNjJkLCAweDJlM2EyNDM2LCAweDIzMzEyYTNmLCAweDY4NTg3MDQ4LCAweDY1NTM3ZTQxLCAweDcyNGU2YzVhLCAweDdmNDU2MjUzLCAweDVjNzQ0ODZjLCAweDUxN2Y0NjY1LCAweDQ2NjI1NDdlLCAweDRiNjk1YTc3LCAweGQwYjBlMDkwLCAweGRkYmJlZTk5LCAweGNhYTZmYzgyLCAweGM3YWRmMjhiLCAweGU0OWNkOGI0LCAweGU5OTdkNmJkLCAweGZlOGFjNGE2LCAweGYzODFjYWFmLCAweGI4ZTg5MGQ4LCAweGI1ZTM5ZWQxLCAweGEyZmU4Y2NhLCAweGFmZjU4MmMzLCAweDhjYzRhOGZjLCAweDgxY2ZhNmY1LCAweDk2ZDJiNGVlLCAweDliZDliYWU3LCAweGJiN2JkYjNiLCAweGI2NzBkNTMyLCAweGExNmRjNzI5LCAweGFjNjZjOTIwLCAweDhmNTdlMzFmLCAweDgyNWNlZDE2LCAweDk1NDFmZjBkLCAweDk4NGFmMTA0LCAweGQzMjNhYjczLCAweGRlMjhhNTdhLCAweGM5MzViNzYxLCAweGM0M2ViOTY4LCAweGU3MGY5MzU3LCAweGVhMDQ5ZDVlLCAweGZkMTk4ZjQ1LCAweGYwMTI4MTRjLCAweDZiY2IzYmFiLCAweDY2YzAzNWEyLCAweDcxZGQyN2I5LCAweDdjZDYyOWIwLCAweDVmZTcwMzhmLCAweDUyZWMwZDg2LCAweDQ1ZjExZjlkLCAweDQ4ZmExMTk0LCAweDAzOTM0YmUzLCAweDBlOTg0NWVhLCAweDE5ODU1N2YxLCAweDE0OGU1OWY4LCAweDM3YmY3M2M3LCAweDNhYjQ3ZGNlLCAweDJkYTk2ZmQ1LCAweDIwYTI2MWRjLCAweDZkZjZhZDc2LCAweDYwZmRhMzdmLCAweDc3ZTBiMTY0LCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDU0ZDE5YjViLCAweDQzY2M4OTQwLCAweDRlYzc4NzQ5LCAweDA1YWVkZDNlLCAweDA4YTVkMzM3LCAweDFmYjhjMTJjLCAweDEyYjNjZjI1LCAweDMxODJlNTFhLCAweDNjODllYjEzLCAweDJiOTRmOTA4LCAweDI2OWZmNzAxLCAweGJkNDY0ZGU2LCAweGIwNGQ0M2VmLCAweGE3NTA1MWY0LCAweGFhNWI1ZmZkLCAweDg5NmE3NWMyLCAweDg0NjE3YmNiLCAweDkzN2M2OWQwLCAweDllNzc2N2Q5LCAweGQ1MWUzZGFlLCAweGQ4MTUzM2E3LCAweGNmMDgyMWJjLCAweGMyMDMyZmI1LCAweGUxMzIwNThhLCAweGVjMzkwYjgzLCAweGZiMjQxOTk4LCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGRiODY3ODQ0LCAweGNjOWI2YTVmLCAweGMxOTA2NDU2LCAweGUyYTE0ZTY5LCAweGVmYWE0MDYwLCAweGY4Yjc1MjdiLCAweGY1YmM1YzcyLCAweGJlZDUwNjA1LCAweGIzZGUwODBjLCAweGE0YzMxYTE3LCAweGE5YzgxNDFlLCAweDhhZjkzZTIxLCAweDg3ZjIzMDI4LCAweDkwZWYyMjMzLCAweDlkZTQyYzNhLCAweDA2M2Q5NmRkLCAweDBiMzY5OGQ0LCAweDFjMmI4YWNmLCAweDExMjA4NGM2LCAweDMyMTFhZWY5LCAweDNmMWFhMGYwLCAweDI4MDdiMmViLCAweDI1MGNiY2UyLCAweDZlNjVlNjk1LCAweDYzNmVlODljLCAweDc0NzNmYTg3LCAweDc5NzhmNDhlLCAweDVhNDlkZWIxLCAweDU3NDJkMGI4LCAweDQwNWZjMmEzLCAweDRkNTRjY2FhLCAweGRhZjc0MWVjLCAweGQ3ZmM0ZmU1LCAweGMwZTE1ZGZlLCAweGNkZWE1M2Y3LCAweGVlZGI3OWM4LCAweGUzZDA3N2MxLCAweGY0Y2Q2NWRhLCAweGY5YzY2YmQzLCAweGIyYWYzMWE0LCAweGJmYTQzZmFkLCAweGE4YjkyZGI2LCAweGE1YjIyM2JmLCAweDg2ODMwOTgwLCAweDhiODgwNzg5LCAweDljOTUxNTkyLCAweDkxOWUxYjliLCAweDBhNDdhMTdjLCAweDA3NGNhZjc1LCAweDEwNTFiZDZlLCAweDFkNWFiMzY3LCAweDNlNmI5OTU4LCAweDMzNjA5NzUxLCAweDI0N2Q4NTRhLCAweDI5NzY4YjQzLCAweDYyMWZkMTM0LCAweDZmMTRkZjNkLCAweDc4MDljZDI2LCAweDc1MDJjMzJmLCAweDU2MzNlOTEwLCAweDViMzhlNzE5LCAweDRjMjVmNTAyLCAweDQxMmVmYjBiLCAweDYxOGM5YWQ3LCAweDZjODc5NGRlLCAweDdiOWE4NmM1LCAweDc2OTE4OGNjLCAweDU1YTBhMmYzLCAweDU4YWJhY2ZhLCAweDRmYjZiZWUxLCAweDQyYmRiMGU4LCAweDA5ZDRlYTlmLCAweDA0ZGZlNDk2LCAweDEzYzJmNjhkLCAweDFlYzlmODg0LCAweDNkZjhkMmJiLCAweDMwZjNkY2IyLCAweDI3ZWVjZWE5LCAweDJhZTVjMGEwLCAweGIxM2M3YTQ3LCAweGJjMzc3NDRlLCAweGFiMmE2NjU1LCAweGE2MjE2ODVjLCAweDg1MTA0MjYzLCAweDg4MWI0YzZhLCAweDlmMDY1ZTcxLCAweDkyMGQ1MDc4LCAweGQ5NjQwYTBmLCAweGQ0NmYwNDA2LCAweGMzNzIxNjFkLCAweGNlNzkxODE0LCAweGVkNDgzMjJiLCAweGUwNDMzYzIyLCAweGY3NWUyZTM5LCAweGZhNTUyMDMwLCAweGI3MDFlYzlhLCAweGJhMGFlMjkzLCAweGFkMTdmMDg4LCAweGEwMWNmZTgxLCAweDgzMmRkNGJlLCAweDhlMjZkYWI3LCAweDk5M2JjOGFjLCAweDk0MzBjNmE1LCAweGRmNTk5Y2QyLCAweGQyNTI5MmRiLCAweGM1NGY4MGMwLCAweGM4NDQ4ZWM5LCAweGViNzVhNGY2LCAweGU2N2VhYWZmLCAweGYxNjNiOGU0LCAweGZjNjhiNmVkLCAweDY3YjEwYzBhLCAweDZhYmEwMjAzLCAweDdkYTcxMDE4LCAweDcwYWMxZTExLCAweDUzOWQzNDJlLCAweDVlOTYzYTI3LCAweDQ5OGIyODNjLCAweDQ0ODAyNjM1LCAweDBmZTk3YzQyLCAweDAyZTI3MjRiLCAweDE1ZmY2MDUwLCAweDE4ZjQ2ZTU5LCAweDNiYzU0NDY2LCAweDM2Y2U0YTZmLCAweDIxZDM1ODc0LCAweDJjZDg1NjdkLCAweDBjN2EzN2ExLCAweDAxNzEzOWE4LCAweDE2NmMyYmIzLCAweDFiNjcyNWJhLCAweDM4NTYwZjg1LCAweDM1NWQwMThjLCAweDIyNDAxMzk3LCAweDJmNGIxZDllLCAweDY0MjI0N2U5LCAweDY5Mjk0OWUwLCAweDdlMzQ1YmZiLCAweDczM2Y1NWYyLCAweDUwMGU3ZmNkLCAweDVkMDU3MWM0LCAweDRhMTg2M2RmLCAweDQ3MTM2ZGQ2LCAweGRjY2FkNzMxLCAweGQxYzFkOTM4LCAweGM2ZGNjYjIzLCAweGNiZDdjNTJhLCAweGU4ZTZlZjE1LCAweGU1ZWRlMTFjLCAweGYyZjBmMzA3LCAweGZmZmJmZDBlLCAweGI0OTJhNzc5LCAweGI5OTlhOTcwLCAweGFlODRiYjZiLCAweGEzOGZiNTYyLCAweDgwYmU5ZjVkLCAweDhkYjU5MTU0LCAweDlhYTg4MzRmLCAweDk3YTM4ZDQ2XTtcbmNvbnN0IFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuZnVuY3Rpb24gY29udmVydFRvSW50MzIoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChieXRlc1tpXSA8PCAyNCkgfCAoYnl0ZXNbaSArIDFdIDw8IDE2KSB8IChieXRlc1tpICsgMl0gPDwgOCkgfCBieXRlc1tpICsgM10pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BRVMgPSBBRVM7XG5fQUVTX2tleSA9IG5ldyBXZWFrTWFwKCksIF9BRVNfS2QgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGtjczdTdHJpcCA9IGV4cG9ydHMucGtjczdQYWQgPSBleHBvcnRzLk9GQiA9IGV4cG9ydHMuRUNCID0gZXhwb3J0cy5DVFIgPSBleHBvcnRzLkNGQiA9IGV4cG9ydHMuQ0JDID0gZXhwb3J0cy5Nb2RlT2ZPcGVyYXRpb24gPSBleHBvcnRzLkFFUyA9IHZvaWQgMDtcbnZhciBhZXNfanNfMSA9IHJlcXVpcmUoXCIuL2Flcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFFU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWVzX2pzXzEuQUVTOyB9IH0pO1xudmFyIG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNb2RlT2ZPcGVyYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb247IH0gfSk7XG52YXIgbW9kZV9jYmNfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtY2JjLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ0JDXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2NiY19qc18xLkNCQzsgfSB9KTtcbnZhciBtb2RlX2NmYl9qc18xID0gcmVxdWlyZShcIi4vbW9kZS1jZmIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDRkJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVfY2ZiX2pzXzEuQ0ZCOyB9IH0pO1xudmFyIG1vZGVfY3RyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLWN0ci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNUUlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZV9jdHJfanNfMS5DVFI7IH0gfSk7XG52YXIgbW9kZV9lY2JfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtZWNiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRUNCXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2VjYl9qc18xLkVDQjsgfSB9KTtcbnZhciBtb2RlX29mYl9qc18xID0gcmVxdWlyZShcIi4vbW9kZS1vZmIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPRkJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVfb2ZiX2pzXzEuT0ZCOyB9IH0pO1xudmFyIHBhZGRpbmdfanNfMSA9IHJlcXVpcmUoXCIuL3BhZGRpbmcuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwa2NzN1BhZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFkZGluZ19qc18xLnBrY3M3UGFkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGtjczdTdHJpcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFkZGluZ19qc18xLnBrY3M3U3RyaXA7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIENpcGhlciBCbG9jayBDaGFpbmluZ1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DQkNfaXYsIF9DQkNfbGFzdEJsb2NrO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DQkMgPSB2b2lkIDA7XG5jb25zdCBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuY2xhc3MgQ0JDIGV4dGVuZHMgbW9kZV9qc18xLk1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdikge1xuICAgICAgICBzdXBlcihcIkVDQ1wiLCBrZXksIENCQyk7XG4gICAgICAgIF9DQkNfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DQkNfbGFzdEJsb2NrLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGl2IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5pdiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSBePSBwbGFpbnRleHRbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0LnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIiksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuYWVzLmRlY3J5cHQoY2lwaGVydGV4dC5zdWJhcnJheShpLCBpICsgMTYpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal0gPSBjaXBoZXJ0ZXh0W2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuQ0JDID0gQ0JDO1xuX0NCQ19pdiA9IG5ldyBXZWFrTWFwKCksIF9DQkNfbGFzdEJsb2NrID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY2JjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gQ2lwaGVyIEZlZWRiYWNrXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NGQl9pbnN0YW5jZXMsIF9DRkJfaXYsIF9DRkJfc2hpZnRSZWdpc3RlciwgX0NGQl9zaGlmdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0ZCID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIENGQiBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYsIHNlZ21lbnRTaXplID0gOCkge1xuICAgICAgICBzdXBlcihcIkNGQlwiLCBrZXksIENGQik7XG4gICAgICAgIF9DRkJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0NGQl9pdi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NGQl9zaGlmdFJlZ2lzdGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBUaGlzIGxpYnJhcnkgY3VycmVudGx5IG9ubHkgaGFuZGxlcyBieXRlLWFsaWduZWQgc2VnbWVudFNpemVcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZ21lbnRTaXplKSB8fCAoc2VnbWVudFNpemUgJSA4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2VnbWVudFNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgc2VnbWVudFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHNlZ21lbnRTaXplIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0ZCX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgdGhpcy5pdiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAoOCAqIHBsYWludGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhvclNlZ21lbnQgPSB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pbnN0YW5jZXMsIFwibVwiLCBfQ0ZCX3NoaWZ0KS5jYWxsKHRoaXMsIGNpcGhlcnRleHQuc3ViYXJyYXkoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKDggKiBjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSBzZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgeG9yU2VnbWVudCA9IHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHRbaSArIGpdIF49IHhvclNlZ21lbnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaW5zdGFuY2VzLCBcIm1cIiwgX0NGQl9zaGlmdCkuY2FsbCh0aGlzLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuQ0ZCID0gQ0ZCO1xuX0NGQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9DRkJfc2hpZnRSZWdpc3RlciA9IG5ldyBXZWFrTWFwKCksIF9DRkJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0NGQl9zaGlmdCA9IGZ1bmN0aW9uIF9DRkJfc2hpZnQoZGF0YSkge1xuICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XG4gICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zdWJhcnJheShzZWdtZW50U2l6ZSkpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikuc2V0KGRhdGEuc3ViYXJyYXkoMCwgc2VnbWVudFNpemUpLCAxNiAtIHNlZ21lbnRTaXplKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNmYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIENvdW50ZXIgTW9kZVxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DVFJfcmVtYWluaW5nLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBfQ1RSX2NvdW50ZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNUUiA9IHZvaWQgMDtcbmNvbnN0IG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5jbGFzcyBDVFIgZXh0ZW5kcyBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBzdXBlcihcIkNUUlwiLCBrZXksIENUUik7XG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlcyBmb3IgdGhlIG9uZS10aW1lIHBhZFxuICAgICAgICBfQ1RSX3JlbWFpbmluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NUUl9yZW1haW5pbmdJbmRleC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBfQ1RSX2NvdW50ZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9jb3VudGVyLCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5maWxsKDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLCBcImZcIik7IC8vIFRoaXMgd2lsbCBiZSBkaXNjYXJkZWQgaW1tZWRpYXRlbHlcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAxNiwgXCJmXCIpO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoaW5pdGlhbFZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRDb3VudGVyVmFsdWUoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlckJ5dGVzKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvdW50ZXIoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpKTsgfVxuICAgIHNldENvdW50ZXJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgaW50ZWdlciB2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE1OyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2luZGV4XSA9IHZhbHVlICUgMjU2O1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMjU2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDb3VudGVyQnl0ZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgaW5pdGlhbCBVaW50OEFycmF5IHZhbHVlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0gPT09IDI1NSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNyeXB0dGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3J5cHR0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBcImZcIikgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcnlwdHRleHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgXCJmXCIpW19fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgKF9iID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBcImZcIiksIF9hID0gX2IrKywgX2IpLCBcImZcIiksIF9hXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3J5cHR0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdChjaXBoZXJ0ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkNUUiA9IENUUjtcbl9DVFJfcmVtYWluaW5nID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9yZW1haW5pbmdJbmRleCA9IG5ldyBXZWFrTWFwKCksIF9DVFJfY291bnRlciA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWN0ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIEVsZWN0cm9uaWMgQ29kZSBCb29rXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVDQiA9IHZvaWQgMDtcbmNvbnN0IG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5jbGFzcyBFQ0IgZXh0ZW5kcyBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0JcIiwga2V5LCBFQ0IpO1xuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY3J5cHR0ZXh0LnNldCh0aGlzLmFlcy5lbmNyeXB0KHBsYWludGV4dC5zdWJhcnJheShpLCBpICsgMTYpKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjcnlwdHRleHQpIHtcbiAgICAgICAgaWYgKGNyeXB0dGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjcnlwdHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBwbGFpbnRleHQuc2V0KHRoaXMuYWVzLmRlY3J5cHQoY3J5cHR0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuRUNCID0gRUNCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1lY2IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBPdXRwdXQgRmVlZGJhY2tcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfT0ZCX2l2LCBfT0ZCX2xhc3RQcmVjaXBoZXIsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PRkIgPSB2b2lkIDA7XG5jb25zdCBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuY2xhc3MgT0ZCIGV4dGVuZHMgbW9kZV9qc18xLk1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdikge1xuICAgICAgICBzdXBlcihcIk9GQlwiLCBrZXksIE9GQik7XG4gICAgICAgIF9PRkJfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9PRkJfbGFzdFByZWNpcGhlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX09GQl9sYXN0UHJlY2lwaGVySW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5pdiwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAxNiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpcGhlcnRleHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCBcImZcIiksIF9hID0gX2IrKywgX2IpLCBcImZcIiksIF9hXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy5PRkIgPSBPRkI7XG5fT0ZCX2l2ID0gbmV3IFdlYWtNYXAoKSwgX09GQl9sYXN0UHJlY2lwaGVyID0gbmV3IFdlYWtNYXAoKSwgX09GQl9sYXN0UHJlY2lwaGVySW5kZXggPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1vZmIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVPZk9wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFlc19qc18xID0gcmVxdWlyZShcIi4vYWVzLmpzXCIpO1xuY2xhc3MgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBrZXksIGNscykge1xuICAgICAgICBpZiAoY2xzICYmICEodGhpcyBpbnN0YW5jZW9mIGNscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGluc3RhbnRpYXRlZCB3aXRoIFwibmV3XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBhZXNfanNfMS5BRVMoa2V5KSB9LFxuICAgICAgICAgICAgbmFtZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogbmFtZSB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZU9mT3BlcmF0aW9uID0gTW9kZU9mT3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGtjczdTdHJpcCA9IGV4cG9ydHMucGtjczdQYWQgPSB2b2lkIDA7XG5mdW5jdGlvbiBwa2NzN1BhZChkYXRhKSB7XG4gICAgY29uc3QgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBwYWRkZXIpO1xuICAgIHJlc3VsdC5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhZGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGtjczdQYWQgPSBwa2NzN1BhZDtcbmZ1bmN0aW9uIHBrY3M3U3RyaXAoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgaWYgKHBhZGRlciA+IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gcGFkZGVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVyOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbGVuZ3RoICsgaV0gIT09IHBhZGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuc3ViYXJyYXkoMCwgbGVuZ3RoKSk7XG59XG5leHBvcnRzLnBrY3M3U3RyaXAgPSBwa2NzN1N0cmlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnRzLnZlcnNpb24gPSBcIjYuMTIuMVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXG4gKlxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXG4gKlxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJpQ29kZXIgPSB2b2lkIDA7XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hZGRyZXNzLmpzXCIpO1xuY29uc3QgYXJyYXlfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hcnJheS5qc1wiKTtcbmNvbnN0IGJvb2xlYW5fanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9ib29sZWFuLmpzXCIpO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9ieXRlcy5qc1wiKTtcbmNvbnN0IGZpeGVkX2J5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIik7XG5jb25zdCBudWxsX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvbnVsbC5qc1wiKTtcbmNvbnN0IG51bWJlcl9qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL251bWJlci5qc1wiKTtcbmNvbnN0IHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL3N0cmluZy5qc1wiKTtcbmNvbnN0IHR1cGxlX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvdHVwbGUuanNcIik7XG5jb25zdCBmcmFnbWVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2ZyYWdtZW50cy5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDAsIFwiR0VORVJJQ19QQU5JQ1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTIsIFwiRElWSURFX0JZX1pFUk9cIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMxLCBcIlNUQUNLX1VOREVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDUxLCBcIlVOSU5JVElBTElaRURfRlVOQ1RJT05fQ0FMTFwiKTtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xubGV0IGRlZmF1bHRDb2RlciA9IG51bGw7XG5sZXQgZGVmYXVsdE1heEluZmxhdGlvbiA9IDEwMjQ7XG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xuICAgIGxldCBtZXNzYWdlID0gXCJtaXNzaW5nIHJldmVydCBkYXRhXCI7XG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XG4gICAgbGV0IHJldmVydCA9IG51bGw7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKGRhdGEpO1xuICAgICAgICBkYXRhID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XG4gICAgICAgICAgICByZWFzb24gPSBcInJlcXVpcmUoZmFsc2UpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIGRhdGEgbGVuZ3RoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDA4YzM3OWEwXCIpIHtcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIHN0cmluZyBkYXRhKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyAoMCwgaW5kZXhfanNfMi5nZXRBZGRyZXNzKSh0eC50bykgOiBudWxsKSxcbiAgICAgICAgZGF0YTogKHR4LmRhdGEgfHwgXCIweFwiKVxuICAgIH07XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZnJvbSA9ICgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuY2xhc3MgQWJpQ29kZXIge1xuICAgICNnZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFycmF5X2pzXzEuQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhZGRyZXNzX2pzXzEuQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJvb2xlYW5fanNfMS5Cb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJpbmdfanNfMS5TdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYnl0ZXNfanNfMS5CeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbnVsbF9qc18xLk51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnVtYmVyX2pzXzEuTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBmaXhlZF9ieXRlc19qc18xLkZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudENvdW50KSh2YWx1ZXMubGVuZ3RoLCB0eXBlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihmcmFnbWVudHNfanNfMS5QYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuV3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSB0aGUgQUJJICUlZGF0YSUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcbiAgICAgKiAgbm90IGVuZm9yY2VkLiBTb21lIG9sZGVyIHZlcnNpb25zIG9mIFNvbGlkaXR5IGluY29ycmVjdGx5XG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihmcmFnbWVudHNfanNfMS5QYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyB0dXBsZV9qc18xLlR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuUmVhZGVyKGRhdGEsIGxvb3NlLCBkZWZhdWx0TWF4SW5mbGF0aW9uKSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc2V0RGVmYXVsdE1heEluZmxhdGlvbih2YWx1ZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwiaW52YWxpZCBkZWZhdWx0TWF4SW5mbGF0aW9uIGZhY3RvclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdE1heEluZmxhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2hhcmVkIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGRlZmF1bHQgW1tBYmlDb2Rlcl1dLlxuICAgICAqXG4gICAgICogIE9uIHRoZSBmaXJzdCBjYWxsLCB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0QWJpQ29kZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdENvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLWNvbXBhdGlibGUgW1tDYWxsRXhjZXB0aW9uRXJyb3JdXSBFcnJvciBmb3IgdGhlIGdpdmVuXG4gICAgICogIHJlc3VsdCAlJWRhdGElJSBmb3IgdGhlIFtbQ2FsbEV4Y2VwdGlvbkFjdGlvbl1dICUlYWN0aW9uJSUgYWdhaW5zdFxuICAgICAqICB0aGUgVHJhbnNhY3Rpb24gJSV0eCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BYmlDb2RlciA9IEFiaUNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWJvdXQgYnl0ZXMzMiBzdHJpbmdzLi4uXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvdXRpbHM6Qnl0ZXMzMiBTdHJpbmdzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuZW5jb2RlQnl0ZXMzMlN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBFbmNvZGVzICUldGV4dCUlIGFzIGEgQnl0ZXMzMiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzMzJTdHJpbmcodGV4dCkge1xuICAgIC8vIEdldCB0aGUgYnl0ZXNcbiAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc18xLnRvVXRmOEJ5dGVzKSh0ZXh0KTtcbiAgICAvLyBDaGVjayB3ZSBoYXZlIHJvb20gZm9yIG51bGwtdGVybWluYXRpb25cbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnl0ZXMzMiBzdHJpbmcgbXVzdCBiZSBsZXNzIHRoYW4gMzIgYnl0ZXNcIik7XG4gICAgfVxuICAgIC8vIFplcm8tcGFkIChpbXBsaWNpdGx5IG51bGwtdGVybWluYXRlcylcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuemVyb1BhZEJ5dGVzKShieXRlcywgMzIpO1xufVxuZXhwb3J0cy5lbmNvZGVCeXRlczMyU3RyaW5nID0gZW5jb2RlQnl0ZXMzMlN0cmluZztcbi8qKlxuICogIEVuY29kZXMgdGhlIEJ5dGVzMzItZW5jb2RlZCAlJWJ5dGVzJSUgaW50byBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlQnl0ZXMzMlN0cmluZyhfYnl0ZXMpIHtcbiAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICAvLyBNdXN0IGJlIDMyIGJ5dGVzIHdpdGggYSBudWxsLXRlcm1pbmF0aW9uXG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKTtcbiAgICB9XG4gICAgaWYgKGRhdGFbMzFdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiBzdHJpbmcgLSBubyBudWxsIHRlcm1pbmF0b3JcIik7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIG51bGwgdGVybWluYXRpb25cbiAgICBsZXQgbGVuZ3RoID0gMzE7XG4gICAgd2hpbGUgKGRhdGFbbGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgfVxuICAgIC8vIERldGVybWluZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvVXRmOFN0cmluZykoZGF0YS5zbGljZSgwLCBsZW5ndGgpKTtcbn1cbmV4cG9ydHMuZGVjb2RlQnl0ZXMzMlN0cmluZyA9IGRlY29kZUJ5dGVzMzJTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlczMyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkZXIgPSBleHBvcnRzLldyaXRlciA9IGV4cG9ydHMuQ29kZXIgPSBleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gZXhwb3J0cy5SZXN1bHQgPSBleHBvcnRzLldvcmRTaXplID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9pbmRleC5qc1wiKTtcbi8qKlxuICogQF9pZ25vcmU6XG4gKi9cbmV4cG9ydHMuV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShleHBvcnRzLldvcmRTaXplKTtcbi8vIFByb3BlcnRpZXMgdXNlZCB0byBpbW1lZGlhdGUgcGFzcyB0aHJvdWdoIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdFxuLy8gLSBgdGhlbmAgaXMgdXNlZCB0byBkZXRlY3QgaWYgYW4gb2JqZWN0IGlzIGEgUHJvbWlzZSBmb3IgYXdhaXRcbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdGhyb3dFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XG4gICAgd3JhcHBlZC5lcnJvciA9IGVycm9yO1xuICAgIHRocm93IHdyYXBwZWQ7XG59XG4vKipcbiAqICBBIFtbUmVzdWx0XV0gaXMgYSBzdWItY2xhc3Mgb2YgQXJyYXksIHdoaWNoIGFsbG93cyBhY2Nlc3NpbmcgYW55XG4gKiAgb2YgaXRzIHZhbHVlcyBlaXRoZXIgcG9zaXRpb25hbGx5IGJ5IGl0cyBpbmRleCBvciwgaWYga2V5cyBhcmVcbiAqICBwcm92aWRlZCBieSBpdHMgbmFtZS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9hYmlcbiAqL1xuY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICB0aGlzLiNuYW1lcyA9IE9iamVjdC5mcmVlemUoaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgbmFtZUNvdW50cy5nZXQobmFtZSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleCBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKHByb3AsIFwiJWluZGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJlc3VsdCByYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5I25vX3ByaXZhdGVfcHJvcGVydHlfZm9yd2FyZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIG5hbWUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0VmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhIG5vcm1hbCBBcnJheS4gSWYgJSVkZWVwJSUsIGFueSBjaGlsZHJlblxuICAgICAqICB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc28gY29udmVydGVkIHRvIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGRlZXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvQXJyYXkoZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXG4gICAgICogICUlZGVlcCUlLCBhbnkgY2hpbGRyZW4gd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvXG4gICAgICogIGNvbnZlcnRlZCB0byBhbiBPYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdChkZWVwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShuYW1lICE9IG51bGwsIFwidmFsdWUgYXQgaW5kZXggJHsgaW5kZXggfSB1bm5hbWVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZXMgZm9yIG5hbWVzIHRoYXQgZG9uJ3QgY29uZmxpY3RcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjaGlsZCBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnRvT2JqZWN0KGRlZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy4jbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzdWx0ID0gUmVzdWx0O1xuLyoqXG4gKiAgUmV0dXJucyBhbGwgZXJyb3JzIGZvdW5kIGluIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgU2luY2UgY2VydGFpbiBlcnJvcnMgZW5jb3VudGVyZWQgd2hlbiBjcmVhdGluZyBhIFtbUmVzdWx0XV0gZG9cbiAqICBub3QgaW1wYWN0IHRoZSBhYmlsaXR5IHRvIGNvbnRpbnVlIHBhcnNpbmcgZGF0YSwgdGhleSBhcmVcbiAqICBkZWZlcnJlZCB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseSBhY2Nlc3NlZC4gSGVuY2UgYSBmYXVsdHkgc3RyaW5nXG4gKiAgaW4gYW4gRXZlbnQgdGhhdCBpcyBuZXZlciB1c2VkIGRvZXMgbm90IGltcGFjdCB0aGUgcHJvZ3JhbSBmbG93LlxuICpcbiAqICBIb3dldmVyLCBzb21ldGltZXMgaXQgbWF5IGJlIHVzZWZ1bCB0byBhY2Nlc3MsIGlkZW50aWZ5IG9yXG4gKiAgdmFsaWRhdGUgY29ycmVjdG5lc3Mgb2YgYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBAX2RvY2xvYyBhcGkvYWJpXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGNoZWNrUmVzdWx0RXJyb3JzO1xuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS50b0JlQXJyYXkpKHZhbHVlKTtcbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGJ5dGVzLmxlbmd0aCA8PSBleHBvcnRzLldvcmRTaXplLCBcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogZXhwb3J0cy5Xb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gZXhwb3J0cy5Xb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoKDAsIGluZGV4X2pzXzEuY29uY2F0KShbUGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSBleHBvcnRzLldvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgbWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVyID0gQ29kZXI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmNvbmNhdCkodGhpcy4jZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhTGVuZ3RoOyB9XG4gICAgI3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBleHBvcnRzLldvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKCgwLCBpbmRleF9qc18xLmNvbmNhdCkoW2J5dGVzLCBQYWRkaW5nLnNsaWNlKHBhZGRpbmdPZmZzZXQpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBOdW1lcmljIGl0ZW07IHBhZCBvbiB0aGUgbGVmdCAqdG8qIFdvcmRTaXplXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldFZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIEluc2VydHMgYSBudW1lcmljIHBsYWNlLWhvbGRlciwgcmV0dXJuaW5nIGEgY2FsbGJhY2sgdGhhdCBjYW5cbiAgICAvLyBiZSB1c2VkIHRvIGFzanVzdCB0aGUgdmFsdWUgbGF0ZXJcbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLiNkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKFBhZGRpbmcpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGV4cG9ydHMuV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlciA9IFdyaXRlcjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFJlYWRlciB7XG4gICAgLy8gQWxsb3dzIGluY29tcGxldGUgdW5wYWRkZWQgZGF0YSB0byBiZSByZWFkOyBvdGhlcndpc2UgYW4gZXJyb3JcbiAgICAvLyBpcyByYWlzZWQgaWYgYXR0ZW1wdGluZyB0byBvdmVycnVuIHRoZSBidWZmZXIuIFRoaXMgaXMgcmVxdWlyZWRcbiAgICAvLyB0byBkZWFsIHdpdGggYW4gb2xkIFNvbGlkaXR5IGJ1ZywgaW4gd2hpY2ggZXZlbnQgZGF0YSBmb3JcbiAgICAvLyBleHRlcm5hbCAobm90IHB1YmxpYyB0aG9ndWgpIHdhcyB0aWdodGx5IHBhY2tlZC5cbiAgICBhbGxvd0xvb3NlO1xuICAgICNkYXRhO1xuICAgICNvZmZzZXQ7XG4gICAgI2J5dGVzUmVhZDtcbiAgICAjcGFyZW50O1xuICAgICNtYXhJbmZsYXRpb247XG4gICAgY29uc3RydWN0b3IoZGF0YSwgYWxsb3dMb29zZSwgbWF4SW5mbGF0aW9uKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xuICAgICAgICB0aGlzLiNkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShkYXRhKTtcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4SW5mbGF0aW9uID0gKG1heEluZmxhdGlvbiAhPSBudWxsKSA/IG1heEluZmxhdGlvbiA6IDEwMjQ7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkodGhpcy4jZGF0YSk7IH1cbiAgICBnZXQgZGF0YUxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGEubGVuZ3RoOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGJ5dGVzKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jZGF0YSk7IH1cbiAgICAjaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQuI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkICs9IGNvdW50O1xuICAgICAgICAvLyBDaGVjayBmb3IgZXhjZXNzaXZlIGluZmxhdGlvbiAoc2VlOiAjNDUzNylcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0aGlzLiNtYXhJbmZsYXRpb24gPCAxIHx8IHRoaXMuI2J5dGVzUmVhZCA8PSB0aGlzLiNtYXhJbmZsYXRpb24gKiB0aGlzLmRhdGFMZW5ndGgsIGBjb21wcmVzc2VkIEFCSSBkYXRhIGV4Y2VlZHMgaW5mbGF0aW9uIHJhdGlvIG9mICR7dGhpcy4jbWF4SW5mbGF0aW9ufSAoIHNlZTogaHR0cHM6L1xcL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9pc3N1ZXMvNDUzNyApYCwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodGhpcy4jZGF0YSksIG9mZnNldDogdGhpcy4jb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBjb3VudCwgaW5mbzoge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuZGF0YUxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gZXhwb3J0cy5Xb3JkU2l6ZSkgKiBleHBvcnRzLldvcmRTaXplO1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCA+IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsaWduZWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiAoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy5hbGxvd0xvb3NlLCB0aGlzLiNtYXhJbmZsYXRpb24pO1xuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvQmlnSW50KSh0aGlzLnJlYWRCeXRlcyhleHBvcnRzLldvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvTnVtYmVyKSh0aGlzLnJlYWRCeXRlcyhleHBvcnRzLldvcmRTaXplKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkZXIgPSBSZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc0NvZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9tYXRocy5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgoMCwgbWF0aHNfanNfMS50b0JlSGV4KShyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzQ29kZXIgPSBBZGRyZXNzQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bbm9ueW1vdXNDb2RlciA9IHZvaWQgMDtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcbiAqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5vbnltb3VzQ29kZXIgPSBBbm9ueW1vdXNDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJyYXlDb2RlciA9IGV4cG9ydHMudW5wYWNrID0gZXhwb3J0cy5wYWNrID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBhbm9ueW1vdXNfanNfMSA9IHJlcXVpcmUoXCIuL2Fub255bW91cy5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShuYW1lLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCF1bmlxdWVbbmFtZV0sIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoY29kZXJzLmxlbmd0aCA9PT0gYXJyYXlWYWx1ZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBhYnN0cmFjdF9jb2Rlcl9qc18xLldyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuV3JpdGVyKCk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMucGFjayA9IHBhY2s7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXN0aWdhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICBrZXlzLnB1c2goY29kZXIubG9jYWxOYW1lIHx8IG51bGwpO1xuICAgIH0pO1xuICAgIHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLlJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbmV4cG9ydHMudW5wYWNrID0gdW5wYWNrO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgY29kZXIsIGxlbmd0aCB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudENvdW50KSh2YWx1ZS5sZW5ndGgsIGNvdW50LCBcImNvZGVyIGFycmF5XCIgKyAodGhpcy5sb2NhbE5hbWUgPyAoXCIgXCIgKyB0aGlzLmxvY2FsTmFtZSkgOiBcIlwiKSk7XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2godGhpcy5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHN0cmF5IHJhbmRvbSBkYXRhIGlzIG5vdCBiZWluZyByZWFkIGFzIGEgbGVuZ3RoLiBFYWNoXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcbiAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuICAgICAgICAgICAgLy8gdGlnaHRlciBib3VuZCwgYnV0IHdlIGFyZSBlcnJvcmluZyBvbiB0aGUgc2lkZSBvZiBzYWZldHkuXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGNvdW50ICogYWJzdHJhY3RfY29kZXJfanNfMS5Xb3JkU2l6ZSA8PSByZWFkZXIuZGF0YUxlbmd0aCwgXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogcmVhZGVyLmJ5dGVzLCBvZmZzZXQ6IGNvdW50ICogYWJzdHJhY3RfY29kZXJfanNfMS5Xb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IGFub255bW91c19qc18xLkFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG5leHBvcnRzLkFycmF5Q29kZXIgPSBBcnJheUNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvb2xlYW5Db2RlciA9IHZvaWQgMDtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuQ29kZXIgPSBCb29sZWFuQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlc0NvZGVyID0gZXhwb3J0cy5EeW5hbWljQnl0ZXNDb2RlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh2YWx1ZSk7XG4gICAgICAgIGxldCBsZW5ndGggPSB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gd3JpdGVyLndyaXRlQnl0ZXModmFsdWUpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGVzKHJlYWRlci5yZWFkSW5kZXgoKSwgdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5EeW5hbWljQnl0ZXNDb2RlciA9IER5bmFtaWNCeXRlc0NvZGVyO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlc0NvZGVyID0gQnl0ZXNDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaXhlZEJ5dGVzQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpeGVkQnl0ZXNDb2RlciA9IEZpeGVkQnl0ZXNDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdWxsQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIE51bGxDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5OdWxsQ29kZXIgPSBOdWxsQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdW1iZXJDb2RlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB0eXBlZF9qc18xID0gcmVxdWlyZShcIi4uL3R5cGVkLmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgYWJzdHJhY3RfY29kZXJfanNfMS5Db2RlciB7XG4gICAgc2l6ZTtcbiAgICBzaWduZWQ7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gKDAsIGluZGV4X2pzXzEuZ2V0QmlnSW50KSh0eXBlZF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2RpbmdcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9ICgwLCBpbmRleF9qc18xLm1hc2spKEJOX01BWF9VSU5UMjU2LCBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9ICgwLCBpbmRleF9qc18xLm1hc2spKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzEudG9Ud29zKSh2YWx1ZSwgOCAqIGFic3RyYWN0X2NvZGVyX2pzXzEuV29yZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+ICgwLCBpbmRleF9qc18xLm1hc2spKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgdmFsdWUgPSAoMCwgaW5kZXhfanNfMS5tYXNrKShyZWFkZXIucmVhZFZhbHVlKCksIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzEuZnJvbVR3b3MpKHZhbHVlLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJDb2RlciA9IE51bWJlckNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdDb2RlciA9IHZvaWQgMDtcbmNvbnN0IHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91dGY4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGJ5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgYnl0ZXNfanNfMS5EeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW5jb2RlKHdyaXRlciwgKDAsIHV0ZjhfanNfMS50b1V0ZjhCeXRlcykodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGY4X2pzXzEudG9VdGY4U3RyaW5nKShzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdDb2RlciA9IFN0cmluZ0NvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UdXBsZUNvZGVyID0gdm9pZCAwO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIik7XG5jb25zdCB0eXBlZF9qc18xID0gcmVxdWlyZShcIi4uL3R5cGVkLmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuY29uc3QgYXJyYXlfanNfMSA9IHJlcXVpcmUoXCIuL2FycmF5LmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwidHVwbGVcIik7XG4gICAgICAgIHJldHVybiAoMCwgYXJyYXlfanNfMS5wYWNrKSh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBhcnJheV9qc18xLnVucGFjaykocmVhZGVyLCB0aGlzLmNvZGVycyk7XG4gICAgfVxufVxuZXhwb3J0cy5UdXBsZUNvZGVyID0gVHVwbGVDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQSBmcmFnbWVudCBpcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gQUJJLCB3aGljaCBtYXkgcmVwcmVzZW50IGFueSBvZjpcbiAqXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxuICogIC0gW0V2ZW50c10oRXZlbnRGcmFnbWVudClcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcbiAqICAtIFtGYWxsYmFjayBvciBSZWNlaXZlXShGYWxsYmFja0ZyYWdtZW50KSBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGV4cG9ydHMuRmFsbGJhY2tGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuTmFtZWRGcmFnbWVudCA9IGV4cG9ydHMuRnJhZ21lbnQgPSBleHBvcnRzLlBhcmFtVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke3RvcC50eXBlfSAke0pTT04uc3RyaW5naWZ5KHRvcC50ZXh0KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwiQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3BlbmluZyBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudGV4dCArPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleElkUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoS2V5d29yZHMuaGFzKHRva2VuLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiS0VZV09SRFwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQubWF0Y2gocmVnZXhUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIlRZUEVcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleE51bWJlclByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiTlVNQkVSXCI7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW4gJHtKU09OLnN0cmluZ2lmeShjdXJbMF0pfSBhdCBwb3NpdGlvbiAke29mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0b2tlbnMubWFwKCh0KSA9PiBPYmplY3QuZnJlZXplKHQpKSk7XG59XG4vLyBDaGVjayBvbmx5IG9uZSBvZiBgYWxsb3dlZGAgaXMgaW4gYHNldGBcbmZ1bmN0aW9uIGFsbG93U2luZ2xlKHNldCwgYWxsb3dlZCkge1xuICAgIGxldCBpbmNsdWRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93ZWQua2V5cygpKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0aW5nIHR5cGVzOiAke2luY2x1ZGVkLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG4vLyBGdW5jdGlvbnMgdG8gcHJvY2VzcyBhIFNvbGlkaXR5IFNpZ25hdHVyZSBUb2tlblN0cmluZyBmcm9tIGxlZnQtdG8tcmlnaHQgZm9yLi4uXG4vLyAuLi50aGUgbmFtZSB3aXRoIGFuIG9wdGlvbmFsIHR5cGUsIHJldHVybmluZyB0aGUgbmFtZVxuZnVuY3Rpb24gY29uc3VtZU5hbWUodHlwZSwgdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrS2V5d29yZChLd1R5cGVzKSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgIGlmIChrZXl3b3JkICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX0sIGdvdCAke2tleXdvcmR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5wb3BUeXBlKFwiSURcIik7XG59XG4vLyAuLi5hbGwga2V5d29yZHMgbWF0Y2hpbmcgYWxsb3dlZCwgcmV0dXJuaW5nIHRoZSBrZXl3b3Jkc1xuZnVuY3Rpb24gY29uc3VtZUtleXdvcmRzKHRva2VucywgYWxsb3dlZCkge1xuICAgIGNvbnN0IGtleXdvcmRzID0gbmV3IFNldCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PSBudWxsIHx8IChhbGxvd2VkICYmICFhbGxvd2VkLmhhcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUga2V5d29yZHM6ICR7SlNPTi5zdHJpbmdpZnkoa2V5d29yZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZHMuYWRkKGtleXdvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShrZXl3b3Jkcyk7XG59XG4vLyAuLi5hbGwgdmlzaWJpbGl0eSBrZXl3b3JkcywgcmV0dXJuaW5nIHRoZSBjb2FsZXNjZWQgbXV0YWJpbGl0eVxuZnVuY3Rpb24gY29uc3VtZU11dGFiaWxpdHkodG9rZW5zKSB7XG4gICAgbGV0IG1vZGlmaWVycyA9IGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIEt3VmlzaWIpO1xuICAgIC8vIERldGVjdCBjb25mbGljdGluZyBtb2RpZmllcnNcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcImNvbnN0YW50IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwicHVyZSB2aWV3IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIC8vIFByb2Nlc3MgbXV0YWJpbGl0eSBzdGF0ZXNcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInZpZXdcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInB1cmVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicHVyZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcIm5vbnBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGxlZ2FjeSBgY29uc3RhbnRgIGxhc3RcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcImNvbnN0YW50XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xufVxuLy8gLi4uYSBwYXJhbWV0ZXIgbGlzdCwgcmV0dXJuaW5nIHRoZSBQYXJhbVR5cGUgbGlzdFxuZnVuY3Rpb24gY29uc3VtZVBhcmFtcyh0b2tlbnMsIGFsbG93SW5kZXhlZCkge1xuICAgIHJldHVybiB0b2tlbnMucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0LCBhbGxvd0luZGV4ZWQpKTtcbn1cbi8vIC4uLmEgZ2FzIGxpbWl0LCByZXR1cm5pbmcgYSBCaWdOdW1iZXIgb3IgbnVsbCBpZiBub25lXG5mdW5jdGlvbiBjb25zdW1lR2FzKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJBVFwiKSkge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJOVU1CRVJcIikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRCaWdJbnQpKHRva2Vucy5wb3AoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGdhc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb25zdW1lRW9pKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbnMgYXQgb2Zmc2V0ICR7dG9rZW5zLm9mZnNldH06ICR7dG9rZW5zLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxufVxuY29uc3QgcmVnZXhBcnJheVR5cGUgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZnVuY3Rpb24gdmVyaWZ5QmFzaWNUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhUeXBlKTtcbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIC8vIGludFhYIG9yIHVpbnRYWFxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuLy8gTWFrZSB0aGUgRnJhZ21lbnQgY29uc3RydWN0b3JzIGVmZmVjdGl2ZWx5IHByaXZhdGVcbmNvbnN0IF9ndWFyZCA9IHt9O1xuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc19pbnRlcm5hbFwiKTtcbmNvbnN0IFBhcmFtVHlwZUludGVybmFsID0gXCJfUGFyYW1UeXBlSW50ZXJuYWxcIjtcbmNvbnN0IEVycm9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Vycm9ySW50ZXJuYWxcIjtcbmNvbnN0IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCA9IFwiX0V2ZW50SW50ZXJuYWxcIjtcbmNvbnN0IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0NvbnN0cnVjdG9ySW50ZXJuYWxcIjtcbmNvbnN0IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0ZhbGxiYWNrSW50ZXJuYWxcIjtcbmNvbnN0IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Z1bmN0aW9uSW50ZXJuYWxcIjtcbmNvbnN0IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgPSBcIl9TdHJ1Y3RJbnRlcm5hbFwiO1xuLyoqXG4gKiAgRWFjaCBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgW1tGcmFnbWVudF1dIGlzIGFuIEFycmF5IG9mICoqUGFyYW1UeXBlKiouXG4gKi9cbmNsYXNzIFBhcmFtVHlwZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgKG9yIGBgXCJcImBgIGlmIHVuYm91bmQpXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlKGFkZHJlc3MpXCJgYCxcbiAgICAgKiAgYGBcInVpbnQyNTZbM11bXVwiYGApXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZVwiYGAsIGBgXCJhcnJheVwiYGApXG4gICAgICovXG4gICAgYmFzZVR5cGU7XG4gICAgLyoqXG4gICAgICogIFRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaXMgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWluZGV4YWJsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGluZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wb25lbnRzIGZvciB0aGUgdHVwbGUuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi10dXBsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGNvbXBvbmVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcnJheSBsZW5ndGgsIG9yIGBgLTFgYCBmb3IgZHluYW1pYy1sZW5ndGhlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5TGVuZ3RoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiBlYWNoIGNoaWxkIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlDaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiUGFyYW1UeXBlXCIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFBhcmFtVHlwZUludGVybmFsIH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IE9iamVjdC5mcmVlemUoY29tcG9uZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoID09IG51bGwgfHwgYXJyYXlDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5TGVuZ3RoICE9IG51bGwgfHwgYXJyYXlDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXG4gICAgICovXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt2YWx1ZV07XG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cbiAgICAgKlxuICAgICAqICBJZiAlJWFsbG93SW5kZXhlZCUlIHRoZW4gdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgaXMgcGVybWl0dGVkLFxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmosIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb20obGV4KG9iaiksIGFsbG93SW5kZXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSghbmFtZSB8fCAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpKSwgXCJpbnZhbGlkIG5hbWVcIiwgXCJvYmoubmFtZVwiLCBuYW1lKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSBvYmouaW5kZXhlZDtcbiAgICAgICAgaWYgKGluZGV4ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXJyYXlNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJhcnJheVwiLCBpbmRleGVkLCBudWxsLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wcyA9IChvYmouY29tcG9uZW50cyAhPSBudWxsKSA/IG9iai5jb21wb25lbnRzLm1hcCgoYykgPT4gUGFyYW1UeXBlLmZyb20oYykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgdHlwZSwgaW5kZXhlZCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgKipQYXJhbVR5cGUqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFBhcmFtVHlwZUludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcmFtVHlwZSA9IFBhcmFtVHlwZTtcbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50IGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIkZyYWdtZW50XCIpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyB0eXBlLCBpbnB1dHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRnJhZ21lbnQqKiBmb3IgJSVvYmolJSwgd2ljaCBjYW4gYmUgYW55IHN1cHBvcnRlZFxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucGVla0tleXdvcmQoS3dUeXBlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBKU09OIEFCSVxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgZnJnYW1lbnQgb2JqZWN0XCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tDb25zdHJ1Y3RvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXJyb3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0V2ZW50RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0Z1bmN0aW9uRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW1N0cnVjdEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzU3RydWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudFxuICogIHdoaWNoIGhhcyBhIG5hbWUgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSwgXCJpbnZhbGlkIGlkZW50aWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZWRGcmFnbWVudCA9IE5hbWVkRnJhZ21lbnQ7XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5pZCkodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLkVycm9yRnJhZ21lbnQgPSBFcnJvckZyYWdtZW50O1xuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGFuIEV2ZW50LlxuICovXG5jbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhbm9ueW1vdXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRXZlbnQgdG9waWMgaGFzaC5cbiAgICAgKi9cbiAgICBnZXQgdG9waWNIYXNoKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaWQpKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiAmJiB0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdG9waWMgaGFzaCBmb3IgYW4gZXZlbnQgd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBFdmVudEZyYWdtZW50O1xuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgY29uc3RydWN0b3IuXG4gKi9cbmNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHBheWFibGUsIGdhcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3RvciBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQgIT09IFwic2lnaGFzaFwiLCBcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIiB9KTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XG4gICAgICAgIGlmICh0aGlzLnBheWFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipDb25zdHJ1Y3RvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25zdHJ1Y3RvckZyYWdtZW50ID0gQ29uc3RydWN0b3JGcmFnbWVudDtcbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwYXlhYmxlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZhbGxiYWNrIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBjb25zdCB0eXBlID0gKCh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApID8gXCJyZWNlaXZlXCIgOiBcImZhbGxiYWNrXCIpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVNdXRhYmlsaXR5ID0gKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0eXBlfSgpJHt0aGlzLnBheWFibGUgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRmFsbGJhY2tGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRmFsbGJhY2tGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0b3BJc1ZhbGlkID0gb2JqLnBlZWtLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5wdXRzLmxlbmd0aCA9PT0gMCwgYHJlY2VpdmUgY2Fubm90IGhhdmUgYXJndW1lbnRzYCwgXCJvYmouaW5wdXRzXCIsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInBheWFibGVcIl0pKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soKSBbcGF5YWJsZV1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKGJ5dGVzKSBbcGF5YWJsZV0gcmV0dXJucyAoYnl0ZXMpXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgaW5wdXRzXCIsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShvdXRwdXRzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIG91dHB1dHNcIiwgXCJvYmoub3V0cHV0c1wiLCBvdXRwdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gKG9iai5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgcGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZGVzY3JpcHRpb25cIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZhbGxiYWNrRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRmFsbGJhY2tGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBGYWxsYmFja0ZyYWdtZW50O1xuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5jbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBpcyBjb25zdGFudCAoZS5nLiBgYHB1cmVgYCBvciBgYHZpZXdgYCBmdW5jdGlvbnMpLlxuICAgICAqL1xuICAgIGNvbnN0YW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcmV0dXJuZWQgdHlwZXMgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG91dHB1dHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0ZSBtdXRhYmlsaXR5IChlLmcuIGBgcGF5YWJsZWBgLCBgYG5vbnBheWFibGVgYCwgYGB2aWV3YGBcbiAgICAgKiAgb3IgYGBwdXJlYGApXG4gICAgICovXG4gICAgc3RhdGVNdXRhYmlsaXR5O1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCB0byBzZW5kIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmdW5jdGlvblwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgb3V0cHV0cyA9IE9iamVjdC5mcmVlemUob3V0cHV0cy5zbGljZSgpKTtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBzdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaWQpKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG8pID0+IEpTT04ucGFyc2Uoby5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc3RhdGVNdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicmV0dXJuc1wiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5vdXRwdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNlbGVjdG9yIGZvciBhIGZ1bmN0aW9uIHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIFwidmlld1wiLCBwYXJhbXMsIFtdLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnNlbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZ1bmN0aW9uRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBmdW5jdGlvbiBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJmdW5jdGlvblwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBtdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlTXV0YWJpbGl0eSA9IG9iai5zdGF0ZU11dGFiaWxpdHk7XG4gICAgICAgIC8vIFVzZSBsZWdhY3kgU29saWRpdHkgQUJJIGxvZ2ljIGlmIHN0YXRlTXV0YWJpbGl0eSBpcyBtaXNzaW5nXG4gICAgICAgIGlmIChzdGF0ZU11dGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChvYmouY29uc3RhbnQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IHZlcmlmeVN0YXRlIGZvciBzdGF0ZU11dGFiaWxpdHkgKGUuZy4gdGhyb3cgaWZcbiAgICAgICAgLy8gICAgICAgIHBheWFibGU6IGZhbHNlIGJ1dCBzdGF0ZU11dGFiaWxpdHkgaXMgXCJub25wYXlhYmxlXCIpXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBzdGF0ZU11dGFiaWxpdHksIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgb2JqLm91dHB1dHMgPyBvYmoub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRnVuY3Rpb25GcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IEZ1bmN0aW9uRnJhZ21lbnQ7XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJzdHJ1Y3RcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBTdHJ1Y3RGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0cnVjdCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqU3RydWN0RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdEZyYWdtZW50ID0gU3RydWN0RnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGUgQXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAoQUJJKSBkZXNjcmliZXMgaG93IG1ldGhvZCBpbnB1dFxuICogIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGVuY29kZWQsIHRoZWlyIHJlc3VsdHMgZGVjb2RlZCwgYW5kIGhvdyB0b1xuICogIGRlY29kZSBldmVudHMgYW5kIGVycm9ycy5cbiAqXG4gKiAgU2VlIFtBYm91dCBBQklzXShkb2NzLWFiaSkgZm9yIG1vcmUgZGV0YWlscyBob3cgdGhleSBhcmUgdXNlZC5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmk6QXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAgW2Fib3V0LWFiaV1cbiAqICBAX25hdlRpdGxlOiBBQklcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZCA9IGV4cG9ydHMuUmVzdWx0ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuRXJyb3JEZXNjcmlwdGlvbiA9IGV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5JbmRleGVkID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGV4cG9ydHMuU3RydWN0RnJhZ21lbnQgPSBleHBvcnRzLlBhcmFtVHlwZSA9IGV4cG9ydHMuTmFtZWRGcmFnbWVudCA9IGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGV4cG9ydHMuRnJhZ21lbnQgPSBleHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBleHBvcnRzLkVycm9yRnJhZ21lbnQgPSBleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLkFiaUNvZGVyID0gdm9pZCAwO1xuLy8vLy8vXG52YXIgYWJpX2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYmktY29kZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpX2NvZGVyX2pzXzEuQWJpQ29kZXI7IH0gfSk7XG52YXIgYnl0ZXMzMl9qc18xID0gcmVxdWlyZShcIi4vYnl0ZXMzMi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUJ5dGVzMzJTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzMzJfanNfMS5kZWNvZGVCeXRlczMyU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMzMl9qc18xLmVuY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG52YXIgZnJhZ21lbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9mcmFnbWVudHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdHJ1Y3RvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5Db25zdHJ1Y3RvckZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkV2ZW50RnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5GYWxsYmFja0ZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25GcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRnVuY3Rpb25GcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVkRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLk5hbWVkRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLlBhcmFtVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cnVjdEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5TdHJ1Y3RGcmFnbWVudDsgfSB9KTtcbnZhciBpbnRlcmZhY2VfanNfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUmVzdWx0RXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5jaGVja1Jlc3VsdEVycm9yczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZGV4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkluZGV4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkludGVyZmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLkVycm9yRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dEZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlX2pzXzEuTG9nRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5SZXN1bHQ7IH0gfSk7XG52YXIgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVkX2pzXzEuVHlwZWQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5JbmRleGVkID0gZXhwb3J0cy5FcnJvckRlc2NyaXB0aW9uID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuUmVzdWx0ID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFiaV9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJpLWNvZGVyLmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUmVzdWx0RXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLmNoZWNrUmVzdWx0RXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLlJlc3VsdDsgfSB9KTtcbmNvbnN0IGZyYWdtZW50c19qc18xID0gcmVxdWlyZShcIi4vZnJhZ21lbnRzLmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLmpzXCIpO1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxuICogIGZvciBwYXJzaW5nLCBhICoqTG9nRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoZSBgYHRvcGljMGBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvcGljIGhhc2ggZm9yIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICB0b3BpYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gTG9nRGVzY3JpcHRpb247XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXG4gKiAgYSAqKlRyYW5zYWN0aW9uRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBGdW5jdGlvbiBzaWduYXR1cmUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yLCB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRXJyb3Igd2l0aCBgYHJldmVydGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkVycm9yRGVzY3JpcHRpb24gPSBFcnJvckRlc2NyaXB0aW9uO1xuLyoqXG4gKiAgQW4gKipJbmRleGVkKiogaXMgdXNlZCBhcyBhIHZhbHVlIHdoZW4gYSB2YWx1ZSB0aGF0IGRvZXMgbm90XG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXG4gKiAgYXJyYXlzLCB0dXBsZXMsIGJ5dGVzIGFuZCBzdHJpbmdzLlxuICovXG5jbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmRleGVkID0gSW5kZXhlZDtcbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTMvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWw/aGlnaGxpZ2h0PXBhbmljI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxuICAgIFwiMVwiOiBcImFzc2VydChmYWxzZSlcIixcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxuICAgIFwiMzNcIjogXCJlbnVtIG92ZXJmbG93XCIsXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcbiAgICBcIjUwXCI6IFwib3V0LW9mLWJvdW5kcyBhY2Nlc3Mgb2YgYW4gYXJyYXkgb3IgYnl0ZXNOXCIsXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxufTtcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XG4gICAgXCIweDA4YzM3OWEwXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgcmVhc29uOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZWFzb24gPSBcInVua25vd24gcGFuaWMgY29kZVwiO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogIEFuIEludGVyZmFjZSBhYnN0cmFjdHMgbWFueSBvZiB0aGUgbG93LWxldmVsIGRldGFpbHMgZm9yXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxuICpcbiAqICBBbiBBQkkgcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGVuY29kZSBkYXRhIHRvIHNlbmQgdG9cbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxuICpcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxuICovXG5jbGFzcyBJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxuICAgICAqL1xuICAgIGZyYWdtZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGRlcGxveTtcbiAgICAvKipcbiAgICAgKiAgVGhlIEZhbGxiYWNrIG1ldGhvZCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHJlY2VpdmU7XG4gICAgI2Vycm9ycztcbiAgICAjZXZlbnRzO1xuICAgICNmdW5jdGlvbnM7XG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcbiAgICAjYWJpQ29kZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICBsZXQgYWJpID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiaSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Vycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZnJhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFncy5wdXNoKGZyYWdtZW50c19qc18xLkZyYWdtZW50LmZyb20oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtXYXJuaW5nXSBJbnZhbGlkIEZyYWdtZW50ICR7SlNPTi5zdHJpbmdpZnkoYSl9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50czogT2JqZWN0LmZyZWV6ZShmcmFncylcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2FiaUNvZGVyID0gdGhpcy5nZXRBYmlDb2RlcigpO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0O1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCFmYWxsYmFjayB8fCBmcmFnbWVudC5wYXlhYmxlICE9PSBmYWxsYmFjay5wYXlhYmxlLCBcImNvbmZsaWN0aW5nIGZhbGxiYWNrIGZyYWdtZW50c1wiLCBgZnJhZ21lbnRzWyR7aW5kZXh9XWAsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gZmFsbGJhY2sucGF5YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Z1bmN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR3byBpZGVudGljYWwgZW50cmllczsgaWdub3JlIGl0XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXQuaGFzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXQuc2V0KHNpZ25hdHVyZSwgZnJhZ21lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBkZXBsb3k6IGZyYWdtZW50c19qc18xLkNvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShcImNvbnN0cnVjdG9yKClcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIGFiaV9jb2Rlcl9qc18xLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKShrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNmdW5jdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gKHZhbHVlcy5sZW5ndGggPiAwKSA/IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGFsbG93T3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVkX2pzXzEuVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRfanNfMS5UeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBwYXN0IHRoZSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2luZ2xlIG1hdGNoaW5nIHNpZ25hdHVyZSB3aXRoIGFuIG92ZXJyaWRlcywgYnV0IHRoZVxuICAgICAgICAgICAgLy8gbGFzdCB2YWx1ZSBpcyBzb21ldGhpbmcgdGhhdCBjYW5ub3QgcG9zc2libHkgYmUgYW4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCAhPT0gbWF0Y2hpbmdbMF0uaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QXJnID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShsYXN0QXJnKSB8fCB0eXBlb2YgKGxhc3RBcmcpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChmcmFnbWVudHNfanNfMS5GdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhIGZ1bmN0aW9uIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yXG4gICAgICogIGZ1bmN0aW9uIHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGEgZnVuY3Rpb24gbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0Z1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uXG4gICAgICogIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZnVuY3Rpb25zIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBmdW5jdGlvbiBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBmdW5jdGlvbnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Z1bmN0aW9ucy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZnVuY3Rpb25zLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRFdmVudChrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gRXZlbnRUb3BpY1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXZlbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VG9waWMgPT09IGZyYWdtZW50LnRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlZF9qc18xLlR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBhbWJpZ3VvdXMgZXZlbnQgZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50cy5nZXQoZnJhZ21lbnRzX2pzXzEuRXZlbnRGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBldmVudCBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRFdmVudE5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Vycm9ycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Vycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGFtYmlndW91cyBlcnJvciBkZXNjcmlwdGlvbiAoaS5lLiAke21hdGNoU3RyfSlgLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBrZXkgPSBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvcihzdHJpbmcpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Vycm9ycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXJyb3JzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNlcnJvcnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Vycm9ycy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIDQtYnl0ZSBzZWxlY3RvciB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICAvKlxuZ2V0U2VsZWN0b3IoZnJhZ21lbnQ6IEVycm9yRnJhZ21lbnQgfCBGdW5jdGlvbkZyYWdtZW50KTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBBcnJheTxGcmFnbWVudD4gPSBbIF07XG5cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpKTsgfSBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRFcnJvcig8c3RyaW5nPmZyYWdtZW50KSk7IH0gY2F0Y2ggKF8pIHsgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gZnJhZ21lbnRcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBmcmFnbWVudCBtYXRjaGVzIGZ1bmN0aW9uIGFuZCBlcnJvclwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xufVxuICAgICovXG4gICAgLy8gR2V0IHRoZSAzMi1ieXRlIHRvcGljIGhhc2ggdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIC8qXG4gICAgZ2V0RXZlbnRUb3BpYyhmcmFnbWVudDogRXZlbnRGcmFnbWVudCk6IHN0cmluZyB7XG4gICAgICAgIC8vaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHsgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpOyB9XG4gICAgICAgIHJldHVybiBpZChmcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgICovXG4gICAgX2RlY29kZVBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShwYXJhbXMsIGRhdGEpO1xuICAgIH1cbiAgICBfZW5jb2RlUGFyYW1zKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUocGFyYW1zLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyBhIGBgdHguZGF0YWBgIG9iamVjdCBmb3IgZGVwbG95aW5nIHRoZSBDb250cmFjdCB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZXJyb3IgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBlcnJvciAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsICgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlICUlZGF0YSUlIGZyb20gYSB0cmFuc2FjdGlvbiBgYHR4LmRhdGFgYCBmb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlVHJhbnNhY3Rpb25dXSBtZXRob2RcbiAgICAgKiAgaW5zdGVhZCwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsICgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlc0NvcHkpKGRhdGEpO1xuICAgICAgICBpZiAoKGJ5dGVzLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcImNvdWxkIG5vdCBkZWNvZGUgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHJldHVybmVkIGRhdGEgd2l0aCBubyBlcnJvciwgYnV0IHRoZSBkYXRhIGlzIGp1bmtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgbWVzc2FnZSwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKF9kYXRhLCBcImRhdGFcIik7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYWJpX2NvZGVyX2pzXzEuQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oXCJjYWxsXCIsIHR4LCBkYXRhKTtcbiAgICAgICAgLy8gTm90IGEgYnVpbHQtaW4gZXJyb3I7IHRyeSBmaW5kaW5nIGEgY3VzdG9tIGVycm9yXG4gICAgICAgIGNvbnN0IGN1c3RvbVByZWZpeCA9IFwiZXhlY3V0aW9uIHJldmVydGVkICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChjdXN0b21QcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgY29uc3QgZWYgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlZikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZWYuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWYubmFtZSwgc2lnbmF0dXJlOiBlZi5mb3JtYXQoKSwgYXJnc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZWFzb24gPSBlcnJvci5yZXZlcnQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZDogJHtlcnJvci5yZWFzb259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQgKGNvdWx0IG5vdCBkZWNvZGUgY3VzdG9tIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgaW52b2NhdGlvbiwgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIGVycm9yLmludm9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJzZWQubmFtZSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnNlZC5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFyc2VkLmFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgcmVzdWx0IGRhdGEgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkodGhpcy4jYWJpQ29kZXIuZW5jb2RlKGZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvKlxuICAgICAgICBzcGVsdW5rKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4sIHByb2Nlc3NmdW5jOiAodHlwZTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBQcm9taXNlPGFueT4pOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPD4+ID0gWyBdO1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IGZ1bmN0aW9uKHR5cGU6IFBhcmFtVHlwZSwgdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZCh0eXBlLmNoaWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlLiA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgZGVzY2VuZCA9IGZ1bmN0aW9uIChpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG1pc21hdGNoXCIpOyB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxhbnk+ID0gWyBdO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgKi9cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmlkKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzMudG9CZUhleCkodmFsdWUpOyAvLyBAVE9ETzogU2hvdWxkIHRoaXMgdG9Ud29zPz9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL15ieXRlcy8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMy56ZXJvUGFkQnl0ZXMpKHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKSgoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBmcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID09IG51bGwsIFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHZhbHVlcy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKCgwLCBpbmRleF9qc18yLmlkKSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuI2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxuICAgICAgICAgICAgdG9waWNzOiB0b3BpY3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGEgZmlsdGVyIGZvciB0aGUgZXZlbnQgYW5kIHRoZSBzZWFyY2ggY3JpdGVyaWFcbiAgICBkZWNvZGVFdmVudExvZyhmcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKSh0b3BpY3NbMF0sIDMyKSAmJiB0b3BpY3NbMF0udG9Mb3dlckNhc2UoKSA9PT0gZXZlbnRUb3BpYywgXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBcInRvcGljc1swXVwiLCB0b3BpY3NbMF0pO1xuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9uSW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gW107XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2goZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlLmZyb20oeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgKDAsIGluZGV4X2pzXzMuY29uY2F0KSh0b3BpY3MpKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc3QgcmVzdWx0OiAoQXJyYXk8YW55PiAmIHsgWyBrZXk6IHN0cmluZyBdOiBhbnkgfSkgPSBbIF07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQocmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcmFtLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWJzdHJhY3RfY29kZXJfanNfMS5SZXN1bHQuZnJvbUl0ZW1zKHZhbHVlcywga2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSB0cmFuc2FjdGlvbiwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGZ1bmN0aW9uIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJuIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKHR4LmRhdGEsIFwidHguZGF0YVwiKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEuc2xpY2UoMCwgNCkpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbFJlc3VsdChkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmVjZWlwdCBsb2csIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGV2ZW50IGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBldmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBldmVudCBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUxvZyhsb2cpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG4gICAgICAgIC8vICAgICAgICBQcm9iYWJseSBub3QsIGJlY2F1c2UganVzdCBiZWNhdXNlIGl0IGlzIHRoZSBvbmx5IGV2ZW50IGluIHRoZSBBQkkgZG9lc1xuICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGp1c3QgYSBmcmFnbWVudD9cbiAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQudG9waWNIYXNoLCB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmV2ZXJ0IGRhdGEsIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGVycm9yIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBlcnJvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBlcnJvciBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCAoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGhleERhdGEsIDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbSW50ZXJmYWNlXV0gZnJvbSB0aGUgQUJJICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSV2YWx1ZSUlIG1heSBiZSBwcm92aWRlZCBhcyBhbiBleGlzdGluZyBbW0ludGVyZmFjZV1dIG9iamVjdCxcbiAgICAgKiAgYSBKU09OLWVuY29kZWQgQUJJIG9yIGFueSBIdW1hbi1SZWFkYWJsZSBBQkkgZm9ybWF0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYW4gSW50ZXJmYWNlLCB3aGljaCBpcyBpbW11dGFibGVcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlNPTlxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbiBJbnRlcmZhY2U7IHBvc3NpYmx5IGZyb20gYW5vdGhlciB2NiBpbnN0YW5jZVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXRKc29uKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXRKc29uKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgbGVnYWN5IEludGVyZmFjZTsgZnJvbSBhbiBvbGRlciB2ZXJzaW9uXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgZnJhZ21lbnRzXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyZmFjZSA9IEludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgVHlwZWQgb2JqZWN0IGFsbG93cyBhIHZhbHVlIHRvIGhhdmUgaXRzIHR5cGUgZXhwbGljaXRseVxuICogIHNwZWNpZmllZC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGluIFNvbGlkaXR5LCB0aGUgdmFsdWUgYGA0NWBgIGNvdWxkIHJlcHJlc2VudCBhXG4gKiAgYGB1aW50OGBgIG9yIGEgYGB1aW50MjU2YGAuIFRoZSB2YWx1ZSBgYDB4MTIzNGBgIGNvdWxkIHJlcHJlc2VudFxuICogIGEgYGBieXRlczJgYCBvciBgYGJ5dGVzYGAuXG4gKlxuICogIFNpbmNlIEphdmFTY3JpcHQgaGFzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGV4cGxpY2l0bHkgaW5mb3JtIGFueVxuICogIEFQSXMgd2hpY2ggd2hhdCB0aGUgdHlwZSBpcywgdGhpcyBhbGxvd3MgdHJhbnNwYXJlbnQgaW50ZXJvcGVyYXRpb25cbiAqICB3aXRoIFNvbGRpdHkuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2FiaTpUeXBlZCBWYWx1ZXNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0UHJpdmF0ZSkoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBfdHlwZWRTeW1ib2wsIHR5cGUsIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbHVlIGlzIHZhbGlkXG4gICAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBGb3JtYXQgdGhlIHR5cGUgYXMgYSBIdW1hbi1SZWFkYWJsZSB0eXBlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcImR5bmFtaWNBcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgdHVwbGUoJHt0aGlzLnZhbHVlLm1hcCgodikgPT4gdi5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgdHlwZS5cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWluVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWF4VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkQmlnSW50XV0uXG4gICAgICovXG4gICAgaXNCaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLnR5cGUubWF0Y2goL151P2ludFswLTldKyQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWREYXRhXV0uXG4gICAgICovXG4gICAgaXNEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZFN0cmluZ11dLlxuICAgICAqL1xuICAgIGlzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0dXBsZSBuYW1lLCBpZiB0aGlzIGlzIGEgdHVwbGUuIFRocm93cyBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IHR1cGxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYSB0dXBsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgdHlwZSBhcyBhbiBhcnJheVxuICAgIC8vIC0gYG51bGxgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIHVuZm9yY2VkLCBpdCBjb3VsZCBiZSBkeW5hbWljXG4gICAgLy8gLSBgLTFgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIGR5bmFtaWNcbiAgICAvLyAtIGFueSBvdGhlciB2YWx1ZSBpbmRpY2F0ZXMgaXQgaXMgYSBzdGF0aWMgYXJyYXkgYW5kIGlzIGl0cyBsZW5ndGhcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB0eXBlIG9yIGBgLTFgYCBpZiBpdCBpcyBkeW5hbWljLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgdHlwZSBpcyBub3QgYW4gYXJyYXkuXG4gICAgICovXG4gICAgZ2V0IGFycmF5TGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqVHlwZWQqKiBvZiAlJXR5cGUlJSB3aXRoIHRoZSAlJXZhbHVlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4KHYpIHsgcmV0dXJuIG4odiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNih2KSB7IHJldHVybiBuKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0KHYpIHsgcmV0dXJuIG4odiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MzIodikgeyByZXR1cm4gbih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0MCh2KSB7IHJldHVybiBuKHYsIDQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQ4KHYpIHsgcmV0dXJuIG4odiwgNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NTYodikgeyByZXR1cm4gbih2LCA1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ2NCh2KSB7IHJldHVybiBuKHYsIDY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDcyKHYpIHsgcmV0dXJuIG4odiwgNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODAodikgeyByZXR1cm4gbih2LCA4MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4OCh2KSB7IHJldHVybiBuKHYsIDg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDk2KHYpIHsgcmV0dXJuIG4odiwgOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEwNCh2KSB7IHJldHVybiBuKHYsIDEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTEyKHYpIHsgcmV0dXJuIG4odiwgMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjAodikgeyByZXR1cm4gbih2LCAxMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyOCh2KSB7IHJldHVybiBuKHYsIDEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTM2KHYpIHsgcmV0dXJuIG4odiwgMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNDQodikgeyByZXR1cm4gbih2LCAxNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE1Mih2KSB7IHJldHVybiBuKHYsIDE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYwKHYpIHsgcmV0dXJuIG4odiwgMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjgodikgeyByZXR1cm4gbih2LCAxNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE3Nih2KSB7IHJldHVybiBuKHYsIDE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTg0KHYpIHsgcmV0dXJuIG4odiwgMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxOTIodikgeyByZXR1cm4gbih2LCAxOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwMCh2KSB7IHJldHVybiBuKHYsIDIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjA4KHYpIHsgcmV0dXJuIG4odiwgMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMTYodikgeyByZXR1cm4gbih2LCAyMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIyNCh2KSB7IHJldHVybiBuKHYsIDIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjMyKHYpIHsgcmV0dXJuIG4odiwgMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDAodikgeyByZXR1cm4gbih2LCAyNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0OCh2KSB7IHJldHVybiBuKHYsIDI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjU2KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OCh2KSB7IHJldHVybiBuKHYsIC04KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNih2KSB7IHJldHVybiBuKHYsIC0xNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQodikgeyByZXR1cm4gbih2LCAtMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDMyKHYpIHsgcmV0dXJuIG4odiwgLTMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0MCh2KSB7IHJldHVybiBuKHYsIC00MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDgodikgeyByZXR1cm4gbih2LCAtNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDU2KHYpIHsgcmV0dXJuIG4odiwgLTU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ2NCh2KSB7IHJldHVybiBuKHYsIC02NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NzIodikgeyByZXR1cm4gbih2LCAtNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgwKHYpIHsgcmV0dXJuIG4odiwgLTgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4OCh2KSB7IHJldHVybiBuKHYsIC04OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OTYodikgeyByZXR1cm4gbih2LCAtOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMDQodikgeyByZXR1cm4gbih2LCAtMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTEyKHYpIHsgcmV0dXJuIG4odiwgLTExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyMCh2KSB7IHJldHVybiBuKHYsIC0xMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjgodikgeyByZXR1cm4gbih2LCAtMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTM2KHYpIHsgcmV0dXJuIG4odiwgLTEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE0NCh2KSB7IHJldHVybiBuKHYsIC0xNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE1Mih2KSB7IHJldHVybiBuKHYsIC0xNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjAodikgeyByZXR1cm4gbih2LCAtMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTY4KHYpIHsgcmV0dXJuIG4odiwgLTE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE3Nih2KSB7IHJldHVybiBuKHYsIC0xNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxODQodikgeyByZXR1cm4gbih2LCAtMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxOTIodikgeyByZXR1cm4gbih2LCAtMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjAwKHYpIHsgcmV0dXJuIG4odiwgLTIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwOCh2KSB7IHJldHVybiBuKHYsIC0yMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMTYodikgeyByZXR1cm4gbih2LCAtMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjI0KHYpIHsgcmV0dXJuIG4odiwgLTIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIzMih2KSB7IHJldHVybiBuKHYsIC0yMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDAodikgeyByZXR1cm4gbih2LCAtMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgLTI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI1Nih2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxKHYpIHsgcmV0dXJuIGIodiwgMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMih2KSB7IHJldHVybiBiKHYsIDIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczModikgeyByZXR1cm4gYih2LCAzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM0KHYpIHsgcmV0dXJuIGIodiwgNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNSh2KSB7IHJldHVybiBiKHYsIDUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczYodikgeyByZXR1cm4gYih2LCA2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM3KHYpIHsgcmV0dXJuIGIodiwgNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOCh2KSB7IHJldHVybiBiKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczkodikgeyByZXR1cm4gYih2LCA5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTAodikgeyByZXR1cm4gYih2LCAxMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczExKHYpIHsgcmV0dXJuIGIodiwgMTEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMih2KSB7IHJldHVybiBiKHYsIDEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTModikgeyByZXR1cm4gYih2LCAxMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE0KHYpIHsgcmV0dXJuIGIodiwgMTQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNSh2KSB7IHJldHVybiBiKHYsIDE1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTYodikgeyByZXR1cm4gYih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE3KHYpIHsgcmV0dXJuIGIodiwgMTcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMThgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOCh2KSB7IHJldHVybiBiKHYsIDE4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTkodikgeyByZXR1cm4gYih2LCAxOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIwKHYpIHsgcmV0dXJuIGIodiwgMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMSh2KSB7IHJldHVybiBiKHYsIDIxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjIodikgeyByZXR1cm4gYih2LCAyMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIzKHYpIHsgcmV0dXJuIGIodiwgMjMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNCh2KSB7IHJldHVybiBiKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjUodikgeyByZXR1cm4gYih2LCAyNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI2KHYpIHsgcmV0dXJuIGIodiwgMjYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNyh2KSB7IHJldHVybiBiKHYsIDI3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjgodikgeyByZXR1cm4gYih2LCAyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI5KHYpIHsgcmV0dXJuIGIodiwgMjkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMCh2KSB7IHJldHVybiBiKHYsIDMwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzEodikgeyByZXR1cm4gYih2LCAzMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMyKHYpIHsgcmV0dXJuIGIodiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFkZHJlc3NgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkcmVzcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFkZHJlc3NcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYm9vbGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBib29sKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYm9vbFwiLCAhIXYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYnl0ZXNcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgc3RyaW5nYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInN0cmluZ1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhcnJheWBgIHR5cGUgZm9yICUldiUlLCBhbGxvd2luZyAlJWR5bmFtaWMlJSBsZW5ndGguXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5KHYsIGR5bmFtaWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYXJyYXlcIiwgdiwgZHluYW1pYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB0dXBsZWBgIHR5cGUgZm9yICUldiUlLCB3aXRoIHRoZSBvcHRpb25hbCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHVwbGUodiwgbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJ0dXBsZVwiLCB2LCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlcyh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcIm92ZXJyaWRlc1wiLCBPYmplY3QuYXNzaWduKHt9LCB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiAlJXZhbHVlJSUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzVHlwZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZVxuICAgICAgICAgICAgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICYmIFwiX3R5cGVkU3ltYm9sXCIgaW4gdmFsdWVcbiAgICAgICAgICAgICYmIHZhbHVlLl90eXBlZFN5bWJvbCA9PT0gX3R5cGVkU3ltYm9sKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRoZSB2YWx1ZSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZSwgdmFsaWRhdGVzIHRoZSB1bmRlcmx5aW5nIHZhbHVlXG4gICAgICogIGFuZCByZXR1cm5zIGl0LCBvdGhlcndpc2UgcmV0dXJucyB2YWx1ZSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHRoYXQgd2l0aCB0byBhY2NlcHQgZWl0aGVyIGEgW1tUeXBlZF1dXG4gICAgICogIG9iamVjdCBvciB2YWx1ZXMuXG4gICAgICovXG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZTogZXhwZWNldGQgJHt0eXBlfSwgZ290ICR7dmFsdWUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZCA9IFR5cGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEljYXBBZGRyZXNzID0gZXhwb3J0cy5nZXRBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KShleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuY29uc3Qgc2FmZURpZ2l0cyA9IDE1O1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogQk5fMzYgKyBCYXNlMzZbdmFsdWVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXG4gKiAgVGhpcyBhY2NlcHRzIG5vbi1jaGVja3N1bSBhZGRyZXNzZXMsIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmRcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cbiAqXG4gKiAgVGhlIGNoZWNrc3VtIGluIEV0aGVyZXVtIHVzZXMgdGhlIGNhcGl0YWxpemF0aW9uICh1cHBlci1jYXNlXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cbiAqXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xuICogIHZhbGlkYXRlZCwgYW5kIGlmIHRoZSBhZGRyZXNzIGZhaWxzIGl0cyBleHBlY3RlZCBjaGVja3N1bSBhblxuICogIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAgSWYgeW91IHdpc2ggdGhlIGNoZWNrc3VtIG9mICUlYWRkcmVzcyUlIHRvIGJlIGlnbm9yZSwgaXQgc2hvdWxkXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXG4gKiAgdGhhdCB5b3Ugd2lzaCB0byBieXBhc3MgdGhlIHNhZmVnYXVyZHMgaW4gcGxhY2UgdG8gcHJvdGVjdFxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcbiAqICBzb3VyY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcbiAqICAgIGdldEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb252ZXJ0cyBJQ0FQIGFkZHJlc3MgYW5kIGFkZHMgY2hlY2tzdW1cbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xuICogICAgZ2V0QWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpID09PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcyksIFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZnJvbUJhc2UzNihhZGRyZXNzLnN1YnN0cmluZyg0KSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xufVxuZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG5leHBvcnRzLmdldEljYXBBZGRyZXNzID0gZ2V0SWNhcEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGlzQWRkcmVzc2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnRzLmlzQWRkcmVzc2FibGUgPSBpc0FkZHJlc3NhYmxlO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gaXNBZGRyZXNzKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNBZGRyZXNzID0gaXNBZGRyZXNzO1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKHRhcmdldCwgcHJvbWlzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHR5cGVvZiAodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIiwgXCJ1bmNvbmZpZ3VyZWQgbmFtZVwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHsgdmFsdWU6IHRhcmdldCB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBhZGRyZXNzX2pzXzEuZ2V0QWRkcmVzcykocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5mdW5jdGlvbiByZXNvbHZlQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBhZGRyZXNzYWJsZSB2YWx1ZVwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IHJlc29sdmVBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGdldENyZWF0ZUFkZHJlc3ModHgpIHtcbiAgICBjb25zdCBmcm9tID0gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKSh0eC5mcm9tKTtcbiAgICBjb25zdCBub25jZSA9ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKSgoMCwgaW5kZXhfanNfMi5kYXRhU2xpY2UpKCgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzIuZW5jb2RlUmxwKShbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG5leHBvcnRzLmdldENyZWF0ZUFkZHJlc3MgPSBnZXRDcmVhdGVBZGRyZXNzO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEUyYGAgb3BlcmF0aW9uXG4gKiAgd2l0aCB0aGUgZ2l2ZW4gJSVmcm9tJSUsICUlc2FsdCUlIGFuZCAlJWluaXRDb2RlSGFzaCUlLlxuICpcbiAqICBUbyBjb21wdXRlIHRoZSAlJWluaXRDb2RlSGFzaCUlIGZyb20gYSBjb250cmFjdCdzIGluaXQgY29kZSwgdXNlXG4gKiAgdGhlIFtba2VjY2FrMjU2XV0gZnVuY3Rpb24uXG4gKlxuICogIEZvciBhIHF1aWNrIG92ZXJ2aWV3IGFuZCBleGFtcGxlIG9mIGBgQ1JFQVRFMmBgLCBzZWUgW1tsaW5rLXJpY21vby13aXNwc11dLlxuICpcbiAqICBAZXhhbXBsZVxuICogICAgLy8gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIlxuICpcbiAqICAgIC8vIFRoZSBzYWx0XG4gKiAgICBzYWx0ID0gaWQoXCJIZWxsb1dvcmxkXCIpXG4gKlxuICogICAgLy8gVGhlIGhhc2ggb2YgdGhlIGluaXRDb2RlXG4gKiAgICBpbml0Q29kZSA9IFwiMHg2Mzk0MTk4ZGYxNjAwMDUyNjEwM2ZmNjAyMDYwMDQ2MDFjMzM1YWZhNjA0MDUxNjA2MGYzXCI7XG4gKiAgICBpbml0Q29kZUhhc2ggPSBrZWNjYWsyNTYoaW5pdENvZGUpXG4gKlxuICogICAgZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKShfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShfc2FsdCwgXCJzYWx0XCIpO1xuICAgIGNvbnN0IGluaXRDb2RlSGFzaCA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShfaW5pdENvZGVIYXNoLCBcImluaXRDb2RlSGFzaFwiKTtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShpbml0Q29kZUhhc2gubGVuZ3RoID09PSAzMiwgXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBfaW5pdENvZGVIYXNoKTtcbiAgICByZXR1cm4gKDAsIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzKSgoMCwgaW5kZXhfanNfMi5kYXRhU2xpY2UpKCgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzIuY29uY2F0KShbXCIweGZmXCIsIGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcbn1cbmV4cG9ydHMuZ2V0Q3JlYXRlMkFkZHJlc3MgPSBnZXRDcmVhdGUyQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LWFkZHJlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBZGRyZXNzZXMgYXJlIGEgZnVuZGFtZW50YWwgcGFydCBvZiBpbnRlcmFjdGluZyB3aXRoIEV0aGVyZXVtLiBUaGV5XG4gKiAgcmVwcmVzZW50IHRoZSBnbG9hYmFsIGlkZW50aXR5IG9mIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudHMgKGFjY291bnRzXG4gKiAgYmFja2VkIGJ5IGEgcHJpdmF0ZSBrZXkpIGFuZCBjb250cmFjdHMuXG4gKlxuICogIFRoZSBFdGhlcmV1bSBOYW1pbmcgU2VydmljZSAoRU5TKSBwcm92aWRlcyBhbiBpbnRlcmNvbm5lY3RlZCBlY29zeXN0ZW1cbiAqICBvZiBjb250cmFjdHMsIHN0YW5kYXJkcyBhbmQgbGlicmFyaWVzIHdoaWNoIGVuYWJsZSBsb29raW5nIHVwIGFuXG4gKiAgYWRkcmVzcyBmb3IgYW4gRU5TIG5hbWUuXG4gKlxuICogIFRoZXNlIGZ1bmN0aW9ucyBoZWxwIGNvbnZlcnQgYmV0d2VlbiB2YXJpb3VzIGZvcm1hdHMsIHZhbGlkYXRlXG4gKiAgYWRkcmVzc2VzIGFuZCBzYWZlbHkgcmVzb2x2ZSBFTlMgbmFtZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2FkZHJlc3M6QWRkcmVzc2VzICBbYWJvdXQtYWRkcmVzc2VzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3MgPSBleHBvcnRzLmlzQWRkcmVzc2FibGUgPSBleHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGVBZGRyZXNzID0gZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuZ2V0QWRkcmVzcyA9IHZvaWQgMDtcbm51bGw7XG52YXIgYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfanNfMS5nZXRBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SWNhcEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfanNfMS5nZXRJY2FwQWRkcmVzczsgfSB9KTtcbnZhciBjb250cmFjdF9hZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmFjdC1hZGRyZXNzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3JlYXRlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfYWRkcmVzc19qc18xLmdldENyZWF0ZUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDcmVhdGUyQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfYWRkcmVzc19qc18xLmdldENyZWF0ZTJBZGRyZXNzOyB9IH0pO1xudmFyIGNoZWNrc19qc18xID0gcmVxdWlyZShcIi4vY2hlY2tzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBZGRyZXNzYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2tzX2pzXzEuaXNBZGRyZXNzYWJsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2tzX2pzXzEuaXNBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc19qc18xLnJlc29sdmVBZGRyZXNzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlplcm9BZGRyZXNzID0gdm9pZCAwO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnRzLlplcm9BZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3Nlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWmVyb0hhc2ggPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydHMuWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgU29tZSBjb21tb24gY29uc3RhbnRzIHVzZWZ1bCBmb3IgRXRoZXJldW0uXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NvbnN0YW50czogQ29uc3RhbnRzICBbYWJvdXQtY29uc3RhbnRzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VQcmVmaXggPSBleHBvcnRzLkV0aGVyU3ltYm9sID0gZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLk4gPSBleHBvcnRzLlplcm9IYXNoID0gZXhwb3J0cy5aZXJvQWRkcmVzcyA9IHZvaWQgMDtcbnZhciBhZGRyZXNzZXNfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3Nlcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlplcm9BZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzZXNfanNfMS5aZXJvQWRkcmVzczsgfSB9KTtcbnZhciBoYXNoZXNfanNfMSA9IHJlcXVpcmUoXCIuL2hhc2hlcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlplcm9IYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfanNfMS5aZXJvSGFzaDsgfSB9KTtcbnZhciBudW1iZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9udW1iZXJzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWlQZXJFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLldlaVBlckV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWF4VWludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk1heFVpbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaW5JbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bWJlcnNfanNfMS5NaW5JbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhJbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bWJlcnNfanNfMS5NYXhJbnQyNTY7IH0gfSk7XG52YXIgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4vc3RyaW5ncy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyU3ltYm9sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuRXRoZXJTeW1ib2w7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlUHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuTWVzc2FnZVByZWZpeDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLk4gPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgb3JkZXIgTiBmb3IgdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiAgKCoqaS5lLioqIGBgMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxbmBgKVxuICovXG5leHBvcnRzLk4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbnVtYmVyIG9mIHdlaSBpbiBhIHNpbmdsZSBldGhlci5cbiAqXG4gKiAgKCoqaS5lLioqIGBgMTAwMDAwMDAwMDAwMDAwMDAwMG5gYClcbiAqL1xuZXhwb3J0cy5XZWlQZXJFdGhlciA9IEJpZ0ludChcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIik7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgYSBgYHVpbnQyNTZgYC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbmBgKVxuICovXG5leHBvcnRzLk1heFVpbnQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbWluaW11bSB2YWx1ZSBmb3IgYW4gYGBpbnQyNTZgYC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgLTgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBuYGApXG4gKi9cbmV4cG9ydHMuTWluSW50MjU2ID0gQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpICogQmlnSW50KC0xKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbiBgYGludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuYGApXG4gKi9cbmV4cG9ydHMuTWF4SW50MjU2ID0gQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IGV4cG9ydHMuRXRoZXJTeW1ib2wgPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgZXRoZXIgc3ltYm9sIChub3JtYWxpemVkIHVzaW5nIE5GS0MpLlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx1MDM5ZVwiYGApXG4gKi9cbmV4cG9ydHMuRXRoZXJTeW1ib2wgPSBcIlxcdTAzOWVcIjsgLy8gXCJcXHVEODM1XFx1REY2M1wiO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIFtbbGluay1laXAtMTkxXV0gcGVyc29uYWwgbWVzc2FnZSBwcmVmaXguXG4gKlxuICogICgqKmkuZS4qKiBgYFwiXFxcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcXFxuXCJgYClcbiAqL1xuZXhwb3J0cy5NZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMucmVzb2x2ZUFyZ3MgPSBleHBvcnRzLmNvcHlPdmVycmlkZXMgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmNvbnN0IHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYW5SZXNvbHZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBQcmVwYXJlZFRvcGljRmlsdGVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGZyYWdtZW50O1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKSh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0VG9waWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XG4gICAgfVxufVxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcbi8vICAgICB0aGUgcXVhbGlmaWVkIHR5cGUsIG90aGVyd2lzZSBSZXN1bHQpXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXG4vL2V4cG9ydCBpbnRlcmZhY2UgQ29udHJhY3RNZXRob2Q8QSBleHRlbmRzIEFycmF5PGFueT4gPSBBcnJheTxhbnk+LCBSID0gYW55LCBEIGV4dGVuZHMgUiB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSA9IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gaW5kZXhfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkoX292ZXJyaWRlcyk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG5leHBvcnRzLmNvcHlPdmVycmlkZXMgPSBjb3B5T3ZlcnJpZGVzO1xuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5kZXhfanNfMS5UeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmV4cG9ydHMucmVzb2x2ZUFyZ3MgPSByZXNvbHZlQXJncztcbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKSh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9ICgoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxuICAgICAgICBjb25zdCBwYXlhYmxlID0gaWZhY2UucmVjZWl2ZSB8fCAoaWZhY2UuZmFsbGJhY2sgJiYgaWZhY2UuZmFsbGJhY2sucGF5YWJsZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNDYWxsRXhjZXB0aW9uKShlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykobWV0aG9kLCB7XG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZE1ldGhvZChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0ICgwLCBpbmRleF9qc18zLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICB0bzogY29udHJhY3QuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNDYWxsRXhjZXB0aW9uKShlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0YXRpY0NhbGwoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKShtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xuICAgIH07XG4gICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKShuYW1lLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcbiAgICAgICAgdG9waWNzID0gYXdhaXQgZXZlbnQuZ2V0VG9waWNGaWx0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENvbnRyYWN0RXZlbnQ7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2ZlcmBcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcbiAgICAgICAgICAgIHN0YXJ0aW5nID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Yjtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSBvbmUgZW1pdCByZXNvbHZlcyBiZWZvcmUgZmlyaW5nIHRoZSBuZXh0IHRvXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxubGV0IGxhc3RFbWl0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKGNvbnRyYWN0LCBldmVudCk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3NBcmdzID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiAhb25jZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgZ2V0SW50ZXJuYWwoY29udHJhY3QpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XG59XG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYyk7XG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xufVxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgKDAsIGluZGV4X2pzXzIuaXNBZGRyZXNzYWJsZSkodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gaW5kZXhfanNfMS5JbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18zLmlzSGV4U3RyaW5nKSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBmaWx0ZXJzXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBpbmRleF9qc18zLmlzRXJyb3IpKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAoKGlmYWNlLnJlY2VpdmUgfHwgaWZhY2UuZmFsbGJhY2spID8gKGJ1aWxkV3JhcHBlZEZhbGxiYWNrKHRoaXMpKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgaW5kZXhfanNfMy5pc0Vycm9yKShlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHByb3ZpZGVyICE9IG51bGwsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIndhaXRGb3JEZXBsb3ltZW50XCIgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGRlcGxveSB0aGlzIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXG4gICAgICogIFtbQ29udHJhY3RGYWN0b3J5XV0uXG4gICAgICovXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWwodGhpcykuZGVwbG95VHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxuICAgIC8vICAgICAgICBpbiB2NyBhbmQgaW4gYSBwb3RlbnRpYWwgU21hcnRDb250cmFjdCBjbGFzcyBpbiBhbiB1cGNvbWluZ1xuICAgIC8vICAgICAgICB2NiByZWxlYXNlXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcbiAgICAgKiAgJSVmcm9tQmxvY2slJSAoZGVmYXVsdDogYGAwYGApIHRvICUldG9CbG9jayUlIChkZWZhdWx0OiBgYFwibGF0ZXN0XCJgYClcbiAgICAgKiAgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2ssIHRvQmxvY2spIHtcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyh0aGlzLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzX2pzXzEuVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkxvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDb250cmFjdCA9IEJhc2VDb250cmFjdDtcbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcbn1cbi8qKlxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cbiAqL1xuY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWJpL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbnRyYWN0X2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmFjdC5qc1wiKTtcbi8vIEEgPSBBcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yXG4vLyBJID0gSW50ZXJmYWNlIG9mIGRlcGxveWVkIGNvbnRyYWN0c1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0RmFjdG9yeSoqIGlzIHVzZWQgdG8gZGVwbG95IGEgQ29udHJhY3QgdG8gdGhlIGJsb2NrY2hhaW4uXG4gKi9cbmNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgZGVwbG95bWVudCBieXRlY29kZS4gT2Z0ZW4gY2FsbGVkIHRoZSBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBieXRlY29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0UnVubmVyIHRvIGRlcGxveSB0aGUgQ29udHJhY3QgYXMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoICUlYWJpJSUgYW5kICUlYnl0ZWNvZGUlJSxcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVieXRlY29kZSUlIG1heSBiZSB0aGUgYGBieXRlY29kZWBgIHByb3BlcnR5IHdpdGhpbiB0aGVcbiAgICAgKiAgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWJpLCBieXRlY29kZSwgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gaW5kZXhfanNfMS5JbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICAvLyBEZXJlZmVyZW5jZSBTb2xpZGl0eSBieXRlY29kZSBvYmplY3RzIGFuZCBhbGxvdyBhIG1pc3NpbmcgYDB4YC1wcmVmaXhcbiAgICAgICAgaWYgKGJ5dGVjb2RlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFieXRlY29kZS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgICAgICBieXRlY29kZSA9IFwiMHhcIiArIGJ5dGVjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZWNvZGUgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBieXRlY29kZSwgaW50ZXJmYWNlOiBpZmFjZSwgcnVubmVyOiAocnVubmVyIHx8IG51bGwpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udHJhY3RfanNfMS5CYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRvIGRlcGxveSB0aGUgY29udHJhY3QsIHBhc3NpbmcgJSVhcmdzJSVcbiAgICAgKiAgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZGVwbG95O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCAoMCwgY29udHJhY3RfanNfMS5jb3B5T3ZlcnJpZGVzKShhcmdzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0ICgwLCBjb250cmFjdF9qc18xLnJlc29sdmVBcmdzKSh0aGlzLnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW3RoaXMuYnl0ZWNvZGUsIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShyZXNvbHZlZEFyZ3MpXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBDb250cmFjdCBkZXBsb3llZCBieSBwYXNzaW5nICUlYXJncyUlIGludG8gdGhlXG4gICAgICogIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXNvbHZlIHRvIHRoZSBDb250cmFjdCBiZWZvcmUgaXQgaGFzIGJlZW4gZGVwbG95ZWQgdG8gdGhlXG4gICAgICogIG5ldHdvcmssIHNvIHRoZSBbW0Jhc2VDb250cmFjdC13YWl0Rm9yRGVwbG95bWVudF1dIHNob3VsZCBiZSB1c2VkIGJlZm9yZVxuICAgICAqICBzZW5kaW5nIGFueSB0cmFuc2FjdGlvbnMgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMucnVubmVyICYmIHR5cGVvZiAodGhpcy5ydW5uZXIuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiLCBcImZhY3RvcnkgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW50VHggPSBhd2FpdCB0aGlzLnJ1bm5lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzIuZ2V0Q3JlYXRlQWRkcmVzcykoc2VudFR4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb250cmFjdF9qc18xLkJhc2VDb250cmFjdChhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIsIHNlbnRUeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgYnl0ZWNvZGUsXG4gICAgICogIGJ1dCBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RmFjdG9yeSh0aGlzLmludGVyZmFjZSwgdGhpcy5ieXRlY29kZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIGZyb20gdGhlIHN0YW5kYXJkIFNvbGlkaXR5IEpTT04gb3V0cHV0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU29saWRpdHkob3V0cHV0LCBydW5uZXIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKG91dHB1dCAhPSBudWxsLCBcImJhZCBjb21waWxlciBvdXRwdXRcIiwgXCJvdXRwdXRcIiwgb3V0cHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiAob3V0cHV0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgb3V0cHV0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IG91dHB1dC5hYmk7XG4gICAgICAgIGxldCBieXRlY29kZSA9IFwiXCI7XG4gICAgICAgIGlmIChvdXRwdXQuYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gb3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dC5ldm0gJiYgb3V0cHV0LmV2bS5ieXRlY29kZSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSBvdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBydW5uZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gQ29udHJhY3RGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5kZWNvZGVkRXZlbnRMb2cgPSBleHBvcnRzLkV2ZW50TG9nID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZXhwb3J0cy5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRQYXlsb2FkID0gZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5CYXNlQ29udHJhY3QgPSB2b2lkIDA7XG4vKipcbiAqICBBICoqQ29udHJhY3QqKiBvYmplY3QgaXMgYSBtZXRhLWNsYXNzIChhIGNsYXNzIHdob3NlIGRlZmluaXRpb24gaXNcbiAqICBkZWZpbmVkIGF0IHJ1bnRpbWUpLCB3aGljaCBjb21tdW5pY2F0ZXMgd2l0aCBhIGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0XG4gKiAgb24gdGhlIGJsb2NrY2hhaW4gYW5kIHByb3ZpZGVzIGEgc2ltcGxlIEphdmFTY3JpcHQgaW50ZXJmYWNlIHRvIGNhbGxcbiAqICBtZXRob2RzLCBzZW5kIHRyYW5zYWN0aW9uLCBxdWVyeSBoaXN0b3JpYyBsb2dzIGFuZCBsaXN0ZW4gZm9yIGl0cyBldmVudHMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NvbnRyYWN0OkNvbnRyYWN0cyAgW2Fib3V0LWNvbnRyYWN0c11cbiAqL1xudmFyIGNvbnRyYWN0X2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmFjdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfanNfMS5CYXNlQ29udHJhY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfanNfMS5Db250cmFjdDsgfSB9KTtcbnZhciBmYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi9mYWN0b3J5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5X2pzXzEuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xudmFyIHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0RXZlbnRQYXlsb2FkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50TG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLkV2ZW50TG9nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5kZWNvZGVkRXZlbnRMb2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdyYXBwZXJzX2pzXzEuVW5kZWNvZGVkRXZlbnRMb2c7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuVW5kZWNvZGVkRXZlbnRMb2cgPSBleHBvcnRzLkV2ZW50TG9nID0gdm9pZCAwO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuY29uc3QgcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuY2xhc3MgRXZlbnRMb2cgZXh0ZW5kcyBwcm92aWRlcl9qc18xLkxvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxufVxuZXhwb3J0cy5FdmVudExvZyA9IEV2ZW50TG9nO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBwcm92aWRlcl9qc18xLkxvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmRlY29kZWRFdmVudExvZyA9IFVuZGVjb2RlZEV2ZW50TG9nO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBsb2dzIGZvciBhbnkgW1tMb2ddXSB3aGljaCBoYXMgYSBtYXRjaGluZyBldmVudCBpbiB0aGVcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBsb2cudG9waWNzLmxlbmd0aCA/IHRoaXMuI2lmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLiNpZmFjZSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ7XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxuICogIFtbQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHRdXSB3aGVuIHdhaXRlZCBvbi5cbiAqL1xuY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBkb2VzIG5vdCBtYXRjaCBhbnkgZXZlbnRzIGluIHRoZSBBQkkuXG4gKi9cbmNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIGluZGV4X2pzXzEuRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZDtcbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuY2xhc3MgQ29udHJhY3RFdmVudFBheWxvYWQgZXh0ZW5kcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIG5ldyBFdmVudExvZyhfbG9nLCBjb250cmFjdC5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIHRoaXMubG9nLmRhdGEsIHRoaXMubG9nLnRvcGljcyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBDb250cmFjdEV2ZW50UGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMucGJrZGYyU3luYyA9IGV4cG9ydHMuY3JlYXRlSG1hYyA9IGV4cG9ydHMuY3JlYXRlSGFzaCA9IHZvaWQgMDtcbnZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcnlwdG9fMS5jcmVhdGVIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEuY3JlYXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBia2RmMlN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLnBia2RmMlN5bmM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEucmFuZG9tQnl0ZXM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVIbWFjID0gdm9pZCAwO1xuLyoqXG4gKiAgQW4gKipITUFDKiogZW5hYmxlcyB2ZXJpZmljYXRpb24gdGhhdCBhIGdpdmVuIGtleSB3YXMgdXNlZFxuICogIHRvIGF1dGhlbnRpY2F0ZSBhIHBheWxvYWQuXG4gKlxuICogIFNlZTogW1tsaW5rLXdpa2ktaG1hY11dXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpITUFDICBbYWJvdXQtaG1hY11cbiAqL1xuY29uc3QgY3J5cHRvX2pzXzEgPSByZXF1aXJlKFwiLi9jcnlwdG8uanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBjcnlwdG9fanNfMS5jcmVhdGVIbWFjKShhbGdvcml0aG0sIGtleSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX2NvbXB1dGVIbWFjID0gX2NvbXB1dGVIbWFjO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBITUFDIGZvciAlJWRhdGElJSB1c2luZyB0aGUgJSVrZXklJSBrZXkgd2l0aCB0aGUgdW5kZXJseWluZ1xuICogICUlYWxnbyUlIHVzZWQgZm9yIGNvbXByZXNzaW9uLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtleSA9IGlkKFwic29tZS1zZWNyZXRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBITUFDXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVG8gY29tcHV0ZSB0aGUgSE1BQyBvZiBVVEYtOCBkYXRhLCB0aGUgZGF0YSBtdXN0IGJlXG4gKiAgICAvLyBjb252ZXJ0ZWQgdG8gVVRGLTggYnl0ZXNcbiAqICAgIGNvbXB1dGVIbWFjKFwic2hhMjU2XCIsIGtleSwgdG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZFwiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVIbWFjKGFsZ29yaXRobSwgX2tleSwgX2RhdGEpIHtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2tleSwgXCJrZXlcIik7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX2NvbXB1dGVIbWFjKGFsZ29yaXRobSwga2V5LCBkYXRhKSk7XG59XG5leHBvcnRzLmNvbXB1dGVIbWFjID0gY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5fID0gX2NvbXB1dGVIbWFjO1xuY29tcHV0ZUhtYWMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmNvbXB1dGVIbWFjLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXB1dGVIbWFjIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19jb21wdXRlSG1hYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShjb21wdXRlSG1hYyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9jayBvZiBFdGhlcmV1bSBpcyB0aGUgdW5kZXJseWluZ1xuICogIGNyeXB0b2dyYXBoaWMgcHJpbWl0aXZlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvY3J5cHRvOkNyeXB0b2dyYXBoaWMgRnVuY3Rpb25zICAgW2Fib3V0LWNyeXB0b11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2NrID0gZXhwb3J0cy5TaWduYXR1cmUgPSBleHBvcnRzLlNpZ25pbmdLZXkgPSBleHBvcnRzLnNjcnlwdFN5bmMgPSBleHBvcnRzLnNjcnlwdCA9IGV4cG9ydHMucGJrZGYyID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5jb21wdXRlSG1hYyA9IHZvaWQgMDtcbm51bGw7XG4vLyBXZSBpbXBvcnQgYWxsIHRoZXNlIHNvIHdlIGNhbiBleHBvcnQgbG9jaygpXG5jb25zdCBobWFjX2pzXzEgPSByZXF1aXJlKFwiLi9obWFjLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUhtYWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhtYWNfanNfMS5jb21wdXRlSG1hYzsgfSB9KTtcbmNvbnN0IGtlY2Nha19qc18xID0gcmVxdWlyZShcIi4va2VjY2FrLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwia2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZWNjYWtfanNfMS5rZWNjYWsyNTY7IH0gfSk7XG5jb25zdCByaXBlbWQxNjBfanNfMSA9IHJlcXVpcmUoXCIuL3JpcGVtZDE2MC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmlwZW1kMTYwX2pzXzEucmlwZW1kMTYwOyB9IH0pO1xuY29uc3QgcGJrZGYyX2pzXzEgPSByZXF1aXJlKFwiLi9wYmtkZjIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYmtkZjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBia2RmMl9qc18xLnBia2RmMjsgfSB9KTtcbmNvbnN0IHJhbmRvbV9qc18xID0gcmVxdWlyZShcIi4vcmFuZG9tLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmFuZG9tQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRvbV9qc18xLnJhbmRvbUJ5dGVzOyB9IH0pO1xuY29uc3Qgc2NyeXB0X2pzXzEgPSByZXF1aXJlKFwiLi9zY3J5cHQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY3J5cHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjcnlwdF9qc18xLnNjcnlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjcnlwdFN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjcnlwdF9qc18xLnNjcnlwdFN5bmM7IH0gfSk7XG5jb25zdCBzaGEyX2pzXzEgPSByZXF1aXJlKFwiLi9zaGEyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGEyX2pzXzEuc2hhMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhNTEyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGEyX2pzXzEuc2hhNTEyOyB9IH0pO1xudmFyIHNpZ25pbmdfa2V5X2pzXzEgPSByZXF1aXJlKFwiLi9zaWduaW5nLWtleS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25pbmdLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25pbmdfa2V5X2pzXzEuU2lnbmluZ0tleTsgfSB9KTtcbnZhciBzaWduYXR1cmVfanNfMSA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hdHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmF0dXJlX2pzXzEuU2lnbmF0dXJlOyB9IH0pO1xuLyoqXG4gKiAgT25jZSBjYWxsZWQsIHByZXZlbnRzIGFueSBmdXR1cmUgY2hhbmdlIHRvIHRoZSB1bmRlcmx5aW5nIGNyeXB0b2dyYXBoaWNcbiAqICBwcmltaXRpdmVzIHVzaW5nIHRoZSBgYC5yZWdpc3RlcmBgIGZlYXR1cmUgZm9yIGhvb2tzLlxuICovXG5mdW5jdGlvbiBsb2NrKCkge1xuICAgIGhtYWNfanNfMS5jb21wdXRlSG1hYy5sb2NrKCk7XG4gICAga2VjY2FrX2pzXzEua2VjY2FrMjU2LmxvY2soKTtcbiAgICBwYmtkZjJfanNfMS5wYmtkZjIubG9jaygpO1xuICAgIHJhbmRvbV9qc18xLnJhbmRvbUJ5dGVzLmxvY2soKTtcbiAgICByaXBlbWQxNjBfanNfMS5yaXBlbWQxNjAubG9jaygpO1xuICAgIHNjcnlwdF9qc18xLnNjcnlwdC5sb2NrKCk7XG4gICAgc2NyeXB0X2pzXzEuc2NyeXB0U3luYy5sb2NrKCk7XG4gICAgc2hhMl9qc18xLnNoYTI1Ni5sb2NrKCk7XG4gICAgc2hhMl9qc18xLnNoYTUxMi5sb2NrKCk7XG4gICAgcmFuZG9tX2pzXzEucmFuZG9tQnl0ZXMubG9jaygpO1xufVxuZXhwb3J0cy5sb2NrID0gbG9jaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtlY2NhazI1NiA9IHZvaWQgMDtcbmNvbnN0IHNoYTNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2tlY2NhazI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBzaGEzXzEua2VjY2FrXzI1NikoZGF0YSk7XG59O1xubGV0IF9fa2VjY2FrMjU2ID0gX2tlY2NhazI1Njtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgS0VDQ0FLMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXG4gKiAgaGFzaCBvZiBVVEYtOCBkYXRhIHVzZSB0aGUgW1tpZF1dIGZ1bmN0aW9uLlxuICpcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZWNjYWsyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gU3RyaW5ncyBhcmUgYXNzdW1lZCB0byBiZSBEYXRhSGV4U3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbFxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxuICogICAga2VjY2FrMjU2KFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5mdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xua2VjY2FrMjU2Ll8gPSBfa2VjY2FrMjU2O1xua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5rZWNjYWsyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fa2VjY2FrMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGtlY2NhazI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBICoqUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24qKiBpcyBkZXNpZ25lZCB0byBjcmVhdGVcbiAqICBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN1aXRpYmxlIGFzIGEgKiprZXkqKiBmcm9tIGEgaHVtYW4tcmVtZW1iZXJhYmxlXG4gKiAgcGFzc3dvcmQuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpQYXNzd29yZHMgIFthYm91dC1wYmtkZl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYmtkZjIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fanNfMSA9IHJlcXVpcmUoXCIuL2NyeXB0by5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfcGJrZGYyID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLnBia2RmMlN5bmMpKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pO1xufTtcbmxldCBfX3Bia2RmMiA9IF9wYmtkZjI7XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbbGluay1wYmtkZjJdXSBmb3IgJSVrZXlsZW4lJSBieXRlcyBmb3IgJSVwYXNzd29yZCUlIHVzaW5nXG4gKiAgdGhlICUlc2FsdCUlIGFuZCB1c2luZyAlJWl0ZXJhdGlvbnMlJSBvZiAlJWFsZ28lJS5cbiAqXG4gKiAgVGhpcyBQQktERiBpcyBvdXRkYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cywgYnV0IGlzXG4gKiAgcmVxdWlyZWQgdG8gZGVjcnlwdCBvbGRlciBmaWxlcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIFBCS0RGMlxuICogICAgcGJrZGYyKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDE2LCBcInNoYTI1NlwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBwYmtkZjIoX3Bhc3N3b3JkLCBfc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3Bhc3N3b3JkLCBcInBhc3N3b3JkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykpO1xufVxuZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjI7XG5wYmtkZjIuXyA9IF9wYmtkZjI7XG5wYmtkZjIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnBia2RmMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYmtkZjIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3Bia2RmMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShwYmtkZjIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHZvaWQgMDtcbi8qKlxuICogIEEgKipDcnlwdG9ncmFwaGljYWxseSBTZWN1cmUgUmFuZG9tIFZhbHVlKiogaXMgb25lIHRoYXQgaGFzIGJlZW5cbiAqICBnZW5lcmF0ZWQgd2l0aCBhZGRpdGlvbmFsIGNhcmUgdGFrZSB0byBwcmV2ZW50IHNpZGUtY2hhbm5lbHNcbiAqICBmcm9tIGFsbG93aW5nIG90aGVycyB0byBkZXRlY3QgaXQgYW5kIHByZXZlbnQgb3RoZXJzIGZyb20gdGhyb3VnaFxuICogIGNvaW5jaWRlbmNlIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlcy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlJhbmRvbSBWYWx1ZXMgIFthYm91dC1jcnlwdG8tcmFuZG9tXVxuICovXG5jb25zdCBjcnlwdG9fanNfMSA9IHJlcXVpcmUoXCIuL2NyeXB0by5qc1wiKTtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKDAsIGNyeXB0b19qc18xLnJhbmRvbUJ5dGVzKShsZW5ndGgpKTtcbn07XG5sZXQgX19yYW5kb21CeXRlcyA9IF9yYW5kb21CeXRlcztcbi8qKlxuICogIFJldHVybiAlJWxlbmd0aCUlIGJ5dGVzIG9mIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gZGF0YS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByYW5kb21CeXRlcyg4KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gX19yYW5kb21CeXRlcyhsZW5ndGgpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xucmFuZG9tQnl0ZXMuXyA9IF9yYW5kb21CeXRlcztcbnJhbmRvbUJ5dGVzLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5yYW5kb21CeXRlcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21CeXRlcyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcmFuZG9tQnl0ZXMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmFuZG9tQnl0ZXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSB2b2lkIDA7XG5jb25zdCByaXBlbWQxNjBfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MFwiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkoZGF0YSk7XG59O1xubGV0IF9fcmlwZW1kMTYwID0gX3JpcGVtZDE2MDtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgUklQRU1ELTE2MCBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByaXBlbWQxNjAoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHJpcGVtZDE2MChcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHJpcGVtZDE2MChuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5mdW5jdGlvbiByaXBlbWQxNjAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKF9fcmlwZW1kMTYwKGRhdGEpKTtcbn1cbmV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xucmlwZW1kMTYwLl8gPSBfcmlwZW1kMTYwO1xucmlwZW1kMTYwLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5yaXBlbWQxNjAucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJpcGVtZDE2MCBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcmlwZW1kMTYwID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHJpcGVtZDE2MCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjcnlwdFN5bmMgPSBleHBvcnRzLnNjcnlwdCA9IHZvaWQgMDtcbmNvbnN0IHNjcnlwdF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2NyeXB0XCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmxldCBsb2NrZWRTeW5jID0gZmFsc2UsIGxvY2tlZEFzeW5jID0gZmFsc2U7XG5jb25zdCBfc2NyeXB0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcykge1xuICAgIHJldHVybiBhd2FpdCAoMCwgc2NyeXB0XzEuc2NyeXB0QXN5bmMpKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcyB9KTtcbn07XG5jb25zdCBfc2NyeXB0U3luYyA9IGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgcmV0dXJuICgwLCBzY3J5cHRfMS5zY3J5cHQpKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiB9KTtcbn07XG5sZXQgX19zY3J5cHRBc3luYyA9IF9zY3J5cHRBc3luYztcbmxldCBfX3NjcnlwdFN5bmMgPSBfc2NyeXB0U3luYztcbi8qKlxuICogIFRoZSBbW2xpbmstd2lraS1zY3J5cHRdXSB1c2VzIGEgbWVtb3J5IGFuZCBjcHUgaGFyZCBtZXRob2Qgb2ZcbiAqICBkZXJpdmF0aW9uIHRvIGluY3JlYXNlIHRoZSByZXNvdXJjZSBjb3N0IHRvIGJydXRlLWZvcmNlIGEgcGFzc3dvcmRcbiAqICBmb3IgYSBnaXZlbiBrZXkuXG4gKlxuICogIFRoaXMgbWVhbnMgdGhpcyBhbGdvcml0aG0gaXMgaW50ZW50aW9uYWxseSBzbG93LCBhbmQgY2FuIGJlIHR1bmVkIHRvXG4gKiAgYmVjb21lIHNsb3dlci4gQXMgY29tcHV0YXRpb24gYW5kIG1lbW9yeSBzcGVlZCBpbXByb3ZlIG92ZXIgdGltZSxcbiAqICBpbmNyZWFzaW5nIHRoZSBkaWZmaWN1bHR5IG1haW50YWlucyB0aGUgY29zdCBvZiBhbiBhdHRhY2tlci5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGlmIGEgdGFyZ2V0IHRpbWUgb2YgNSBzZWNvbmRzIGlzIHVzZWQsIGEgbGVnaXRpbWF0ZSB1c2VyXG4gKiAgd2hpY2gga25vd3MgdGhlaXIgcGFzc3dvcmQgcmVxdWlyZXMgb25seSA1IHNlY29uZHMgdG8gdW5sb2NrIHRoZWlyXG4gKiAgYWNjb3VudC4gQSA2IGNoYXJhY3RlciBwYXNzd29yZCBoYXMgNjggYmlsbGlvbiBwb3NzaWJpbGl0aWVzLCB3aGljaFxuICogIHdvdWxkIHJlcXVpcmUgYW4gYXR0YWNrZXIgdG8gaW52ZXN0IG92ZXIgMTAsMDAwIHllYXJzIG9mIENQVSB0aW1lLiBUaGlzXG4gKiAgaXMgb2YgY291cnNlIGEgY3J1ZGUgZXhhbXBsZSAoYXMgcGFzc3dvcmQgZ2VuZXJhbGx5IGFyZW4ndCByYW5kb20pLFxuICogIGJ1dCBkZW1vbnN0cmF0ZXMgdG8gdmFsdWUgb2YgaW1wb3NpbmcgbGFyZ2UgY29zdHMgdG8gZGVjcnlwdGlvbi5cbiAqXG4gKiAgRm9yIHRoaXMgcmVhc29uLCBpZiBidWlsZGluZyBhIFVJIHdoaWNoIGludm9sdmVkIGRlY3J5cHRpbmcgb3JcbiAqICBlbmNyeXB0aW5nIGRhdHNhIHVzaW5nIHNjcnlwdCwgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFcbiAqICBbW1Byb2dyZXNzQ2FsbGJhY2tdXSAoYXMgZXZlbnQgc2hvcnQgcGVyaW9kcyBjYW4gc2VlbSBsaWsgYW4gZXRlcm5pdHlcbiAqICBpZiB0aGUgVUkgZnJlZXplcykuIEluY2x1ZGluZyB0aGUgcGhyYXNlIC8vXCJkZWNyeXB0aW5nXCIvLyBpbiB0aGUgVUlcbiAqICBjYW4gYWxzbyBoZWxwLCBhc3N1cmluZyB0aGUgdXNlciB0aGVpciB3YWl0aW5nIGlzIGZvciBhIGdvb2QgcmVhc29uLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIHNjcnlwdFxuICogICAgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDgsIDEsIDE2KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5hc3luYyBmdW5jdGlvbiBzY3J5cHQoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IHBhc3N3ZCA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfcGFzc3dkLCBcInBhc3N3ZFwiKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKGF3YWl0IF9fc2NyeXB0QXN5bmMocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpKTtcbn1cbmV4cG9ydHMuc2NyeXB0ID0gc2NyeXB0O1xuc2NyeXB0Ll8gPSBfc2NyeXB0QXN5bmM7XG5zY3J5cHQubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkQXN5bmMgPSB0cnVlOyB9O1xuc2NyeXB0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkQXN5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NyeXB0IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zY3J5cHRBc3luYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzY3J5cHQpO1xuLyoqXG4gKiAgUHJvdmlkZXMgYSBzeW5jaHJvbm91cyB2YXJpYW50IG9mIFtbc2NyeXB0XV0uXG4gKlxuICogIFRoaXMgd2lsbCBjb21wbGV0ZWx5IGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgaW4gYSBicm93c2VyIGFuZCB3aWxsXG4gKiAgcHJldmVudCBhbnkgZXZlbnQgbG9vcCBmcm9tIHByb2dyZXNzaW5nLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzXG4gKiAgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZhcmlhbnRdKHNjcnlwdCkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHRTeW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDgsIDEsIDE2KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBzY3J5cHRTeW5jKF9wYXNzd2QsIF9zYWx0LCBOLCByLCBwLCBka0xlbikge1xuICAgIGNvbnN0IHBhc3N3ZCA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfcGFzc3dkLCBcInBhc3N3ZFwiKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKF9fc2NyeXB0U3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSk7XG59XG5leHBvcnRzLnNjcnlwdFN5bmMgPSBzY3J5cHRTeW5jO1xuc2NyeXB0U3luYy5fID0gX3NjcnlwdFN5bmM7XG5zY3J5cHRTeW5jLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZFN5bmMgPSB0cnVlOyB9O1xuc2NyeXB0U3luYy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZFN5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NyeXB0U3luYyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2NyeXB0U3luYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzY3J5cHRTeW5jKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fanNfMSA9IHJlcXVpcmUoXCIuL2NyeXB0by5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBfc2hhMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUhhc2gpKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUhhc2gpKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcbmxldCBsb2NrZWQyNTYgPSBmYWxzZSwgbG9ja2VkNTEyID0gZmFsc2U7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmZ1bmN0aW9uIHNoYTI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zaGEyNTYoZGF0YSkpO1xufVxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5zaGEyNTYuXyA9IF9zaGEyNTY7XG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcbnNoYTI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGE1MTIoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNoYTUxMihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zaGE1MTIoZGF0YSkpO1xufVxuZXhwb3J0cy5zaGE1MTIgPSBzaGE1MTI7XG5zaGE1MTIuXyA9IF9zaGE1MTI7XG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTUxMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmF0dXJlID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi56ZXJvUGFkVmFsdWUpKCgwLCBpbmRleF9qc18yLnRvQmVBcnJheSkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXV0cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzIuZGF0YUxlbmd0aCkodmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3IgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzIuZGF0YUxlbmd0aCkoX3ZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCBzXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShfdmFsdWUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkocGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSAoMCwgaW5kZXhfanNfMi5nZXROdW1iZXIpKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSh5UGFyaXR5QW5kUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFjdFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5jb25jYXQpKFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuY29uY2F0KShbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIlNpZ25hdHVyZVwiKTtcbiAgICAgICAgdGhpcy4jciA9IHI7XG4gICAgICAgIHRoaXMuI3MgPSBzO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICAgICAgdGhpcy4jbmV0d29ya1YgPSBudWxsO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiBgU2lnbmF0dXJlIHsgcjogXCIke3RoaXMucn1cIiwgczogXCIke3RoaXMuc31cIiwgeVBhcml0eTogJHt0aGlzLnlQYXJpdHl9LCBuZXR3b3JrVjogJHt0aGlzLm5ldHdvcmtWfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgaWRlbnRpY2FsIFtbU2lnbmF0dXJlXV0uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHRoaXMuciwgdGhpcy5zLCB0aGlzLnYpO1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrVikge1xuICAgICAgICAgICAgY2xvbmUuI25ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYGBKU09OLnN0cmluZ2lmeWBgLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBuZXR3b3JrVjogKChuZXR3b3JrViAhPSBudWxsKSA/IG5ldHdvcmtWLnRvU3RyaW5nKCkgOiBudWxsKSxcbiAgICAgICAgICAgIHI6IHRoaXMuciwgczogdGhpcy5zLCB2OiB0aGlzLnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBjaGFpbiBJRCBmcm9tIHRoZSBgYHZgYCBpbiBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWQodikge1xuICAgICAgICBjb25zdCBidiA9ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuICgoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKGNoYWluSWQpICogQk5fMikgKyBCaWdJbnQoMzUgKyB2IC0gMjcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgbm9ybWFsaXplZCBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgZnJvbSBhIGBgeVBhcmlydHlgYCxcbiAgICAgKiAgYSBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgb3IgYSBsZWdhY3kgW1tsaW5rLWVpcC0xNTVdXSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICAvLyBUaGUgdmFsdWVzIDAgYW5kIDEgaW1wbHkgdiBpcyBhY3R1YWxseSB5UGFyaXR5XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDApXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IG5vbi1FSVAtMTU1OSB0cmFuc2FjdGlvbiAoaS5lLiAyNyBvciAyOClcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb24gKGkuZS4gPj0gMzUpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIEludmFsaWQgdmFsdWVzIHRocm93XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDUpXG4gICAgICogICAgLy9fZXJyb3I6XG4gICAgICovXG4gICAgc3RhdGljIGdldE5vcm1hbGl6ZWRWKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoY2hlY2ssIG1lc3NhZ2UsIFwic2lnbmF0dXJlXCIsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoc2lnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgaW5kZXhfanNfMS5aZXJvSGFzaCwgaW5kZXhfanNfMS5aZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoc1swXSAmIDB4ODApID8gMjggOiAyNztcbiAgICAgICAgICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKChzWzBdICYgMHg4MCkgPT09IDAsIFwibm9uLWNhbm9uaWNhbCBzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHMpLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgcmF3IHNpZ25hdHVyZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByXG4gICAgICAgIGNvbnN0IF9yID0gc2lnLnI7XG4gICAgICAgIGFzc2VydEVycm9yKF9yICE9IG51bGwsIFwibWlzc2luZyByXCIpO1xuICAgICAgICBjb25zdCByID0gdG9VaW50MjU2KF9yKTtcbiAgICAgICAgLy8gR2V0IHM7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCBzID0gKGZ1bmN0aW9uIChzLCB5UGFyaXR5QW5kUykge1xuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQyNTYocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKCgwLCBpbmRleF9qc18yLmlzSGV4U3RyaW5nKSh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3Npbmcgc1wiKTtcbiAgICAgICAgfSkoc2lnLnMsIHNpZy55UGFyaXR5QW5kUyk7XG4gICAgICAgIGFzc2VydEVycm9yKCgoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykocylbMF0gJiAweDgwKSA9PSAwLCBcIm5vbi1jYW5vbmljYWwgc1wiKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKDAsIGluZGV4X2pzXzIuaXNIZXhTdHJpbmcpKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2OiAoKCgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICgoMCwgaW5kZXhfanNfMi5nZXROdW1iZXIpKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgKDAsIGluZGV4X2pzXzIuZ2V0TnVtYmVyKShzaWcueVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSA9PT0gcmVzdWx0LnlQYXJpdHksIFwieVBhcml0eSBtaXNtYXRjaFwiKTtcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHlBbmRTID09IG51bGwgfHwgc2lnLnlQYXJpdHlBbmRTID09PSByZXN1bHQueVBhcml0eUFuZFMsIFwieVBhcml0eUFuZFMgbWlzbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TaWduYXR1cmUgPSBTaWduYXR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBZGQgZGV0YWlscyBhYm91dCBzaWduaW5nIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpTaWduaW5nICBbYWJvdXQtc2lnbmluZ11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduaW5nS2V5ID0gdm9pZCAwO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgc2lnbmF0dXJlX2pzXzEgPSByZXF1aXJlKFwiLi9zaWduYXR1cmUuanNcIik7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuY2xhc3MgU2lnbmluZ0tleSB7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTaWduaW5nS2V5KiogZm9yICUlcHJpdmF0ZUtleSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18xLmRhdGFMZW5ndGgpKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI3ByaXZhdGVLZXkgPSAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuI3ByaXZhdGVLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXG4gICAgICogIGFuZCBiZSA2OCBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAzMyBoZXhhZGVjaW1hbFxuICAgICAqICBuaWJibGVzKVxuICAgICAqL1xuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXksIHRydWUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cbiAgICAgKi9cbiAgICBzaWduKGRpZ2VzdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzEuZGF0YUxlbmd0aCkoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5zaWduKCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoZGlnZXN0KSwgKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZV9qc18xLlNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6ICgwLCBpbmRleF9qc18xLnRvQmVIZXgpKHNpZy5yLCAzMiksXG4gICAgICAgICAgICBzOiAoMCwgaW5kZXhfanNfMS50b0JlSGV4KShzaWcucywgMzIpLFxuICAgICAgICAgICAgdjogKHNpZy5yZWNvdmVyeSA/IDB4MWMgOiAweDFiKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFtbbGluay13aWtpLWVjZGhdXSBzaGFyZWQgc2VjcmV0IGJldHdlZW4gdGhpc1xuICAgICAqICBwcml2YXRlIGtleSBhbmQgdGhlICUlb3RoZXIlJSBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhlICUlb3RoZXIlJSBrZXkgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSxcbiAgICAgKiAgYSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJpYyBrZXkgb3IgYXByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEJlc3QgcHJhY3RpY2UgaXMgdXN1YWxseSB0byB1c2UgYSBjcnlwdG9ncmFwaGljIGhhc2ggb24gdGhlXG4gICAgICogIHJldHVybmVkIHZhbHVlIGJlZm9yZSB1c2luZyBpdCBhcyBhIHN5bWV0cmljIHNlY3JldC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduMSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMVwiKSlcbiAgICAgKiAgICBzaWduMiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMlwiKSlcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGF0IHByaXZBLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQikuLi5cbiAgICAgKiAgICBzaWduMS5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24yLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byBwcml2Qi5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkEpLlxuICAgICAqICAgIHNpZ24yLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjEucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShvdGhlcik7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShzZWNwMjU2azFfMS5zZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodGhpcy4jcHJpdmF0ZUtleSksICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShwdWJLZXkpLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgJSVrZXklJSwgb3B0aW9uYWxseSAlJWNvbXByZXNzZWQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVrZXklJSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LCBhXG4gICAgICogIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgb3IgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpO1xuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIGNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXksIHRydWUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIGZhbHNlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBDb21wcmVzc2VkIGEgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocHViS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByYXcgcHVibGljIGtleTsgdXNlIHVuY29tcHJlc3NlZCBrZXkgd2l0aCAweDA0IHByZWZpeFxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgICAgICAgICAgcHViWzBdID0gMHgwNDtcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocG9pbnQudG9SYXdCeXRlcyhjb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGZvciB0aGUgcHJpdmF0ZSBrZXkgd2hpY2ggcHJvZHVjZWQgdGhlXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxuICAgICAqICAgIHNpZyA9IGtleS5zaWduKGRpZ2VzdClcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cbiAgICAgKiAgICBrZXkucHVibGljS2V5XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gdGhlIHJlY292ZXJlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5kYXRhTGVuZ3RoKShkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmF0dXJlX2pzXzEuU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoKDAsIGluZGV4X2pzXzEuY29uY2F0KShbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShkaWdlc3QpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHB1YktleSAhPSBudWxsLCBcImludmFsaWQgc2lnbmF1dHJlIGZvciBkaWdlc3RcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YktleS50b0hleChmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwb2ludCByZXN1bHRpbmcgZnJvbSBhZGRpbmcgdGhlIGVsbGlwaWMgY3VydmUgcG9pbnRzXG4gICAgICogICUlcDAlJSBhbmQgJSVwMSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGEgY29tbW9uIGZ1bmN0aW9uIG1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcmVxdWlyZSwgYnV0XG4gICAgICogIGNhbiBiZSB1c2VmdWwgZm9yIGNlcnRhaW4gcHJpdmFjeS1zcGVjaWZpYyB0ZWNobmlxdWVzLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBpdCBpcyB1c2VkIGJ5IFtbSEROb2RlV2FsbGV0XV0gdG8gY29tcHV0ZSBjaGlsZFxuICAgICAqICBhZGRyZXNzZXMgZnJvbSBwYXJlbnQgcHVibGljIGtleXMgYW5kIGNoYWluIGNvZGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQb2ludHMocDAsIHAxLCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHB1YjAgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMSkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YjAuYWRkKHB1YjEpLnRvSGV4KCEhY29tcHJlc3NlZCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaWduaW5nS2V5ID0gU2lnbmluZ0tleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBleHBvcnRzLlVuZGVjb2RlZEV2ZW50TG9nID0gZXhwb3J0cy5FdmVudExvZyA9IGV4cG9ydHMuQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZXhwb3J0cy5Db250cmFjdEV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gZXhwb3J0cy5NZXNzYWdlUHJlZml4ID0gZXhwb3J0cy5FdGhlclN5bWJvbCA9IGV4cG9ydHMuWmVyb0hhc2ggPSBleHBvcnRzLk4gPSBleHBvcnRzLk1heEludDI1NiA9IGV4cG9ydHMuTWluSW50MjU2ID0gZXhwb3J0cy5NYXhVaW50MjU2ID0gZXhwb3J0cy5XZWlQZXJFdGhlciA9IGV4cG9ydHMuWmVyb0FkZHJlc3MgPSBleHBvcnRzLnJlc29sdmVBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3MgPSBleHBvcnRzLmlzQWRkcmVzc2FibGUgPSBleHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGVBZGRyZXNzID0gZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGV4cG9ydHMuVHlwZWQgPSBleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBleHBvcnRzLlJlc3VsdCA9IGV4cG9ydHMuTG9nRGVzY3JpcHRpb24gPSBleHBvcnRzLkludGVyZmFjZSA9IGV4cG9ydHMuSW5kZXhlZCA9IGV4cG9ydHMuRXJyb3JEZXNjcmlwdGlvbiA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSBleHBvcnRzLlN0cnVjdEZyYWdtZW50ID0gZXhwb3J0cy5QYXJhbVR5cGUgPSBleHBvcnRzLk5hbWVkRnJhZ21lbnQgPSBleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBleHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBleHBvcnRzLkZyYWdtZW50ID0gZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gZXhwb3J0cy5FcnJvckZyYWdtZW50ID0gZXhwb3J0cy5Db25zdHJ1Y3RvckZyYWdtZW50ID0gZXhwb3J0cy5BYmlDb2RlciA9IGV4cG9ydHMuZW5jb2RlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuZGVjb2RlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMuRW5zUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5FbnNSZXNvbHZlciA9IGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JcGNTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBleHBvcnRzLkNoYWluc3RhY2tQcm92aWRlciA9IGV4cG9ydHMuQW5rclByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBleHBvcnRzLkJyb3dzZXJQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjQXBpUHJvdmlkZXIgPSBleHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBleHBvcnRzLkFic3RyYWN0UHJvdmlkZXIgPSBleHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLk5vbmNlTWFuYWdlciA9IGV4cG9ydHMuQWJzdHJhY3RTaWduZXIgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5GZWVEYXRhID0gZXhwb3J0cy5CbG9jayA9IGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSBleHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkU2hhMjU2ID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWQgPSBleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gZXhwb3J0cy5kbnNFbmNvZGUgPSBleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMuZW5zTm9ybWFsaXplID0gZXhwb3J0cy5pZCA9IGV4cG9ydHMuU2lnbmluZ0tleSA9IGV4cG9ydHMuU2lnbmF0dXJlID0gZXhwb3J0cy5sb2NrID0gZXhwb3J0cy5zY3J5cHRTeW5jID0gZXhwb3J0cy5zY3J5cHQgPSBleHBvcnRzLnBia2RmMiA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5leHBvcnRzLmdldFVpbnQgPSBleHBvcnRzLmdldE51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuRmV0Y2hDYW5jZWxTaWduYWwgPSBleHBvcnRzLkZldGNoUmVzcG9uc2UgPSBleHBvcnRzLkZldGNoUmVxdWVzdCA9IGV4cG9ydHMuRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc0NhbGxFeGNlcHRpb24gPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGV4cG9ydHMuYXNzZXJ0Tm9ybWFsaXplID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudENvdW50ID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IGV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy56ZXJvUGFkQnl0ZXMgPSBleHBvcnRzLnN0cmlwWmVyb3NMZWZ0ID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmdldEJ5dGVzQ29weSA9IGV4cG9ydHMuZ2V0Qnl0ZXMgPSBleHBvcnRzLmRhdGFTbGljZSA9IGV4cG9ydHMuZGF0YUxlbmd0aCA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBleHBvcnRzLmRlY29kZUJhc2U2NCA9IGV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBleHBvcnRzLlRyYW5zYWN0aW9uID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSBleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gZXhwb3J0cy5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5GZWVEYXRhTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuRXRoZXJzY2FuUGx1Z2luID0gdm9pZCAwO1xuZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLldvcmRsaXN0T3dsQSA9IGV4cG9ydHMuV29yZGxpc3RPd2wgPSBleHBvcnRzLkxhbmdFbiA9IGV4cG9ydHMuV29yZGxpc3QgPSBleHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuZGVjcnlwdENyb3dkc2FsZUpzb24gPSBleHBvcnRzLmlzS2V5c3RvcmVKc29uID0gZXhwb3J0cy5pc0Nyb3dkc2FsZUpzb24gPSBleHBvcnRzLmdldEluZGV4ZWRBY2NvdW50UGF0aCA9IGV4cG9ydHMuZ2V0QWNjb3VudFBhdGggPSBleHBvcnRzLmRlZmF1bHRQYXRoID0gZXhwb3J0cy5XYWxsZXQgPSBleHBvcnRzLkhETm9kZVZvaWRXYWxsZXQgPSBleHBvcnRzLkhETm9kZVdhbGxldCA9IGV4cG9ydHMuQmFzZVdhbGxldCA9IGV4cG9ydHMuTW5lbW9uaWMgPSBleHBvcnRzLnV1aWRWNCA9IGV4cG9ydHMuZW5jb2RlUmxwID0gZXhwb3J0cy5kZWNvZGVSbHAgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5wYXJzZVVuaXRzID0gZXhwb3J0cy5mb3JtYXRVbml0cyA9IGV4cG9ydHMucGFyc2VFdGhlciA9IGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBleHBvcnRzLm1hc2sgPSBleHBvcnRzLnRvVHdvcyA9IGV4cG9ydHMuZnJvbVR3b3MgPSBleHBvcnRzLnRvUXVhbnRpdHkgPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy50b0JlSGV4ID0gZXhwb3J0cy50b0JpZ0ludCA9IGV4cG9ydHMudG9CZUFycmF5ID0gdm9pZCAwO1xudmFyIF92ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF92ZXJzaW9uX2pzXzEudmVyc2lvbjsgfSB9KTtcbnZhciBpbmRleF9qc18xID0gcmVxdWlyZShcIi4vYWJpL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5kZWNvZGVCeXRlczMyU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5lbmNvZGVCeXRlczMyU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJpQ29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuQWJpQ29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdHJ1Y3RvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkNvbnN0cnVjdG9yRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkVycm9yRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkV2ZW50RnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5GcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZhbGxiYWNrRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRmFsbGJhY2tGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRnVuY3Rpb25GcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVkRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuTmFtZWRGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5QYXJhbVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJ1Y3RGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5TdHJ1Y3RGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUmVzdWx0RXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmNoZWNrUmVzdWx0RXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JEZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5FcnJvckRlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5kZXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5JbmRleGVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJmYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkludGVyZmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ0Rlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkxvZ0Rlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlJlc3VsdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlR5cGVkOyB9IH0pO1xudmFyIGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5nZXRBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SWNhcEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzIuZ2V0SWNhcEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDcmVhdGVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmdldENyZWF0ZUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDcmVhdGUyQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5nZXRDcmVhdGUyQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzIuaXNBZGRyZXNzYWJsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5pc0FkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzczsgfSB9KTtcbnZhciBpbmRleF9qc18zID0gcmVxdWlyZShcIi4vY29uc3RhbnRzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWmVyb0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzMuWmVyb0FkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWlQZXJFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5XZWlQZXJFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1heFVpbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzMuTWF4VWludDI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pbkludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NaW5JbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhJbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzMuTWF4SW50MjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5OOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWmVyb0hhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzMuWmVyb0hhc2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlclN5bWJvbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5FdGhlclN5bWJvbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzMuTWVzc2FnZVByZWZpeDsgfSB9KTtcbnZhciBpbmRleF9qc180ID0gcmVxdWlyZShcIi4vY29udHJhY3QvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuQmFzZUNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuQ29udHJhY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdEZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RFdmVudFBheWxvYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuQ29udHJhY3RFdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRMb2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzQuRXZlbnRMb2c7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmRlY29kZWRFdmVudExvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5VbmRlY29kZWRFdmVudExvZzsgfSB9KTtcbnZhciBpbmRleF9qc181ID0gcmVxdWlyZShcIi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUhtYWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuY29tcHV0ZUhtYWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5yYW5kb21CeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5rZWNjYWsyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyaXBlbWQxNjBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUucmlwZW1kMTYwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnNoYTI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTUxMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5zaGE1MTI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYmtkZjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUucGJrZGYyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyeXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnNjcnlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjcnlwdFN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuc2NyeXB0U3luYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUubG9jazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25hdHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5TaWduYXR1cmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduaW5nS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LlNpZ25pbmdLZXk7IH0gfSk7XG52YXIgaW5kZXhfanNfNiA9IHJlcXVpcmUoXCIuL2hhc2gvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5pZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuc05vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5lbnNOb3JtYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5pc1ZhbGlkTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5hbWVoYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182Lm5hbWVoYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG5zRW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmRuc0VuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182Lmhhc2hNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi52ZXJpZnlNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuc29saWRpdHlQYWNrZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZEtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkU2hhMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnNvbGlkaXR5UGFja2VkU2hhMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWREYXRhRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5UeXBlZERhdGFFbmNvZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5VHlwZWREYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnZlcmlmeVR5cGVkRGF0YTsgfSB9KTtcbnZhciBpbmRleF9qc183ID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RGVmYXVsdFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LmdldERlZmF1bHRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJsb2NrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkJsb2NrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5GZWVEYXRhOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkxvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5UcmFuc2FjdGlvblJlY2VpcHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlRyYW5zYWN0aW9uUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdFNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5BYnN0cmFjdFNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vbmNlTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Ob25jZU1hbmFnZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2lkU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlZvaWRTaWduZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkFic3RyYWN0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkZhbGxiYWNrUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjQXBpUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSnNvblJwY0FwaVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lkpzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSnNvblJwY1NpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJyb3dzZXJQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Ccm93c2VyUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbGNoZW15UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQWxjaGVteVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5rclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkFua3JQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYWluc3RhY2tQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5DaGFpbnN0YWNrUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZGZsYXJlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQ2xvdWRmbGFyZVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJzY2FuUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRXRoZXJzY2FuUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5JbmZ1cmFQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZnVyYVdlYlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkluZnVyYVdlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuUG9ja2V0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWlja05vZGVQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5RdWlja05vZGVQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklwY1NvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LklwY1NvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5XZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1Jlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkVuc1Jlc29sdmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV0d29ya1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5OZXR3b3JrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5zUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkVuc1BsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5FdGhlcnNjYW5QbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVEYXRhTmV0d29ya1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5GZWVEYXRhTmV0d29ya1BsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdhc0Nvc3RQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuR2FzQ29zdFBsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuTmV0d29ya1BsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpY29pblByb3ZpZGVyUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lk11bHRpY29pblByb3ZpZGVyUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0QmxvY2tTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlNvY2tldEJsb2NrU3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldEV2ZW50U3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Tb2NrZXRFdmVudFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRQZW5kaW5nU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0U3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWFuYWdlZFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuVW5tYW5hZ2VkU3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlSZXF1ZXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LmNvcHlSZXF1ZXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hvd1Rocm90dGxlTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5zaG93VGhyb3R0bGVNZXNzYWdlOyB9IH0pO1xudmFyIGluZGV4X2pzXzggPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFjY2Vzc0xpc3RpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzguYWNjZXNzTGlzdGlmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc184LmNvbXB1dGVBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3ZlckFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzgucmVjb3ZlckFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOC5UcmFuc2FjdGlvbjsgfSB9KTtcbnZhciBpbmRleF9qc185ID0gcmVxdWlyZShcIi4vdXRpbHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCYXNlNThcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVjb2RlQmFzZTU4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmVuY29kZUJhc2U1ODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUJhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5kZWNvZGVCYXNlNjQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCYXNlNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZW5jb2RlQmFzZTY0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRhdGFMZW5ndGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGF0YUxlbmd0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRhdGFTbGljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5kYXRhU2xpY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJ5dGVzQ29weVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRCeXRlc0NvcHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhsaWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmhleGxpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5pc0hleFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnl0ZXNMaWtlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmlzQnl0ZXNMaWtlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaXBaZXJvc0xlZnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuc3RyaXBaZXJvc0xlZnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ6ZXJvUGFkQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuemVyb1BhZEJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZFZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185Lnplcm9QYWRWYWx1ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmluZVByb3BlcnRpZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVmaW5lUHJvcGVydGllczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnJlc29sdmVQcm9wZXJ0aWVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmFzc2VydDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydEFyZ3VtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmFzc2VydEFyZ3VtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0QXJndW1lbnRDb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnRBcmd1bWVudENvdW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0Tm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmFzc2VydE5vcm1hbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFByaXZhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuYXNzZXJ0UHJpdmF0ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5tYWtlRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NhbGxFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuaXNDYWxsRXhjZXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5pc0Vycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LkV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZldGNoUmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GZXRjaFJlcXVlc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LkZldGNoUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaENhbmNlbFNpZ25hbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GZXRjaENhbmNlbFNpZ25hbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LkZpeGVkTnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmlnSW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmdldEJpZ0ludDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXROdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRVaW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmdldFVpbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JlQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9CZUFycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CaWdJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9CaWdJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JlSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvQmVIZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b051bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b051bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvUXVhbnRpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9RdWFudGl0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21Ud29zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmZyb21Ud29zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Ud29zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvVHdvczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1hc2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkubWFzazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdEV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmZvcm1hdEV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5wYXJzZUV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0VW5pdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZm9ybWF0VW5pdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnBhcnNlVW5pdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b1V0ZjhCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOENvZGVQb2ludHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9VdGY4Q29kZVBvaW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b1V0ZjhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4RXJyb3JGdW5jc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5VdGY4RXJyb3JGdW5jczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVJscFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5kZWNvZGVSbHA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVSbHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZW5jb2RlUmxwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXVpZFY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnV1aWRWNDsgfSB9KTtcbnZhciBpbmRleF9qc18xMCA9IHJlcXVpcmUoXCIuL3dhbGxldC9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1uZW1vbmljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5NbmVtb25pYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLkJhc2VXYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIRE5vZGVXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLkhETm9kZVdhbGxldDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhETm9kZVZvaWRXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLkhETm9kZVZvaWRXYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLldhbGxldDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5kZWZhdWx0UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFjY291bnRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5nZXRBY2NvdW50UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEluZGV4ZWRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZ2V0SW5kZXhlZEFjY291bnRQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDcm93ZHNhbGVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5pc0Nyb3dkc2FsZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0tleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuaXNLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0Q3Jvd2RzYWxlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVjcnlwdENyb3dkc2FsZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVKc29uU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVjcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5kZWNyeXB0S2V5c3RvcmVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jcnlwdEtleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZW5jcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5lbmNyeXB0S2V5c3RvcmVKc29uU3luYzsgfSB9KTtcbnZhciBpbmRleF9qc18xMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0cy9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS5Xb3JkbGlzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxhbmdFblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTEuTGFuZ0VuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RPd2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzExLldvcmRsaXN0T3dsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RPd2xBXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS5Xb3JkbGlzdE93bEE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3b3JkbGlzdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzExLndvcmRsaXN0czsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaWQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cbiAqICBjb21wdXRlIGFuIDMyLWJ5dGUgaWRlbnRpZmllci5cbiAqXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xuICogIHRoZSBbW2tlY2NhazI1Nl1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGlkKFwiaGVsbG8gd29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gaWQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykodmFsdWUpKTtcbn1cbmV4cG9ydHMuaWQgPSBpZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgVXRpbGl0aWVzIGZvciBjb21tb24gdGFza3MgaW52b2x2aW5nIGhhc2hpbmcuIEFsc28gc2VlXG4gKiAgW2NyeXB0b2dyYXBoaWMgaGFzaGluZ10oYWJvdXQtY3J5cHRvLWhhc2hpbmcpLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9oYXNoaW5nOkhhc2hpbmcgVXRpbGl0aWVzICBbYWJvdXQtaGFzaGluZ11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSBleHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkU2hhMjU2ID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWQgPSBleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gZXhwb3J0cy5kbnNFbmNvZGUgPSBleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMuZW5zTm9ybWFsaXplID0gZXhwb3J0cy5pZCA9IHZvaWQgMDtcbnZhciBpZF9qc18xID0gcmVxdWlyZShcIi4vaWQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRfanNfMS5pZDsgfSB9KTtcbnZhciBuYW1laGFzaF9qc18xID0gcmVxdWlyZShcIi4vbmFtZWhhc2guanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnNOb3JtYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVoYXNoX2pzXzEuZW5zTm9ybWFsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZE5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVoYXNoX2pzXzEuaXNWYWxpZE5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1laGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfanNfMS5uYW1laGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRuc0VuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfanNfMS5kbnNFbmNvZGU7IH0gfSk7XG52YXIgbWVzc2FnZV9qc18xID0gcmVxdWlyZShcIi4vbWVzc2FnZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlX2pzXzEuaGFzaE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlX2pzXzEudmVyaWZ5TWVzc2FnZTsgfSB9KTtcbnZhciBzb2xpZGl0eV9qc18xID0gcmVxdWlyZShcIi4vc29saWRpdHkuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29saWRpdHlfanNfMS5zb2xpZGl0eVBhY2tlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkS2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2xpZGl0eV9qc18xLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRTaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvbGlkaXR5X2pzXzEuc29saWRpdHlQYWNrZWRTaGEyNTY7IH0gfSk7XG52YXIgdHlwZWRfZGF0YV9qc18xID0gcmVxdWlyZShcIi4vdHlwZWQtZGF0YS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVkRGF0YUVuY29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVkX2RhdGFfanNfMS5UeXBlZERhdGFFbmNvZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5VHlwZWREYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZF9kYXRhX2pzXzEudmVyaWZ5VHlwZWREYXRhOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQ29tcHV0ZXMgdGhlIFtbbGluay1laXAtMTkxXV0gcGVyc29uYWwtc2lnbiBtZXNzYWdlIGRpZ2VzdCB0byBzaWduLlxuICpcbiAqICBUaGlzIHByZWZpeGVzIHRoZSBtZXNzYWdlIHdpdGggW1tNZXNzYWdlUHJlZml4XV0gYW5kIHRoZSBkZWNpbWFsIGxlbmd0aFxuICogIG9mICUlbWVzc2FnZSUlIGFuZCBjb21wdXRlcyB0aGUgW1trZWNjYWsyNTZdXSBkaWdlc3QuXG4gKlxuICogIElmICUlbWVzc2FnZSUlIGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gaXRzIFVURi04IGJ5dGVzXG4gKiAgZmlyc3QuIFRvIGNvbXB1dGUgdGhlIGRpZ2VzdCBvZiBhIFtbRGF0YUhleFN0cmluZ11dLCBpdCBtdXN0IGJlIGNvbnZlcnRlZFxuICogIHRvIFtieXRlc10oZ2V0Qnl0ZXMpLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGhhc2hNZXNzYWdlKFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBIYXNoZXMgdGhlIFNJWCAoNikgc3RyaW5nIGNoYXJhY3RlcnMsIGkuZS5cbiAqICAgIC8vIFsgXCIwXCIsIFwieFwiLCBcIjRcIiwgXCIyXCIsIFwiNFwiLCBcIjNcIiBdXG4gKiAgICBoYXNoTWVzc2FnZShcIjB4NDI0M1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEhhc2hlcyB0aGUgVFdPICgyKSBieXRlcyBbIDB4NDIsIDB4NDMgXS4uLlxuICogICAgaGFzaE1lc3NhZ2UoZ2V0Qnl0ZXMoXCIweDQyNDNcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gLi4ud2hpY2ggaXMgZXF1YWwgdG8gdXNpbmcgZGF0YVxuICogICAgaGFzaE1lc3NhZ2UobmV3IFVpbnQ4QXJyYXkoWyAweDQyLCAweDQzIF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSAoMCwgaW5kZXhfanNfNC50b1V0ZjhCeXRlcykobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc180LmNvbmNhdCkoW1xuICAgICAgICAoMCwgaW5kZXhfanNfNC50b1V0ZjhCeXRlcykoaW5kZXhfanNfMi5NZXNzYWdlUHJlZml4KSxcbiAgICAgICAgKDAsIGluZGV4X2pzXzQudG9VdGY4Qnl0ZXMpKFN0cmluZyhtZXNzYWdlLmxlbmd0aCkpLFxuICAgICAgICBtZXNzYWdlXG4gICAgXSkpO1xufVxuZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGhhc2hNZXNzYWdlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXG4gKiAgdGhlIHNpZ25hdHVyZSAlJXNpZyUlIGR1cmluZyBzaWduaW5nIGZvciAlJW1lc3NhZ2UlJS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWcpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMucmVjb3ZlckFkZHJlc3MpKGRpZ2VzdCwgc2lnKTtcbn1cbmV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IHZlcmlmeU1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kbnNFbmNvZGUgPSBleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMuZW5zTm9ybWFsaXplID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgZW5zX25vcm1hbGl6ZV8xID0gcmVxdWlyZShcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIik7XG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChjb21wKSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGxhc3QgPCBieXRlcy5sZW5ndGgsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QpKSk7XG4gICAgcmV0dXJuIGNvbXBzO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRU5TICUlbmFtZSUlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuc19ub3JtYWxpemVfMS5lbnNfbm9ybWFsaXplKShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zTm9ybWFsaXplID0gZW5zTm9ybWFsaXplO1xuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc18yLmNvbmNhdCkoW3Jlc3VsdCwgKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHJlc3VsdCk7XG59XG5leHBvcnRzLm5hbWVoYXNoID0gbmFtZWhhc2g7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUsIF9tYXhMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkobGVuZ3RoIDw9IDI1NSwgXCJETlMgZW5jb2RlZCBsYWJlbCBjYW5ub3QgZXhjZWVkIDI1NVwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMi5jb25jYXQpKGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNvbXAubGVuZ3RoIDw9IGxlbmd0aCwgYGxhYmVsICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGV4Y2VlZHMgJHtsZW5ndGh9IGJ5dGVzYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbmV4cG9ydHMuZG5zRW5jb2RlID0gZG5zRW5jb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNvbGlkaXR5UGFja2VkU2hhMjU2ID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCByZWdleEJ5dGVzID0gbmV3IFJlZ0V4cChcIl5ieXRlcyhbMC05XSspJFwiKTtcbmNvbnN0IHJlZ2V4TnVtYmVyID0gbmV3IFJlZ0V4cChcIl4odT9pbnQpKFswLTldKikkXCIpO1xuY29uc3QgcmVnZXhBcnJheSA9IG5ldyBSZWdFeHAoXCJeKC4qKVxcXFxbKFswLTldKilcXFxcXSRcIik7XG5mdW5jdGlvbiBfcGFjayh0eXBlLCB2YWx1ZSwgaXNBcnJheSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18zLnplcm9QYWRWYWx1ZSkodmFsdWUsIDMyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy50b1V0ZjhCeXRlcykodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgdmFsdWUgPSAoISF2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18zLnplcm9QYWRWYWx1ZSkodmFsdWUsIDMyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKHZhbHVlKTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleE51bWJlcik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxldCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiaW50XCIpO1xuICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKCFtYXRjaFsyXSB8fCBtYXRjaFsyXSA9PT0gU3RyaW5nKHNpemUpKSAmJiAoc2l6ZSAlIDggPT09IDApICYmIHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYsIFwiaW52YWxpZCBudW1iZXIgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBzaXplID0gMjU2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzMudG9Ud29zKSh2YWx1ZSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkodmFsdWUpLCBzaXplIC8gOCkpO1xuICAgIH1cbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhCeXRlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShTdHJpbmcoc2l6ZSkgPT09IG1hdGNoWzFdICYmIHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuZGF0YUxlbmd0aCkodmFsdWUpID09PSBzaXplLCBgaW52YWxpZCB2YWx1ZSBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMy56ZXJvUGFkQnl0ZXMpKHZhbHVlLCAzMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXkpO1xuICAgIGlmIChtYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICBjb25zdCBjb3VudCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFN0cmluZyh2YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBpbnZhbGlkIGFycmF5IGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9wYWNrKGJhc2VUeXBlLCB2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMy5jb25jYXQpKHJlc3VsdCkpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbn1cbi8vIEBUT0RPOiBBcnJheSBFbnVtXG4vKipcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIHJlcHJlc2VudGF0aW9uIG9mICUldmFsdWVzJSVcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cbiAqXG4gKiAgIEBleGFtcGxlOlxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcbiAqICAgICAgIHNvbGlkaXR5UGFja2VkKFsgXCJhZGRyZXNzXCIsIFwidWludFwiIF0sIFsgYWRkciwgNDUgXSk7XG4gKiAgICAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNvbGlkaXR5UGFja2VkKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkodHlwZXMubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoLCBcIndyb25nIG51bWJlciBvZiB2YWx1ZXM7IGV4cGVjdGVkICR7IHR5cGVzLmxlbmd0aCB9XCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgY29uc3QgdGlnaHQgPSBbXTtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgICAgICB0aWdodC5wdXNoKF9wYWNrKHR5cGUsIHZhbHVlc1tpbmRleF0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzMuY29uY2F0KSh0aWdodCkpO1xufVxuZXhwb3J0cy5zb2xpZGl0eVBhY2tlZCA9IHNvbGlkaXR5UGFja2VkO1xuLyoqXG4gKiAgIENvbXB1dGVzIHRoZSBbW2xpbmstc29sYy1wYWNrZWRdXSBbW2tlY2NhazI1Nl1dIGhhc2ggb2YgJSV2YWx1ZXMlJVxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxuICpcbiAqICAgQGV4YW1wbGU6XG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxuICogICAgICAgc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWyBcImFkZHJlc3NcIiwgXCJ1aW50XCIgXSwgWyBhZGRyLCA0NSBdKTtcbiAqICAgICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gc29saWRpdHlQYWNrZWRLZWNjYWsyNTYodHlwZXMsIHZhbHVlcykge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHNvbGlkaXR5UGFja2VkKHR5cGVzLCB2YWx1ZXMpKTtcbn1cbmV4cG9ydHMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYgPSBzb2xpZGl0eVBhY2tlZEtlY2NhazI1Njtcbi8qKlxuICogICBDb21wdXRlcyB0aGUgW1tsaW5rLXNvbGMtcGFja2VkXV0gW1tzaGEyNTZdXSBoYXNoIG9mICUldmFsdWVzJSVcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cbiAqXG4gKiAgIEBleGFtcGxlOlxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcbiAqICAgICAgIHNvbGlkaXR5UGFja2VkU2hhMjU2KFsgXCJhZGRyZXNzXCIsIFwidWludFwiIF0sIFsgYWRkciwgNDUgXSk7XG4gKiAgICAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNvbGlkaXR5UGFja2VkU2hhMjU2KHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuc2hhMjU2KShzb2xpZGl0eVBhY2tlZCh0eXBlcywgdmFsdWVzKSk7XG59XG5leHBvcnRzLnNvbGlkaXR5UGFja2VkU2hhMjU2ID0gc29saWRpdHlQYWNrZWRTaGEyNTY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2xpZGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gdm9pZCAwO1xuLy9pbXBvcnQgeyBUeXBlZERhdGFEb21haW4sIFR5cGVkRGF0YUZpZWxkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyYWJzdHJhY3Qtc2lnbmVyXCI7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgaWRfanNfMSA9IHJlcXVpcmUoXCIuL2lkLmpzXCIpO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IEJOX18xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG47XG47XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKHZhbHVlKTtcbiAgICBjb25zdCBwYWRPZmZzZXQgPSBieXRlcy5sZW5ndGggJSAzMjtcbiAgICBpZiAocGFkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gKDAsIGluZGV4X2pzXzQudG9CZUhleCkoQk5fMSwgMzIpO1xuY29uc3QgaGV4RmFsc2UgPSAoMCwgaW5kZXhfanNfNC50b0JlSGV4KShCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc180LmdldEJpZ0ludCkoX3ZhbHVlLCBcImRvbWFpbi5jaGFpbklkXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LnRvUXVhbnRpdHkpKHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUsIFwiZG9tYWluLnNhbHRcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShieXRlcy5sZW5ndGggPT09IDMyLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLCBcImRvbWFpbi5zYWx0XCIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHdpZHRoICUgOCA9PT0gMCAmJiB3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAyNTYgJiYgbWF0Y2hbMl0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gKDAsIGluZGV4X2pzXzQubWFzaykoQk5fTUFYX1VJTlQyNTYsIHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzTG93ZXIgPSBzaWduZWQgPyAoKGJvdW5kc1VwcGVyICsgQk5fMSkgKiBCTl9fMSkgOiBCTl8wO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc180LmdldEJpZ0ludCkoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSBib3VuZHNMb3dlciAmJiB2YWx1ZSA8PSBib3VuZHNVcHBlciwgYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQudG9CZUhleCkoc2lnbmVkID8gKDAsIGluZGV4X2pzXzQudG9Ud29zKSh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDMyICYmIG1hdGNoWzFdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC56ZXJvUGFkVmFsdWUpKCgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghdmFsdWUpID8gaGV4RmFsc2UgOiBoZXhUcnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGlkX2pzXzEuaWQpKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuLy8gZm9vW11bM10gPT4geyBiYXNlOiBcImZvb1wiLCBpbmRleDogXCJbXVszXVwiLCBhcnJheToge1xuLy8gICAgIGJhc2U6IFwiZm9vXCIsIHByZWZpeDogXCJmb29bXVwiLCBjb3VudDogMyB9IH1cbmZ1bmN0aW9uIHNwbGl0QXJyYXkodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXihbXlxceDViXSopKChcXHg1YlxcZCpcXHg1ZCkqKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgaW5kZXg6IChtYXRjaFsyXSArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGFycmF5OiB7XG4gICAgICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgcHJlZml4OiAobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgY291bnQ6IChtYXRjaFs1XSA/IHBhcnNlSW50KG1hdGNoWzVdKSA6IC0xKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYmFzZTogdHlwZSB9O1xufVxuLyoqXG4gKiAgQSAqKlR5cGVkRGF0YUVuY29kZSoqIHByZXBhcmVzIGFuZCBlbmNvZGVzIFtbbGluay1laXAtNzEyXV0gcGF5bG9hZHNcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXG4gKlxuICogIFRoaXMgaXMgdXNlZnVsIGZvciB0aG9zZSB0aGF0IHdpc2ggdG8gY29tcHV0ZSB2YXJpb3VzIGNvbXBvbmVudHMgb2YgYVxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXG4gKiAgaGlnaGVyIGxldmVsIFtbU2lnbmVyLXNpZ25UeXBlZERhdGFdXSBpcyBtb3JlIHVzZWZ1bC5cbiAqL1xuY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3R5cGVzKSB7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGJhc2UgdHlwZSAodW5sZXNzIG5hbWUgY29uZmxpY3QpXG4gICAgICAgICAgICAgICAgbGV0IHsgYmFzZSwgaW5kZXggfSA9IHNwbGl0QXJyYXkodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcInVpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBzcGxpdEFycmF5KGZpZWxkLnR5cGUpLmJhc2U7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGJhc2VUeXBlICE9PSBuYW1lLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzLmdldChiYXNlVHlwZSkucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBBcnJheS5mcm9tKHBhcmVudHMua2V5cygpKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzLmdldChuKS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMSwgYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKCh0KSA9PiAoSlNPTi5zdHJpbmdpZnkodCkpKS5qb2luKFwiLCBcIil9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKCFmb3VuZC5oYXModHlwZSksIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBhcnJheS5wcmVmaXg7XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyhzdWJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGluZGV4X2pzXzIua2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzQuY29uY2F0KShyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gKDAsIGlkX2pzXzEuaWQpKHRoaXMuI2Z1bGxUeXBlcy5nZXQodHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5jb25jYXQpKHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbCB0eXBlIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVsbFR5cGVzLmdldChuYW1lKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdCwgYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGhhc2ggb2YgJSV2YWx1ZSUlIGZvciB0aGUgdHlwZSBvZiAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoYXJyYXkucHJlZml4LCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsICUlY2FsYmFjayUlIGZvciBlYWNoIHZhbHVlIGluICUldmFsdWUlJSwgcGFzc2luZyB0aGUgdHlwZSBhbmRcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHJlcGxhY2luZyBhZGRyZXNzZXMgb3Igb3RoZXIgdHJhbnNmb3JtYXRpb24gdGhhdFxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSB2YWx1ZSBmcm9tIHJlc29sdmluZyBhbGwgYWRkcmVzc2VzIGluICUldmFsdWUlJSBmb3JcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICBkb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCBkb21haW4pO1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG51bGwgdG8gaWdub3JlIHZhbHVlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgISgwLCBpbmRleF9qc180LmlzSGV4U3RyaW5nKShkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgISgwLCBpbmRleF9qc180LmlzSGV4U3RyaW5nKSh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0gYXdhaXQgcmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcbiAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xuICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBKU09OLWVuY29kZWQgcGF5bG9hZCBleHBlY3RlZCBieSBub2RlcyB3aGljaCBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIEpTT04tUlBDIFtbbGluay1laXAtNzEyXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgY29uc3QgZG9tYWluVmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XG4gICAgICAgIGRvbWFpbkZpZWxkTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgdHlwZXNcbiAgICAgICAgdHlwZXMgPSBlbmNvZGVyLnR5cGVzO1xuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlcyk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID09IG51bGwsIFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5nZXRCaWdJbnQpKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIHR5cGVkIGRhdGEgZm9yIHRoZSAlJXNpZ25hdHVyZSUlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlUeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5yZWNvdmVyQWRkcmVzcykoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSwgc2lnbmF0dXJlKTtcbn1cbmV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gdmVyaWZ5VHlwZWREYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXRoZXJzID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKlxuICogIFRoZSBBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgKEFQSSkgaXMgdGhlIGNvbGxlY3Rpb24gb2ZcbiAqICBmdW5jdGlvbnMsIGNsYXNzZXMgYW5kIHR5cGVzIG9mZmVyZWQgYnkgdGhlIEV0aGVycyBsaWJyYXJ5LlxuICpcbiAqICBAX3NlY3Rpb246IGFwaTpBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgIFthYm91dC1hcGldXG4gKiAgQF9uYXZUaXRsZTogQVBJXG4gKi9cbmNvbnN0IGV0aGVycyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2V0aGVycy5qc1wiKSk7XG5leHBvcnRzLmV0aGVycyA9IGV0aGVycztcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V0aGVycy5qc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBhdmFpbGFibGUgcHJvdmlkZXJzIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IGRldmVsb3BlcnMgcHVycG9zZXMsXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RQcm92aWRlciA9IGV4cG9ydHMuVW5tYW5hZ2VkU3Vic2NyaWJlciA9IHZvaWQgMDtcbi8vIEBUT0RPXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxuLy8gICBvciBFTlMgbmFtZSksIHdlIG5lZWQgdG8gYWRkIGl0IGltbWVpZGF0ZWx5IGZvciB0aGUgRXZlbnQgQVBJLCBidXQgYWxzb1xuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXG4vLyAgIG9mIFNpZ25lci9FTlMgbmFtZSB0byBhZGRyZXNzIHNvIHdlIGNhbiBzeW5jIHJlc3BvbmQgdG8gbGlzdGVuZXJDb3VudC5cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi9jb250cmFjdC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzUgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc182ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgZW5zX3Jlc29sdmVyX2pzXzEgPSByZXF1aXJlKFwiLi9lbnMtcmVzb2x2ZXIuanNcIik7XG5jb25zdCBmb3JtYXRfanNfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdC5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXIuanNcIik7XG5jb25zdCBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiKTtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuY2xhc3MgVW5tYW5hZ2VkU3Vic2NyaWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIGZvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IFVubWFuYWdlZFN1YnNjcmliZXIgd2l0aCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7ICgwLCBpbmRleF9qc182LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5leHBvcnRzLlVubWFuYWdlZFN1YnNjcmliZXIgPSBVbm1hbmFnZWRTdWJzY3JpYmVyO1xuZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb25jaXNpZnkoaXRlbXMpIHtcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XG4gICAgaXRlbXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XG4gICAgaWYgKF9ldmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpYyBhcnJheSBpbmZvIGFuIEV2ZW50RmlsdGVyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNIZXhTdHJpbmcpKF9ldmVudCwgMzIpKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xuICAgIH1cbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgLy8gQFRPRE86IFNob3VsZCBsb3dlcmNhc2UgYW5kIHdoYXRub3QgdGhpbmdzIGhlcmUgaW5zdGVhZCBvZiBjb3B5Li4uXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xuICAgIH1cbiAgICBpZiAoKF9ldmVudC5hZGRyZXNzIHx8IF9ldmVudC50b3BpY3MpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICB0b3BpY3M6ICgoZXZlbnQudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShhZGRyKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKShhZGRyLCBwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpbHRlciwgdGFnOiBnZXRUYWcoXCJldmVudFwiLCBmaWx0ZXIpLCB0eXBlOiBcImV2ZW50XCIgfTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVua25vd24gUHJvdmlkZXJFdmVudFwiLCBcImV2ZW50XCIsIF9ldmVudCk7XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xuICogIGltcGxlbWVudCB0aGUgW1tQcm92aWRlcl1dIEFQSSBieSBub3JtYWxpemluZyBpbnB1dCBhcmd1bWVudHMgYW5kXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cbiAqL1xuY2xhc3MgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI3N1YnM7XG4gICAgI3BsdWdpbnM7XG4gICAgLy8gbnVsbD11bnBhdXNlZCwgdHJ1ZT1wYXVzZWQrZHJvcFdoaWxlUGF1c2VkLCBmYWxzZT1wYXVzZWRcbiAgICAjcGF1c2VkU3RhdGU7XG4gICAgI2Rlc3Ryb3llZDtcbiAgICAjbmV0d29ya1Byb21pc2U7XG4gICAgI2FueU5ldHdvcms7XG4gICAgI3BlcmZvcm1DYWNoZTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgbnVtYmVyIGlmIHJ1bm5pbmcgYW4gZXZlbnQgb3IgLTEgaWYgbm8gXCJibG9ja1wiIGV2ZW50XG4gICAgI2xhc3RCbG9ja051bWJlcjtcbiAgICAjbmV4dFRpbWVyO1xuICAgICN0aW1lcnM7XG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcbiAgICAgKiAgW1tOZXR3b3JrXV0gaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnLWlucy5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgcGx1Zy1pbi5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNvbm5lY3QodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cbiAgICAvLyBTaGFyZXMgbXVsdGlwbGUgaWRlbnRpY2FsIHJlcXVlc3RzIG1hZGUgZHVyaW5nIHRoZSBzYW1lIDI1MG1zXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcbiAgICAgICAgLy8gQ2FjaGluZyBkaXNhYmxlZFxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xuICAgICAgICBsZXQgcGVyZm9ybSA9IHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLnNldCh0YWcsIHBlcmZvcm0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAvL2NvbnN0IGpzb246IHN0cmluZyB8IG51bGwgPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc182LkZldGNoUmVxdWVzdChocmVmKTtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSB7IGRhdGEsIHNlbmRlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkocmVzcC5zdGF0dXNDb2RlIDwgNDAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+PSA1MDAsIGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwgeyByZWFzb246IFwiNDA0X01JU1NJTkdfUkVTT1VSQ0VcIiwgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybCwgZXJyb3JNZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIjUwMF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmxzLCBlcnJvck1lc3NhZ2VzIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBibG9jayBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIF93cmFwQmxvY2sodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkJsb2NrKCgwLCBmb3JtYXRfanNfMS5mb3JtYXRCbG9jaykodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cbiAgICAgKi9cbiAgICBfd3JhcExvZyh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuTG9nKCgwLCBmb3JtYXRfanNfMS5mb3JtYXRMb2cpKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZWNlaXB0IGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlY2VpcHQoKDAsIGZvcm1hdF9qc18xLmZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCkodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlc3BvbnNlIGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVzcG9uc2UoKDAsIGZvcm1hdF9qc18xLmZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UpKHR4KSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXG4gICAgICogIHRlY2huaXF1ZSB0aGUgc3ViLWNsYXNzIHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwic3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcbiAgICAgKiAgbWV0aG9kcyBzYW5pdGl6ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHZhbHVlcyBwYXNzZWQgaW50byB0aGlzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIGB1bnN1cHBvcnRlZCBtZXRob2Q6ICR7cmVxLm1ldGhvZH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBpbmZvOiByZXFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXRlXG4gICAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKShhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLCByZXNvbHZpbmcgRU5TXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cbiAgICAgKiAgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykoYWRkcmVzcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdmFsaWQgYmxvY2sgdGFnIGZvciAlJWJsb2NrVGFnJSUsIHJlc29sdmluZ1xuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxuICAgICAqL1xuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShibG9ja1RhZykpIHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0hleFN0cmluZykoYmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi50b1F1YW50aXR5KShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICgwLCBpbmRleF9qc182LmdldE51bWJlcikoYmxvY2tUYWcsIFwiYmxvY2tUYWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi50b1F1YW50aXR5KShibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYudG9RdWFudGl0eSkodGhpcy4jbGFzdEJsb2NrTnVtYmVyICsgYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiAoMCwgaW5kZXhfanNfNi50b1F1YW50aXR5KShiICsgYmxvY2tUYWcpKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBibG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSBmaWx0ZXIgZm9yICUlZmlsdGVyJSUsIHJlc29sdmluZyBhbnkgRU5TXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgZmlsdGVyLlxuICAgICAqL1xuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IChmaWx0ZXIudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKFwiYmxvY2tIYXNoXCIgaW4gZmlsdGVyKSA/IGZpbHRlci5ibG9ja0hhc2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9hZGRyZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiZnJvbUJsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxuICAgICAgICAgICAgKHRvQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKHRvQmxvY2spICE9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXG4gICAgICogIGFueSBFTlMgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9ICgwLCBwcm92aWRlcl9qc18xLmNvcHlSZXF1ZXN0KShfcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykocmVxdWVzdFtrZXldLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYWRkcikpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3Rba2V5XSA9IGF3YWl0IGFkZHI7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXF1ZXN0LmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcocmVxdWVzdC5ibG9ja1RhZyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdC5ibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tUYWcgPSBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBuZXR3b3JrIHdhcyBzZXQgYW5kIHRoaXMgaXMgb3VyIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgY3VycmVudCBuZXR3b3JrIChzaGFyZWQgd2l0aCBhbGwgY2FsbHMpXG4gICAgICAgICAgICBjb25zdCBkZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSwgcHJpb3JpdHlGZWUgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgX2Jsb2NrOiB0aGlzLiNnZXRCbG9jayhcImxhdGVzdFwiLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KSh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KSh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWNvbW1lbmRlZCBFSVAtMTU1OSBoZXVyaXN0aWNzIGZvciBmZWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAocHJpb3JpdHlGZWUgIT0gbnVsbCkgPyBwcmlvcml0eUZlZSA6IEJpZ0ludChcIjEwMDAwMDAwMDBcIik7XG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiBCTl8yKSArIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IGluZGV4X2pzXzYuRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5GZWVEYXRhKGZlZURhdGEuZ2FzUHJpY2UsIGZlZURhdGEubWF4RmVlUGVyR2FzLCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RmVlRGF0YUZ1bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoX3R4KSB7XG4gICAgICAgIGxldCB0eCA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHR4KSkge1xuICAgICAgICAgICAgdHggPSBhd2FpdCB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KShhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkodHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LmhleGxpZnkpKGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmICgwLCBpbmRleF9qc182LmlzQ2FsbEV4Y2VwdGlvbikoZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShlcnJvci5kYXRhLCAwLCA0KSA9PT0gXCIweDU1NmYxODMwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKSh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgZXJyb3IubWVzc2FnZSwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQkFEX0RBVEFcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBpbmRleF9qc182LmNvbmNhdCkoW2NjaXBBcmdzLnNlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgY2NpcEFyZ3MuZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkQ2FsbFwiLCB0cmFuc2FjdGlvbjogdHggfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbFJlc3VsdFwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsRXJyb3JcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNjaGVja05ldHdvcmsocHJvbWlzZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LmdldE51bWJlcikoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5oZXhsaWZ5KShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBpbmRleF9qc182LmdldEJpZ0ludCkoX3Bvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuaGV4bGlmeSkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBpbmRleF9qc181LlRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNnZXRCbG9jayhibG9jaywgISFwcmVmZXRjaFR4cylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBCbG9jayhwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuaGV4bGlmeSkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcInByb3ZpZGVyIGNhbm5vdCBjb25uZWN0IHRvIHRhcmdldCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0UHJvdmlkZXIoKVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbnNfcmVzb2x2ZXJfanNfMS5FbnNSZXNvbHZlci5mcm9tTmFtZSh0aGlzLCBuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXZhdGFyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICgwLCBpbmRleF9qc180Lm5hbWVoYXNoKShhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IGVuc19yZXNvbHZlcl9qc18xLkVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IGluZGV4X2pzXzIuWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQ29udHJhY3QgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNFcnJvcikoZXJyb3IsIFwiQkFEX0RBVEFcIikgJiYgZXJyb3IudmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHJlZXJ0ZWRcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0Vycm9yKShlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgaW5kZXhfanNfNi5tYWtlRXJyb3IpKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIsIFwiTk9UX0lNUExFTUVOVEVEXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ3YWl0Rm9yQmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGEgdGltZXIgY3JlYXRlZCB1c2luZyB0aGUgW1tfc2V0VGltZW91dF1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLiN0aW1lcnMuZ2V0KHRpbWVySWQpO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSB0aW1lciB0aGF0IHdpbGwgZXhlY3V0ZSAlJWZ1bmMlJSBhZnRlciBhdCBsZWFzdCAlJXRpbWVvdXQlJVxuICAgICAqICAoaW4gbXMpLiBJZiAlJXRpbWVvdXQlJSBpcyB1bnNwZWNpZmllZCwgdGhlbiAlJWZ1bmMlJSB3aWxsIGV4ZWN1dGVcbiAgICAgKiAgaW4gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqICBbUGF1c2luZ10oQWJzdHJhY3RQcm92aWRlci1wYXVzZWQpIHRoZSBwcm92aWRlciB3aWxsIHBhdXNlIGFueVxuICAgICAqICBhc3NvY2lhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICBfc2V0VGltZW91dChfZnVuYywgdGltZW91dCkge1xuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lcklkID0gdGhpcy4jbmV4dFRpbWVyKys7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgICAgICAgICAgX2Z1bmMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXI6IG51bGwsIGZ1bmMsIHRpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXIsIGZ1bmMsIHRpbWU6IGdldFRpbWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBlcmZvcm0gJSVmdW5jJSUgb24gZWFjaCBzdWJzY3JpYmVyLlxuICAgICAqL1xuICAgIF9mb3JFYWNoU3Vic2NyaWJlcihmdW5jKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZ1bmMoc3ViLnN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBjdXN0b21pemUgc3Vic2NyaXB0aW9uXG4gICAgICogIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgc3dpdGNoIChzdWIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMS5Qb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlcih0aGlzLCBzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIodGhpcywgc3ViLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ09ycGhhblN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBldmVudDogJHtzdWIudHlwZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgW1tTdWJzY3JpYmVyXV0gZmFpbHMgYW5kIG5lZWRzIHRvIHJlcGxhY2UgaXRzZWxmLCB0aGlzXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgdGhpcyBpcyB1c2VkIGZvciBwcm92aWRlcnMgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAgYGBldGhfZ2V0RmlsdGVyQ2hhbmdlc2BgIG1ldGhvZCwgd2hpY2ggY2FuIHJldHVybiBudWxsIGlmIHN0YXRlXG4gICAgICogIGZpbHRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJhY2tlbmQsIGFsbG93aW5nIHRoZSBTdWJzY3JpYmVyXG4gICAgICogIHRvIHN3YXAgaW4gYSBbW1BvbGxpbmdFdmVudFN1YnNjcmliZXJdXS5cbiAgICAgKi9cbiAgICBfcmVjb3ZlclN1YnNjcmliZXIob2xkU3ViLCBuZXdTdWIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVyID09PSBvbGRTdWIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlciA9IG5ld1N1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNoYXNTdWIoZXZlbnQsIGVtaXRBcmdzKSB7XG4gICAgICAgIGxldCBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbG9nIHRoYXQgaXMgcmVtb3ZpbmcgYW4gZXhpc3RpbmcgbG9nOyB3ZSBhY3R1YWxseSB3YW50XG4gICAgICAgIC8vIHRvIGVtaXQgYW4gb3JwaGFuIGV2ZW50IGZvciB0aGUgcmVtb3ZlZCBsb2dcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIgJiYgZW1pdEFyZ3MgJiYgZW1pdEFyZ3MubGVuZ3RoID4gMCAmJiBlbWl0QXJnc1swXS5yZW1vdmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oeyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiBlbWl0QXJnc1swXSB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jc3Vicy5nZXQoc3ViLnRhZykgfHwgbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgI2dldFN1YihldmVudCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBQcmV2ZW50IHRhbXBlcmluZyB3aXRoIG91ciB0YWcgaW4gYW55IHN1YmNsYXNzJyBfZ2V0U3Vic2NyaWJlclxuICAgICAgICBjb25zdCB0YWcgPSBzdWJzY3JpcHRpb24udGFnO1xuICAgICAgICBsZXQgc3ViID0gdGhpcy4jc3Vicy5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLl9nZXRTdWJzY3JpYmVyKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzYWJsZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgc3ViID0geyBzdWJzY3JpYmVyLCB0YWcsIGFkZHJlc3NhYmxlTWFwLCBuYW1lTWFwLCBzdGFydGVkOiBmYWxzZSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy4jc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3Qgc3Vic2NyaXB0aW9uIG9yIGlmIGEgcmVjZW50IGVtaXQgcmVtb3ZlZFxuICAgICAgICAvLyB0aGUgbGFzdCBvZiB0aGVtICh3aGljaCBhbHNvIGRlbGV0ZWQgdGhlIHN1YikgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXN1YiB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgaW5kZXhfanNfNi5FdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwiY2Fubm90IGNoYW5nZSBwYXVzZSB0eXBlOyByZXN1bWUgZmlyc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwYXVzZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5wYXVzZShkcm9wV2hpbGVQYXVzZWQpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSAhIWRyb3BXaGlsZVBhdXNlZDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG5lZWRlZCBmb3Igd2hlbiB3ZSBiZWNvbWUgdW5wYXVzZWRcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCkgLSB0aW1lci50aW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXN1bWUgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIHdoZW4gd2Ugd2VyZSBwYXVzZWRcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGltZXIudGltZTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgdGltZSAoaW4gY2F1c2UgcGF1c2VkLCBzbyB3ZSBjb24gY29tcHV0ZSByZW1haW5pbmYgdGltZSlcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdGltZXJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZXIuZnVuYywgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0UHJvdmlkZXIgPSBBYnN0cmFjdFByb3ZpZGVyO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi50b1V0ZjhTdHJpbmcpKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSAoMCwgaW5kZXhfanNfNi50b0JlQXJyYXkpKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfNi5nZXRCeXRlcykoZGF0YXNbaV0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGJ5dGVzIG9mZnNldFxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtUGFkKGRhdGEubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5jb25jYXQpKHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKCgwLCBpbmRleF9qc182LmRhdGFMZW5ndGgpKGRhdGEpID49IDUgKiAzMiwgXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCJcbiAgICB9KTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDAsIDMyKTtcbiAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoc2VuZGVyLCAwLCAxMikgPT09ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpO1xuICAgICAgICBjb25zdCB1cmxzRGF0YSA9ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShkYXRhLCAxMDAsIDEyOCkgPT09ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoemVyb3MsIDAsIDI4KSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbGVjdG9yID0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLkFic3RyYWN0U2lnbmVyID0gdm9pZCAwO1xuLyoqXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcbiAqICBhcmUgc3VmZmljZW50IGZvciBtb3N0IGRldmVsb3BlcnMsIGJ1dCB0aGlzIGlzIHByb3ZpZGVkIHRvXG4gKiAgZmFzY2lsaXRhdGUgbW9yZSBjb21wbGV4IFNpZ25lcnMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXI6IFN1YmNsYXNzaW5nIFNpZ25lciBbYWJzdHJhY3Qtc2lnbmVyXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci5qc1wiKTtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwibWlzc2luZyBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcbiAgICBsZXQgcG9wID0gKDAsIHByb3ZpZGVyX2pzXzEuY29weVJlcXVlc3QpKHR4KTtcbiAgICBpZiAocG9wLnRvICE9IG51bGwpIHtcbiAgICAgICAgcG9wLnRvID0gKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykoZnJvbSwgc2lnbmVyKVxuICAgICAgICBdKS50aGVuKChbYWRkcmVzcywgZnJvbV0pID0+IHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGZyb20udG9Mb3dlckNhc2UoKSwgXCJ0cmFuc2FjdGlvbiBmcm9tIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCBmcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvcC5mcm9tID0gc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0ICgwLCBpbmRleF9qc18zLnJlc29sdmVQcm9wZXJ0aWVzKShwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5jbGFzcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIHNpZ25lciBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgU2lnbmVyIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KShwb3AuY2hhaW5JZCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkLCBcInRyYW5zYWN0aW9uIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJ0eC5jaGFpbklkXCIsIHR4LmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wLmNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgaGFzRWlwMTU1OSA9IChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwgJiYgKHBvcC50eXBlID09PSAyIHx8IGhhc0VpcDE1NTkpKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09IG51bGwpICYmIChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwsIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0R2FzUHJpY2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG4gICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgIGlmIChwb3AudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKCFoYXNFaXAxNTU5LCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogTWF5YmUgdGhpcyBzaG9sZCBhbGxvdyB0eXBlIDE/XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5IG9yIEVJUC00ODQ0XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGluZGV4X2pzXzMucmVzb2x2ZVByb3BlcnRpZXMpKHBvcCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBpbmRleF9qc18yLlRyYW5zYWN0aW9uLmZyb20ocG9wKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmJyb2FkY2FzdFRyYW5zYWN0aW9uKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4T2JqKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdFNpZ25lciA9IEFic3RyYWN0U2lnbmVyO1xuLyoqXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxuICogIGluIGFueSBBUEkgd2hpY2ggYWNjZXB0cyBhIFNpZ25lciwgYnV0IGZvciB3aGljaCB0aGVyZSBhcmUgbm9cbiAqICBjcmVkZW50aWFscyBhdmFpbGFibGUgdG8gcGVyZm9ybSBhbnkgYWN0dWFsIHNpZ25pbmcuXG4gKlxuICogIFRoaXMgZm9yIGV4YW1wbGUgYWxsb3cgaW1wZXJzb25hdGluZyBhbiBhY2NvdW50IGZvciB0aGUgcHVycG9zZSBvZlxuICogIHN0YXRpYyBjYWxscyBvciBlc3RpbWF0aW5nIGdhcywgYnV0IGRvZXMgbm90IGFsbG93IHNlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICovXG5jbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZhbHNlLCBgVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiAke3N1ZmZpeH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcIm1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInR5cGVkLWRhdGFcIiwgXCJzaWduVHlwZWREYXRhXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVm9pZFNpZ25lciA9IFZvaWRTaWduZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGVyZSBhcmUgbWFueSBhd2Vzb21lIGNvbW11bml0eSBzZXJ2aWNlcyB0aGF0IHByb3ZpZGUgRXRoZXJldW1cbiAqICBub2RlcyBib3RoIGZvciBkZXZlbG9wZXJzIGp1c3Qgc3RhcnRpbmcgb3V0IGFuZCBmb3IgbGFyZ2Utc2NhbGVcbiAqICBjb21tdW5pdGllcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6IENvbW11bml0eSBQcm92aWRlcnMgIFt0aGlyZHBhcnR5XVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSB2b2lkIDA7XG4vLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZSBwZXIgc2VydmljZVxuY29uc3Qgc2hvd24gPSBuZXcgU2V0KCk7XG4vKipcbiAqICBEaXNwbGF5cyBhIHdhcm5pbmcgaW4gdGh0IGNvbnNvbGUgd2hlbiB0aGUgY29tbXVuaXR5IHJlc291cmNlIGlzXG4gKiAgYmVpbmcgdXNlZCB0b28gaGVhdmlseSBieSB0aGUgYXBwLCByZWNvbW1lbmRpbmcgdGhlIGRldmVsb3BlclxuICogIGFjcXVpcmUgdGhlaXIgb3duIGNyZWRlbnRpYWxzIGluc3RlYWQgb2YgdXNpbmcgdGhlIGNvbW11bml0eVxuICogIGNyZWRlbnRpYWxzLlxuICpcbiAqICBUaGUgbm90aWZpY2F0aW9uIHdpbGwgb25seSBvY2N1ciBvbmNlIHBlciBzZXJ2aWNlLlxuICovXG5mdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKHNlcnZpY2UpIHtcbiAgICBpZiAoc2hvd24uaGFzKHNlcnZpY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2hvd24uYWRkKHNlcnZpY2UpO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coYFJlcXVlc3QtUmF0ZSBFeGNlZWRlZCBmb3IgJHtzZXJ2aWNlfSAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKWApO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcbiAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLm9yZy9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbmV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IHNob3dUaHJvdHRsZU1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tdW5pdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBwcm92aWRlcl9hbmtyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1hbmtyLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfYWxjaGVteV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItYWxjaGVteS5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2NoYWluc3RhY2tfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWNoYWluc3RhY2suanNcIik7XG5jb25zdCBwcm92aWRlcl9jbG91ZGZsYXJlX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1jbG91ZGZsYXJlLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfZXRoZXJzY2FuX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1ldGhlcnNjYW4uanNcIik7XG5jb25zdCBwcm92aWRlcl9pbmZ1cmFfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWluZnVyYS5qc1wiKTtcbi8vaW1wb3J0IHsgUG9ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1wb2NrZXQuanNcIjtcbmNvbnN0IHByb3ZpZGVyX3F1aWNrbm9kZV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItcXVpY2tub2RlLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfZmFsbGJhY2tfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWZhbGxiYWNrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl93ZWJzb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXdlYnNvY2tldC5qc1wiKTtcbmZ1bmN0aW9uIGlzV2ViU29ja2V0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5zZW5kKSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiAodmFsdWUuY2xvc2UpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuY29uc3QgVGVzdG5ldHMgPSBcImdvZXJsaSBrb3ZhbiBzZXBvbGlhIGNsYXNzaWNLb3R0aSBvcHRpbWlzbS1nb2VybGkgYXJiaXRydW0tZ29lcmxpIG1hdGljLW11bWJhaSBibmJ0XCIuc3BsaXQoXCIgXCIpO1xuLyoqXG4gKiAgUmV0dXJucyBhIGRlZmF1bHQgcHJvdmlkZXIgZm9yICUlbmV0d29yayUlLlxuICpcbiAqICBJZiAlJW5ldHdvcmslJSBpcyBhIFtbV2ViU29ja2V0TGlrZV1dIG9yIHN0cmluZyB0aGF0IGJlZ2lucyB3aXRoXG4gKiAgYGBcIndzOlwiYGAgb3IgYGBcIndzczpcImBgLCBhIFtbV2ViU29ja2V0UHJvdmlkZXJdXSBpcyByZXR1cm5lZCBiYWNrZWRcbiAqICBieSB0aGF0IFdlYlNvY2tldCBvciBVUkwuXG4gKlxuICogIElmICUlbmV0d29yayUlIGlzIGEgc3RyaW5nIHRoYXQgYmVnaW5zIHdpdGggYGBcIkhUVFA6XCJgYCBvciBgYFwiSFRUUFM6XCJgYCxcbiAqICBhIFtbSnNvblJwY1Byb3ZpZGVyXV0gaXMgcmV0dXJuZWQgY29ubmVjdGVkIHRvIHRoYXQgVVJMLlxuICpcbiAqICBPdGhlcndpc2UsIGEgZGVmYXVsdCBwcm92aWRlciBpcyBjcmVhdGVkIGJhY2tlZCBieSB3ZWxsLWtub3duIHB1YmxpY1xuICogIFdlYjMgYmFja2VuZHMgKHN1Y2ggYXMgW1tsaW5rLWluZnVyYV1dKSB1c2luZyBjb21tdW5pdHktcHJvdmlkZWQgQVBJXG4gKiAga2V5cy5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGFsbG93cyBzcGVjaWZ5aW5nIGN1c3RvbSBBUEkga2V5cyBwZXIgYmFja2VuZCAoc2V0dGluZ1xuICogIGFuIEFQSSBrZXkgdG8gYGBcIi1cImBgIHdpbGwgb21pdCB0aGF0IHByb3ZpZGVyKSBhbmQgYGBvcHRpb25zLmV4Y2x1c2l2ZWBgXG4gKiAgY2FuIGJlIHNldCB0byBlaXRoZXIgYSBiYWNrZW5kIG5hbWUgb3IgYW5kIGFycmF5IG9mIGJhY2tlbmQgbmFtZXMsIHdoaWNoXG4gKiAgd2lsbCB3aGl0ZWxpc3QgKipvbmx5KiogdGhvc2UgYmFja2VuZHMuXG4gKlxuICogIEN1cnJlbnQgYmFja2VuZCBzdHJpbmdzIHN1cHBvcnRlZCBhcmU6XG4gKiAgLSBgYFwiYWxjaGVteVwiYGBcbiAqICAtIGBgXCJhbmtyXCJgYFxuICogIC0gYGBcImNsb3VkZmxhcmVcImBgXG4gKiAgLSBgYFwiY2hhaW5zdGFja1wiYGBcbiAqICAtIGBgXCJldGhlcnNjYW5cImBgXG4gKiAgLSBgYFwiaW5mdXJhXCJgYFxuICogIC0gYGBcInB1YmxpY1BvbHlnb25cImBgXG4gKiAgLSBgYFwicXVpY2tub2RlXCJgYFxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIENvbm5lY3QgdG8gYSBsb2NhbCBHZXRoIG5vZGVcbiAqICAgIHByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyKFwiaHR0cDovL2xvY2FsaG9zdDo4NTQ1L1wiKTtcbiAqXG4gKiAgICAvLyBDb25uZWN0IHRvIEV0aGVyZXVtIG1haW5uZXQgd2l0aCBhbnkgY3VycmVudCBhbmQgZnV0dXJlXG4gKiAgICAvLyB0aGlyZC1wYXJ0eSBzZXJ2aWNlcyBhdmFpbGFibGVcbiAqICAgIHByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyKFwibWFpbm5ldFwiKTtcbiAqXG4gKiAgICAvLyBDb25uZWN0IHRvIFBvbHlnb24sIGJ1dCBvbmx5IGFsbG93IEV0aGVyc2NhbiBhbmRcbiAqICAgIC8vIElORlVSQSBhbmQgdXNlIFwiTVlfQVBJX0tFWVwiIGluIGNhbGxzIHRvIEV0aGVyc2Nhbi5cbiAqICAgIHByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIiwge1xuICogICAgICBldGhlcnNjYW46IFwiTVlfQVBJX0tFWVwiLFxuICogICAgICBleGNsdXNpdmU6IFsgXCJldGhlcnNjYW5cIiwgXCJpbmZ1cmFcIiBdXG4gKiAgICB9KTtcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dTZXJ2aWNlID0gKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5leGNsdXNpdmUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IG9wdGlvbnMuZXhjbHVzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV4Y2x1c2l2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5leGNsdXNpdmUuaW5kZXhPZihuYW1lKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgJiYgbmV0d29yay5tYXRjaCgvXmh0dHBzPzovKSkge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIobmV0d29yayk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiICYmIG5ldHdvcmsubWF0Y2goL153c3M/Oi8pIHx8IGlzV2ViU29ja2V0TGlrZShuZXR3b3JrKSkge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX3dlYnNvY2tldF9qc18xLldlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIG5ldHdvcmsgYW5kIG5hbWUsIGlmIHBvc3NpYmxlXG4gICAgbGV0IHN0YXRpY05ldHdvcmsgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHN0YXRpY05ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKG5ldHdvcmspO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHByb3ZpZGVycyA9IFtdO1xuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJwdWJsaWNQb2x5Z29uXCIpICYmIHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgaWYgKHN0YXRpY05ldHdvcmsubmFtZSA9PT0gXCJtYXRpY1wiKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlcihcImh0dHBzOi9cXC9wb2x5Z29uLXJwYy5jb20vXCIsIHN0YXRpY05ldHdvcmssIHsgc3RhdGljTmV0d29yayB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yay5uYW1lID09PSBcIm1hdGljLWFtb3lcIikge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIoXCJodHRwczovXFwvcnBjLWFtb3kucG9seWdvbi50ZWNobm9sb2d5L1wiLCBzdGF0aWNOZXR3b3JrLCB7IHN0YXRpY05ldHdvcmsgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJhbGNoZW15XCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfYWxjaGVteV9qc18xLkFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFsY2hlbXkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiYW5rclwiKSAmJiBvcHRpb25zLmFua3IgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2Fua3JfanNfMS5BbmtyUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbmtyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImNoYWluc3RhY2tcIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBwcm92aWRlcl9jaGFpbnN0YWNrX2pzXzEuQ2hhaW5zdGFja1Byb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuY2hhaW5zdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJjbG91ZGZsYXJlXCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfY2xvdWRmbGFyZV9qc18xLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImV0aGVyc2NhblwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xLkV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuZXRoZXJzY2FuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImluZnVyYVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb2plY3RJZCA9IG9wdGlvbnMuaW5mdXJhO1xuICAgICAgICAgICAgbGV0IHByb2plY3RTZWNyZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChwcm9qZWN0SWQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IHByb2plY3RJZC5wcm9qZWN0U2VjcmV0O1xuICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RJZC5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfaW5mdXJhX2pzXzEuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgLypcbiAgICAgICAgaWYgKG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYXBwSWQgPSBvcHRpb25zLnBvY2tldDtcbiAgICAgICAgICAgICAgICBsZXQgc2VjcmV0S2V5OiB1bmRlZmluZWQgfCBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGxvYWRCYWxhbmNlcjogdW5kZWZpbmVkIHwgYm9vbGVhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGFwcElkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQmFsYW5jZXIgPSAhIWFwcElkLmxvYWRCYWxhbmNlcjtcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0S2V5ID0gYXBwSWQuc2VjcmV0S2V5O1xuICAgICAgICAgICAgICAgICAgICBhcHBJZCA9IGFwcElkLmFwcElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgUG9ja2V0UHJvdmlkZXIobmV0d29yaywgYXBwSWQsIHNlY3JldEtleSwgbG9hZEJhbGFuY2VyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgeyBjb25zb2xlLmxvZyhlcnJvcik7IH1cbiAgICAgICAgfVxuICAgICovXG4gICAgaWYgKGFsbG93U2VydmljZShcInF1aWNrbm9kZVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gb3B0aW9ucy5xdWlja25vZGU7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfcXVpY2tub2RlX2pzXzEuUXVpY2tOb2RlUHJvdmlkZXIobmV0d29yaywgdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHByb3ZpZGVycy5sZW5ndGgsIFwidW5zdXBwb3J0ZWQgZGVmYXVsdCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiXG4gICAgfSk7XG4gICAgLy8gTm8gbmVlZCBmb3IgYSBGYWxsYmFja1Byb3ZpZGVyXG4gICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1swXTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIHRoZSBmbG9vciBiZWNhdXNlIHB1YmxpYyB0aGlyZC1wYXJ0eSBwcm92aWRlcnMgY2FuIGJlIHVucmVsaWFibGUsXG4gICAgLy8gc28gYSBsb3cgbnVtYmVyIG9mIHByb3ZpZGVycyB3aXRoIGEgbGFyZ2UgcXVvcnVtIHdpbGwgZmFpbCB0b28gb2Z0ZW5cbiAgICBsZXQgcXVvcnVtID0gTWF0aC5mbG9vcihwcm92aWRlcnMubGVuZ3RoIC8gMik7XG4gICAgaWYgKHF1b3J1bSA+IDIpIHtcbiAgICAgICAgcXVvcnVtID0gMjtcbiAgICB9XG4gICAgLy8gVGVzdG5ldHMgZG9uJ3QgbmVlZCBhcyBzdHJvbmcgYSBzZWN1cml0eSBnYXVyYW50ZWUgYW5kIHNwZWVkIGlzXG4gICAgLy8gbW9yZSB1c2VmdWwgZHVyaW5nIHRlc3RpbmdcbiAgICBpZiAoc3RhdGljTmV0d29yayAmJiBUZXN0bmV0cy5pbmRleE9mKHN0YXRpY05ldHdvcmsubmFtZSkgIT09IC0xKSB7XG4gICAgICAgIHF1b3J1bSA9IDE7XG4gICAgfVxuICAgIC8vIFByb3ZpZGVkIG92ZXJyaWRlIHFvcnVtIHRha2VzIHByaW9yaXR5XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0pIHtcbiAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgfVxuICAgIHJldHVybiBuZXcgcHJvdmlkZXJfZmFsbGJhY2tfanNfMS5GYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgdW5kZWZpbmVkLCB7IHF1b3J1bSB9KTtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBleHBvcnRzLkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5jbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbiA9IE11bHRpY29pblByb3ZpZGVyUGx1Z2luO1xuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luID0gQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbjtcbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQoKDAsIGluZGV4X2pzXzQubmFtZWhhc2gpKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5kbnNFbmNvZGUpKHRoaXMubmFtZSwgMjU1KSxcbiAgICAgICAgICAgICAgICBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHBhcmFtcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IGluZGV4X2pzXzIuWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0hleFN0cmluZykoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wcm92aWRlci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luUGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbY29pblR5cGVdKTtcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29pblBsdWdpbi5kZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7KDAsIGluZGV4X2pzXzUuZW5jb2RlQmFzZTU4KShcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGZhbHNlLCBgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhdmF0YXIgdXJsIG9yIGBgbnVsbGBgIGlmIHRoZSBhdmF0YXIgaXMgZWl0aGVyXG4gICAgICogIHVuY29uZmlndXJlZCBvciBpbmNvcnJlY3RseSBjb25maWd1cmVkIChlLmcuIHJlZmVyZW5jZXMgYW4gTkZUXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXG4gICAgICpcbiAgICAgKiAgSWYgZGlhZ25vc2luZyBpc3N1ZXMgd2l0aCBjb25maWd1cmF0aW9ucywgdGhlIFtbX2dldEF2YXRhcl1dXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XG4gICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hlbiByZXNvbHZpbmcgYW4gYXZhdGFyLCB0aGVyZSBhcmUgbWFueSBzdGVwcyBpbnZvbHZlZCwgc3VjaFxuICAgICAqICBmZXRjaGluZyBtZXRhZGF0YSBhbmQgcG9zc2libHkgdmFsaWRhdGluZyBvd25lcnNoaXAgb2YgYW5cbiAgICAgKiAgTkZULlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4YW1pbmUgZWFjaCBzdGVwIGFuZCB0aGUgdmFsdWUgaXRcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBnZXRJcGZzTGluayhhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IGAhJHtzY2hlbWV9Y2FpcGAsIHZhbHVlOiAobWF0Y2hbMl0gfHwgXCJcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gY29tcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCAoMCwgaW5kZXhfanNfNS50b0JlSGV4KSh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAobmV3IGluZGV4X2pzXzUuRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkoYnl0ZXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogbnVsbCB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RW5zQWRkcmVzcyhwcm92aWRlcikge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydCkoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IGNvbnRyYWN0LnJlc29sdmVyKCgwLCBpbmRleF9qc180Lm5hbWVoYXNoKShuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBpbmRleF9qc18yLlplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpLFxuICAgICAgICAgICAgLy8gc28gcHJvYmFibHkgYSBsaW5rIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIEVOUyByZXNvbHZlciBmb3IgJSVuYW1lJSUgdXNpbmcgJSVwcm92aWRlciUlIG9yXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5hbWUocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci4jZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIGN1cnJlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRW5zUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgIShhd2FpdCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBFbnNSZXNvbHZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy1yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSA9IGV4cG9ydHMuZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZXhwb3J0cy5mb3JtYXRSZWNlaXB0TG9nID0gZXhwb3J0cy5mb3JtYXRCbG9jayA9IGV4cG9ydHMuZm9ybWF0TG9nID0gZXhwb3J0cy5mb3JtYXRVaW50MjU2ID0gZXhwb3J0cy5mb3JtYXRIYXNoID0gZXhwb3J0cy5mb3JtYXREYXRhID0gZXhwb3J0cy5mb3JtYXRCb29sZWFuID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLmFycmF5T2YgPSBleHBvcnRzLmFsbG93TnVsbCA9IHZvaWQgMDtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmFsbG93TnVsbCA9IGFsbG93TnVsbDtcbmZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0LCBhbGxvd051bGwpIHtcbiAgICByZXR1cm4gKChhcnJheSkgPT4ge1xuICAgICAgICBpZiAoYWxsb3dOdWxsICYmIGFycmF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5mdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZXMgJiYga2V5IGluIGFsdE5hbWVzICYmICEoc3JjS2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjS2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG52ID0gZm9ybWF0W2tleV0odmFsdWVbc3JjS2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFwibm90LWFuLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRCb29sZWFuID0gZm9ybWF0Qm9vbGVhbjtcbmZ1bmN0aW9uIGZvcm1hdERhdGEodmFsdWUpIHtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5mb3JtYXREYXRhID0gZm9ybWF0RGF0YTtcbmZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuZm9ybWF0SGFzaCA9IGZvcm1hdEhhc2g7XG5mdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCEoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc180Lnplcm9QYWRWYWx1ZSkodmFsdWUsIDMyKTtcbn1cbmV4cG9ydHMuZm9ybWF0VWludDI1NiA9IGZvcm1hdFVpbnQyNTY7XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBpbmRleF9qc18xLmdldEFkZHJlc3MsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogaW5kZXhfanNfNC5nZXROdW1iZXIsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmV4cG9ydHMuZm9ybWF0TG9nID0gZm9ybWF0TG9nO1xuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBudW1iZXI6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIHRpbWVzdGFtcDogaW5kZXhfanNfNC5nZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogaW5kZXhfanNfNC5nZXRCaWdJbnQsXG4gICAgZ2FzVXNlZDogaW5kZXhfanNfNC5nZXRCaWdJbnQsXG4gICAgc3RhdGVSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgcmVjZWlwdHNSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCwgbnVsbCksXG4gICAgZXhjZXNzQmxvYkdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICBtaW5lcjogYWxsb3dOdWxsKGluZGV4X2pzXzEuZ2V0QWRkcmVzcyksXG4gICAgcHJldlJhbmRhbzogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXRCaWdJbnQpXG59LCB7XG4gICAgcHJldlJhbmRhbzogW1wibWl4SGFzaFwiXVxufSk7XG5mdW5jdGlvbiBmb3JtYXRCbG9jayh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5mb3JtYXRCbG9jayA9IGZvcm1hdEJsb2NrO1xuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogaW5kZXhfanNfMS5nZXRBZGRyZXNzLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRSZWNlaXB0TG9nID0gZm9ybWF0UmVjZWlwdExvZztcbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChpbmRleF9qc18xLmdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaW5kZXhfanNfNC5oZXhsaWZ5KSxcbiAgICBnYXNVc2VkOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICBibG9iR2FzUHJpY2U6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCwgbnVsbCksXG4gICAgc3RhdHVzOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSk7XG59XG5leHBvcnRzLmZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdDtcbmZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KSh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICAvLyBTb21lIG5vZGVzIGRvIG5vdCByZXR1cm4gdGhpcywgdXN1YWxseSB0ZXN0IG5vZGVzIChsaWtlIEdhbmFjaGUpXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXROdW1iZXIsIHVuZGVmaW5lZCksXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmdldE51bWJlcikodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoaW5kZXhfanNfMy5hY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogYWxsb3dOdWxsKGFycmF5T2YoZm9ybWF0SGFzaCwgdHJ1ZSksIG51bGwpLFxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGluZGV4X2pzXzEuZ2V0QWRkcmVzcyxcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxuICAgICAgICBnYXNQcmljZTogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKSxcbiAgICAgICAgZ2FzTGltaXQ6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGluZGV4X2pzXzEuZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl0sXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9ICgwLCBpbmRleF9qc18xLmdldENyZWF0ZUFkZHJlc3MpKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayBmZWUgZGF0YVxuICAgIC8vIEFkZCBhbiBhY2Nlc3MgbGlzdCB0byBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoKHZhbHVlLnR5cGUgPT09IDEgfHwgdmFsdWUudHlwZSA9PT0gMikgJiYgdmFsdWUuYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gW107XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIHNpZ25hdHVyZVxuICAgIGlmICh2YWx1ZS5zaWduYXR1cmUpIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiAoMCwgaW5kZXhfanNfNC5nZXRCaWdJbnQpKHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5mb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlID0gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgKipQcm92aWRlcioqIHByb3ZpZGVzIGEgY29ubmVjdGlvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2hjaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGl0cyBjdXJyZW50IHN0YXRlLCBzaW11bGF0ZSBleGVjdXRpb24gYW5kIHNlbmQgdHJhbnNhY3Rpb25zXG4gKiAgdG8gdXBkYXRlIHRoZSBzdGF0ZS5cbiAqXG4gKiAgSXQgaXMgb25lIG9mIHRoZSBtb3N0IGZ1bmRhbWVudGFsIGNvbXBvbmVudHMgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhXG4gKiAgYmxvY2tjaGFpbiBhcHBsaWNhdGlvbiwgYW5kIHRoZXJlIGFyZSBtYW55IHdheXMgdG8gY29ubmVjdCwgc3VjaCBhcyBvdmVyXG4gKiAgSFRUUCwgV2ViU29ja2V0cyBvciBpbmplY3RlZCBwcm92aWRlcnMgc3VjaCBhcyBbTWV0YU1hc2tdKGxpbmstbWV0YW1hc2spLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnM6UHJvdmlkZXJzICBbYWJvdXQtcHJvdmlkZXJzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldEV2ZW50U3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0UGVuZGluZ1N1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldEJsb2NrU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0U3Vic2NyaWJlciA9IGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JcGNTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblBsdWdpbiA9IGV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBleHBvcnRzLkNoYWluc3RhY2tQcm92aWRlciA9IGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSBleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuQnJvd3NlclByb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNBcGlQcm92aWRlciA9IGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IGV4cG9ydHMuY29weVJlcXVlc3QgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5GZWVEYXRhID0gZXhwb3J0cy5CbG9jayA9IGV4cG9ydHMuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLkVuc1BsdWdpbiA9IGV4cG9ydHMuR2FzQ29zdFBsdWdpbiA9IGV4cG9ydHMuTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuTm9uY2VNYW5hZ2VyID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbiA9IGV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IGV4cG9ydHMuVm9pZFNpZ25lciA9IGV4cG9ydHMuQWJzdHJhY3RTaWduZXIgPSBleHBvcnRzLlVubWFuYWdlZFN1YnNjcmliZXIgPSBleHBvcnRzLkFic3RyYWN0UHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5tYW5hZ2VkU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5Vbm1hbmFnZWRTdWJzY3JpYmVyOyB9IH0pO1xudmFyIGFic3RyYWN0X3NpZ25lcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3NpZ25lcl9qc18xLkFic3RyYWN0U2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVm9pZFNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3Rfc2lnbmVyX2pzXzEuVm9pZFNpZ25lcjsgfSB9KTtcbnZhciBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3dUaHJvdHRsZU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2U7IH0gfSk7XG52YXIgZGVmYXVsdF9wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vZGVmYXVsdC1wcm92aWRlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdF9wcm92aWRlcl9qc18xLmdldERlZmF1bHRQcm92aWRlcjsgfSB9KTtcbnZhciBlbnNfcmVzb2x2ZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Vucy1yZXNvbHZlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1Jlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnNfcmVzb2x2ZXJfanNfMS5FbnNSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpY29pblByb3ZpZGVyUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnNfcmVzb2x2ZXJfanNfMS5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbjsgfSB9KTtcbnZhciBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV0d29ya1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV0d29ya19qc18xLk5ldHdvcms7IH0gfSk7XG52YXIgc2lnbmVyX25vbmNlbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4vc2lnbmVyLW5vbmNlbWFuYWdlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vbmNlTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmVyX25vbmNlbWFuYWdlcl9qc18xLk5vbmNlTWFuYWdlcjsgfSB9KTtcbnZhciBwbHVnaW5zX25ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdpbnNfbmV0d29ya19qc18xLk5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHYXNDb3N0UGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5HYXNDb3N0UGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5zUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5FbnNQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVEYXRhTmV0d29ya1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luc19uZXR3b3JrX2pzXzEuRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luOyB9IH0pO1xudmFyIHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJsb2NrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLkJsb2NrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5GZWVEYXRhOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLkxvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlY2VpcHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdDsgfSB9KTtcbnZhciBwcm92aWRlcl9mYWxsYmFja19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZmFsbGJhY2suanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9mYWxsYmFja19qc18xLkZhbGxiYWNrUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNBcGlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNBcGlQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjU2lnbmVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2Jyb3dzZXJfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWJyb3dzZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCcm93c2VyUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2Jyb3dzZXJfanNfMS5Ccm93c2VyUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfYWxjaGVteV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItYWxjaGVteS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfYWxjaGVteV9qc18xLkFsY2hlbXlQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9hbmtyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1hbmtyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5rclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9hbmtyX2pzXzEuQW5rclByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2Nsb3VkZmxhcmVfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWNsb3VkZmxhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZGZsYXJlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2Nsb3VkZmxhcmVfanNfMS5DbG91ZGZsYXJlUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfY2hhaW5zdGFja19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItY2hhaW5zdGFjay5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYWluc3RhY2tQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfY2hhaW5zdGFja19qc18xLkNoYWluc3RhY2tQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9ldGhlcnNjYW5fanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWV0aGVyc2Nhbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9ldGhlcnNjYW5fanNfMS5FdGhlcnNjYW5Qcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfZXRoZXJzY2FuX2pzXzEuRXRoZXJzY2FuUGx1Z2luOyB9IH0pO1xudmFyIHByb3ZpZGVyX2luZnVyYV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItaW5mdXJhLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2luZnVyYV9qc18xLkluZnVyYVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2luZnVyYV9qc18xLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX3BvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItcG9ja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3BvY2tldF9qc18xLlBvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX3F1aWNrbm9kZV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItcXVpY2tub2RlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVpY2tOb2RlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3F1aWNrbm9kZV9qc18xLlF1aWNrTm9kZVByb3ZpZGVyOyB9IH0pO1xuY29uc3QgcHJvdmlkZXJfaXBjc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1pcGNzb2NrZXQuanNcIik7IC8qLWJyb3dzZXIqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXBjU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2lwY3NvY2tldF9qc18xLklwY1NvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX3NvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItc29ja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3NvY2tldF9qc18xLlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX3dlYnNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItd2Vic29ja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3dlYnNvY2tldF9qc18xLldlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX3NvY2tldF9qc18yID0gcmVxdWlyZShcIi4vcHJvdmlkZXItc29ja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0U3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfc29ja2V0X2pzXzIuU29ja2V0U3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldEJsb2NrU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfc29ja2V0X2pzXzIuU29ja2V0QmxvY2tTdWJzY3JpYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0UGVuZGluZ1N1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3NvY2tldF9qc18yLlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0RXZlbnRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9zb2NrZXRfanNfMi5Tb2NrZXRFdmVudFN1YnNjcmliZXI7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cbiAqICBpbnRlcmFjdCB3aXRoIGEgc3BlY2lmaWMgY2hhaW4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmsgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHBsdWdpbnNfbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCIpO1xuLyogKiAqICpcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cbi8vIHNwZWNpZnkgaG93IHRvIGFjY2VzcyBMMSwgZm9yIHRoZSBwdXJwb3NlIG9mIHJlc29sdmluZyBFTlMsXG4vLyBmb3IgZXhhbXBsZS5cbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSBwcm92aWRlciE6IFByb3ZpZGVyO1xuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLmxheWVyLW9uZS1jb25uZWN0aW9uXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG59XG4qL1xuY29uc3QgTmV0d29ya3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXG4gKiAgZm9yIHBsdWctaW5zIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxuICovXG5jbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKGNoYWluSWQpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIE5ldHdvcmsuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm5hbWUsIGNoYWluSWQ6IFN0cmluZyh0aGlzLmNoYWluSWQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjb21tb24gbmFtZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXG4gICAgICogIG5hbWVzLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7IHRoaXMuI25hbWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KSh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgcGx1Z2luc19uZXR3b3JrX2pzXzEuR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gKDAsIGluZGV4X2pzXzEuYWNjZXNzTGlzdGlmeSkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25hYmxlIHdpdGggbmV0d29yay1saWtlIGFiaWxpdGllc1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZihuZXR3b3JrLm5hbWUpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXR3b3JraXNoXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IHBsdWdpbnNfbmV0d29ya19qc18xLkVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtzLnNldChuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrID0gTmV0d29yaztcbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0KShmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IHBsdWdpbnNfbmV0d29ya19qc18xLkVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5HYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7IGVuc05ldHdvcms6IDExMTU1MTExIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiaG9sZXNreVwiLCAxNzAwMCwgeyBlbnNOZXR3b3JrOiAxNzAwMCB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tc2Vwb2xpYVwiLCA0MjE2MTQsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2VcIiwgODQ1MywgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1nb2VybGlcIiwgODQ1MzEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5iXCIsIDU2LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJ0XCIsIDk3LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtZ29lcmxpXCIsIDU5MTQwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1tdW1iYWlcIiwgODAwMDEsIHtcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi10ZXN0bmV0LnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbVwiLCAxMCwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLkZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5FbnNQbHVnaW4gPSBleHBvcnRzLkdhc0Nvc3RQbHVnaW4gPSBleHBvcnRzLk5ldHdvcmtQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBwcm9wZXJ0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmNsYXNzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrUGx1Z2luKHRoaXMubmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gTmV0d29ya1BsdWdpbjtcbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5jbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgdG8gdHJlYXQgdGhlc2UgdmFsdWVzIGFzIHZhbGlkIGZyb20uXG4gICAgICpcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcbiAgICAgKiAgbXVsdXRpcGxlIGhhcmRmb3JrcyB0byBiZSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZWZmZWN0aXZlQmxvY2s7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXG4gICAgICovXG4gICAgdHhCYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxuICAgICAqL1xuICAgIHR4Q3JlYXRlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciB6ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhWmVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFOb256ZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgYWRkcmVzcyBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXG4gICAgICogIHdpdGggdGhlIGFzc29jaWF0ZWQgJSVjb3N0cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xuICAgICAgICBpZiAoZWZmZWN0aXZlQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGBvcmcuZXRoZXJzLm5ldHdvcmsucGx1Z2lucy5HYXNDb3N0IyR7KGVmZmVjdGl2ZUJsb2NrIHx8IDApfWApO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChjb3N0cyB8fCB7fSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gR2FzQ29zdFBsdWdpbjtcbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG5leHBvcnRzLkVuc1BsdWdpbiA9IEVuc1BsdWdpbjtcbi8qKlxuICogIEEgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbmQgYWx0ZXJuYXRlXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXG4gKlxuICogIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBbW2xpbmstZWlwLTE1NTldXSBtYXlcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxuICovXG5jbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnRzLkZlZURhdGFOZXR3b3JrUGx1Z2luID0gRmVlRGF0YU5ldHdvcmtQbHVnaW47XG5jbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmV4cG9ydHMuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiA9IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW47XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgW1tsaW5rLWFsY2hlbXldXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIEFtb3kgVGVzdG5ldCAoYGBtYXRpYy1hbW95YGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpBbGNoZW15ICBbcHJvdmlkZXJzLWFsY2hlbXldXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5hbGNoZW15YXBpLmlvXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLXNlcG9saWEuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJiLWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmItc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYmFzZS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJhc2UtZ29lcmxpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwibWF0aWMtYW1veVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1hbW95LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0LWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHQtc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qKlxuICogIFRoZSAqKkFsY2hlbXlQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstYWxjaGVteV1dXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstYWxjaGVteS1zaWdudXApLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5XG4gKi9cbmNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIGFwaUtleTtcbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcGlLZXkgPSBkZWZhdWx0QXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBBbGNoZW15UHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15UHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICAvLyBodHRwczovL2RvY3MuYWxjaGVteS5jb20vcmVmZXJlbmNlL3RyYWNlLXRyYW5zYWN0aW9uXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2UsIHR4IH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgIHRyYWNlOiB0aGlzLnNlbmQoXCJ0cmFjZV90cmFuc2FjdGlvblwiLCBbcmVxLmhhc2hdKSxcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbihyZXEuaGFzaClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09IG51bGwgfHwgdHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRyYWNlWzBdLnJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAodHJhY2VbMF0uZXJyb3IgPT09IFwiUmV2ZXJ0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCFlcnJvciwgXCJhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdHJhbnNhY3Rpb24gZXhlY3V0aW9uc1wiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IG51bGwgLy8gQFRPRE9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwiY291bGQgbm90IHBhcnNlIHRyYWNlIHJlc3VsdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRyYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzEuRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YyLyR7YXBpS2V5fWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiYWxjaGVteVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBBbGNoZW15UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1hbGNoZW15LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstYW5rcl1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxuICogIC0gQmFzZSBHb2VybGlhIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gQk5CIChgYGJuYmBgKVxuICogIC0gQk5CIFRlc3RuZXQgKGBgYm5idGBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkFua3IgIFtwcm92aWRlcnMtYW5rcl1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCI5ZjdkOTI5YjAxOGNkZmZiMzM4NTE3ZWZhMDZmNTgzNTllODZmZjFmZmQzNTBiYzg4OTczODUyMzY1OWU3OTcyXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhcIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2V0aF9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9hcmJpdHJ1bVwiO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2VcIjtcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYmFzZV9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2Vfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjX3Rlc3RuZXRfY2hhcGVsXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25fbXVtYmFpXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL29wdGltaXNtXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9vcHRpbWlzbV90ZXN0bmV0XCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vb3B0aW1pc21fc2Vwb2xpYVwiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipBbmtyUHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWFua3JdXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWFua3Itc2lnbnVwKS5cbiAqL1xuY2xhc3MgQW5rclByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IGZvciB0aGUgQW5rciBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQW5rclByb3ZpZGVyKiouXG4gICAgICpcbiAgICAgKiAgQnkgZGVmYXVsdCBjb25uZWN0aW5nIHRvIGBgbWFpbm5ldGBgIHdpdGggYSBoaWdobHkgdGhyb3R0bGVkXG4gICAgICogIEFQSSBrZXkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmtyIGRvZXMgbm90IHN1cHBvcnQgZmlsdGVySWQsIHNvIHdlIGZvcmNlIHBvbGxpbmdcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcG9sbGluZzogdHJ1ZSwgc3RhdGljTmV0d29yazogbmV0d29yayB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQW5rclByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmtyUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJSB3aXRoXG4gICAgICogICUlYXBpS2V5JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzEuRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9LyR7YXBpS2V5fWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiQW5rclByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmVycm9yICYmIGVycm9yLmVycm9yLm1lc3NhZ2UgPT09IFwiSU5URVJOQUxfRVJST1I6IGNvdWxkIG5vdCByZXBsYWNlIGV4aXN0aW5nIHR4XCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcik7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5rclByb3ZpZGVyID0gQW5rclByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYW5rci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NlclByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG47XG4vKipcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxuICogIGFkaGVyZXMgdG8gdGhlIFtbbGluay1laXAtMTE5M11dIHN0YW5kYXJkLCB3aGljaCBtb3N0IChpZiBub3QgYWxsKVxuICogIGN1cnJlbnRseSBkby5cbiAqL1xuY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNyZXF1ZXN0O1xuICAgIC8qKlxuICAgICAqICBDb25ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShldGhlcmV1bSAmJiBldGhlcmV1bS5yZXF1ZXN0LCBcImludmFsaWQgRUlQLTExOTMgcHJvdmlkZXJcIiwgXCJldGhlcmV1bVwiLCBldGhlcmV1bSk7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IGFzeW5jIChtZXRob2QsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRFaXAxMTkzUmVxdWVzdFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICBlcnJvci5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiRUlQLTExOTMgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCByZXF1ZXN0XCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3JlcXVlc3QocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zIHx8IFtdKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBpZDogcGF5bG9hZC5pZCwgcmVzdWx0IH1dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IGUuY29kZSwgZGF0YTogZS5kYXRhLCBtZXNzYWdlOiBlLm1lc3NhZ2UgfVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XG4gICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAvLyBFSVAtMTE5MyBnaXZlcyB1cyBzb21lIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZXMsIHNvIHJld3JpdGVcbiAgICAgICAgLy8gdGhlbSBpbnRvIFxuICAgICAgICBzd2l0Y2ggKGVycm9yLmVycm9yLmNvZGUgfHwgLTEpIHtcbiAgICAgICAgICAgIGNhc2UgNDAwMTpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11c2VyLWRlbmllZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQyMDA6XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IGBldGhlcnMtdW5zdXBwb3J0ZWQ6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiB0aGUgcHJvdmlkZXIgbWFuYWdlcyB0aGUgJSVhZGRyZXNzJSUuXG4gICAgICovXG4gICAgYXN5bmMgaGFzU2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhY2NvdW50cy5sZW5ndGggPiBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMuZmlsdGVyKChhKSA9PiAoYS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzKSkubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmhhc1NpZ25lcihhZGRyZXNzKSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy9jb25zdCByZXNwID0gXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcmVxdWVzdChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSRVNQXCIsIHJlc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVycm9yLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCB7IGlkOiBwYXlsb2FkLmlkLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZ2V0U2lnbmVyKGFkZHJlc3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3NlclByb3ZpZGVyID0gQnJvd3NlclByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYnJvd3Nlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhaW5zdGFja1Byb3ZpZGVyID0gdm9pZCAwO1xuLyoqXG4gKiAgW1tsaW5rLWNoYWluc3RhY2tdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6Q2hhaW5zdGFjayAgW3Byb3ZpZGVycy1jaGFpbnN0YWNrXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmZ1bmN0aW9uIGdldEFwaUtleShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6IHJldHVybiBcIjM5ZjFkNjdjZWRmOGI3ODMxMDEwYTY2NTMyOGM5MTk3XCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOiByZXR1cm4gXCIwNTUwYzIwOWRiMzNjM2FiZjRjYzkyN2UxZTE4Y2VhMVwiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6IHJldHVybiBcIjk4YjVhNzdlNTMxNjE0Mzg3MzY2ZjZmYzVkYTA5N2Y4XCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOiByZXR1cm4gXCJjZDlkNGQ3MDM3NzQ3MWFhN2MxNDJlYzRhNDIwNTI0OVwiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVyZXVtLW1haW5uZXQuY29yZS5jaGFpbnN0YWNrLmNvbVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLW1haW5uZXQuY29yZS5jaGFpbnN0YWNrLmNvbVwiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJic2MtbWFpbm5ldC5jb3JlLmNoYWluc3RhY2suY29tXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tYWlubmV0LmNvcmUuY2hhaW5zdGFjay5jb21cIjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqQ2hhaW5zdGFja1Byb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1jaGFpbnN0YWNrXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1jaGFpbnN0YWNrKS5cbiAqL1xuY2xhc3MgQ2hhaW5zdGFja1Byb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IGZvciB0aGUgQ2hhaW5zdGFjayBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkNoYWluc3RhY2tQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGdldEFwaUtleShuZXR3b3JrLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBDaGFpbnN0YWNrUHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbnN0YWNrUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGdldEFwaUtleSh0aGlzLl9uZXR3b3JrLm5hbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBwcmVwYXJlZCByZXF1ZXN0IGZvciBjb25uZWN0aW5nIHRvICUlbmV0d29yayUlXG4gICAgICogIHdpdGggJSVhcGlLZXklJSBhbmQgJSVwcm9qZWN0U2VjcmV0JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZ2V0QXBpS2V5KG5ldHdvcmsubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBnZXRBcGlLZXkobmV0d29yay5uYW1lKSkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJDaGFpbnN0YWNrUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhaW5zdGFja1Byb3ZpZGVyID0gQ2hhaW5zdGFja1Byb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItY2hhaW5zdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEFib3V0IENsb3VkZmxhcmVcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6Q2xvdWRmbGFyZSAgW3Byb3ZpZGVycy1jbG91ZGZsYXJlXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbi8qKlxuICogIEFib3V0IENsb3VkZmxhcmUuLi5cbiAqL1xuY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoX25ldHdvcmspIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobmV0d29yay5uYW1lID09PSBcIm1haW5uZXRcIiwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBfbmV0d29yayk7XG4gICAgICAgIHN1cGVyKFwiaHR0cHM6L1xcL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIiwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gQ2xvdWRmbGFyZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItY2xvdWRmbGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFtbbGluay1ldGhlcnNjYW5dXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgYSBjb21iaW5hdGlvbiBvZiBKU09OLVJQQyBhbmQgY3VzdG9tIEFQSVxuICogIGVuZHBvaW50cy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gSG9sZXNreSBUZXN0bmV0IChgYGhvbGVza3lgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBNYWlubmV0IChgYGJuYmBgKVxuICogIC0gQk5CIFNtYXJ0IENoYWluIFRlc3RuZXQgKGBgYm5idGBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gUG9seWdvbiBNdW1iYWkgVGVzdG5ldCAoYGBtYXRpYy1tdW1iYWlgYClcbiAqICAtIFBvbHlnb24gQW1veSBUZXN0bmV0IChgYG1hdGljLWFtb3lgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW4gIFtwcm92aWRlcnMtZXRoZXJzY2FuXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5FdGhlcnNjYW5QbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY29udHJhY3QvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwbHVnaW5zX25ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgVEhST1RUTEUgPSAyMDAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuY29uc3QgRXRoZXJzY2FuUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5FdGhlcnNjYW5cIjtcbi8qKlxuICogIEEgTmV0d29yayBjYW4gaW5jbHVkZSBhbiAqKkV0aGVyc2NhblBsdWdpbioqIHRvIHByb3ZpZGVcbiAqICBhIGN1c3RvbSBiYXNlIFVSTC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW5cbiAqL1xuY2xhc3MgRXRoZXJzY2FuUGx1Z2luIGV4dGVuZHMgcGx1Z2luc19uZXR3b3JrX2pzXzEuTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBFdGhlcnNjYW4gQVBJIGJhc2UgVVJMLlxuICAgICAqL1xuICAgIGJhc2VVcmw7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFdGhlcnNjYW5Qcm92aWRlcioqIHdoaWNoIHdpbGwgdXNlXG4gICAgICogICUlYmFzZVVybCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwpIHtcbiAgICAgICAgc3VwZXIoRXRoZXJzY2FuUGx1Z2luSWQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGJhc2VVcmwgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEV0aGVyc2NhblBsdWdpbih0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXRoZXJzY2FuUGx1Z2luID0gRXRoZXJzY2FuUGx1Z2luO1xuY29uc3Qgc2tpcEtleXMgPSBbXCJlbmFibGVDY2lwUmVhZFwiXTtcbmxldCBuZXh0SWQgPSAxO1xuLyoqXG4gKiAgVGhlICoqRXRoZXJzY2FuQmFzZVByb3ZpZGVyKiogaXMgdGhlIHN1cGVyLWNsYXNzIG9mXG4gKiAgW1tFdGhlcnNjYW5Qcm92aWRlcl1dLCB3aGljaCBzaG91bGQgZ2VuZXJhbGx5IGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiAgU2luY2UgdGhlICoqRXRoZXJzY2FuUHJvdmlkZXIqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gKiAgW1tDb250cmFjdF1dIGFjY2VzcywgaW4gLy9yYXJlIGNhc2VzLy8gdGhhdCBjb250cmFjdHMgYXJlIG5vdFxuICogIHVzZWQsIHRoaXMgY2xhc3MgY2FuIHJlZHVjZSBjb2RlIHNpemUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuXG4gKi9cbmNsYXNzIEV0aGVyc2NhblByb3ZpZGVyIGV4dGVuZHMgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBuZXR3b3JrLlxuICAgICAqL1xuICAgIG5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IG9yIG51bGwgaWYgdXNpbmcgdGhlIGNvbW11bml0eSBwcm92aWRlZCBiYW5kd2lkdGguXG4gICAgICovXG4gICAgYXBpS2V5O1xuICAgICNwbHVnaW47XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFdGhlcnNjYW5CYXNlUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgX2FwaUtleSkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSAoX2FwaUtleSAhPSBudWxsKSA/IF9hcGlLZXkgOiBudWxsO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIHRoaXMuI3BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKEV0aGVyc2NhblBsdWdpbklkKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhcGlLZXksIG5ldHdvcmsgfSk7XG4gICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgbmV0d29yayBpcyBzdXBwb3J0ZWQgYnkgRXRoZXJzY2FuXG4gICAgICAgIHRoaXMuZ2V0QmFzZVVybCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmFzZSBVUkwuXG4gICAgICpcbiAgICAgKiAgSWYgYW4gW1tFdGhlcnNjYW5QbHVnaW5dXSBpcyBjb25maWd1cmVkIG9uIHRoZVxuICAgICAqICBbW0V0aGVyc2NhbkJhc2VQcm92aWRlcl9uZXR3b3JrXV0sIHJldHVybnMgdGhlIHBsdWdpbidzXG4gICAgICogIGJhc2VVcmwuXG4gICAgICovXG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BsdWdpbi5iYXNlVXJsO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5uZXR3b3JrLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1zZXBvbGlhLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImhvbGVza3lcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWhvbGVza3kuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmFyYmlzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGkuYXJiaXNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJibmJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmJzY3NjYW4uY29tXCI7XG4gICAgICAgICAgICBjYXNlIFwiYm5idFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktdGVzdG5ldC5ic2NzY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5wb2x5Z29uc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpYy1hbW95XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1hbW95LnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktdGVzdG5ldC5wb2x5Z29uc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS1vcHRpbWlzdGljLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgdGhpcy5uZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdGhlICUlbW9kdWxlJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFjY3VtICs9IGAmJHtrZXl9PSR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9ICgodGhpcy5hcGlLZXkpID8gYCZhcGlrZXk9JHt0aGlzLmFwaUtleX1gIDogXCJcIik7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEJhc2VVcmwoKX0vYXBpP21vZHVsZT0ke21vZHVsZX0ke3F1ZXJ5fSR7YXBpS2V5fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBVUkwgZm9yIHVzaW5nIFBPU1QgcmVxdWVzdHMuXG4gICAgICovXG4gICAgZ2V0UG9zdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0QmFzZVVybCgpfS9hcGlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGFyYW1ldGVycyBmb3IgdXNpbmcgUE9TVCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBnZXRQb3N0RGF0YShtb2R1bGUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICBwYXJhbXMuYXBpa2V5ID0gdGhpcy5hcGlLZXk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgJSVtb2R1bGUlJSB3aXRoICUlcGFyYW1zJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwb3N0JSUsIHRoZSByZXF1ZXN0IGlzIG1hZGUgYXMgYSBQT1NUIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2gobW9kdWxlLCBwYXJhbXMsIHBvc3QpIHtcbiAgICAgICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICAgICAgY29uc3QgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAocG9zdCA/IHRoaXMuZ2V0UG9zdERhdGEobW9kdWxlLCBwYXJhbXMpIDogbnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRSZXF1ZXN0XCIsIGlkLCB1cmwsIHBheWxvYWQ6IHBheWxvYWQgfSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfNC5GZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgcmVxdWVzdC5zZXRUaHJvdHRsZVBhcmFtcyh7IHNsb3RJbnRlcnZhbDogMTAwMCB9KTtcbiAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSAocmVxLCByZXNwLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbW11bml0eVJlc291cmNlKCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJFdGhlcnNjYW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnByb2Nlc3NGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5oYXNCb2R5KCkgPyBKU09OLnBhcnNlKCgwLCBpbmRleF9qc180LnRvVXRmOFN0cmluZykocmVzcG9uc2UuYm9keSkpIDoge307XG4gICAgICAgICAgICBjb25zdCB0aHJvdHRsZSA9ICgodHlwZW9mIChyZXN1bHQucmVzdWx0KSA9PT0gXCJzdHJpbmdcIikgPyByZXN1bHQucmVzdWx0IDogXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBKU09OIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdHVzID09IDAgJiYgcmVzdWx0Lm1lc3NhZ2UgPT0gXCJOT1RPS1wiICYmIHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcInByb3h5LU5PVE9LXCIsIGVycm9yOiByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcihyZXN1bHQucmVzdWx0LCBUSFJPVFRMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcIm51bGwgcmVzdWx0XCIsIGVycm9yOiByZXN1bHQucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3IocmVzdWx0LnJlc3VsdCwgVEhST1RUTEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gT2JqZWN0LmtleXMocGF5bG9hZCkubWFwKChrKSA9PiBgJHtrfT0ke3BheWxvYWRba119YCkuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yLCByZWFzb246IFwiYXNzZXJ0T2tcIiB9KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwicmVzcG9uc2UgZXJyb3JcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCBlcnJvcjogXCJtaXNzaW5nIGJvZHlcIiwgcmVhc29uOiBcIm51bGwgYm9keVwiIH0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJtaXNzaW5nIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgoMCwgaW5kZXhfanNfNC50b1V0ZjhTdHJpbmcpKHJlc3BvbnNlLmJvZHkpKTtcbiAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiaW52YWxpZCBKU09OLVJQQ1wiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiaW52YWxpZCBKU09OLVJQQyByZXNwb25zZSAobWlzc2luZyBqc29ucnBjPScyLjAnKVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBpbmZvOiB7IHJlc3VsdCB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiSlNPTi1SUEMgZXJyb3JcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImVycm9yIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gMSB8fCAodHlwZW9mIChyZXN1bHQubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgIXJlc3VsdC5tZXNzYWdlLm1hdGNoKC9eT0svKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImVycm9yIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0cmFuc2FjdGlvbiUlIG5vcm1hbGl6ZWQgZm9yIHRoZSBFdGhlcnNjYW4gQVBJLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChza2lwS2V5cy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrVGFnXCIgJiYgdmFsdWUgPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFF1YW50aXR5LXR5cGVzIHJlcXVpcmUgbm8gbGVhZGluZyB6ZXJvLCB1bmxlc3MgMFxuICAgICAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc180LnRvUXVhbnRpdHkpKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJhY2Nlc3NMaXN0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiW1wiICsgKDAsIGluZGV4X2pzXzMuYWNjZXNzTGlzdGlmeSkodmFsdWUpLm1hcCgoc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBge2FkZHJlc3M6XCIke3NldC5hZGRyZXNzfVwiLHN0b3JhZ2VLZXlzOltcIiR7c2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJyl9XCJdfWA7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIHRoZSBub3JtYWxpemVkIEV0aGVyc2NhbiBlcnJvci5cbiAgICAgKi9cbiAgICBfY2hlY2tFcnJvcihyZXEsIGVycm9yLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBQdWxsIGFueSBtZXNzYWdlIG91dCBpZiwgcG9zc2libGVcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzQuaXNFcnJvcikoZXJyb3IsIFwiU0VSVkVSX0VSUk9SXCIpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYW4gZXJyb3IgZW1pdHRlZCBieSBhIHByb3h5IGNhbGxcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmluZm8ucmVzdWx0LmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuaW5mby5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgbWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogcmVxLnRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiByZXZlcnRlZC9pKSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXJyb3IuaW5mby5yZXN1bHQuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICBjb25zdCBlID0gaW5kZXhfanNfMS5BYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihyZXEubWV0aG9kLCByZXEudHJhbnNhY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgICAgIGUuaW5mbyA9IHsgcmVxdWVzdDogcmVxLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGluZGV4X2pzXzMuVHJhbnNhY3Rpb24uZnJvbShyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudC9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGhpbmcgd2UgY291bGQgbm90IHByb2Nlc3NcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgIH1cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwgeyBhY3Rpb246IFwiZXRoX2Jsb2NrTnVtYmVyXCIgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9nYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgRXRoZXJzY2FuIGNvbXBsZXRlcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lID09PSBcIm1haW5uZXRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIxMDAwMDAwMDAwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV0d29yay5uYW1lID09PSBcIm9wdGltaXNtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiMTAwMDAwMFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFsbGJhY2sgb250byB0aGUgQWJzdHJhY3RQcm92aWRlciBkZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFdvcmtpbmcgd2l0aCBFdGhlcnNjYW4gdG8gZ2V0IHRoaXMgYWRkZWQ6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBhd2FpdCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHXCIsIGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyogVGhpcyBtaWdodCBiZSBzYWZlOyBidXQgZHVlIHRvIHJvdW5kaW5nIG5laXRoZXIgbXlzZWxmXG4gICAgICAgICAgICAgICBvciBFdGhlcnNjYW4gYXJlIG5lY2Vzc2FyaWx5IGNvbWZvcnRhYmxlIHdpdGggdGhpcy4gOilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaChcImdhc3RyYWNrZXJcIiwgeyBhY3Rpb246IFwiZ2Fzb3JhY2xlXCIgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBhcnNlVW5pdHMocmVzdWx0LlNhZmVHYXNQcmljZSwgXCJnd2VpXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VGZWUgPSBwYXJzZVVuaXRzKHJlc3VsdC5zdWdnZXN0QmFzZUZlZSwgXCJnd2VpXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5RmVlID0gZ2FzUHJpY2UgLSBiYXNlRmVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmlvcml0eUZlZSA8IDApIHsgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcHJpb3JpdHkgZmVlOyBkZWZlciB0byBhYnN0cmFjdCBwcm92aWRlciBkZWZhdWx0XCIpOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5RmVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcImFjY291bnRcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiYmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVxLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGhleDogcmVxLnNpZ25lZFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHJlcS5zaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sZWFuOiAocmVxLmluY2x1ZGVUcmFuc2FjdGlvbnMgPyBcInRydWVcIiA6IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiZ2V0QmxvY2sgYnkgYmxvY2tIYXNoIG5vdCBzdXBwb3J0ZWQgYnkgRXRoZXJzY2FuXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEJsb2NrKGJsb2NrSGFzaClcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgdHhoYXNoOiByZXEuaGFzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHJlcS5oYXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5ibG9ja1RhZyAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcnNjYW5Qcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrVGFnIGZvciBjYWxsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0RGF0YSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUG9zdERhdGEocmVxLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfY2FsbFwiO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgcmVxLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3REYXRhID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShyZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICBwb3N0RGF0YS5hY3Rpb24gPSBcImV0aF9lc3RpbWF0ZUdhc1wiO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgcmVxLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWRzIHRvIGNvbXBsYWluIGlmIG1vcmUgdGhhbiBvbmUgYWRkcmVzcyBpcyBwYXNzZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0geyBhY3Rpb246IFwiZ2V0TG9nc1wiIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudG9CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIudG9CbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmFkZHJlc3MgPSBwYXJhbXMuZmlsdGVyLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdlIGNhbiBoYW5kbGUgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBsb2dzIHVzaW5nIHRoZSBsb2dzIEFQSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGNvdW50XCIsIExvZ2dlci5FcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljczogcGFyYW1zLmZpbHRlci50b3BpY3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9waWMwID0gcGFyYW1zLmZpbHRlci50b3BpY3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRvcGljMCkgIT09IFwic3RyaW5nXCIgfHwgdG9waWMwLmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBMb2dnZXIuRXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpYzA6IHRvcGljMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudG9waWMwID0gdG9waWMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nczogQXJyYXk8YW55PiA9IGF3YWl0IHRoaXMuZmV0Y2goXCJsb2dzXCIsIGFyZ3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdHhIYXNoID0+IGJsb2NrSGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9ja3M6IHsgW3RhZzogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbWlzc2luZyBibG9ja0hhc2ggdG8gdGhlIGxvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nID0gbG9nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tzW2xvZy5ibG9ja051bWJlcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9IGJsb2NrLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gYmxvY2tzW2xvZy5ibG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBjdXJyZW50IHByaWNlIG9mIGV0aGVyLlxuICAgICAqXG4gICAgICogIFRoaXMgcmV0dXJucyBgYDBgYCBvbiBhbnkgbmV0d29yayBvdGhlciB0aGFuIGBgbWFpbm5ldGBgLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEV0aGVyUHJpY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmsubmFtZSAhPT0gXCJtYWlubmV0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKGF3YWl0IHRoaXMuZmV0Y2goXCJzdGF0c1wiLCB7IGFjdGlvbjogXCJldGhwcmljZVwiIH0pKS5ldGh1c2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbQ29udHJhY3RdXSBmb3IgJSVhZGRyZXNzJSUsIHVzaW5nIHRoZVxuICAgICAqICBFdGhlcnNjYW4gQVBJIHRvIHJldHJlaXZlIHRoZSBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udHJhY3QoX2FkZHJlc3MpIHtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKF9hZGRyZXNzKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyZXNzKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IGF3YWl0IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmZldGNoKFwiY29udHJhY3RcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJnZXRhYmlcIiwgYWRkcmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhYmkgPSBKU09OLnBhcnNlKHJlc3ApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkNvbnRyYWN0KGFkZHJlc3MsIGFiaSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBFdGhlcnNjYW5Qcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWV0aGVyc2Nhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogcHJvdmlkZXMgcmVzaWxpZW5jZSwgc2VjdXJpdHkgYW5kIHBlcmZvcm1hbmNlXG4gKiAgaW4gYSB3YXkgdGhhdCBpcyBjdXN0b21pemFibGUgYW5kIGNvbmZpZ3VyYWJsZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2ZhbGxiYWNrLXByb3ZpZGVyOkZhbGxiYWNrIFByb3ZpZGVyIFthYm91dC1mYWxsYmFjay1wcm92aWRlcl1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBCTl8xID0gQmlnSW50KFwiMVwiKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoXCIyXCIpO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgY29uc3QgdG1wID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgIGFycmF5W2pdID0gdG1wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaWdpbnRcIiwgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG47XG5jb25zdCBkZWZhdWx0Q29uZmlnID0geyBzdGFsbFRpbWVvdXQ6IDQwMCwgcHJpb3JpdHk6IDEsIHdlaWdodDogMSB9O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGJsb2NrTnVtYmVyOiAtMiwgcmVxdWVzdHM6IDAsIGxhdGVSZXNwb25zZXM6IDAsIGVycm9yUmVzcG9uc2VzOiAwLFxuICAgIG91dE9mU3luYzogLTEsIHVuc3VwcG9ydGVkRXZlbnRzOiAwLCByb2xsaW5nRHVyYXRpb246IDAsIHNjb3JlOiAwLFxuICAgIF9uZXR3b3JrOiBudWxsLCBfdXBkYXRlTnVtYmVyOiBudWxsLCBfdG90YWxUaW1lOiAwLFxuICAgIF9sYXN0RmF0YWxFcnJvcjogbnVsbCwgX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wOiAwXG59O1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuICAgIHdoaWxlIChjb25maWcuYmxvY2tOdW1iZXIgPCAwIHx8IGNvbmZpZy5ibG9ja051bWJlciA8IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGlmICghY29uZmlnLl91cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdXBkYXRlTnVtYmVyID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IGNvbmZpZy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjb25maWcuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9sYXN0RmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcuX3VwZGF0ZU51bWJlciA9IG51bGw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbmZpZy5fdXBkYXRlTnVtYmVyO1xuICAgICAgICBjb25maWcub3V0T2ZTeW5jKys7XG4gICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyAodmFsdWUubWFwKF9ub3JtYWxpemUpKS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIF9ub3JtYWxpemUodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoKGspID0+IGAke0pTT04uc3RyaW5naWZ5KGspfToke19ub3JtYWxpemUodmFsdWVba10pfWApLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJDb3VsZCBub3Qgc2VyaWFsaXplXCIsIHZhbHVlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIbW0uLi5cIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZXN1bHQodmFsdWUpIHtcbiAgICBpZiAoXCJlcnJvclwiIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICAgIHJldHVybiB7IHRhZzogX25vcm1hbGl6ZShlcnJvciksIHZhbHVlOiBlcnJvciB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgcmV0dXJuIHsgdGFnOiBfbm9ybWFsaXplKHJlc3VsdCksIHZhbHVlOiByZXN1bHQgfTtcbn1cbi8vIFRoaXMgc3RyYXRlZ3kgcGlja3MgdGhlIGhpZ2hlc3Qgd2VpZ2h0IHJlc3VsdCwgYXMgbG9uZyBhcyB0aGUgd2VpZ2h0IGlzXG4vLyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gcXVvcnVtXG5mdW5jdGlvbiBjaGVja1F1b3J1bShxdW9ydW0sIHJlc3VsdHMpIHtcbiAgICBjb25zdCB0YWxseSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHRhZywgd2VpZ2h0IH0gb2YgcmVzdWx0cykge1xuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHRhZykgfHwgeyB2YWx1ZSwgd2VpZ2h0OiAwIH07XG4gICAgICAgIHQud2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgdGFsbHkuc2V0KHRhZywgdCk7XG4gICAgfVxuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGFsbHkudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHIud2VpZ2h0ID49IHF1b3J1bSAmJiAoIWJlc3QgfHwgci53ZWlnaHQgPiBiZXN0LndlaWdodCkpIHtcbiAgICAgICAgICAgIGJlc3QgPSByO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0KSB7XG4gICAgICAgIHJldHVybiBiZXN0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFuKHF1b3J1bSwgcmVzdWx0cykge1xuICAgIGxldCByZXN1bHRXZWlnaHQgPSAwO1xuICAgIGNvbnN0IGVycm9yTWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBiZXN0RXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgdGFnLCB3ZWlnaHQgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gZXJyb3JNYXAuZ2V0KHRhZykgfHwgeyB2YWx1ZSwgd2VpZ2h0OiAwIH07XG4gICAgICAgICAgICBlLndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgICAgICBlcnJvck1hcC5zZXQodGFnLCBlKTtcbiAgICAgICAgICAgIGlmIChiZXN0RXJyb3IgPT0gbnVsbCB8fCBlLndlaWdodCA+IGJlc3RFcnJvci53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBiZXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goQmlnSW50KHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHRXZWlnaHQgKz0gd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHRXZWlnaHQgPCBxdW9ydW0pIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBxdW9ydW0gZm9yIGFuIGVycm9yXG4gICAgICAgIGlmIChiZXN0RXJyb3IgJiYgYmVzdEVycm9yLndlaWdodCA+PSBxdW9ydW0pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0RXJyb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgcXVvcnVtIGZvciBhIHJlc3VsdFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHNvcnRlZCB2YWx1ZXNcbiAgICB2YWx1ZXMuc29ydCgoYSwgYikgPT4gKChhIDwgYikgPyAtMSA6IChiID4gYSkgPyAxIDogMCkpO1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgIC8vIE9kZC1sZW5ndGg7IHRha2UgdGhlIG1pZGRsZSB2YWx1ZVxuICAgIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgICAgICByZXR1cm4gdmFsdWVzW21pZF07XG4gICAgfVxuICAgIC8vIEV2ZW4gbGVuZ3RoOyB0YWtlIHRoZSBjZWlsaW5nIG9mIHRoZSBtZWFuIG9mIHRoZSBjZW50ZXIgdHdvIHZhbHVlc1xuICAgIHJldHVybiAodmFsdWVzW21pZCAtIDFdICsgdmFsdWVzW21pZF0gKyBCTl8xKSAvIEJOXzI7XG59XG5mdW5jdGlvbiBnZXRBbnlSZXN1bHQocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgLy8gSWYgYW55IHZhbHVlIG9yIGVycm9yIG1lZXRzIHF1b3J1bSwgdGhhdCBpcyBvdXIgcHJlZmVycmVkIHJlc3VsdFxuICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHF1b3J1bSwgcmVzdWx0cyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZG8gd2UgaGF2ZSBhbnkgcmVzdWx0P1xuICAgIGZvciAoY29uc3QgciBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChyLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3BlIVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRGdXp6eU1vZGUocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgaWYgKHF1b3J1bSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0TnVtYmVyKShnZXRNZWRpYW4ocXVvcnVtLCByZXN1bHRzKSwgXCIlaW50ZXJuYWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZCA9IChyZXN1bHQsIHdlaWdodCkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHJlc3VsdCkgfHwgeyByZXN1bHQsIHdlaWdodDogMCB9O1xuICAgICAgICB0LndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgIHRhbGx5LnNldChyZXN1bHQsIHQpO1xuICAgIH07XG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgdmFsdWUgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKHZhbHVlKTtcbiAgICAgICAgYWRkKHIgLSAxLCB3ZWlnaHQpO1xuICAgICAgICBhZGQociwgd2VpZ2h0KTtcbiAgICAgICAgYWRkKHIgKyAxLCB3ZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgYmVzdFdlaWdodCA9IDA7XG4gICAgbGV0IGJlc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgcmVzdWx0IH0gb2YgdGFsbHkudmFsdWVzKCkpIHtcbiAgICAgICAgLy8gVXNlIHRoaXMgcmVzdWx0LCBpZiB0aGlzIHJlc3VsdCBtZWV0cyBxdW9ydW0gYW5kIGhhcyBlaXRoZXI6XG4gICAgICAgIC8vIC0gYSBiZXR0ZXIgd2VpZ2h0XG4gICAgICAgIC8vIC0gb3IgZXF1YWwgd2VpZ2h0LCBidXQgdGhlIHJlc3VsdCBpcyBsYXJnZXJcbiAgICAgICAgaWYgKHdlaWdodCA+PSBxdW9ydW0gJiYgKHdlaWdodCA+IGJlc3RXZWlnaHQgfHwgKGJlc3RSZXN1bHQgIT0gbnVsbCAmJiB3ZWlnaHQgPT09IGJlc3RXZWlnaHQgJiYgcmVzdWx0ID4gYmVzdFJlc3VsdCkpKSB7XG4gICAgICAgICAgICBiZXN0V2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgICAgICAgYmVzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdFJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogbWFuYWdlcyBzZXZlcmFsIFtbUHJvdmlkZXJzXV0gcHJvdmlkaW5nXG4gKiAgcmVzaWxpZW5jZSBieSBzd2l0Y2hpbmcgYmV0d2VlbiBzbG93IG9yIG1pc2JlaGF2aW5nIG5vZGVzLCBzZWN1cml0eVxuICogIGJ5IHJlcXVpcmluZyBtdWx0aXBsZSBiYWNrZW5kcyB0byBhZ2dyZWUgYW5kIHBlcmZvcm1hbmNlIGJ5IGFsbG93aW5nXG4gKiAgZmFzdGVyIGJhY2tlbmRzIHRvIHJlc3BvbmQgZWFybGllci5cbiAqXG4gKi9cbmNsYXNzIEZhbGxiYWNrUHJvdmlkZXIgZXh0ZW5kcyBhYnN0cmFjdF9wcm92aWRlcl9qc18xLkFic3RyYWN0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJhY2tlbmRzIHRoYXQgbXVzdCBhZ3JlZSBvbiBhIHZhbHVlIGJlZm9yZSBpdCBpc1xuICAgICAqICBhY2NwZXRlZC5cbiAgICAgKi9cbiAgICBxdW9ydW07XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGV2ZW50UXVvcnVtO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBldmVudFdvcmtlcnM7XG4gICAgI2NvbmZpZ3M7XG4gICAgI2hlaWdodDtcbiAgICAjaW5pdGlhbFN5bmNQcm9taXNlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmFsbGJhY2tQcm92aWRlcioqIHdpdGggJSVwcm92aWRlcnMlJSBjb25uZWN0ZWQgdG9cbiAgICAgKiAgJSVuZXR3b3JrJSUuXG4gICAgICpcbiAgICAgKiAgSWYgYSBbW1Byb3ZpZGVyXV0gaXMgaW5jbHVkZWQgaW4gJSVwcm92aWRlcnMlJSwgZGVmYXVsdHMgYXJlIHVzZWRcbiAgICAgKiAgZm9yIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVycywgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jY29uZmlncyA9IHByb3ZpZGVycy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBwcm92aWRlcjogcCB9LCBkZWZhdWx0Q29uZmlnLCBkZWZhdWx0U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcsIHAsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNoZWlnaHQgPSAtMjtcbiAgICAgICAgdGhpcy4jaW5pdGlhbFN5bmNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5xdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVvcnVtID0gTWF0aC5jZWlsKHRoaXMuI2NvbmZpZ3MucmVkdWNlKChhY2N1bSwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gY29uZmlnLndlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCAwKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdW9ydW0gPSAxO1xuICAgICAgICB0aGlzLmV2ZW50V29ya2VycyA9IDE7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSh0aGlzLnF1b3J1bSA8PSB0aGlzLiNjb25maWdzLnJlZHVjZSgoYSwgYykgPT4gKGEgKyBjLndlaWdodCksIDApLCBcInF1b3J1bSBleGNlZWQgcHJvdmlkZXIgd2VpZ2h0XCIsIFwicXVvcnVtXCIsIHRoaXMucXVvcnVtKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyQ29uZmlncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbmZpZ3MubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBjKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKCgwLCBpbmRleF9qc18xLmdldEJpZ0ludCkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjaGFpbklkXCIgfSkpKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFkZCBzdXBwb3J0IHRvIHNlbGVjdCBwcm92aWRlcnMgdG8gYmUgdGhlIGV2ZW50IHN1YnNjcmliZXJcbiAgICAvL19nZXRTdWJzY3JpYmVyKHN1YjogU3Vic2NyaXB0aW9uKTogU3Vic2NyaWJlciB7XG4gICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgLy99XG4gICAgLyoqXG4gICAgICogIFRyYW5zZm9ybXMgYSAlJXJlcSUlIGludG8gdGhlIGNvcnJlY3QgbWV0aG9kIGNhbGwgb24gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGFzeW5jIF90cmFuc2xhdGVQZXJmb3JtKHByb3ZpZGVyLCByZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24ocmVxLnNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmNhbGwoT2JqZWN0LmFzc2lnbih7fSwgcmVxLnRyYW5zYWN0aW9uLCB7IGJsb2NrVGFnOiByZXEuYmxvY2tUYWcgfSkpO1xuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5lc3RpbWF0ZUdhcyhyZXEudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSAoXCJibG9ja0hhc2hcIiBpbiByZXEpID8gcmVxLmJsb2NrSGFzaCA6IHJlcS5ibG9ja1RhZztcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2ssIHJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpKS5nYXNQcmljZTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpKS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldExvZ3MocmVxLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRTdG9yYWdlKHJlcS5hZGRyZXNzLCByZXEucG9zaXRpb24sIHJlcS5ibG9ja1RhZyk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVxLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXEuYWRkcmVzcywgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlcS5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdChyZXEuaGFzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR3JhYiB0aGUgbmV4dCAocmFuZG9tKSBjb25maWcgdGhhdCBpcyBub3QgYWxyZWFkeSBwYXJ0IG9mXG4gICAgLy8gdGhlIHJ1bm5pbmcgc2V0XG4gICAgI2dldE5leHRDb25maWcocnVubmluZykge1xuICAgICAgICAvLyBAVE9ETzogTWF5YmUgZG8gYSBjaGVjayBoZXJlIHRvIGZhdm91ciAoaGVhdmlseSkgcHJvdmlkZXJzIHRoYXRcbiAgICAgICAgLy8gICAgICAgIGRvIG5vdCByZXF1aXJlIHdhaXRGb3JTeW5jIGFuZCBkaXNmYXZvdXIgcHJvdmlkZXJzIHRoYXRcbiAgICAgICAgLy8gICAgICAgIHNlZW0gZG93bi1pc2ggb3IgYXJlIGJlaGF2aW5nIHNsb3dseVxuICAgICAgICBjb25zdCBjb25maWdzID0gQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHIuY29uZmlnKTtcbiAgICAgICAgLy8gU2h1ZmZsZSB0aGUgc3RhdGVzLCBzb3J0ZWQgYnkgcHJpb3JpdHlcbiAgICAgICAgY29uc3QgYWxsQ29uZmlncyA9IHRoaXMuI2NvbmZpZ3Muc2xpY2UoKTtcbiAgICAgICAgc2h1ZmZsZShhbGxDb25maWdzKTtcbiAgICAgICAgYWxsQ29uZmlncy5zb3J0KChhLCBiKSA9PiAoYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpKTtcbiAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgYWxsQ29uZmlncykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fbGFzdEZhdGFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWdzLmluZGV4T2YoY29uZmlnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBBZGRzIGEgbmV3IHJ1bm5lciAoaWYgYXZhaWxhYmxlKSB0byBydW5uaW5nLlxuICAgICNhZGRSdW5uZXIocnVubmluZywgcmVxKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuI2dldE5leHRDb25maWcocnVubmluZyk7XG4gICAgICAgIC8vIE5vIHJ1bm5lcnMgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJ1bm5lclxuICAgICAgICBjb25zdCBydW5uZXIgPSB7XG4gICAgICAgICAgICBjb25maWcsIHJlc3VsdDogbnVsbCwgZGlkQnVtcDogZmFsc2UsXG4gICAgICAgICAgICBwZXJmb3JtOiBudWxsLCBzdGFsbGVyOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vdyA9IGdldFRpbWUoKTtcbiAgICAgICAgLy8gU3RhcnQgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvblxuICAgICAgICBydW5uZXIucGVyZm9ybSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5yZXF1ZXN0cysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3RyYW5zbGF0ZVBlcmZvcm0oY29uZmlnLnByb3ZpZGVyLCByZXEpO1xuICAgICAgICAgICAgICAgIHJ1bm5lci5yZXN1bHQgPSB7IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVycm9yUmVzcG9uc2VzKys7XG4gICAgICAgICAgICAgICAgcnVubmVyLnJlc3VsdCA9IHsgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR0ID0gKGdldFRpbWUoKSAtIG5vdyk7XG4gICAgICAgICAgICBjb25maWcuX3RvdGFsVGltZSArPSBkdDtcbiAgICAgICAgICAgIGNvbmZpZy5yb2xsaW5nRHVyYXRpb24gPSAwLjk1ICogY29uZmlnLnJvbGxpbmdEdXJhdGlvbiArIDAuMDUgKiBkdDtcbiAgICAgICAgICAgIHJ1bm5lci5wZXJmb3JtID0gbnVsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgLy8gU3RhcnQgYSBzdGFsbGVyOyB3aGVuIHRoaXMgdGltZXMgb3V0LCBpdCdzIHRpbWUgdG8gZm9yY2VcbiAgICAgICAgLy8ga2lja2luZyBvZmYgYW5vdGhlciBydW5uZXIgYmVjYXVzZSB3ZSBhcmUgdGFraW5nIHRvbyBsb25nXG4gICAgICAgIHJ1bm5lci5zdGFsbGVyID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuICAgICAgICAgICAgcnVubmVyLnN0YWxsZXIgPSBudWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICBydW5uaW5nLmFkZChydW5uZXIpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICAvLyBJbml0aWFsaXplcyB0aGUgYmxvY2tOdW1iZXIgYW5kIG5ldHdvcmsgZm9yIGVhY2ggcnVubmVyIGFuZFxuICAgIC8vIGJsb2NrcyB1bnRpbCBpbml0aWFsaXplZFxuICAgIGFzeW5jICNpbml0aWFsU3luYygpIHtcbiAgICAgICAgbGV0IGluaXRpYWxTeW5jID0gdGhpcy4jaW5pdGlhbFN5bmNQcm9taXNlO1xuICAgICAgICBpZiAoIWluaXRpYWxTeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy4jY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JTeW5jKGNvbmZpZywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9uZXR3b3JrID0gYXdhaXQgY29uZmlnLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsU3luY1Byb21pc2UgPSBpbml0aWFsU3luYyA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHByb3ZpZGVycyB0byBoYXZlIGEgYmxvY2sgbnVtYmVyIGFuZCBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFsbCB0aGUgbmV0d29ya3MgbWF0Y2hcbiAgICAgICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgdGhpcy4jY29uZmlncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IChjb25maWcuX25ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3QgbWl4IHByb3ZpZGVycyBvbiBkaWZmZXJlbnQgbmV0d29ya3NcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRmFsbGJhY2tQcm92aWRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW5pdGlhbFN5bmM7XG4gICAgfVxuICAgIGFzeW5jICNjaGVja1F1b3J1bShydW5uaW5nLCByZXEpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgcmVzdWx0IG9iamVjdHNcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICBpZiAocnVubmVyLnJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YWcsIHZhbHVlIH0gPSBub3JtYWxpemVSZXN1bHQocnVubmVyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgdGFnLCB2YWx1ZSwgd2VpZ2h0OiBydW5uZXIuY29uZmlnLndlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgdGhlcmUgZW5vdWdoIHJlc3VsdHMgdG8gZXZlbnQgbWVldCBxdW9ydW0/XG4gICAgICAgIGlmIChyZXN1bHRzLnJlZHVjZSgoYSwgcikgPT4gKGEgKyByLndlaWdodCksIDApIDwgdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjoge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IHRoZSBib290c3RyYXAgYmxvY2sgaGVpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hlaWdodCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gTWF0aC5jZWlsKCgwLCBpbmRleF9qc18xLmdldE51bWJlcikoZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCB0aGlzLiNjb25maWdzLmZpbHRlcigoYykgPT4gKCFjLl9sYXN0RmF0YWxFcnJvcikpLm1hcCgoYykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKGMuYmxvY2tOdW1iZXIpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGMud2VpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pKSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbW9kZSBhY3Jvc3MgYWxsIHRoZSBwcm92aWRlcnMsIGFsbG93aW5nIGZvclxuICAgICAgICAgICAgICAgIC8vIGEgbGl0dGxlIGRyaWZ0IGJldHdlZW4gYmxvY2sgaGVpZ2h0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBnZXRGdXp6eU1vZGUodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPiB0aGlzLiNoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gbW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgYmxvY2tzIGFyZSBpbiB0aGUgbWVtcG9vbCBhbmQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHF1aXRlIHVudHJ1c3R3b3J0aHk7IGp1c3QgZ3JhYiBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxICYmIHJlcS5ibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1F1b3J1bSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbnlSZXN1bHQodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYF9wZXJmb3JtKCR7c3RyaW5naWZ5KHJlcS5tZXRob2QpfSlgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAjd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmcuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcnVubmVycz8hXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFueSBwcm9taXNlcyB0aGF0IGFyZSBpbnRlcmVzdGluZyB0byB3YXRjaCBmb3I7IGFuIGV4cGlyZWQgc3RhbGxcbiAgICAgICAgLy8gb3IgYSBzdWNjZXNzZnVsIHBlcmZvcm1cbiAgICAgICAgY29uc3QgaW50ZXJlc3RpbmcgPSBbXTtcbiAgICAgICAgbGV0IG5ld1J1bm5lcnMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBObyByZXNwb25zZXMsIHlldDsga2VlcCBhbiBleWUgb24gaXRcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSkge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnBlcmZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RpbGwgc3RhbGxpbmcuLi5cbiAgICAgICAgICAgIGlmIChydW5uZXIuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnN0YWxsZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBydW5uZXIgaGFzIGFscmVhZHkgdHJpZ2dlcmVkIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBpZiAocnVubmVyLmRpZEJ1bXApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdvdCBhIHJlc3BvbnNlIChyZXN1bHQgb3IgZXJyb3IpIG9yIHN0YWxsZWQ7IGtpY2sgb2ZmIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBydW5uZXIuZGlkQnVtcCA9IHRydWU7XG4gICAgICAgICAgICBuZXdSdW5uZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIHF1b3J1bSBvbiBhIHJlc3VsdCAob3IgZXJyb3IpXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jY2hlY2tRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFueSBuZXcgcnVubmVycywgYmVjYXVzZSBhIHN0YWxsZXIgdGltZWQgb3V0IG9yIGEgcmVzdWx0XG4gICAgICAgIC8vIG9yIGVycm9yIHJlc3BvbnNlIGNhbWUgaW4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UnVubmVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLiNhZGRSdW5uZXIocnVubmluZywgcmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgcHJvdmlkZXJzIGhhdmUgcmV0dXJuZWQsIGFuZCB3ZSBoYXZlIG5vIHJlc3VsdFxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGludGVyZXN0aW5nLmxlbmd0aCA+IDAsIFwicXVvcnVtIG5vdCBtZXRcIiwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHN0cmluZ2lmeShyLnJlc3VsdCkpIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHNvbWVvbmUgdG8gZWl0aGVyIGNvbXBsZXRlIGl0cyBwZXJmb3JtIG9yIHN0YWxsIG91dFxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoaW50ZXJlc3RpbmcpO1xuICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZSwgYnV0IGF0IHdvcnN0IGNhc2UgdGhlIGRlcHRoIGlzIDJ4IHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcHJvdmlkZXJzIChlYWNoIGhhcyBhIHBlcmZvcm0gYW5kIGEgc3RhbGxlcilcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdGluZyBhIHRyYW5zYWN0aW9uIGlzIHJhcmUgKGlzaCkgYW5kIGFscmVhZHkgaW5jdXJzXG4gICAgICAgIC8vIGEgY29zdCBvbiB0aGUgdXNlciwgc28gc3BhbW1pbmcgaXMgc2FmZS1pc2guIEp1c3Qgc2VuZCBpdCB0b1xuICAgICAgICAvLyBldmVyeSBiYWNrZW5kLlxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBPbmNlIGFueSBicm9hZGNhc3QgcHJvdmlkZXMgYSBwb3NpdGl2ZSByZXN1bHQsIHVzZSBpdC4gTm9cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgYW55b25lIGVsc2VcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLiNjb25maWdzLm1hcCgoYykgPT4gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBicm9hZGNhc3RzID0gdGhpcy4jY29uZmlncy5tYXAoYXN5bmMgKHsgcHJvdmlkZXIsIHdlaWdodCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihub3JtYWxpemVSZXN1bHQoeyByZXN1bHQgfSksIHsgd2VpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZVJlc3VsdCh7IGVycm9yIH0pLCB7IHdlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzIGVhY2ggcHJvbWlzZSBmaW5pc2hlcy4uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSB2YWxpZCBicm9hZGNhc3QgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiAociAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlIH0gb2YgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIGxlZ2l0IGJyb2FkY2FzdCBlcnJvciAob25lIHdoaWNoIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgZnJvbTsgc29tZSBub2RlcyBtYXkgcmV0dXJuIHRoZSBmb2xsb3dpbmcgcmVkXG4gICAgICAgICAgICAgICAgLy8gaGVycmluZyBldmVudHM6XG4gICAgICAgICAgICAgICAgLy8gLSBhbHJlZHkgc2VlbmQgKFVOS05PV05fRVJST1IpXG4gICAgICAgICAgICAgICAgLy8gLSBOT05DRV9FWFBJUkVEXG4gICAgICAgICAgICAgICAgLy8gLSBSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzLmZpbHRlcigocikgPT4gKHIgIT0gbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikocmVzdWx0LCBcIklOU1VGRklDSUVOVF9GVU5EU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEtpY2sgb2ZmIHRoZSBuZXh0IHByb3ZpZGVyIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZyA9IGJyb2FkY2FzdHMuZmlsdGVyKChiLCBpKSA9PiAocmVzdWx0c1tpXSA9PSBudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2Uod2FpdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2Ugc3RhbmRhcmQgcXVvcnVtIHJlc3VsdHM7IGFueSByZXN1bHQgd2FzIHJldHVybmVkIGFib3ZlLFxuICAgICAgICAgICAgLy8gc28gdGhpcyB3aWxsIGZpbmQgYW55IGVycm9yIHRoYXQgbWV0IHF1b3J1bSBpZiBhbnlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcInByb2JsZW0gbXVsdGktYnJvYWRjYXN0aW5nXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBcIiVzdWItcmVxdWVzdHNcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogcmVzdWx0cy5tYXAoc3RyaW5naWZ5KSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy4jaW5pdGlhbFN5bmMoKTtcbiAgICAgICAgLy8gQm9vdHN0cmFwIGVub3VnaCBydW5uZXJzIHRvIG1lZXQgcXVvcnVtXG4gICAgICAgIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBpbmZsaWdodFF1b3J1bSA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzLiNhZGRSdW5uZXIocnVubmluZywgcmVxKTtcbiAgICAgICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mbGlnaHRRdW9ydW0gKz0gcnVubmVyLmNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaW5mbGlnaHRRdW9ydW0gPj0gdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiN3YWl0Rm9yUXVvcnVtKHJ1bm5pbmcsIHJlcSk7XG4gICAgICAgIC8vIFRyYWNrIHJlcXVlc3RzIHNlbnQgdG8gYSBwcm92aWRlciB0aGF0IGFyZSBzdGlsbFxuICAgICAgICAvLyBvdXRzdGFuZGluZyBhZnRlciBxdW9ydW0gaGFzIGJlZW4gb3RoZXJ3aXNlIGZvdW5kXG4gICAgICAgIGZvciAoY29uc3QgcnVubmVyIG9mIHJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSAmJiBydW5uZXIucmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuY29uZmlnLmxhdGVSZXNwb25zZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcHJvdmlkZXIgfSBvZiB0aGlzLiNjb25maWdzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IEZhbGxiYWNrUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1mYWxsYmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuLyoqXG4gKiAgW1tsaW5rLWluZnVyYV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxuICogIC0gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0IChgYGFyYml0cnVtLXNlcG9saWFgYClcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxuICogIC0gQmFzZSBHb2VybGlhIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gQk5CIFNtYXJ0IENoYWluIE1haW5uZXQgKGBgYm5iYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gVGVzdG5ldCAoYGBibmJ0YGApXG4gKiAgLSBMaW5lYSAoYGBsaW5lYWBgKVxuICogIC0gTGluZWEgR29lcmxpIFRlc3RuZXQgKGBgbGluZWEtZ29lcmxpYGApXG4gKiAgLSBMaW5lYSBTZXBvbGlhIFRlc3RuZXQgKGBgbGluZWEtc2Vwb2xpYWBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gQW1veSBUZXN0bmV0IChgYG1hdGljLWFtb3lgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OklORlVSQSAgW3Byb3ZpZGVycy1pbmZ1cmFdXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIik7XG5jb25zdCBkZWZhdWx0UHJvamVjdElkID0gXCI4NDg0MjA3OGIwOTk0NjYzOGMwMzE1N2Y4MzQwNTIxM1wiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLXNlcG9saWEuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJhc2UtZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLXNlcG9saWEuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJibmJcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJuYnNtYXJ0Y2hhaW4tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImJuYnRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJuYnNtYXJ0Y2hhaW4tdGVzdG5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImxpbmVhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJsaW5lYS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibGluZWEtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJsaW5lYS1nb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJsaW5lYS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJsaW5lYS1zZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLWFtb3lcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tYW1veS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc20tc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tc2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWluZnVyYV1dXG4gKiAgV2ViU29ja2V0IGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWluZnVyYS1zaWdudXApLlxuICovXG5jbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX3dlYnNvY2tldF9qc18xLldlYlNvY2tldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgSUQgZm9yIHRoZSBJTkZVUkEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBwcm9qZWN0SWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBQcm9qZWN0IFNlY3JldC5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCBubyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzIGFyZSBtYWRlLiBUaGlzIHNob3VsZCBub3RcbiAgICAgKiAgYmUgdXNlZCBvdXRzaWRlIG9mIHByaXZhdGUgY29udGV4dHMuXG4gICAgICovXG4gICAgcHJvamVjdFNlY3JldDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVdlYlNvY2tldFByb3ZpZGVyKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaywgcHJvamVjdElkKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCk7XG4gICAgICAgIGNvbnN0IHJlcSA9IHByb3ZpZGVyLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIXJlcS5jcmVkZW50aWFscywgXCJJTkZVUkEgV2ViU29ja2V0IHByb2plY3Qgc2VjcmV0cyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlcigpXCIgfSk7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcS51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIHN1cGVyKHVybCwgcHJvdmlkZXIuX25ldHdvcmspO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHByb3ZpZGVyLnByb2plY3RJZCxcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQ6IHByb3ZpZGVyLnByb2plY3RTZWNyZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgPSBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjtcbi8qKlxuICogIFRoZSAqKkluZnVyYVByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1pbmZ1cmFdXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWluZnVyYS1zaWdudXApLlxuICovXG5jbGFzcyBJbmZ1cmFQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHByb2plY3RJZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgU2VjcmV0LlxuICAgICAqXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxuICAgICAqICBiZSB1c2VkIG91dHNpZGUgb2YgcHJpdmF0ZSBjb250ZXh0cy5cbiAgICAgKi9cbiAgICBwcm9qZWN0U2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqSW5mdXJhUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWQgPSBkZWZhdWx0UHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBJbmZ1cmFQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIHByb2plY3RJZCwgcHJvamVjdFNlY3JldCk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQgfSk7XG4gICAgfVxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluZnVyYVByb3ZpZGVyKGNoYWluSWQsIHRoaXMucHJvamVjdElkLCB0aGlzLnByb2plY3RTZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVdlYlNvY2tldFByb3ZpZGVyKiouXG4gICAgICovXG4gICAgc3RhdGljIGdldFdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJVxuICAgICAqICB3aXRoICUlcHJvamVjdElkJSUgYW5kICUlcHJvamVjdFNlY3JldCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIHByb2plY3RJZCwgcHJvamVjdFNlY3JldCkge1xuICAgICAgICBpZiAocHJvamVjdElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RJZCA9IGRlZmF1bHRQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92My8ke3Byb2plY3RJZH1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAocHJvamVjdFNlY3JldCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zZXRDcmVkZW50aWFscyhcIlwiLCBwcm9qZWN0U2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlKShcIkluZnVyYVByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gSW5mdXJhUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1pbmZ1cmEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklwY1NvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgcHJvdmlkZXJfc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG4vLyBAVE9ETzogSXMgdGhpcyBzdWZmaWNpZW50PyBJcyB0aGlzIHJvYnVzdD8gV2lsbCBuZXdsaW5lcyBvY2N1ciBiZXR3ZWVuXG4vLyBhbGwgcGF5bG9hZHMgYW5kIG9ubHkgYmV0d2VlbiBwYXlsb2Fkcz9cbmZ1bmN0aW9uIHNwbGl0QnVmZmVyKGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBsYXN0U3RhcnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5sID0gZGF0YS5pbmRleE9mKDEwLCBsYXN0U3RhcnQpO1xuICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlcy5wdXNoKGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0LCBubCkudG9TdHJpbmcoKS50cmltKCkpO1xuICAgICAgICBsYXN0U3RhcnQgPSBubCArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VzLCByZW1haW5pbmc6IGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0KSB9O1xufVxuLyoqXG4gKiAgQW4gKipJcGNTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIG92ZXIgYW4gSVBDIHNvY2tldCBvbiB0aGUgaG9zdFxuICogIHdoaWNoIHByb3ZpZGVzIGZhc3QgYWNjZXNzIHRvIHRoZSBub2RlLCBidXQgcmVxdWlyZXMgdGhlIG5vZGUgYW5kXG4gKiAgdGhlIHNjcmlwdCBydW4gb24gdGhlIHNhbWUgbWFjaGluZS5cbiAqL1xuY2xhc3MgSXBjU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9zb2NrZXRfanNfMS5Tb2NrZXRQcm92aWRlciB7XG4gICAgI3NvY2tldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBzb2NrZXQuXG4gICAgICovXG4gICAgZ2V0IHNvY2tldCgpIHsgcmV0dXJuIHRoaXMuI3NvY2tldDsgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3NvY2tldCA9ICgwLCBuZXRfMS5jb25uZWN0KShwYXRoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJyZWFkeVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBzdGFydCBJcGNTb2NrZXRQcm92aWRlclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IE5vdyB3aGF0PyBSZXN0YXJ0P1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gQnVmZmVyLmNvbmNhdChbcmVzcG9uc2UsIGRhdGFdKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZXMsIHJlbWFpbmluZyB9ID0gc3BsaXRCdWZmZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlbWFpbmluZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuSXBjU29ja2V0UHJvdmlkZXIgPSBJcGNTb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWlwY3NvY2tldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIE9uZSBvZiB0aGUgbW9zdCBjb21tb24gd2F5cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBibG9ja2NoYWluIGlzXG4gKiAgYnkgYSBub2RlIHJ1bm5pbmcgYSBKU09OLVJQQyBpbnRlcmZhY2Ugd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB0byxcbiAqICBiYXNlZCBvbiB0aGUgdHJhbnNwb3J0LCB1c2luZzpcbiAqXG4gKiAgLSBIVFRQIG9yIEhUVFBTIC0gW1tKc29uUnBjUHJvdmlkZXJdXVxuICogIC0gV2ViU29ja2V0IC0gW1tXZWJTb2NrZXRQcm92aWRlcl1dXG4gKiAgLSBJUEMgLSBbW0lwY1NvY2tldFByb3ZpZGVyXV1cbiAqXG4gKiBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvanNvbnJwYzpKU09OLVJQQyBQcm92aWRlciAgW2Fib3V0LWpzb25ycGNQcm92aWRlcl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNBcGlQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IHZvaWQgMDtcbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hYmkvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3NpZ25lcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHN1YnNjcmliZXJfZmlsdGVyaWRfanNfMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIik7XG5jb25zdCBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiKTtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIGFic3RyYWN0X3NpZ25lcl9qc18xLkFic3RyYWN0U2lnbmVyIHtcbiAgICBhZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3QgcmVjb25uZWN0IEpzb25ScGNTaWduZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5jb25uZWN0XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gICAgfVxuICAgIC8vIEpTT04tUlBDIHdpbGwgYXV0b21hdGlhbGx5IGZpbGwgaW4gbm9uY2UsIGV0Yy4gc28gd2UganVzdCBjaGVjayBmcm9tXG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGp1c3QgdGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIHNlbnQsIHdoaWNoIGlzIHdoYXRcbiAgICAvLyB0aGUgYmFyZSBKU09OLVJQQyBBUEkgZG9lcztcbiAgICBhc3luYyBzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgX2Zyb20gPSB0eC5mcm9tO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KShmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHsgLi4udHgsIGZyb206IHRoaXMuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhZGRyZXNzIG1heSBiZSBhbiBFTlMgbmFtZSBvciBBZGRyZXNzYWJsZVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3RvID0gdHgudG87XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHgudG8gPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykoX3RvLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG9mIG91ciBwcm9wZXJ0aWVzIGFyZSBmaWxsZWQgaW5cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgbWluZWQgYW55IGVhcmxpZXIgdGhhbiBhbnkgcmVjZW50IGJsb2NrXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuICAgICAgICByZXR1cm4gYXdhaXQgKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRzID0gWzEwMDAsIDEwMF07XG4gICAgICAgICAgICBsZXQgaW52YWxpZHMgPSAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgY2FuY2VsbGVkOiBzdG9wIHBvbGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIGJhZDogdGhlIG5vZGUgcmV0dXJucyBiYWQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGNoYW5nZWQ6IGNhbGxpbmcgYWdhaW4gd2lsbCBhbHNvIGZhaWxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdW5zdXBwb3J0ZWQ6IGxpa2VseSBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc181LmlzRXJyb3IpKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCAoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJCQURfREFUQVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiTkVUV09SS19FUlJPUlwiIHx8ICgwLCBpbmRleF9qc181LmlzRXJyb3IpKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzUuaXNFcnJvcikoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWRzID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYW55b25lIHRoYXQgY2FyZXM7IGJ1dCB3ZSB3aWxsIHRyeSBhZ2Fpbiwgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgbGlrZWx5IGFuIGludGVybWl0dGVudCBzZXJ2aWNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZW1pdChcImVycm9yXCIsICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJmYWlsZWQgdG8gZmV0Y2ggdHJhbnNhdGlvbiBhZnRlciBzZW5kaW5nICh3aWxsIHRyeSBhZ2FpbilcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGFub3RoZXIgNCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fc2V0VGltZW91dCgoKSA9PiB7IGNoZWNrVHgoKTsgfSwgdGltZW91dHMucG9wKCkgfHwgNDAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tUeCgpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/ICgwLCBpbmRleF9qc181LnRvVXRmOEJ5dGVzKShfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmhleGxpZnkpKG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgaW5kZXhfanNfMy5UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHZhbHVlKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KShhZGRyZXNzICE9IG51bGwsIFwiVHlwZWREYXRhIGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhZGRyZXNzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShpbmRleF9qc18zLlR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gKDAsIGluZGV4X2pzXzUudG9VdGY4Qnl0ZXMpKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCAoMCwgaW5kZXhfanNfNS5oZXhsaWZ5KShtZXNzYWdlKVxuICAgICAgICBdKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNTaWduZXIgPSBKc29uUnBjU2lnbmVyO1xuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5jbGFzcyBKc29uUnBjQXBpUHJvdmlkZXIgZXh0ZW5kcyBhYnN0cmFjdF9wcm92aWRlcl9qc18xLkFic3RyYWN0UHJvdmlkZXIge1xuICAgICNvcHRpb25zO1xuICAgIC8vIFRoZSBuZXh0IElEIHRvIHVzZSBmb3IgdGhlIEpTT04tUlBDIElEIGZpZWxkXG4gICAgI25leHRJZDtcbiAgICAvLyBQYXlsb2FkcyBhcmUgcXVldWVkIGFuZCB0cmlnZ2VyZWQgaW4gYmF0Y2hlcyB1c2luZyB0aGUgZHJhaW5UaW1lclxuICAgICNwYXlsb2FkcztcbiAgICAjZHJhaW5UaW1lcjtcbiAgICAjbm90UmVhZHk7XG4gICAgI25ldHdvcms7XG4gICAgI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICNzY2hlZHVsZURyYWluKCkge1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBiYXRjaGluZywgbm8gaGFybSBpbiBzZW5kaW5nIGl0IGltbWVkaWF0ZWx5XG4gICAgICAgIGNvbnN0IHN0YWxsVGltZSA9ICh0aGlzLl9nZXRPcHRpb24oXCJiYXRjaE1heENvdW50XCIpID09PSAxKSA/IDAgOiB0aGlzLl9nZXRPcHRpb24oXCJiYXRjaFN0YWxsVGltZVwiKTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRoaXMuI3BheWxvYWRzO1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcGF5bG9hZCBiYXRjaGVzIHRoYXQgc2F0aXNmeSBvdXIgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IFsocGF5bG9hZHMuc2hpZnQoKSldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA9PT0gdGhpcy4jb3B0aW9ucy5iYXRjaE1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKChwYXlsb2Fkcy5zaGlmdCgpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gSlNPTi5zdHJpbmdpZnkoYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2Fkcy51bnNoaWZ0KChiYXRjaC5wb3AoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcmVzdWx0IHRvIGVhY2ggcGF5bG9hZFxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoKGJhdGNoLmxlbmd0aCA9PT0gMSkgPyBiYXRjaFswXS5wYXlsb2FkIDogYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVzdWx0cyBpbiBiYXRjaCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlc29sdmUsIHJlamVjdCwgcGF5bG9hZCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3VsdC5maWx0ZXIoKHIpID0+IChyLmlkID09PSBwYXlsb2FkLmlkKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0OyB0aGUgbm9kZSBmYWlsZWQgdXMgaW4gdW5leHBlY3RlZCB3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9ICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoIXN0YXRpY05ldHdvcmsgfHwgbmV0d29yayAhPT0gXCJhbnlcIiwgXCJzdGF0aWNOZXR3b3JrIGNhbm5vdCBiZSB1c2VkIG9uIHNwZWNpYWwgbmV0d29yayAnYW55J1wiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3RhdGljTmV0d29yayAmJiBuZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0aWNOZXR3b3JrKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHN0YXRpYyBuZXR3b3JrIGlzIGNvbXBhdGJpbGUgd2l0aCB0aGUgcHJvdmlkZWQgbmV0d3Jva1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KSh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgKDAsIGluZGV4X2pzXzUuZ2V0QmlnSW50KSh0eC50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLWE1NTlcbiAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IHR5cGU6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UnBjUmVxdWVzdChyZXEpO1xuICAgICAgICBpZiAocmVxdWVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXM7IGl0IGRldGVjdHMgdGhlICphY3R1YWwqIG5ldHdvcmsgdGhhdFxuICAgICAqICB3ZSBhcmUgKipjdXJyZW50bHkqKiBjb25uZWN0ZWQgdG8uXG4gICAgICpcbiAgICAgKiAgS2VlcCBpbiBtaW5kIHRoYXQgW1tzZW5kXV0gbWF5IG9ubHkgYmUgdXNlZCBvbmNlIFtbcmVhZHldXSwgb3RoZXJ3aXNlIHRoZVxuICAgICAqICBfc2VuZCBwcmltaXRpdmUgbXVzdCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAobmV0d29yaykge1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVhZHksIHVzZSBgYHNlbmRgYCwgd2hpY2ggZW5hYmxlZCByZXF1ZXN0cyB0byBiZSBiYXRjaGVkXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbSgoMCwgaW5kZXhfanNfNS5nZXRCaWdJbnQpKGF3YWl0IHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIG5vdCByZWFkeSB5ZXQ7IHVzZSB0aGUgcHJpbWl0aXZlIF9zZW5kXG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuI25leHRJZCsrLCBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgcGFyYW1zOiBbXSwganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKSlbMF07XG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgaWYgKFwicmVzdWx0XCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oKDAsIGluZGV4X2pzXzUuZ2V0QmlnSW50KShyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwiZmFpbGVkIHRvIGJvb3RzdHJhcCBuZXR3b3JrIGRldGVjdGlvblwiLCBcIk5FVFdPUktfRVJST1JcIiwgeyBldmVudDogXCJpbml0aWFsLW5ldHdvcmstZGlzY292ZXJ5XCIsIGluZm86IHsgZXJyb3IgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGRpc3BhdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC4gVGhpcyBjYW4gYmUgdXNlZCBpblxuICAgICAqICBzdWItY2xhc3NlcyB0byBkZWZlciBzZW5kaW5nIGRhdGEgdW50aWwgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiAgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNub3RSZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgU3Vic2NyaWJlciB0aGF0IHdpbGwgbWFuYWdlIHRoZSAlJXN1YiUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgKiAgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIC8vIFBlbmRpbmcgRmlsdGVycyBhcmVuJ3QgYXZhaWxibGUgdmlhIHBvbGxpbmdcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdWJzY3JpYmVyX2ZpbHRlcmlkX2pzXzEuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfZmlsdGVyaWRfanNfMS5GaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcihcIm9ycGhhblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0eCUlIGFzIGEgbm9ybWFsaXplZCBKU09OLVJQQyB0cmFuc2FjdGlvbiByZXF1ZXN0LFxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZHN0S2V5XSA9ICgwLCBpbmRleF9qc181LnRvUXVhbnRpdHkpKCgwLCBpbmRleF9qc181LmdldEJpZ0ludCkodHhba2V5XSwgYHR4LiR7a2V5fWApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhZGRyZXNzZXMgYW5kIGRhdGEgYXJlIGxvd2VyY2FzZVxuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkodHhba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGFjY2VzcyBsaXN0IG9iamVjdFxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9ICgwLCBpbmRleF9qc180LmFjY2Vzc0xpc3RpZnkpKHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBpbmRleF9qc18xLkFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xuICAgICAgICAgICAgZS5pbmZvID0geyBlcnJvciwgcGF5bG9hZCB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlc3RpbWF0ZUdhcyBhbmQgY2FsbCBjYW4gcmV0dXJuIGFyYml0cmFyeSBjb250cmFjdC1kZWZpbmVkIHRleHQsIHNvIG5vdyB3ZVxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkfGV0aGVycy11c2VyLWRlbmllZC9pKSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGVyc29uYWxfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKGFjdGlvbk1hcFttZXRob2RdIHx8IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKHBheWxvYWQucGFyYW1zWzBdKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbi9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJjb3VsZCBub3QgY29hbGVzY2UgZXJyb3JcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXF1ZXN0cyB0aGUgJSVtZXRob2QlJSB3aXRoICUlcGFyYW1zJSUgdmlhIHRoZSBKU09OLVJQQyBwcm90b2NvbFxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXG4gICAgICogIEFQSS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xuICAgICAqICBpbiB0aGUgb3B0aW9ucywgYXNzaWducyB0aGUgcmVxdWVzdCBhIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXG4gICAgICogIG92ZXJyaWRlIFtbX3NlbmRdXSBvciBmb3JjZSB0aGUgb3B0aW9ucyB2YWx1ZXMgaW4gdGhlXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMi5nZXRBZGRyZXNzKShhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KCgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgLy8gUGFyZW50IGNsZWFuLXVwXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNBcGlQcm92aWRlciA9IEpzb25ScGNBcGlQcm92aWRlcjtcbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI3BvbGxpbmdJbnRlcnZhbDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcG9sbGluZ0ludGVydmFsID0gdGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ0ludGVydmFsXCIpO1xuICAgICAgICBpZiAocG9sbGluZ0ludGVydmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IGRlZmF1bHRPcHRpb25zLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI3BvbGxpbmdJbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzdWIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcbiAgICAgICAgICAgICAgICBzdWIucG9sbGluZ0ludGVydmFsID0gdGhpcy4jcG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgPSBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyO1xuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG5ldyBpbmRleF9qc181LkZldGNoUmVxdWVzdCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29ubmVjdC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEFsbCByZXF1ZXN0cyBhcmUgb3ZlciBIVFRQLCBzbyB3ZSBjYW4ganVzdCBzdGFydCBoYW5kbGluZyByZXF1ZXN0c1xuICAgICAgICAvLyBXZSBkbyB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhbnlcbiAgICAgICAgLy8gcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmsgKGkuZS4gZXRoX2NoYWluSWQpIHVudGlsIHdlIGFic29sdXRlbHkgaGF2ZSB0by5cbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFBPU1QgY29ubmVjdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2RcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgbGV0IHJlc3AgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3ApKSB7XG4gICAgICAgICAgICByZXNwID0gW3Jlc3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgKDAsIGluZGV4X2pzXzUuaXNIZXhTdHJpbmcpKHZhbHVlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IHZhbHVlLmRhdGEgfTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rRGF0YShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3BlbHVua01lc3NhZ2UodmFsdWVba2V5XSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfc3BlbHVua01lc3NhZ2UoSlNPTi5wYXJzZSh2YWx1ZSksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rTWVzc2FnZSh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItanNvbnJwYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstcG9ja2V0XV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIEpTT04tUlBDLlxuICpcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXG4gKlxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OlBvY2tldCAgW3Byb3ZpZGVycy1wb2NrZXRdXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgZGVmYXVsdEFwcGxpY2F0aW9uSWQgPSBcIjYyZTFhZDUxYjM3YjhlMDAzOTRiZGEzYlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seS1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbXVtYmFpLXJwYy5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipQb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcG9ja2V0XV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1wb2NrZXQtc2lnbnVwKS5cbiAqL1xuY2xhc3MgUG9ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIElEIGZvciB0aGUgUG9ja2V0IGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXBwbGljYXRpb25JZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIFNlY3JldCBmb3IgbWFraW5nIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHNcbiAgICAgKiAgdG8gdGhlIFBvY2tldCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwcGxpY2F0aW9uU2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2NrZXRQcm92aWRlcioqLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxuICAgICAqICBBUEkga2V5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwbGljYXRpb25TZWNyZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IFBvY2tldFByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBwbGljYXRpb25JZCwgYXBwbGljYXRpb25TZWNyZXQpO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9ja2V0UHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcHBsaWNhdGlvbklkLCB0aGlzLmFwcGxpY2F0aW9uU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSUgd2l0aFxuICAgICAqICAlJWFwcGxpY2F0aW9uSWQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbklkID0gZGVmYXVsdEFwcGxpY2F0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92MS9sYi8ke2FwcGxpY2F0aW9uSWR9YCk7XG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uU2VjcmV0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIGFwcGxpY2F0aW9uU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiUG9ja2V0UHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSBQb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXBvY2tldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFtbbGluay1xdWlja25vZGVdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEhvbGVza3kgVGVzdG5ldCAoYGBob2xlc2t5YGApXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxuICogIC0gQXJiaXRydW0gR29lcmxpIFRlc3RuZXQgKGBgYXJiaXRydW0tZ29lcmxpYGApXG4gKiAgLSBBcmJpdHJ1bSBTZXBvbGlhIFRlc3RuZXQgKGBgYXJiaXRydW0tc2Vwb2xpYWBgKVxuICogIC0gQmFzZSBNYWlubmV0IChgYGJhc2VgYCk7XG4gKiAgLSBCYXNlIEdvZXJsaSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApO1xuICogIC0gQmFzZSBTZXBvbGlhIFRlc3RuZXQgKGBgYmFzZS1zZXBvbGlhYGApO1xuICogIC0gQk5CIFNtYXJ0IENoYWluIE1haW5uZXQgKGBgYm5iYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gVGVzdG5ldCAoYGBibmJ0YGApXG4gKiAgLSBPcHRpbWlzbSAoYGBvcHRpbWlzbWBgKVxuICogIC0gT3B0aW1pc20gR29lcmxpIFRlc3RuZXQgKGBgb3B0aW1pc20tZ29lcmxpYGApXG4gKiAgLSBPcHRpbWlzbSBTZXBvbGlhIFRlc3RuZXQgKGBgb3B0aW1pc20tc2Vwb2xpYWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gUG9seWdvbiBNdW1iYWkgVGVzdG5ldCAoYGBtYXRpYy1tdW1iYWlgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6UXVpY2tOb2RlICBbcHJvdmlkZXJzLXF1aWNrbm9kZV1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWlja05vZGVQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgZGVmYXVsdFRva2VuID0gXCI5MTliNDEyYTA1N2I1ZTljOWI2ZGNlMTkzYzVhNjAyNDJkNmVmYWRiXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ldGhlcmV1bS1zZXBvbGlhLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLWhvbGVza3kucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmFyYml0cnVtLW1haW5uZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5hcmJpdHJ1bS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYXJiaXRydW0tc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5iYXNlLW1haW5uZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmJhc2UtZ29lcmxpLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZS1zcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5iYXNlLXNlcG9saWEucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJibmJcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ic2MucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYnNjLXRlc3RuZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm1hdGljLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMubWF0aWMtdGVzdG5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMub3B0aW1pc20ucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMub3B0aW1pc20tc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcInhkYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy54ZGFpLnF1aWtub2RlLnByb1wiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKlxuQFRPRE86XG4gIFRoZXNlIG5ldHdvcmtzIGFyZSBub3QgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIE5ldHdvcmtcbiAgZGVmYXVsdCBpbmNsdWRlZCBuZXR3b3Jrcy4gUmVzZWFyY2ggdGhlbSBhbmQgZW5zdXJlIHRoZXlcbiAgYXJlIEVWTSBjb21wYXRpYmxlIGFuZCB3b3JrIHdpdGggZXRoZXJzXG5cbiAgaHR0cDovL2V0aGVycy5tYXRpYy1hbW95LnF1aWtub2RlLnByb1xuXG4gIGh0dHA6Ly9ldGhlcnMuYXZhbGFuY2hlLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuYXZhbGFuY2hlLXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuYmxhc3Qtc2Vwb2xpYS5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5jZWxvLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuZmFudG9tLnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLmlteC1kZW1vLnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLmlteC1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLmlteC10ZXN0bmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLm5lYXItbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5uZWFyLXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMubm92YS1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnNjcm9sbC1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnNjcm9sbC10ZXN0bmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnRyb24tbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy56a2V2bS1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnprZXZtLXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuemtzeW5jLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuemtzeW5jLXRlc3RuZXQucXVpa25vZGUucHJvXG4qL1xuLyoqXG4gKiAgVGhlICoqUXVpY2tOb2RlUHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLXF1aWNrbm9kZV1dXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSB0b2tlbiBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1xdWlja25vZGUpLlxuICovXG5jbGFzcyBRdWlja05vZGVQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgQVBJIHRva2VuLlxuICAgICAqL1xuICAgIHRva2VuO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUXVpY2tOb2RlUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgdG9rZW4pIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4gPSBkZWZhdWx0VG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IFF1aWNrTm9kZVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgdG9rZW4gfSk7XG4gICAgfVxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1aWNrTm9kZVByb3ZpZGVyKGNoYWluSWQsIHRoaXMudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50b2tlbiA9PT0gZGVmYXVsdFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgcmVxdWVzdCBwcmVwYXJlZCBmb3IgJSVuZXR3b3JrJSUgYW5kIHRoZVxuICAgICAqICAlJXRva2VuJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuID0gZGVmYXVsdFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfMS5GZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vJHt0b2tlbn1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICAvL2lmIChwcm9qZWN0U2VjcmV0KSB7IHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgcHJvamVjdFNlY3JldCk7IH1cbiAgICAgICAgaWYgKHRva2VuID09PSBkZWZhdWx0VG9rZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiUXVpY2tOb2RlUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBRdWlja05vZGVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXF1aWNrbm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEdlbmVyaWMgbG9uZy1saXZlZCBzb2NrZXQgcHJvdmlkZXIuXG4gKlxuICogIFN1Yi1jbGFzc2luZyBub3Rlc1xuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSB0aGUgYF93cml0ZShzdHJpbmcpYCBtZXRob2RcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1QgY2FsbCBgX3Byb2Nlc3NNZXNzYWdlKHN0cmluZylgIGZvciBlYWNoIG1lc3NhZ2VcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyOlNvY2tldCBQcm92aWRlcnMgIFthYm91dC1zb2NrZXRQcm92aWRlcl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0QmxvY2tTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG4vKipcbiAqICBBICoqU29ja2V0U3Vic2NyaWJlcioqIHVzZXMgYSBzb2NrZXQgdHJhbnNwb3J0IHRvIGhhbmRsZSBldmVudHMgYW5kXG4gKiAgc2hvdWxkIHVzZSBbW19lbWl0XV0gdG8gbWFuYWdlIHRoZSBldmVudHMuXG4gKi9cbmNsYXNzIFNvY2tldFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGdldCBmaWx0ZXIoKSB7IHJldHVybiBKU09OLnBhcnNlKHRoaXMuI2ZpbHRlcik7IH1cbiAgICAjZmlsdGVySWQ7XG4gICAgI3BhdXNlZDtcbiAgICAjZW1pdFByb21pc2U7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTb2NrZXRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlIGxpc3RlbmluZ1xuICAgICAqICB0byAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jZmlsdGVySWQgPSBudWxsO1xuICAgICAgICB0aGlzLiNwYXVzZWQgPSBudWxsO1xuICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHRoaXMuZmlsdGVyKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlZ2lzdGVyKGZpbHRlcklkLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgICh0aGlzLiNmaWx0ZXJJZCkudGhlbigoZmlsdGVySWQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwcm92aWRlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3Vuc3Vic2NyaWJlXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jZmlsdGVySWQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBAVE9ETzogcGF1c2Ugc2hvdWxkIHRyYXAgdGhlIGN1cnJlbnQgYmxvY2tOdW1iZXIsIHVuc3ViLCBhbmQgb24gcmVzdW1lIHVzZSBnZXRMb2dzXG4gICAgLy8gICAgICAgIGFuZCByZXN1bWVcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShkcm9wV2hpbGVQYXVzZWQsIFwicHJlc2VydmUgbG9ncyB3aGlsZSBwYXVzZWQgbm90IHN1cHBvcnRlZCBieSBTb2NrZXRTdWJzY3JpYmVyIHlldFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJwYXVzZShmYWxzZSlcIiB9KTtcbiAgICAgICAgdGhpcy4jcGF1c2VkID0gISFkcm9wV2hpbGVQYXVzZWQ7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy4jcGF1c2VkID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuI2ZpbHRlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jcGF1c2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZW1pdFByb21pc2UgPSB0aGlzLiNlbWl0UHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChlbWl0UHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW1pdFByb21pc2UgPSB0aGlzLl9lbWl0KHRoaXMuI3Byb3ZpZGVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXRQcm9taXNlID0gZW1pdFByb21pc2UudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXQodGhpcy4jcHJvdmlkZXIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZW1pdFByb21pc2UgPSBlbWl0UHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jZW1pdFByb21pc2UgPT09IGVtaXRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBlbWl0IHRoZSBldmVudHMgb24gdGhlXG4gICAgICogIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGFzeW5jIF9lbWl0KHByb3ZpZGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50ZSB0aGlzOyBfZW1pdFwiKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldFN1YnNjcmliZXIgPSBTb2NrZXRTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQSAqKlNvY2tldEJsb2NrU3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIGBgbmV3SGVhZHNgYCBldmVudHMgYW5kIGVtaXRzXG4gKiAgYGBcImJsb2NrXCJgYCBldmVudHMuXG4gKi9cbmNsYXNzIFNvY2tldEJsb2NrU3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibmV3SGVhZHNcIl0pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xuICAgICAgICBwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgcGFyc2VJbnQobWVzc2FnZS5udW1iZXIpKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldEJsb2NrU3Vic2NyaWJlciA9IFNvY2tldEJsb2NrU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIHBlbmRpbmcgdHJhbnNhY2l0b25zIGFuZCBlbWl0c1xuICogIGBgXCJwZW5kaW5nXCJgYCBldmVudHMuXG4gKi9cbmNsYXNzIFNvY2tldFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgU29ja2V0U3Vic2NyaWJlciB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyLCBbXCJuZXdQZW5kaW5nVHJhbnNhY3Rpb25zXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IFNvY2tldFBlbmRpbmdTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQSAqKlNvY2tldEV2ZW50U3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIGV2ZW50IGxvZ3MuXG4gKi9cbmNsYXNzIFNvY2tldEV2ZW50U3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xuICAgICNsb2dGaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaWx0ZXIuXG4gICAgICovXG4gICAgZ2V0IGxvZ0ZpbHRlcigpIHsgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jbG9nRmlsdGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyLCBbXCJsb2dzXCIsIGZpbHRlcl0pO1xuICAgICAgICB0aGlzLiNsb2dGaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xuICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMubG9nRmlsdGVyLCBwcm92aWRlci5fd3JhcExvZyhtZXNzYWdlLCBwcm92aWRlci5fbmV0d29yaykpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gU29ja2V0RXZlbnRTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQSAqKlNvY2tldFByb3ZpZGVyKiogaXMgYmFja2VkIGJ5IGEgbG9uZy1saXZlZCBjb25uZWN0aW9uIG92ZXIgYVxuICogIHNvY2tldCwgd2hpY2ggY2FuIHN1YnNjcmliZSBhbmQgcmVjZWl2ZSByZWFsLXRpbWUgbWVzc2FnZXMgb3ZlclxuICogIGl0cyBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKi9cbmNsYXNzIFNvY2tldFByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI2NhbGxiYWNrcztcbiAgICAvLyBNYXBzIGVhY2ggZmlsdGVySWQgdG8gaXRzIHN1YnNjcmliZXJcbiAgICAjc3VicztcbiAgICAvLyBJZiBhbnkgZXZlbnRzIGNvbWUgaW4gYmVmb3JlIGEgc3Vic2NyaWJlciBoYXMgZmluaXNoZWRcbiAgICAvLyByZWdpc3RlcmluZywgcXVldWUgdGhlbVxuICAgICNwZW5kaW5nO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU29ja2V0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUuXG4gICAgICpcbiAgICAgKiAgSWYgdW5zcGVjaWZpZWQsIHRoZSBuZXR3b3JrIHdpbGwgYmUgZGlzY292ZXJlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBfb3B0aW9ucykge1xuICAgICAgICAvLyBDb3B5IHRoZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAoX29wdGlvbnMgIT0gbnVsbCkgPyBfb3B0aW9ucyA6IHt9KTtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgYmF0Y2hlcyBpcyBnZW5lcmFsbHkgbm90IHN1cHBvcnRlZCBmb3JcbiAgICAgICAgLy8gY29ubmVjdGlvbi1iYXNlIHByb3ZpZGVyczsgaWYgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gdGhlIF9zZW5kIHNob3VsZCBiZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhpc1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkob3B0aW9ucy5iYXRjaE1heENvdW50ID09IG51bGwgfHwgb3B0aW9ucy5iYXRjaE1heENvdW50ID09PSAxLCBcInNvY2tldHMtYmFzZWQgcHJvdmlkZXJzIGRvIG5vdCBzdXBwb3J0IGJhdGNoZXNcIiwgXCJvcHRpb25zLmJhdGNoTWF4Q291bnRcIiwgX29wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLmJhdGNoTWF4Q291bnQgPSAxO1xuICAgICAgICAvLyBTb2NrZXQtYmFzZWQgUHJvdmlkZXJzIChnZW5lcmFsbHkpIGNhbm5vdCBjaGFuZ2UgdGhlaXIgbmV0d29yayxcbiAgICAgICAgLy8gc2luY2UgdGhleSBoYXZlIGEgbG9uZy1saXZlZCBjb25uZWN0aW9uOyBidXQgbGV0IHBlb3BsZSBvdmVycmlkZVxuICAgICAgICAvLyB0aGlzIGlmIHRoZXkgaGF2ZSBqdXN0IGNhdXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0aWNOZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGljTmV0d29yayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI2NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGVuZGluZyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBvbmx5IHZhbGlkIGFmdGVyIF9zdGFydCBoYXMgYmVlbiBjYWxsZWRcbiAgICAvKlxuICAgIGdldCBfbmV0d29yaygpOiBOZXR3b3JrIHtcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrLmNsb25lKCk7XG4gICAgfVxuICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5Vbm1hbmFnZWRTdWJzY3JpYmVyKFwiY2xvc2VcIik7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvY2tldEJsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ja2V0RXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgYXV0by1tYXRpY2FsbHkgd2l0aGluIEFic3RyYWN0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBsb2cucmVtb3ZlZCA9IHRydWVcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmZpbHRlci5vcnBoYW4gPT09IFwiZHJvcC1sb2dcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcihcImRyb3AtbG9nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyIGEgbmV3IHN1YnNjcmliZXIuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGxlZCBieSBTdWJzY3JpYmVyc1xuICAgICAqICBhbmQgZ2VuZXJhbGx5IGlzIHVuZWNlc3NhcnkgdW5sZXNzIGV4dGVuZGluZyBjYXBhYmlsaXRpZXMuXG4gICAgICovXG4gICAgX3JlZ2lzdGVyKGZpbHRlcklkLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuI3N1YnMuc2V0KGZpbHRlcklkLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMuI3BlbmRpbmcuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmcuZGVsZXRlKGZpbHRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIFdlYlNvY2tldCBwcm92aWRlciBkb2Vzbid0IGFjY2VwdCBiYXRjaGVzXG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJXZWJTb2NrZXQgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCBzZW5kXCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgLy8gQFRPRE86IHN0cmluZ2lmeSBwYXlsb2FkcyBoZXJlIGFuZCBzdG9yZSB0byBwcmV2ZW50IG11dGF0aW9uc1xuICAgICAgICAvLyBQcmVwYXJlIGEgcHJvbWlzZSB0byByZXNwb25kIHRvXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNjYWxsYmFja3Muc2V0KHBheWxvYWQuaWQsIHsgcGF5bG9hZCwgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FpdCB1bnRpbCB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBiZWZvcmUgd3JpdGluZyB0byBpdFxuICAgICAgICBhd2FpdCB0aGlzLl93YWl0VW50aWxSZWFkeSgpO1xuICAgICAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCB0byB0aGUgc29ja2V0XG4gICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgcmV0dXJuIFthd2FpdCBwcm9taXNlXTtcbiAgICB9XG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBjYWxsIHRoaXMgb25jZSB0aGV5IGFyZSBjb25uZWN0ZWRcbiAgICAvKlxuICAgIGFzeW5jIF9zdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKHRoaXMuI3JlYWR5KSB7IHJldHVybjsgfVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkIH0gb2YgdGhpcy4jY2FsbGJhY2tzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl93cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNyZWFkeSA9IChhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF3YWl0IHN1cGVyLl9zdGFydCgpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIHRoaXMgd2l0aCBtZXNzYWdlcyByZWNlaXZlZCBvdmVyIHRoZWlyXG4gICAgICogIHRyYW5zcG9ydCB0byBiZSBwcm9jZXNzZWQgYW5kIGRpc3BhdGNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKEpTT04ucGFyc2UobWVzc2FnZSkpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiAocmVzdWx0KSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuI2NhbGxiYWNrcy5nZXQocmVzdWx0LmlkKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgKDAsIGluZGV4X2pzXzEubWFrZUVycm9yKShcInJlY2VpdmVkIHJlc3VsdCBmb3IgdW5rbm93biBpZFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25Db2RlOiBcIlVOS05PV05fSURcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5kZWxldGUocmVzdWx0LmlkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgJiYgcmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcklkID0gcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb247XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy4jc3Vicy5nZXQoZmlsdGVySWQpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLl9oYW5kbGVNZXNzYWdlKHJlc3VsdC5wYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy4jcGVuZGluZy5nZXQoZmlsdGVySWQpO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nLnNldChmaWx0ZXJJZCwgcGVuZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCAoMCwgaW5kZXhfanNfMS5tYWtlRXJyb3IpKFwicmVjZWl2ZWQgdW5leHBlY3RlZCBtZXNzYWdlXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTkVYUEVDVEVEX01FU1NBR0VcIixcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBzZW5kICUlbWVzc2FnZSUlIG92ZXIgdGhlaXJcbiAgICAgKiAgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldFByb3ZpZGVyID0gU29ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1zb2NrZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgd3NfanNfMSA9IHJlcXVpcmUoXCIuL3dzLmpzXCIpOyAvKi1icm93c2VyKi9cbmNvbnN0IHByb3ZpZGVyX3NvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItc29ja2V0LmpzXCIpO1xuLyoqXG4gKiAgQSBKU09OLVJQQyBwcm92aWRlciB3aGljaCBpcyBiYWNrZWQgYnkgYSBXZWJTb2NrZXQuXG4gKlxuICogIFdlYlNvY2tldHMgYXJlIG9mdGVuIHByZWZlcnJlZCBiZWNhdXNlIHRoZXkgcmV0YWluIGEgbGl2ZSBjb25uZWN0aW9uXG4gKiAgdG8gYSBzZXJ2ZXIsIHdoaWNoIHBlcm1pdHMgbW9yZSBpbnN0YW50IGFjY2VzcyB0byBldmVudHMuXG4gKlxuICogIEhvd2V2ZXIsIHRoaXMgaW5jdXJzIGhpZ2hlciBzZXJ2ZXIgaW5mcmFzdHVydHVyZSBjb3N0cywgc28gYWRkaXRpb25hbFxuICogIHJlc291cmNlcyBtYXkgYmUgcmVxdWlyZWQgdG8gaG9zdCB5b3VyIG93biBXZWJTb2NrZXQgbm9kZXMgYW5kIG1hbnlcbiAqICB0aGlyZC1wYXJ0eSBzZXJ2aWNlcyBjaGFyZ2UgYWRkaXRpb25hbCBmZWVzIGZvciBXZWJTb2NrZXQgZW5kcG9pbnRzLlxuICovXG5jbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX3NvY2tldF9qc18xLlNvY2tldFByb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICAjd2Vic29ja2V0O1xuICAgIGdldCB3ZWJzb2NrZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLiN3ZWJzb2NrZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2Vic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd2Vic29ja2V0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSAoKSA9PiB7IHJldHVybiBuZXcgd3NfanNfMS5XZWJTb2NrZXQodXJsKTsgfTtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHRoaXMuI2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHVybCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHVybCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBzdGFydCBXZWJzb2NrZXRQcm92aWRlclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IG5vdyB3aGF0PyBBdHRlbXB0IHJlY29ubmVjdD9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2hhdCBldmVudC5jb2RlIHNob3VsZCB3ZSByZWNvbm5lY3Qgb24/XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB0aGlzLiNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0Lm9ub3BlbiA9IC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHJlcXVpcmVzIHRoZSBzdXBlciBjbGFzcyB0byByZWJyb2FkY2FzdDsgbW92ZSBpdCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIH1cbiAgICBhc3luYyBfd3JpdGUobWVzc2FnZSkge1xuICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy4jd2Vic29ja2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IFdlYlNvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItd2Vic29ja2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLkxvZyA9IGV4cG9ydHMuQmxvY2sgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5GZWVEYXRhID0gdm9pZCAwO1xuLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuY2xhc3MgRmVlRGF0YSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgZm9yIGxlZ2FjeSBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIHRvIHBheSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIGlzIGRlZmluZWQgYnkgdGhlIG5ldHdvcmsgYW5kIGJhc2VkIG9uXG4gICAgICogIGNvbmdlc3Rpb24sIGluY3JlYXNpbmcgdGhlIGNvc3QgZHVyaW5nIHRpbWVzIG9mIGhlYXZ5IGxvYWRcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxuICAgICAqXG4gICAgICogIFRoZSBhY3R1YWwgZmVlIHBlciBnYXMgd2lsbCBiZSB0aGUgYmFzZSBmZWUgZm9yIHRoZSBibG9ja1xuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXG4gICAgICogIHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcbiAgICAgKiAgYWRqdXN0ZWQgcmlzayBmb3IgaW5jbHVkaW5nIGEgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBGZWVEYXRhIGZvciAlJWdhc1ByaWNlJSUsICUlbWF4RmVlUGVyR2FzJSUgYW5kXG4gICAgICogICUlbWF4UHJpb3JpdHlGZWVQZXJHYXMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRmVlRGF0YSA9IEZlZURhdGE7XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyQmxvYkdhcyxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSAoMCwgaW5kZXhfanNfMS5nZXRCaWdJbnQpKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSAoMCwgaW5kZXhfanNfMi5hY2Nlc3NMaXN0aWZ5KShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzLnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQua3pnID0gcmVxLmt6ZztcbiAgICB9XG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9icyA9IHJlcS5ibG9icy5tYXAoKGIpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0J5dGVzTGlrZSkoYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb3B5UmVxdWVzdCA9IGNvcHlSZXF1ZXN0O1xuLyoqXG4gKiAgQSAqKkJsb2NrKiogcmVwcmVzZW50cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBmdWxsIGJsb2NrIG9uXG4gKiAgRXRoZXJldW0uXG4gKi9cbmNsYXNzIEJsb2NrIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgYmxvY2sgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyLCBzb21ldGltZXMgY2FsbGVkIHRoZSBibG9jayBoZWlnaHQuIFRoaXMgaXMgYVxuICAgICAqICBzZXF1ZW50aWFsIG51bWJlciB0aGF0IGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIG51bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYXNoIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBjYW4gYmUgc2FmZWx5IHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVzdGFtcCBmb3IgdGhpcyBibG9jaywgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogIGVwb2NoIHRoYXQgdGhpcyBibG9jayB3YXMgaW5jbHVkZWQuXG4gICAgICovXG4gICAgdGltZXN0YW1wO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIHBhcmVudEhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBoYXNoIHRyZWUgcm9vdCBvZiB0aGUgcGFyZW50IGJlYWNvbiBibG9jayBmb3IgdGhlIGdpdmVuXG4gICAgICogIGV4ZWN1dGlvbiBibG9jay4gU2VlIFtbbGluay1laXAtNDc4OF1dLlxuICAgICAqL1xuICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcmFuZG9tIG51bWJlciBpbnNlcnRlZCB3aGljaFxuICAgICAqICBwZXJtaXR0ZWQgdGhlIGRpZmZpY3VsdHkgdGFyZ2V0IHRvIGJlIHJlYWNoZWQuXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBkaWZmaWN1bHR5IHRhcmdldC5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHByb29mLW9mLXdvcmsgdGFyZ2V0IHJlcXVpcmVkXG4gICAgICogIGZvciBhIGJsb2NrIHRvIG1lZXQgdGhlIHByb3RvY29sIHJ1bGVzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogIE9uIG1vZGVybiBuZXR3b3JrcywgdGhpcyBpcyBhIHJhbmRvbSBudW1iZXIgYXJyaXZlZCBhdCB1c2luZ1xuICAgICAqICByYW5kYW8uICBAVE9ETzogRmluZCBsaW5rcz9cbiAgICAgKi9cbiAgICBkaWZmaWN1bHR5O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIGxpbWl0IGZvciB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc0xpbWl0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZ2FzIHVzZWQgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIGZvciB0aGUgZ2xvYmFsIHN0YXRlIGFmdGVyIGFwcGx5aW5nIGNoYW5nZXNcbiAgICAgKiAgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBzdGF0ZVJvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cyB0cmllLlxuICAgICAqL1xuICAgIHJlY2VpcHRzUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGFtb3VudCBvZiBibG9iIGdhcyBjb25zdW1lZCBieSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHdpdGhpbiB0aGUgYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJ1bm5pbmcgdG90YWwgb2YgYmxvYiBnYXMgY29uc3VtZWQgaW4gZXhjZXNzIG9mIHRoZVxuICAgICAqICB0YXJnZXQsIHByaW9yIHRvIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGV4Y2Vzc0Jsb2JHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5lciBjb2luYmFzZSBhZGRyZXNzLCB3aWhjaCByZWNlaXZlcyBhbnkgc3Vic2lkaWVzIGZvclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBtaW5lcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxhdGVzdCBSQU5EQU8gbWl4IG9mIHRoZSBwb3N0IGJlYWNvbiBzdGF0ZSBvZlxuICAgICAqICB0aGUgcHJldmlvdXMgYmxvY2suXG4gICAgICovXG4gICAgcHJldlJhbmRhbztcbiAgICAvKipcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBleHRyYURhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIHRoYXQgYWxsIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrIHdlcmVcbiAgICAgKiAgY2hhcmdlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGFkanVzdHMgYWZ0ZXIgZWFjaCBibG9jaywgZGVwZW5kaW5nIG9uIGhvdyBjb25nZXN0ZWQgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMuXG4gICAgICovXG4gICAgYmFzZUZlZVBlckdhcztcbiAgICAjdHJhbnNhY3Rpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipCbG9jayoqIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXG4gICAgICogIGxvdy1sZXZlbCBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiN0cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGJsb2NrLnBhcmVudEJlYWNvbkJsb2NrUm9vdCxcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGJsb2NrLmRpZmZpY3VsdHksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmxvY2suZ2FzTGltaXQsXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogYmxvY2suZXhjZXNzQmxvYkdhcyxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIHByZXZSYW5kYW86IGdldFZhbHVlKGJsb2NrLnByZXZSYW5kYW8pLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHN0YXRlUm9vdDogYmxvY2suc3RhdGVSb290LFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggPT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2NrID0gQmxvY2s7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nID0gTG9nO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyB1c2VkIGZvciBCTE9icy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmljZSBwYWlkIHBlciBCTE9CIGluIGdhcy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNjdGlvbiBjYW5ub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVvcmRlcmVkRXZlbnQob3RoZXIpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBUcmFuc2FjdGlvblJlY2VpcHQ7XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBCTE9iIHZlcnNpb25lZCBoYXNoZXMuXG4gICAgICovXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsIHx8IHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdGhpcy5ibG9ja051bWJlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgPT0gbnVsbCkgPyAxIDogX2NvbmZpcm1zO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF90aW1lb3V0ID09IG51bGwpID8gMCA6IF90aW1lb3V0O1xuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgIGxldCBuZXh0U2NhbiA9IC0xO1xuICAgICAgICBsZXQgc3RvcFNjYW5uaW5nID0gKHN0YXJ0QmxvY2sgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCBmb3IgdGhpcyBzZW5kZXJcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIG5vbmNlIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmZyb20pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zYWN0aW9uIG9yIG91ciBub25jZSBoYXMgbm90IGJlZW4gbWluZWQgeWV0OyBidXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdGFydCBzY2FubmluZyBsYXRlciB3aGVuIHdlIGRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5lZCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHRvIHNjYW47IGxvb2sgYmFjayBhIGZldyBleHRyYSBibG9ja3MgZm9yIHNhZmV0eVxuICAgICAgICAgICAgaWYgKG5leHRTY2FuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTY2FuIDwgdGhpcy4jc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5leHRTY2FuIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobmV4dFNjYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRoaXMuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYmxvY2suZ2V0VHJhbnNhY3Rpb24oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4Lmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCByZXRyeSB0aGlzIG9uIHRoZSBuZXh0IGJsb2NrICh0aGlzIGNhc2UgY291bGQgYmUgb3B0aW1pemVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxKSA8IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHRoaXMuZGF0YSAmJiB0eC50byA9PT0gdGhpcy50byAmJiB0eC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInRyYW5zYWN0aW9uIGV4ZWN1dGlvbiByZXZlcnRlZFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCwgcmVhc29uOiBudWxsLCBpbnZvY2F0aW9uOiBudWxsLCByZXZlcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJcIiAvLyBAVE9ETzogaW4gdjcsIHNwbGl0IG91dCBzZW5kVHJhbnNhY3Rpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNlaXB0KSB7XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhyb3dzIGlmIGEgcmVwbGFjZW1lbnQgd2FzIGZvdW5kXG4gICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdGVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7IGNhbmNlbGxlcnMuZm9yRWFjaCgoYykgPT4gYygpKTsgfTtcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBzdG9wU2Nhbm5pbmcgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBhbnkgdGltZW91dCByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIGluZGV4X2pzXzEubWFrZUVycm9yKShcIndhaXQgZm9yIHRyYW5zYWN0aW9uIHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4TGlzdGVuZXIgPSBhc3luYyAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2hlY2tSZWNlaXB0KHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYodGhpcy5oYXNoLCB0eExpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHJlcGxhY2VtZW50IGRldGVjdGlvbjsgc3RhcnQgY2hlY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFydEJsb2NrID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhpcyB0aHJvd3Mgb25seSBpZiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNFcnJvcikoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gVHJhbnNhY3Rpb25SZXNwb25zZTtcbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9uY2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3NpZ25lcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCIpO1xuLyoqXG4gKiAgQSAqKk5vbmNlTWFuYWdlcioqIHdyYXBzIGFub3RoZXIgW1tTaWduZXJdXSBhbmQgYXV0b21hdGljYWxseSBtYW5hZ2VzXG4gKiAgdGhlIG5vbmNlLCBlbnN1cmluZyBzZXJpYWxpemVkIGFuZCBzZXF1ZW50aWFsIG5vbmNlcyBhcmUgdXNlZCBkdXJpbmdcbiAqICB0cmFuc2FjdGlvbi5cbiAqL1xuY2xhc3MgTm9uY2VNYW5hZ2VyIGV4dGVuZHMgYWJzdHJhY3Rfc2lnbmVyX2pzXzEuQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgU2lnbmVyIGJlaW5nIG1hbmFnZWQuXG4gICAgICovXG4gICAgc2lnbmVyO1xuICAgICNub25jZVByb21pc2U7XG4gICAgI2RlbHRhO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTm9uY2VNYW5hZ2VyKiogdG8gbWFuYWdlICUlc2lnbmVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2lnbmVyKSB7XG4gICAgICAgIHN1cGVyKHNpZ25lci5wcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgc2lnbmVyIH0pO1xuICAgICAgICB0aGlzLiNub25jZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZWx0YSA9IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25jZU1hbmFnZXIodGhpcy5zaWduZXIuY29ubmVjdChwcm92aWRlcikpO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jbm9uY2VQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNub25jZVByb21pc2UgPSBzdXBlci5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuI2RlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLiNub25jZVByb21pc2UpICsgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlKGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIE1hbnVhbGx5IGluY3JlbWVudCB0aGUgbm9uY2UuIFRoaXMgbWF5IGJlIHVzZWZ1bCB3aGVuIG1hbmFnbmdcbiAgICAgKiAgb2ZmbGluZSB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5jcmVtZW50KCkge1xuICAgICAgICB0aGlzLiNkZWx0YSsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzZXRzIHRoZSBub25jZSwgY2F1c2luZyB0aGUgKipOb25jZU1hbmFnZXIqKiB0byByZWxvYWQgdGhlIGN1cnJlbnRcbiAgICAgKiAgbm9uY2UgZnJvbSB0aGUgYmxvY2tjaGFpbiBvbiB0aGUgbmV4dCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy4jZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLiNub25jZVByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3Qgbm9uY2VQcm9taXNlID0gdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50KCk7XG4gICAgICAgIHR4ID0gYXdhaXQgdGhpcy5zaWduZXIucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHR4Lm5vbmNlID0gYXdhaXQgbm9uY2VQcm9taXNlO1xuICAgICAgICAvLyBAVE9ETzogTWF5YmUgaGFuZGxlIGludGVyZXN0aW5nL3JlY292ZXJhYmxlIGVycm9ycz9cbiAgICAgICAgLy8gTGlrZSBkb24ndCBpbmNyZW1lbnQgaWYgdGhlIHR4IHdhcyBjZXJ0YWlubHkgbm90IHNlbnRcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuICAgIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9uY2VNYW5hZ2VyID0gTm9uY2VNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmVyLW5vbmNlbWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuRmlsdGVySWRFdmVudFN1YnNjcmliZXIgPSBleHBvcnRzLkZpbHRlcklkU3Vic2NyaWJlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMSA9IHJlcXVpcmUoXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiKTtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgICNuZXR3b3JrO1xuICAgICNoYXVsdDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxuICAgICAqICB0byB0aGUgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBpbmRleF9qc18xLmlzRXJyb3IpKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwcm92aWRlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnRzLkZpbHRlcklkU3Vic2NyaWJlciA9IEZpbHRlcklkU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNldmVudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlXG4gICAgICogIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZXZlbnQgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0V2ZW50U3Vic2NyaWJlcihwcm92aWRlciwgdGhpcy4jZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkID0gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdGaWx0ZXJcIiwgW3RoaXMuI2V2ZW50XSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jZXZlbnQsIHByb3ZpZGVyLl93cmFwTG9nKHJlc3VsdCwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRFdmVudFN1YnNjcmliZXIgPSBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciA9IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLWZpbHRlcmlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nRXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Qb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyID0gZXhwb3J0cy5Qb2xsaW5nT3JwaGFuU3Vic2NyaWJlciA9IGV4cG9ydHMuUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciA9IGV4cG9ydHMuT25CbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLlBvbGxpbmdCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLmdldFBvbGxpbmdTdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIHBvbGxpbmcgc3Vic2NyaWJlciBmb3IgY29tbW9uIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKCgwLCBpbmRleF9qc18xLmlzSGV4U3RyaW5nKShldmVudCwgMzIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFBvbGxpbmdTdWJzY3JpYmVyID0gZ2V0UG9sbGluZ1N1YnNjcmliZXI7XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsZXI7XG4gICAgI2ludGVydmFsO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkgeyB0aGlzLiNpbnRlcnZhbCA9IHZhbHVlOyB9XG4gICAgYXN5bmMgI3BvbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgcG9sbCB0byBzZXR1cCBvdXIgaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPOiBQdXQgYSBjYXAgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyBwZXIgbG9vcD9cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciAhPT0gdGhpcy4jYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQFRPRE86IE1pbm9yIGJ1bXAsIGFkZCBhbiBcImVycm9yXCIgZXZlbnQgdG8gbGV0IHN1YnNjcmliZXJzXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuI3BvbGwoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5fY2xlYXJUaW1lb3V0KHRoaXMuI3BvbGxlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdCbG9ja1N1YnNjcmliZXIgPSBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsO1xuICAgICNydW5uaW5nO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipPbkJsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3BvbGwgPSAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGwoYmxvY2tOdW1iZXIsIHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgdGhpcy5zdG9wKCk7IH1cbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxufVxuZXhwb3J0cy5PbkJsb2NrU3Vic2NyaWJlciA9IE9uQmxvY2tTdWJzY3JpYmVyO1xuY2xhc3MgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjdGFnO1xuICAgICNsYXN0QmxvY2s7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHRhZykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXVzZShkcm9wV2hpbGVQYXVzZWQpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9jayh0aGlzLiN0YWcpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2subnVtYmVyID4gdGhpcy4jbGFzdEJsb2NrKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciA9IFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXI7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgUG9sbGluZ09ycGhhblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nT3JwaGFuU3Vic2NyaWJlciA9IFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyO1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAqICBoYXNoIGZvciBpdHMgcmVjZWlwdC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaGFzaCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2hhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaGFzaCk7XG4gICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgPSBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyO1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICAvLyBUaGUgaW5pdGlhbCBibG9jayBoYXNuJ3QgYmVlbiBkZXRlcm1pbmVkIHlldFxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAvLyBObyBsb2dzIGNvdWxkIGp1c3QgbWVhbiB0aGUgbm9kZSBoYXMgbm90IGluZGV4ZWQgdGhlbSB5ZXQsXG4gICAgICAgIC8vIHNvIHdlIGtlZXAgYSBzbGlkaW5nIHdpbmRvdyBvZiA2MCBibG9ja3MgdG8ga2VlcCBzY2FubmluZ1xuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA8IGJsb2NrTnVtYmVyIC0gNjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZW1pdCh0aGlzLiNmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAvLyBPbmx5IGFkdmFuY2UgdGhlIGJsb2NrIG51bWJlciB3aGVuIGxvZ3Mgd2VyZSBmb3VuZCB0b1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcbiAgICAgICAgICAgIC8vIHNhY3JpZmljZSBldmVudCBjb25zaXN0ZW5jeSBmb3IgYmxvY2sgZXZlbnQgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nRXZlbnRTdWJzY3JpYmVyID0gUG9sbGluZ0V2ZW50U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItcG9sbGluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xudmFyIHdzXzEgPSByZXF1aXJlKFwid3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdzXzEuV2ViU29ja2V0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzIuaXNIZXhTdHJpbmcpKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHNldCAhPSBudWxsICYmIHR5cGVvZiAoc2V0KSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFkZHJlc3Mtc2xvdCBzZXRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhY2Nlc3MgbGlzdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IGFjY2Vzc0xpc3RpZnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBpbmRleF9qc18yLlNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoaW5kZXhfanNfMi5TaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcbn1cbmV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSByZWNvdmVyQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBFYWNoIHN0YXRlLWNoYW5naW5nIG9wZXJhdGlvbiBvbiBFdGhlcmV1bSByZXF1aXJlcyBhIHRyYW5zYWN0aW9uLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3RyYW5zYWN0aW9uOlRyYW5zYWN0aW9ucyAgW2Fib3V0LXRyYW5zYWN0aW9uc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IGV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSBleHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gZXhwb3J0cy5hY2Nlc3NMaXN0aWZ5ID0gdm9pZCAwO1xubnVsbDtcbnZhciBhY2Nlc3NsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi9hY2Nlc3NsaXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWNjZXNzTGlzdGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjZXNzbGlzdF9qc18xLmFjY2Vzc0xpc3RpZnk7IH0gfSk7XG52YXIgYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEuY29tcHV0ZUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWNvdmVyQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc19qc18xLnJlY292ZXJBZGRyZXNzOyB9IH0pO1xudmFyIHRyYW5zYWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc2FjdGlvbl9qc18xLlRyYW5zYWN0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgYWRkcmVzc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzL2FkZHJlc3Nlcy5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFjY2Vzc2xpc3RfanNfMSA9IHJlcXVpcmUoXCIuL2FjY2Vzc2xpc3QuanNcIik7XG5jb25zdCBhZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBCTl9NQVhfVUlOVCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmNvbnN0IEJMT0JfU0laRSA9IDQwOTYgKiAzMjtcbmZ1bmN0aW9uIGdldFZlcnNpb25lZEhhc2godmVyc2lvbiwgaGFzaCkge1xuICAgIGxldCB2ZXJzaW9uZWQgPSB2ZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAodmVyc2lvbmVkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdmVyc2lvbmVkID0gXCIwXCIgKyB2ZXJzaW9uZWQ7XG4gICAgfVxuICAgIHZlcnNpb25lZCArPSAoMCwgaW5kZXhfanNfMi5zaGEyNTYpKGhhc2gpLnN1YnN0cmluZyg0KTtcbiAgICByZXR1cm4gXCIweFwiICsgdmVyc2lvbmVkO1xufVxuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXROdW1iZXIpKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkoX3ZhbHVlLCBwYXJhbSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KShfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KSh2YWx1ZSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgYWNjZXNzbGlzdF9qc18xLmFjY2Vzc0xpc3RpZnkpKHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhhc2hlcyh2YWx1ZSwgcGFyYW0pIHtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCAkeyBwYXJhbSB9IGhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoZGF0YSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUxlZ2FjeSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgXTtcbiAgICBsZXQgY2hhaW5JZCA9IEJOXzA7XG4gICAgaWYgKHR4LmNoYWluSWQgIT0gQk5fMCkge1xuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuICAgICAgICBjaGFpbklkID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoIXNpZyB8fCBzaWcubmV0d29ya1YgPT0gbnVsbCB8fCBzaWcubGVnYWN5Q2hhaW5JZCA9PT0gY2hhaW5JZCwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR4LnNpZ25hdHVyZSkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBjaGFpbklkLCBidXQgRUlQLTE1NSBoYXZlIGEgZGVyaXZlZCBpbXBsaWNpdCBjaGFpbklkXG4gICAgICAgIGNvbnN0IGxlZ2FjeSA9IHR4LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAobGVnYWN5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBsZWdhY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoY2hhaW5JZCkpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmVuY29kZVJscCkoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBpbmRleF9qc18yLlNpZ25hdHVyZS5nZXRDaGFpbklkVihjaGFpbklkLCBzaWcudik7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJpZ0ludChzaWcudikgIT09IHYpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHYpKTtcbiAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5yKSk7XG4gICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucykpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5lbmNvZGVSbHApKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xuICAgIGxldCB5UGFyaXR5O1xuICAgIHRyeSB7XG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XG4gICAgICAgIGlmICh5UGFyaXR5ICE9PSAwICYmIHlQYXJpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIsIFwieVBhcml0eVwiLCBmaWVsZHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCByID0gKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKShmaWVsZHNbMV0sIDMyKTtcbiAgICBjb25zdCBzID0gKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKShmaWVsZHNbMl0sIDMyKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcbiAgICB0eC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSAoMCwgaW5kZXhfanNfMy5kZWNvZGVSbHApKCgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShkYXRhKS5zbGljZSgxKSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg5KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcIjB4MDJcIiwgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSAoMCwgaW5kZXhfanNfMy5kZWNvZGVSbHApKCgwLCBpbmRleF9qc18zLmdldEJ5dGVzKShkYXRhKS5zbGljZSgxKSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzZdKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbN10sIFwiYWNjZXNzTGlzdFwiKVxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTI5MzAgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg4KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcIjB4MDFcIiwgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXA0ODQ0KGRhdGEpIHtcbiAgICBsZXQgZmllbGRzID0gKDAsIGluZGV4X2pzXzMuZGVjb2RlUmxwKSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGxldCB0eXBlTmFtZSA9IFwiM1wiO1xuICAgIGxldCBibG9icyA9IG51bGw7XG4gICAgLy8gUGFyc2UgdGhlIG5ldHdvcmsgZm9ybWF0XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDQgJiYgQXJyYXkuaXNBcnJheShmaWVsZHNbMF0pKSB7XG4gICAgICAgIHR5cGVOYW1lID0gXCIzIChuZXR3b3JrIGZvcm1hdClcIjtcbiAgICAgICAgY29uc3QgZkJsb2JzID0gZmllbGRzWzFdLCBmQ29tbWl0cyA9IGZpZWxkc1syXSwgZlByb29mcyA9IGZpZWxkc1szXTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZkJsb2JzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbMV1cIiwgZkJsb2JzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1syXVwiLCBmQ29tbWl0cyk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShBcnJheS5pc0FycmF5KGZQcm9vZnMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IHByb29mcyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbM11cIiwgZlByb29mcyk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmQmxvYnMubGVuZ3RoID09PSBmQ29tbWl0cy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvY29tbWl0bWVudHMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmQmxvYnMubGVuZ3RoID09PSBmUHJvb2ZzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9wcm9vZnMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGJsb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBmQmxvYnNbaV0sXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGZQcm9vZnNbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBmaWVsZHNbMF07XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDExIHx8IGZpZWxkcy5sZW5ndGggPT09IDE0KSwgYGludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogZmllbGRzWzEwXVxuICAgIH07XG4gICAgaWYgKGJsb2JzKSB7XG4gICAgICAgIHR4LmJsb2JzID0gYmxvYnM7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh0eC50byAhPSBudWxsLCBgaW52YWxpZCBhZGRyZXNzIGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheSh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoZXM6IG11c3QgYmUgYW4gYXJyYXlcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHguYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXNbaV0sIDMyKSwgYGludmFsaWQgYmxvYlZlcnNpb25lZEhhc2ggYXQgaW5kZXggJHtpfTogbXVzdCBiZSBsZW5ndGggMzJgLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIC8vIFVuc2lnbmVkIEVJUC00ODQ0IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDExKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gQFRPRE86IERvIHdlIG5lZWQgdG8gZG8gdGhpcz8gVGhpcyBpcyBvbmx5IGNhbGxlZCBpbnRlcm5hbGx5XG4gICAgLy8gYW5kIHVzZWQgdG8gdmVyaWZ5IGhhc2hlczsgaXQgbWlnaHQgc2F2ZSB0aW1lIHRvIG5vdCBkbyB0aGlzXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGNvbmNhdChbIFwiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKSBdKSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTEpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNDg0NCh0eCwgc2lnLCBibG9icykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgYWRkcmVzc2VzX2pzXzEuWmVyb0FkZHJlc3MpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJCbG9iR2FzIHx8IDAsIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgZm9ybWF0SGFzaGVzKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgfHwgW10sIFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShzaWcucykpO1xuICAgICAgICAvLyBXZSBoYXZlIGJsb2JzOyByZXR1cm4gdGhlIG5ldHdvcmsgd3JhcHBlZCBmb3JtYXRcbiAgICAgICAgaWYgKGJsb2JzKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuY29uY2F0KShbXG4gICAgICAgICAgICAgICAgXCIweDAzXCIsXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShbXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5wcm9vZiksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5jb25jYXQpKFtcIjB4MDNcIiwgKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAjbWF4RmVlUGVyQmxvYkdhcztcbiAgICAjYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAja3pnO1xuICAgICNibG9icztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgdGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGJhc2VkIG9uXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLiN0eXBlOyB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0yOTMwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jdW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNDg0NFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN0bztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzX2pzXzEuWmVyb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gKDAsIGluZGV4X2pzXzMuZ2V0TnVtYmVyKSh2YWx1ZSwgXCJ2YWx1ZVwiKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy4jc2lnIHx8IG51bGw7IH1cbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckJsb2JHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEJMT2IgdmVyc2lvbmVkIGhhc2hlcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgYmxvYlZlcnNpb25lZEhhc2hlcygpIHtcbiAgICAgICAgLy8gQFRPRE86IE11dGF0aW9uIGlzIGluY29uc2lzdGVudDsgaWYgdW5zZXQsIHRoZSByZXR1cm5lZCB2YWx1ZVxuICAgICAgICAvLyBjYW5ub3QgbXV0YXRlIHRoZSBvYmplY3QsIGlmIHNldCBpdCBjYW5cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYmxvYlZlcnNpb25lZEhhc2hlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEJMT2JzIGZvciB0aGUgVHJhbnNhY3Rpb24sIGlmIGFueS5cbiAgICAgKlxuICAgICAqICBJZiBgYGJsb2JzYGAgaXMgbm9uLWBgbnVsbGBgLCB0aGVuIHRoZSBbW3NlcmlhaWxpemVkXV1cbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIG5ldHdvcmsgZm9ybWF0dGVkIHNpZGVjYXIsIG90aGVyd2lzZSBpdFxuICAgICAqICB3aWxsIHJldHVybiB0aGUgc3RhbmRhcmQgW1tsaW5rLWVpcC0yNzE4XV0gcGF5bG9hZC4gVGhlXG4gICAgICogIFtbdW5zaWduZWRTZXJpYWxpemVkXV0gaXMgdW5hZmZlY3RlZCByZWdhcmRsZXNzLlxuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBgYGJsb2JzYGAsIGVpdGhlciBmdWxseSB2YWxpZCBbW0Jsb2JdXSBvYmplY3RzXG4gICAgICogIG1heSBiZSBzcGVjaWZpZWQgKGkuZS4gY29ycmVjdGx5IHBhZGRlZCwgd2l0aCBjb3JyZWN0XG4gICAgICogIGNvbW1pdHRtZW50cyBhbmQgcHJvb2ZzKSBvciBhIHJhdyBbW0J5dGVzTGlrZV1dIG1heVxuICAgICAqICBiZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqICBJZiByYXcgW1tCeXRlc0xpa2VdXSBhcmUgcHJvdmlkZWQsIHRoZSBbW2t6Z11dIHByb3BlcnR5ICoqbXVzdCoqXG4gICAgICogIGJlIGFscmVhZHkgc2V0LiBUaGUgYmxvYiB3aWxsIGJlIGNvcnJlY3RseSBwYWRkZWQgYW5kIHRoZVxuICAgICAqICBbW0t6Z0xpYnJhcnldXSB3aWxsIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY29tbWl0dG1lbnQgYW5kXG4gICAgICogIHByb29mIGZvciB0aGUgYmxvYi5cbiAgICAgKlxuICAgICAqICBBIEJMT2IgaXMgYSBzZXF1ZW5jZSBvZiBmaWVsZCBlbGVtZW50cywgZWFjaCBvZiB3aGljaCBtdXN0XG4gICAgICogIGJlIHdpdGhpbiB0aGUgQkxTIGZpZWxkIG1vZHVsbywgc28gc29tZSBhZGRpdGlvbmFsIHByb2Nlc3NpbmdcbiAgICAgKiAgbWF5IGJlIHJlcXVpcmVkIHRvIGVuY29kZSBhcmJpdHJhcnkgZGF0YSB0byBlbnN1cmUgZWFjaCAzMiBieXRlXG4gICAgICogIGZpZWxkIGlzIHdpdGhpbiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyB0aGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVzIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLFxuICAgICAqICBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmcgdmFsdWVzLiBTZXR0aW5nIHRoaXMgdG8gYGBudWxsYGBcbiAgICAgKiAgZG9lcyAqKm5vdCoqIHJlbW92ZSB0aGUgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sIGxlYXZpbmcgdGhlbVxuICAgICAqICBwcmVzZW50LlxuICAgICAqL1xuICAgIGdldCBibG9icygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2JzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNibG9icy5tYXAoKGIpID0+IE9iamVjdC5hc3NpZ24oe30sIGIpKTtcbiAgICB9XG4gICAgc2V0IGJsb2JzKF9ibG9icykge1xuICAgICAgICBpZiAoX2Jsb2JzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9icyA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmxvYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBfYmxvYnNbaV07XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNCeXRlc0xpa2UpKGJsb2IpKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSh0aGlzLiNremcsIFwiYWRkaW5nIGEgcmF3IGJsb2IgcmVxdWlyZXMgYSBLWkcgbGlicmFyeVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXQgYmxvYnMoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoYmxvYik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGRhdGEubGVuZ3RoIDw9IEJMT0JfU0laRSwgXCJibG9iIGlzIHRvbyBsYXJnZVwiLCBgYmxvYnNbJHtpfV1gLCBibG9iKTtcbiAgICAgICAgICAgICAgICAvLyBQYWQgYmxvYiBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IEJMT0JfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCTE9CX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWQuc2V0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSB0aGlzLiNremcuYmxvYlRvS3pnQ29tbWl0bWVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9vZiA9ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKHRoaXMuI2t6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGRhdGEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoY29tbWl0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2ZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoYmxvYi5jb21taXRtZW50KTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoYmxvYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0LFxuICAgICAgICAgICAgICAgICAgICBwcm9vZjogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoYmxvYi5wcm9vZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JzID0gYmxvYnM7XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2ZXJzaW9uZWRIYXNoZXM7XG4gICAgfVxuICAgIGdldCBremcoKSB7IHJldHVybiB0aGlzLiNremc7IH1cbiAgICBzZXQga3pnKGt6Zykge1xuICAgICAgICB0aGlzLiNremcgPSBremc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLiN0byA9IG51bGw7XG4gICAgICAgIHRoaXMuI25vbmNlID0gMDtcbiAgICAgICAgdGhpcy4jZ2FzTGltaXQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCTl8wO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQk5fMDtcbiAgICAgICAgdGhpcy4jc2lnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGRpZ2VzdCB0aGF0IGEgW1tTaWduZXJdXSBtdXN0IHNpZ24gdG8gYXV0aG9yaXplXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBhZGRyZXNzX2pzXzEucmVjb3ZlckFkZHJlc3MpKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhfanNfMi5TaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCBwcm9wZXJ0aWVzIHJlcXVpcmluZyBhIHNpZ25lZFxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xuICAgIH1cbiAgICAjZ2V0U2VyaWFsaXplZChzaWduZWQsIHNpZGVjYXIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSghc2lnbmVkIHx8IHRoaXMuc2lnbmF0dXJlICE9IG51bGwsIFwiY2Fubm90IHNlcmlhbGl6ZSB1bnNpZ25lZCB0cmFuc2FjdGlvbjsgbWF5YmUgeW91IG1lYW50IC51bnNpZ25lZFNlcmlhbGl6ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmVkID8gdGhpcy5zaWduYXR1cmUgOiBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCBzaWcsIHNpZGVjYXIgPyB0aGlzLmJsb2JzIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHRocm93cyBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5zaWduZWQuIEZvciB0aGUgcHJlLWltYWdlLFxuICAgICAqICB1c2UgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXS5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5pbmZlclR5cGVzKCk7XG4gICAgICAgIC8vIFByZWZlciBMb25kb24gKEVJUC0xNTU5KSBvdmVyIENhbmN1biAoQkxPYilcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoMikgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBoaWdoZXN0IGluZmVycmVkIHR5cGVcbiAgICAgICAgcmV0dXJuICh0eXBlcy5wb3AoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBWYWxpZGF0ZXMgdGhlIGV4cGxpY2l0IHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGNvbXBhdGlibGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gdHlwZXMuXG4gICAgICovXG4gICAgaW5mZXJUeXBlcygpIHtcbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgc2V0XG4gICAgICAgIGNvbnN0IGhhc0dhc1ByaWNlID0gdGhpcy5nYXNQcmljZSAhPSBudWxsO1xuICAgICAgICBjb25zdCBoYXNGZWUgPSAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNBY2Nlc3NMaXN0ID0gKHRoaXMuYWNjZXNzTGlzdCAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQmxvYiA9ICh0aGlzLiNtYXhGZWVQZXJCbG9iR2FzICE9IG51bGwgfHwgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoIWhhc0ZlZSB8fCAodGhpcy50eXBlICE9PSAwICYmIHRoaXMudHlwZSAhPT0gMSksIFwidHJhbnNhY3Rpb24gdHlwZSBjYW5ub3QgaGF2ZSBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzRmVlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0dhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQmxvYiAmJiB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMWBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQmVybGluKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBsb25kb24gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAyYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIFtbbGluay1laXAtNDg0NF1dIEJMT0JcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHRyYW5zYWNpdG9uLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIEpTT04tZnJpZW5kbHkgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcyA9ICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHModGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogcyh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBzKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBzKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHZhbHVlOiBzKHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgY2hhaW5JZDogcyh0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgc2lnOiB0aGlzLnNpZ25hdHVyZSA/IHRoaXMuc2lnbmF0dXJlLnRvSlNPTigpIDogbnVsbCxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHgpIHtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykodHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IGJsb2JzLCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXNzaWduIHRoZSBremcgYmVmb3JlIGFzc2lnbmluZyBibG9icywgd2hpY2hcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgbGlicmFyeSBpbiB0aGUgZXZlbnQgcmF3IGJsb2IgZGF0YSBpcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKHR4Lmt6ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQua3pnID0gdHgua3pnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYnMgPSB0eC5ibG9icztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSAnLmhhc2gnXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5oYXNoID09PSB0eC5oYXNoLCBcImhhc2ggbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShyZXN1bHQuZnJvbS50b0xvd2VyQ2FzZSgpID09PSAodHguZnJvbSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLCBcImZyb20gbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBleHBvcnRzLmVuY29kZUJhc2U1OCA9IHZvaWQgMDtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IG1hdGhzX2pzXzEgPSByZXF1aXJlKFwiLi9tYXRocy5qc1wiKTtcbmNvbnN0IEFscGhhYmV0ID0gXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7XG5sZXQgTG9va3VwID0gbnVsbDtcbmZ1bmN0aW9uIGdldEFscGhhKGxldHRlcikge1xuICAgIGlmIChMb29rdXAgPT0gbnVsbCkge1xuICAgICAgICBMb29rdXAgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgTG9va3VwW0FscGhhYmV0W2ldXSA9IEJpZ0ludChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBMb29rdXBbbGV0dGVyXTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoX3ZhbHVlKTtcbiAgICBsZXQgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS50b0JpZ0ludCkoYnl0ZXMpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0WzBdICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5lbmNvZGVCYXNlNTggPSBlbmNvZGVCYXNlNTg7XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTU4KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IEJOXzA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKj0gQk5fNTg7XG4gICAgICAgIHJlc3VsdCArPSBnZXRBbHBoYSh2YWx1ZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZUJhc2U1OCA9IGRlY29kZUJhc2U1ODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlQmFzZTY0ID0gZXhwb3J0cy5kZWNvZGVCYXNlNjQgPSB2b2lkIDA7XG4vKipcbiAqICBbQmFzZTY0IGVuY29kaW5nXShsaW5rLXdpa2ktYmFzZTY0KSB1c2luZyA2LWJpdCB3b3JkcyB0byBlbmNvZGVcbiAqICBhcmJpdHJhcnkgYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyA2NSBwcmludGFibGUgc3ltYm9scywgdGhlXG4gKiAgdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSBhbHBoYWJldCwgdGhlIGRpZ2l0cyBgYDBgYCB0aHJvdWdoIGBgOWBgLFxuICogIGBgXCIrXCJgYCBhbmQgYGBcIi9cImBgIHdpdGggdGhlIGBgXCI9XCJgYCB1c2VkIGZvciBwYWRkaW5nLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNjQgRW5jb2RpbmcgIFthYm91dC1iYXNlNjRdXG4gKi9cbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG4vKipcbiAqICBEZWNvZGVzIHRoZSBiYXNlLTY0IGVuY29kZWQgJSV2YWx1ZSUlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBiaW5hcnkgZGF0YS4uLlxuICogICAgcmVzdWx0ID0gZGVjb2RlQmFzZTY0KFwiU0dWc2JHOGdWMjl5YkdRaElRPT1cIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4U3RyaW5nIHRvIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuXG4gKiAgICB0b1V0ZjhTdHJpbmcocmVzdWx0KVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIERlY29kaW5nIGJpbmFyeSBkYXRhXG4gKiAgICBkZWNvZGVCYXNlNjQoXCJFalE9XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgZGF0YV9qc18xLmdldEJ5dGVzQ29weSkoQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpKTtcbn1cbmV4cG9ydHMuZGVjb2RlQmFzZTY0ID0gZGVjb2RlQmFzZTY0O1xuO1xuLyoqXG4gKiAgRW5jb2RlcyAlJWRhdGElJSBhcyBhIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBoZXhzdHJpbmdcbiAqICAgIGVuY29kZUJhc2U2NChcIjB4MTIzNFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVuY29kaW5nIGJpbmFyeSBkYXRhIGFzIGEgVWludDhBcnJheVxuICogICAgZW5jb2RlQmFzZTY0KG5ldyBVaW50OEFycmF5KFsgMHgxMiwgMHgzNCBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaGUgaW5wdXQgTVVTVCBiZSBkYXRhLi4uXG4gKiAgICBlbmNvZGVCYXNlNjQoXCJIZWxsbyBXb3JsZCEhXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4Qnl0ZXMgZm9yIHRoaXMuXG4gKiAgICBlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZCEhXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShkYXRhKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG5leHBvcnRzLmVuY29kZUJhc2U2NCA9IGVuY29kZUJhc2U2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuemVyb1BhZEJ5dGVzID0gZXhwb3J0cy56ZXJvUGFkVmFsdWUgPSBleHBvcnRzLnN0cmlwWmVyb3NMZWZ0ID0gZXhwb3J0cy5kYXRhU2xpY2UgPSBleHBvcnRzLmRhdGFMZW5ndGggPSBleHBvcnRzLmNvbmNhdCA9IGV4cG9ydHMuaGV4bGlmeSA9IGV4cG9ydHMuaXNCeXRlc0xpa2UgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRCeXRlc0NvcHkgPSBleHBvcnRzLmdldEJ5dGVzID0gdm9pZCAwO1xuLyoqXG4gKiAgU29tZSBkYXRhIGhlbHBlcnMuXG4gKlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOkRhdGEgSGVscGVycyAgW2Fib3V0LWRhdGFdXG4gKi9cbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KFswLTlhLWZdWzAtOWEtZl0pKiQvaSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xufVxuZXhwb3J0cy5nZXRCeXRlcyA9IGdldEJ5dGVzO1xuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XG4gKiAgdG8gcHJldmVudCBhbnkgbW9kaWZpY2F0aW9ucyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBiZWluZ1xuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xufVxuZXhwb3J0cy5nZXRCeXRlc0NvcHkgPSBnZXRCeXRlc0NvcHk7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cbiAqL1xuZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XG59XG5leHBvcnRzLmlzQnl0ZXNMaWtlID0gaXNCeXRlc0xpa2U7XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXG4gKi9cbmZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5oZXhsaWZ5ID0gaGV4bGlmeTtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcbiAqICB3aXRoaW4gJSVkYXRhJSUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzKGRhdGEpLmxlbmd0aDtcbn1cbmV4cG9ydHMuZGF0YUxlbmd0aCA9IGRhdGFMZW5ndGg7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxuICpcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXG4gKi9cbmZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuZXhwb3J0cy5kYXRhU2xpY2UgPSBkYXRhU2xpY2U7XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBzdHJpcFplcm9zTGVmdChkYXRhKSB7XG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xufVxuZXhwb3J0cy5zdHJpcFplcm9zTGVmdCA9IHN0cmlwWmVyb3NMZWZ0O1xuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIHRydWUpO1xufVxuZXhwb3J0cy56ZXJvUGFkVmFsdWUgPSB6ZXJvUGFkVmFsdWU7XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgYnl0ZXMxNmBgKS5cbiAqL1xuZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuZXhwb3J0cy56ZXJvUGFkQnl0ZXMgPSB6ZXJvUGFkQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFByaXZhdGUgPSBleHBvcnRzLmFzc2VydE5vcm1hbGl6ZSA9IGV4cG9ydHMuYXNzZXJ0QXJndW1lbnRDb3VudCA9IGV4cG9ydHMuYXNzZXJ0QXJndW1lbnQgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMubWFrZUVycm9yID0gZXhwb3J0cy5pc0NhbGxFeGNlcHRpb24gPSBleHBvcnRzLmlzRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBfdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL192ZXJzaW9uLmpzXCIpO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlsgXCIgKyAodmFsdWUubWFwKHN0cmluZ2lmeSkpLmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ7IFwiICsga2V5cy5tYXAoKGspID0+IGAke3N0cmluZ2lmeShrKX06ICR7c3RyaW5naWZ5KHZhbHVlW2tdKX1gKS5qb2luKFwiLCBcIikgKyBcIiB9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBbIENPVUxEIE5PVCBTRVJJQUxJWkUgXWA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgdGhlICUlZXJyb3IlJSBtYXRjaGVzIGFuIGVycm9yIHRocm93biBieSBldGhlcnNcbiAqICB0aGF0IG1hdGNoZXMgdGhlIGVycm9yICUlY29kZSUlLlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhpcyBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGF0ICUlZXJyb3IlJVxuICogIG1hdGNoZXMgYW4gRXRoZXJzRXJyb3IgdHlwZSwgd2hpY2ggbWVhbnMgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbFxuICogIGJlIHNldC5cbiAqXG4gKiAgQFNlZSBbRXJyb3JDb2Rlc10oYXBpOkVycm9yQ29kZSlcbiAqICBAZXhhbXBsZVxuICogICAgdHJ5IHtcbiAqICAgICAgLy8gY29kZS4uLi5cbiAqICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgaWYgKGlzRXJyb3IoZSwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICogICAgICAgICAgLy8gVGhlIFR5cGUgR3VhcmQgaGFzIHZhbGlkYXRlZCB0aGlzIG9iamVjdFxuICogICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcbiAqICAgICAgfVxuICogICAgfVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVlcnJvciUlIGlzIGEgW1tDYWxsRXhjZXB0aW9uRXJyb3JdLlxuICovXG5mdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbmV4cG9ydHMuaXNDYWxsRXhjZXB0aW9uID0gaXNDYWxsRXhjZXB0aW9uO1xuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke192ZXJzaW9uX2pzXzEudmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLm1ha2VFcnJvciA9IG1ha2VFcnJvcjtcbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnQgPSBhc3NlcnRBcmd1bWVudDtcbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1ZW1udFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG4gICAgYXNzZXJ0KGNvdW50IDw9IGV4cGVjdGVkQ291bnQsIFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbn1cbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnRDb3VudCA9IGFzc2VydEFyZ3VtZW50Q291bnQ7XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaW5mbzogeyBmb3JtIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYXNzZXJ0Tm9ybWFsaXplID0gYXNzZXJ0Tm9ybWFsaXplO1xuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFByaXZhdGUgPSBhc3NlcnRQcml2YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudFBheWxvYWQgPSB2b2lkIDA7XG4vKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuY2xhc3MgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IGZpbHRlci5cbiAgICAgKi9cbiAgICBmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSAqKkV2ZW50RW1pdHRlcmFibGUqKi5cbiAgICAgKi9cbiAgICBlbWl0dGVyO1xuICAgICNsaXN0ZW5lcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqRXZlbnRQYXlsb2FkKiogZm9yICUlZW1pdHRlciUlIHdpdGhcbiAgICAgKiAgdGhlICUlbGlzdGVuZXIlJSBhbmQgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgbGlzdGVuZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZW1pdHRlciwgZmlsdGVyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVW5yZWdpc3RlciB0aGUgdHJpZ2dlcmVkIGxpc3RlbmVyIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdHRlci5vZmYodGhpcy5maWx0ZXIsIHRoaXMuI2xpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50UGF5bG9hZCA9IEV2ZW50UGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2hSZXNwb25zZSA9IGV4cG9ydHMuRmV0Y2hSZXF1ZXN0ID0gZXhwb3J0cy5GZXRjaENhbmNlbFNpZ25hbCA9IHZvaWQgMDtcbi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmNvbnN0IGJhc2U2NF9qc18xID0gcmVxdWlyZShcIi4vYmFzZTY0LmpzXCIpO1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuL3V0ZjguanNcIik7XG5jb25zdCBnZXR1cmxfanNfMSA9IHJlcXVpcmUoXCIuL2dldHVybC5qc1wiKTtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gKDAsIGdldHVybF9qc18xLmNyZWF0ZUdldFVybCkoKTtcbmNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW147Ol0qKT8oO2Jhc2U2NCk/LCguKikkXCIsIFwiaVwiKTtcbmNvbnN0IHJlSXBmcyA9IG5ldyBSZWdFeHAoXCJeaXBmczovXFwvKGlwZnMvKT8oLiopJFwiLCBcImlcIik7XG4vLyBJZiBsb2NrZWQsIG5ldyBHYXRld2F5cyBjYW5ub3QgYmUgYWRkZWRcbmxldCBsb2NrZWQgPSBmYWxzZTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUkxzXG5hc3luYyBmdW5jdGlvbiBkYXRhR2F0ZXdheUZ1bmModXJsLCBzaWduYWwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZURhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDIwMCwgXCJPS1wiLCB7XG4gICAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiAobWF0Y2hbMV0gfHwgXCJ0ZXh0L3BsYWluXCIpLFxuICAgICAgICB9LCAobWF0Y2hbMl0gPyAoMCwgYmFzZTY0X2pzXzEuZGVjb2RlQmFzZTY0KShtYXRjaFszXSkgOiB1bnBlcmNlbnQobWF0Y2hbM10pKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIGRhdGE6IFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRmV0Y2hHYXRld2F5RnVuY11dIGZvciBmZXRjaGluZyBjb250ZW50IGZyb20gYSBzdGFuZGFyZFxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlSXBmcyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsaW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xufVxuY29uc3QgR2F0ZXdheXMgPSB7XG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcbiAgICBcImlwZnNcIjogZ2V0SXBmc0dhdGV3YXlGdW5jKFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiKVxufTtcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKCF0aGlzLiNjYW5jZWxsZWQsIFwic2luZ2FsIGFscmVhZHkgY2FuY2VsbGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmZXRjaENhbmNlbFNpZ25hbC5hZGRDYW5jZWxMaXN0ZW5lclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGdldCBjYW5jZWxsZWQoKSB7IHJldHVybiB0aGlzLiNjYW5jZWxsZWQ7IH1cbiAgICBjaGVja1NpZ25hbCgpIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoIXRoaXMuY2FuY2VsbGVkLCBcImNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiLCB7fSk7XG4gICAgfVxufVxuZXhwb3J0cy5GZXRjaENhbmNlbFNpZ25hbCA9IEZldGNoQ2FuY2VsU2lnbmFsO1xuLy8gQ2hlY2sgdGhlIHNpZ25hbCwgdGhyb3dpbmcgaWYgaXQgaXMgY2FuY2VsbGVkXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UgdXNpbmcgYSBVUkkuXG4gKlxuICogIEJ5IGRlZmF1bHQsIHRoZSBzdXBwb3J0ZWQgc2NoZW1lcyBhcmUgYGBIVFRQYGAsIGBgSFRUUFNgYCwgYGBkYXRhOmBgLFxuICogIGFuZCBgYElQRlM6YGAuXG4gKlxuICogIEFkZGl0aW9uYWwgc2NoZW1lcyBjYW4gYmUgYWRkZWQgZ2xvYmFsbHkgdXNpbmcgW1tyZWdpc3RlckdhdGV3YXldXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KFwiaHR0cHM6Ly93d3cucmljbW9vLmNvbVwiKVxuICogICAgcmVzcCA9IGF3YWl0IHJlcS5zZW5kKClcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHsoMCwgYmFzZTY0X2pzXzEuZW5jb2RlQmFzZTY0KSgoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKSh0aGlzLiNjcmVkcykpfWA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImd6aXBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9PSBudWxsICYmIHRoaXMuI2JvZHlUeXBlKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0gU3RyaW5nKHRoaXMuYm9keS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlIHRvICUldmFsdWUlJS4gQWxsIHZhbHVlcyBhcmUgY29lcmNlZFxuICAgICAqICB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzW1N0cmluZyhrZXkpLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGFsbCBoZWFkZXJzLCByZXNldHRpbmcgYWxsIGludHJpbnNpYyBoZWFkZXJzLlxuICAgICAqL1xuICAgIGNsZWFySGVhZGVycygpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIFRvIHNldCB0aGUgY3JlZGVudGlhbHMsIHVzZSB0aGUgYGBzZXRDcmVkZW50aWFsc2BgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjcmVkcyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0cyBhbiBgYEF1dGhvcml6YXRpb25gYCBmb3IgJSV1c2VybmFtZSUlIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGV0ZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyAoMCwgZGF0YV9qc18xLmhleGxpZnkpKHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShnZXRUaW1lKCkgPD0gZXhwaXJlcywgXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbnkgR2F0ZXdheXNcbiAgICAgICAgaWYgKHNjaGVtZSBpbiBHYXRld2F5cykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRmV0Y2hSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBhIHByZWZsaWdodCBmdW5jdGlvbjsgdXBkYXRlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcbiAgICAgICAgICAgIHJlcSA9IGF3YWl0IHRoaXMucHJlZmxpZ2h0RnVuYyhyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3Auc3RhdHVzQ29kZSwgcmVzcC5zdGF0dXNNZXNzYWdlLCByZXNwLmhlYWRlcnMsIHJlc3AuYm9keSwgX3JlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgLy8gUmVkaXJlY3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRyeUZ1bmMgPT0gbnVsbCB8fCAoYXdhaXQgdGhpcy5yZXRyeUZ1bmMocmVxLCByZXNwb25zZSwgYXR0ZW1wdCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBlcnJvci5zdGFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZW5kKCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkodGhpcy5tZXRob2QgPT09IFwiR0VUXCIgJiYgKGN1cnJlbnQgIT09IFwiaHR0cHNcIiB8fCB0YXJnZXQgIT09IFwiaHR0cFwiKSAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzPzovKSwgYHVuc3VwcG9ydGVkIHJlZGlyZWN0YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVkaXJlY3QoJHt0aGlzLm1ldGhvZH0gJHtKU09OLnN0cmluZ2lmeSh0aGlzLnVybCl9ID0+ICR7SlNPTi5zdHJpbmdpZnkobG9jYXRpb24pfSlgXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgcmVxdWVzdCwgd2l0aCBhIG5ldyBVUkxcbiAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChsb2NhdGlvbik7XG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICByZXEuYWxsb3dHemlwID0gdGhpcy5hbGxvd0d6aXA7XG4gICAgICAgIHJlcS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIHJlcS4jYm9keSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gRG8gbm90IGZvcndhcmQgY3JlZGVudGlhbHMgdW5sZXNzIG9uIHRoZSBzYW1lIGRvbWFpbjsgb25seSBhYnNvbHV0ZVxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIC8vIHBhdGhzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOyBtYXkgd2FudCBhIHdheSB0byBzcGVjaWZ5IHRvIGZvcndhcmQ/XG4gICAgICAgIC8vc2V0U3RvcmUocmVxLiNwcm9wcywgXCJjcmVkc1wiLCBnZXRTdG9yZSh0aGlzLiNwcm9zLCBcImNyZWRzXCIpKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IG1ldGhvZFwiIChpLmUuIG51bGwpXG4gICAgICAgIGNsb25lLiNtZXRob2QgPSB0aGlzLiNtZXRob2Q7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgIGNsb25lLiNib2R5ID0gdGhpcy4jYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jYm9keVR5cGUgPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGhlYWRlcnNcIlxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICAvLyBDcmVkZW50aWFscyBpcyByZWFkb25seSwgc28gd2UgY29weSBpbnRlcm5hbGx5XG4gICAgICAgIGNsb25lLiNjcmVkcyA9IHRoaXMuI2NyZWRzO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNwcmVmbGlnaHQgPSB0aGlzLiNwcmVmbGlnaHQ7XG4gICAgICAgIGNsb25lLiNwcm9jZXNzID0gdGhpcy4jcHJvY2VzcztcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XG4gICAgICAgIGNsb25lLiN0aHJvdHRsZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI3Rocm90dGxlKTtcbiAgICAgICAgY2xvbmUuI2dldFVybEZ1bmMgPSB0aGlzLiNnZXRVcmxGdW5jO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBMb2NrcyBhbGwgc3RhdGljIGNvbmZpZ3VyYXRpb24gZm9yIGdhdGV3YXlzIGFuZCBGZXRjaEdldFVybEZ1bmNcbiAgICAgKiAgcmVnaXN0cmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2NrQ29uZmlnKCkge1xuICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBjdXJyZW50IEdhdGV3YXkgZnVuY3Rpb24gZm9yICUlc2NoZW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEdhdGV3YXkoc2NoZW1lKSB7XG4gICAgICAgIHJldHVybiBHYXRld2F5c1tzY2hlbWUudG9Mb3dlckNhc2UoKV0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSB0aGUgJSVmdW5jJSUgd2hlbiBmZXRjaGluZyBVUklzIHVzaW5nICUlc2NoZW1lJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2F0ZXdheShzY2hlbWUsIGZ1bmMpIHtcbiAgICAgICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IFwiaHR0cFwiIHx8IHNjaGVtZSA9PT0gXCJodHRwc1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBpbnRlcmNlcHQgJHtzY2hlbWV9OyB1c2UgcmVnaXN0ZXJHZXRVcmxgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgR2F0ZXdheXNbc2NoZW1lXSA9IGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgJSVnZXRVcmwlJSB3aGVuIGZldGNoaW5nIFVSSXMgb3ZlciBIVFRQIGFuZCBIVFRQUyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHZXRVcmwoZ2V0VXJsKSB7XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0R2V0VXJsRnVuYyA9IGdldFVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBnZXRVcmwgZnVuY3Rpb24gdGhhdCBmZXRjaGVzIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzLlxuICAgICAqXG4gICAgICogIFRoZSBhdmFpbGFibGUgJSVvcHRpb25zJSUgYXJlIGRlcGVuZGVudCBvbiB0aGUgcGxhdGZvcm1cbiAgICAgKiAgaW1wbGVtZW50YXRpb24gb2YgdGhlIGRlZmF1bHQgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBpcyB1c2VmdWxcbiAgICAgKiAgd2hlbiB0cnlpbmcgdG8gY3VzdG9taXplIHNpbXBsZSBiZWhhdmlvdXIgd2hlbiBmZXRjaGluZyBIVFRQXG4gICAgICogIGNvbnRlbnQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUdldFVybEZ1bmMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGdldHVybF9qc18xLmNyZWF0ZUdldFVybCkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gXCJmZXRjaFwiIGRhdGEgVVJJcy5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XG4gICAgICogIGRhdGEgVVJJcywgc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWdpc3RlciBpdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XG4gICAgICogIGJlIHVzZWZ1bCBpbiBhIHdyYXBwZXIgdG8gcGVyZm9tIGN1c3RvbSBkYXRhIFVSSSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFHYXRld2F5RnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZmV0Y2ggSVBGUyAodW52YWxpZGF0ZWQpIGZyb21cbiAgICAgKiAgYSBjdXN0b20gZ2F0ZXdheSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IElQRlMgZ2F0ZXdheSB1c2VkIGludGVybmFsbHkgaXNcbiAgICAgKiAgYGBcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cImBgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmV0Y2hSZXF1ZXN0ID0gRmV0Y2hSZXF1ZXN0O1xuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuY2xhc3MgRmV0Y2hSZXNwb25zZSB7XG4gICAgI3N0YXR1c0NvZGU7XG4gICAgI3N0YXR1c01lc3NhZ2U7XG4gICAgI2hlYWRlcnM7XG4gICAgI2JvZHk7XG4gICAgI3JlcXVlc3Q7XG4gICAgI2Vycm9yO1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYDxGZXRjaFJlc3BvbnNlIHN0YXR1cz0ke3RoaXMuc3RhdHVzQ29kZX0gYm9keT0ke3RoaXMuI2JvZHkgPyAoMCwgZGF0YV9qc18xLmhleGxpZnkpKHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c0NvZGUoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNDb2RlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzTWVzc2FnZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c01lc3NhZ2U7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGhlYWRlcnMuIEFsbCBrZXlzIGFyZSBsb3dlci1jYXNlLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIG9yIGBgbnVsbGBgIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSBhcyBhIFVURi04IGVuY29kZWQgc3RyaW5nLCBvciB0aGUgZW1wdHlcbiAgICAgKiAgc3RyaW5nIChpLmUuIGBgXCJcImBgKSBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBVVEYtOCBkYXRhLlxuICAgICAqL1xuICAgIGdldCBib2R5VGV4dCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IFwiXCIgOiAoMCwgdXRmOF9qc18xLnRvVXRmOFN0cmluZykodGhpcy4jYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keVRleHRcIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBKU09OLWVuY29kZWQgZGF0YVxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keUpzb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKE51bWJlci5pc0ludGVnZXIoc3RhbGwpICYmIHN0YWxsID49IDAsIFwiaW52YWxpZCBzdGFsbCB0aW1lb3V0XCIsIFwic3RhbGxcIiwgc3RhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJ0aHJvdHRsaW5nIHJlcXVlc3RzXCIpO1xuICAgICAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKGVycm9yLCB7IHN0YWxsLCB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciB2YWx1ZSBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXNwb25zZSBoYXMgYSBib2R5LlxuICAgICAqL1xuICAgIGhhc0JvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXF1ZXN0IG1hZGUgZm9yIHRoaXMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7IHJldHVybiB0aGlzLiNyZXF1ZXN0OyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlc3BvbnNlIHdhcyBhIHN1Y2Nlc3Mgc3RhdHVzQ29kZS5cbiAgICAgKi9cbiAgICBvaygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNlcnJvci5tZXNzYWdlID09PSBcIlwiICYmIHRoaXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgdGhpcy5zdGF0dXNDb2RlIDwgMzAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRocm93cyBhIGBgU0VSVkVSX0VSUk9SYGAgaWYgdGhpcyByZXNwb25zZSBpcyBub3Qgb2suXG4gICAgICovXG4gICAgYXNzZXJ0T2soKSB7XG4gICAgICAgIGlmICh0aGlzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBtZXNzYWdlLCBlcnJvciB9ID0gdGhpcy4jZXJyb3I7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYHNlcnZlciByZXNwb25zZSAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxdWVzdFVybCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgPSB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZUJvZHkgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2JvZHkpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUJvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOFN0cmluZykodGhpcy4jYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogKHRoaXMucmVxdWVzdCB8fCBcInVua25vd24gcmVxdWVzdFwiKSwgcmVzcG9uc2U6IHRoaXMsIGVycm9yLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVN0YXR1czogYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRmV0Y2hSZXNwb25zZSA9IEZldGNoUmVzcG9uc2U7XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuZnVuY3Rpb24gdW5wZXJjZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCB1dGY4X2pzXzEudG9VdGY4Qnl0ZXMpKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTYpKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRml4ZWROdW1iZXIgPSB2b2lkIDA7XG4vKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuL21hdGhzLmpzXCIpO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IEJOX04xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fNSA9IEJpZ0ludCg1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IFplcm9zID0gXCIwMDAwXCI7XG53aGlsZSAoWmVyb3MubGVuZ3RoIDwgODApIHtcbiAgICBaZXJvcyArPSBaZXJvcztcbn1cbi8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcbmZ1bmN0aW9uIGdldFRlbnMoZGVjaW1hbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICByZXN1bHQgKz0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KFwiMVwiICsgcmVzdWx0LnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWwsIGZvcm1hdCwgc2FmZU9wKSB7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZm9ybWF0LndpZHRoKTtcbiAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCA9ICgwLCBtYXRoc19qc18xLmZyb21Ud29zKSgoMCwgbWF0aHNfanNfMS5tYXNrKSh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLSgwLCBtYXRoc19qc18xLmZyb21Ud29zKSgoMCwgbWF0aHNfanNfMS5tYXNrKSgtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCB3aWR0aCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgfVxuICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZba2V5XSkgPT09IHR5cGUsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdltrZXldKTtcbiAgICAgICAgICAgIHJldHVybiB2W2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xuICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKCh3aWR0aCAlIDgpID09PSAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGFuIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5jbGFzcyBGaXhlZE51bWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzcGVjaWZpYyBmaXhlZC1wb2ludCBhcml0aG1ldGljIGZpZWxkIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGZvcm1hdDtcbiAgICAjZm9ybWF0O1xuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxuICAgICN2YWw7XG4gICAgLy8gQSBiYXNlLTEwIHZhbHVlIHRvIG11bHRpcGxlIHZhbHVlcyBieSB0byBtYWludGFpbiB0aGUgbWFnbml0dWRlXG4gICAgI3RlbnM7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgYSBwcm9wZXJ0eSBzbyBjb25zb2xlLmxvZyBzaG93cyBhIGh1bWFuLW1lYW5pbmdmdWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsdWU7XG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXG4gICAgLy8gYnV0IHRoZW4gc3dpdGNoIHRvIGFueSB0byBtYXNrIHRoZSBpbnRlcm5hbCB0eXBlXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIkZpeGVkTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLiN2YWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy4jZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBjb25zdCBfdmFsdWUgPSB0b1N0cmluZyh2YWx1ZSwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGZvcm1hdDogZm9ybWF0Lm5hbWUsIF92YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jdGVucyA9IGdldFRlbnMoZm9ybWF0LmRlY2ltYWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRydWUsIG5lZ2F0aXZlIHZhbHVlcyBhcmUgcGVybWl0dGVkLCBvdGhlcndpc2Ugb25seVxuICAgICAqICBwb3NpdGl2ZSB2YWx1ZXMgYW5kIHplcm8gYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgZ2V0IHNpZ25lZCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5zaWduZWQ7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBiaXRzIGF2YWlsYWJsZSB0byBzdG9yZSB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LndpZHRoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaW4gdGhlIGZpeGVkLXBvaW50IGFyaXRobWVudCBmaWVsZC5cbiAgICAgKi9cbiAgICBnZXQgZGVjaW1hbHMoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuZGVjaW1hbHM7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIGFzIGFuIGludGVnZXIsIGJhc2VkIG9uIHRoZSBzbWFsbGVzdCB1bml0IHRoZVxuICAgICAqICBbW2RlY2ltYWxzXV0gYWxsb3cuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsOyB9XG4gICAgI2NoZWNrRm9ybWF0KG90aGVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibXVsU2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcbiAgICB9XG4gICAgI2RpdihvLCBzYWZlT3ApIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoby4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogdGhpcy4jdGVucykgLyBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdihvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyLCBcImRpdlwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiB1bmRlcmZsb3dcbiAgICAgKiAgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2U2lnbmFsKG90aGVyKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBzdWl0YWJsZSBmb3IgdXNlIGluIHNvcnRpbmcsIHdoZXJlIGBgLTFgYCBpbXBsaWVzICUldGhpcyUlXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNtcChvdGhlcikge1xuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcbiAgICAgICAgLy8gQ29lcmNlIGEgYW5kIGIgdG8gdGhlIHNhbWUgbWFnbml0dWRlXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBiICo9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgYSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbnBhcmVcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPCBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgKz0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImNlaWxpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBkZWNpbWFsIGNvbXBvbmVudFxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cbiAgICAgKi9cbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xuICAgICAgICBjb25zdCBidW1wID0gQk5fNSAqIGdldFRlbnMoZGVsdGEgLSAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLyB0ZW5zKSAqIHRlbnM7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxuICAgICAqL1xuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBsZXNzIHRoYW4gYGAwYGAuXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXG4gICAgICogIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcbiAgICAgKiAgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IChfZGVjaW1hbHMgPT0gbnVsbCkgPyAwIDogKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKShfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9ICgwLCBtYXRoc19qc18xLmdldEJpZ0ludCkoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGRlY2ltYWxzIC0gZm9ybWF0LmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgd2hvbGUgPSAobWF0Y2hbMl0gfHwgXCIwXCIpLCBkZWNpbWFsID0gKG1hdGNoWzNdIHx8IFwiXCIpO1xuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gWmVyb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZGVjaW1hbC5zdWJzdHJpbmcoZm9ybWF0LmRlY2ltYWxzKS5tYXRjaCgvXjAqJC8pLCBcInRvbyBtYW55IGRlY2ltYWxzIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tU3RyaW5nXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgcGFkZGluZ1xuICAgICAgICBkZWNpbWFsID0gZGVjaW1hbC5zdWJzdHJpbmcoMCwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQobWF0Y2hbMV0gKyB3aG9sZSArIGRlY2ltYWwpO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvblxuICAgICAqICAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlIGR1ZSB0byBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS50b0JpZ0ludCkoKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoX3ZhbHVlLCBcInZhbHVlXCIpKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS5mcm9tVHdvcykodmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRml4ZWROdW1iZXIgPSBGaXhlZE51bWJlcjtcbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVybCA9IGV4cG9ydHMuY3JlYXRlR2V0VXJsID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IGh0dHBfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJodHRwXCIpKTtcbmNvbnN0IGh0dHBzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2V0VXJsKG9wdGlvbnMpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBzaWduYWwpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLmhlYWRlcnMpO1xuICAgICAgICBjb25zdCByZXFPcHRpb25zID0geyBtZXRob2QsIGhlYWRlcnMgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgICAgICAgICAgICAgcmVxT3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9ICgocHJvdG9jb2wgPT09IFwiaHR0cFwiKSA/IGh0dHBfMS5kZWZhdWx0IDogaHR0cHNfMS5kZWZhdWx0KS5yZXF1ZXN0KHJlcS51cmwsIHJlcU9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQocmVxLnRpbWVvdXQpO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVxLmJvZHk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKEJ1ZmZlci5mcm9tKGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gQFRPRE86IE5vZGUgMTUgYWRkZWQgQWJvcnRTaWduYWw7IG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvclxuICAgICAgICAgICAgLy8gTm9kZTE0LCB3ZSBjYW4gYWRkIHRoYXQgaW4gaGVyZSB0b29cbiAgICAgICAgICAgIHJlcXVlc3Qub25jZShcInJlc3BvbnNlXCIsIChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3Auc3RhdHVzQ29kZSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSByZXNwLnN0YXR1c01lc3NhZ2UgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMocmVzcC5oZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3AuaGVhZGVyc1tuYW1lXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vcmVzcC5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLmNoZWNrU2lnbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdCb2R5ID0gbmV3IFVpbnQ4QXJyYXkoYm9keS5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Qm9keS5zZXQoYm9keSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCb2R5LnNldChjaHVuaywgYm9keS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ld0JvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LWVuY29kaW5nXCJdID09PSBcImd6aXBcIiAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoKDAsIHpsaWJfMS5ndW56aXBTeW5jKShib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL0BUT0RPOiBTaG91bGQgdGhpcyBqdXN0IHJldHVybiBub3JuYWwgcmVzcG9uc2Ugd2l0aCBhIHNlcnZlciBlcnJvcj9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIChlcnJvcikgPT4geyByZWplY3QoZXJyb3IpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRVcmw7XG59XG5leHBvcnRzLmNyZWF0ZUdldFVybCA9IGNyZWF0ZUdldFVybDtcbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBzaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIHNpZ25hbCk7XG59XG5leHBvcnRzLmdldFVybCA9IGdldFVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZXJlIGFyZSBtYW55IHNpbXBsZSB1dGlsaXRpZXMgcmVxdWlyZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICogIEV0aGVyZXVtIGFuZCB0byBzaW1wbGlmeSB0aGUgbGlicmFyeSwgd2l0aG91dCBpbmNyZWFzaW5nXG4gKiAgdGhlIGxpYnJhcnkgZGVwZW5kZW5jaWVzIGZvciBzaW1wbGUgZnVuY3Rpb25zLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzOlV0aWxpdGllcyAgW2Fib3V0LXV0aWxzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVXRmOFN0cmluZyA9IGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBleHBvcnRzLnBhcnNlVW5pdHMgPSBleHBvcnRzLmZvcm1hdFVuaXRzID0gZXhwb3J0cy5wYXJzZUV0aGVyID0gZXhwb3J0cy5mb3JtYXRFdGhlciA9IGV4cG9ydHMuZW5jb2RlUmxwID0gZXhwb3J0cy5kZWNvZGVSbHAgPSBleHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gZXhwb3J0cy50b1F1YW50aXR5ID0gZXhwb3J0cy50b0JlQXJyYXkgPSBleHBvcnRzLnRvQmVIZXggPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy50b0JpZ0ludCA9IGV4cG9ydHMuZ2V0VWludCA9IGV4cG9ydHMuZ2V0TnVtYmVyID0gZXhwb3J0cy5nZXRCaWdJbnQgPSBleHBvcnRzLm1hc2sgPSBleHBvcnRzLnRvVHdvcyA9IGV4cG9ydHMuZnJvbVR3b3MgPSBleHBvcnRzLkZpeGVkTnVtYmVyID0gZXhwb3J0cy5GZXRjaENhbmNlbFNpZ25hbCA9IGV4cG9ydHMuRmV0Y2hSZXNwb25zZSA9IGV4cG9ydHMuRmV0Y2hSZXF1ZXN0ID0gZXhwb3J0cy5FdmVudFBheWxvYWQgPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuYXNzZXJ0Tm9ybWFsaXplID0gZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudENvdW50ID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc0NhbGxFeGNlcHRpb24gPSBleHBvcnRzLnplcm9QYWRCeXRlcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy5zdHJpcFplcm9zTGVmdCA9IGV4cG9ydHMuZGF0YVNsaWNlID0gZXhwb3J0cy5kYXRhTGVuZ3RoID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmlzQnl0ZXNMaWtlID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0Qnl0ZXNDb3B5ID0gZXhwb3J0cy5nZXRCeXRlcyA9IGV4cG9ydHMuZW5jb2RlQmFzZTY0ID0gZXhwb3J0cy5kZWNvZGVCYXNlNjQgPSBleHBvcnRzLmVuY29kZUJhc2U1OCA9IGV4cG9ydHMuZGVjb2RlQmFzZTU4ID0gdm9pZCAwO1xuZXhwb3J0cy51dWlkVjQgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gdm9pZCAwO1xudmFyIGJhc2U1OF9qc18xID0gcmVxdWlyZShcIi4vYmFzZTU4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNThfanNfMS5kZWNvZGVCYXNlNTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCYXNlNThcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U1OF9qc18xLmVuY29kZUJhc2U1ODsgfSB9KTtcbnZhciBiYXNlNjRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUJhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0X2pzXzEuZGVjb2RlQmFzZTY0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRfanNfMS5lbmNvZGVCYXNlNjQ7IH0gfSk7XG52YXIgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuZ2V0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCeXRlc0NvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5nZXRCeXRlc0NvcHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmlzSGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCeXRlc0xpa2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5pc0J5dGVzTGlrZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleGxpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5oZXhsaWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuY29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGF0YUxlbmd0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmRhdGFMZW5ndGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5kYXRhU2xpY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpcFplcm9zTGVmdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLnN0cmlwWmVyb3NMZWZ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZFZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuemVyb1BhZFZhbHVlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuemVyb1BhZEJ5dGVzOyB9IH0pO1xudmFyIGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDYWxsRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5pc0NhbGxFeGNlcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Vycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5pc0Vycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5hc3NlcnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRBcmd1bWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRBcmd1bWVudENvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudENvdW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0UHJpdmF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuYXNzZXJ0UHJpdmF0ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydE5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuYXNzZXJ0Tm9ybWFsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5tYWtlRXJyb3I7IH0gfSk7XG52YXIgZXZlbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9ldmVudHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFBheWxvYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c19qc18xLkV2ZW50UGF5bG9hZDsgfSB9KTtcbnZhciBmZXRjaF9qc18xID0gcmVxdWlyZShcIi4vZmV0Y2guanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFJlcXVlc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoX2pzXzEuRmV0Y2hSZXF1ZXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hSZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2hfanNfMS5GZXRjaFJlc3BvbnNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hDYW5jZWxTaWduYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoX2pzXzEuRmV0Y2hDYW5jZWxTaWduYWw7IH0gfSk7XG52YXIgZml4ZWRudW1iZXJfanNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkbnVtYmVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpeGVkbnVtYmVyX2pzXzEuRml4ZWROdW1iZXI7IH0gfSk7XG52YXIgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuL21hdGhzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVR3b3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEuZnJvbVR3b3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1R3b3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9Ud29zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFza1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS5tYXNrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmlnSW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLmdldEJpZ0ludDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS5nZXROdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRVaW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLmdldFVpbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b0JpZ0ludDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvTnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUhleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b0JlSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvQmVBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvUXVhbnRpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9RdWFudGl0eTsgfSB9KTtcbnZhciBwcm9wZXJ0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZVByb3BlcnRpZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXNfanNfMS5yZXNvbHZlUHJvcGVydGllczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmluZVByb3BlcnRpZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzOyB9IH0pO1xudmFyIHJscF9kZWNvZGVfanNfMSA9IHJlcXVpcmUoXCIuL3JscC1kZWNvZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVSbHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJscF9kZWNvZGVfanNfMS5kZWNvZGVSbHA7IH0gfSk7XG52YXIgcmxwX2VuY29kZV9qc18xID0gcmVxdWlyZShcIi4vcmxwLWVuY29kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVJscFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmxwX2VuY29kZV9qc18xLmVuY29kZVJscDsgfSB9KTtcbnZhciB1bml0c19qc18xID0gcmVxdWlyZShcIi4vdW5pdHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNfanNfMS5mb3JtYXRFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRXRoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzX2pzXzEucGFyc2VFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c19qc18xLmZvcm1hdFVuaXRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VVbml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNfanNfMS5wYXJzZVVuaXRzOyB9IH0pO1xudmFyIHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuL3V0ZjguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF9qc18xLnRvVXRmOEJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Q29kZVBvaW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF9qc18xLnRvVXRmOENvZGVQb2ludHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfanNfMS50b1V0ZjhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4RXJyb3JGdW5jc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF9qc18xLlV0ZjhFcnJvckZ1bmNzOyB9IH0pO1xudmFyIHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuL3V1aWQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dWlkVjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV1aWRfanNfMS51dWlkVjQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9RdWFudGl0eSA9IGV4cG9ydHMudG9CZUFycmF5ID0gZXhwb3J0cy50b0JlSGV4ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMuZ2V0TnVtYmVyID0gZXhwb3J0cy50b0JpZ0ludCA9IGV4cG9ydHMuZ2V0VWludCA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gdm9pZCAwO1xuLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbi8vY29uc3QgQk5fTWF4MjU2ID0gKEJOXzEgPDwgQmlnSW50KDI1NikpIC0gQk5fMTtcbi8vIElFRUUgNzU0IHN1cHBvcnQgNTMtYml0cyBvZiBtYW50aXNzYVxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgZnJvbSBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZiAlJXdpZHRoJSVcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cbiAqXG4gKiAgSWYgdGhlIGhpZ2hlc3QgYml0IGlzIGBgMWBgLCB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuZnJvbVR3b3MgPSBmcm9tVHdvcztcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIHRvVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy50b1R3b3MgPSB0b1R3b3M7XG4vKipcbiAqICBNYXNrICUldmFsdWUlJSB3aXRoIGEgYml0bWFzayBvZiAlJWJpdHMlJSBvbmVzLlxuICovXG5mdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuZXhwb3J0cy5tYXNrID0gbWFzaztcbi8qKlxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSBCaWdJbnQsIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0QmlnSW50ID0gZ2V0QmlnSW50O1xuLyoqXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcbiAqICB2YWx1ZSBhbmQgdGhhdCBpdCBpcyBwb3NpdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0VWludCA9IGdldFVpbnQ7XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG5leHBvcnRzLnRvQmlnSW50ID0gdG9CaWdJbnQ7XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKEJpZ0ludCh2YWx1ZSksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0TnVtYmVyID0gZ2V0TnVtYmVyO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgbnVtYmVyLiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYnl0ZXMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9CZUhleCA9IHRvQmVIZXg7XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGlmICh2YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9CZUFycmF5ID0gdG9CZUFycmF5O1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cbiAqXG4gKiAgQSAvL1F1YW50aXR5Ly8gZG9lcyBub3QgaGF2ZSBhbmQgbGVhZGluZyAwIHZhbHVlcyB1bmxlc3MgdGhlIHZhbHVlIGlzXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcbiAqICBudW1lcmljIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSAoMCwgZGF0YV9qc18xLmhleGxpZnkpKCgwLCBkYXRhX2pzXzEuaXNCeXRlc0xpa2UpKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmV4cG9ydHMudG9RdWFudGl0eSA9IHRvUXVhbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRocy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSB2b2lkIDA7XG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSByZXNvbHZlUHJvcGVydGllcztcbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlUmxwID0gdm9pZCAwO1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgZGF0YV9qc18yID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGNoaWxkT2Zmc2V0IDw9IG9mZnNldCArIDEgKyBsZW5ndGgsIFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aCwgb2Zmc2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xufVxuLy8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cbmZ1bmN0aW9uIF9kZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIGRhdGFfanNfMS5oZXhsaWZ5KShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBkYXRhX2pzXzEuaGV4bGlmeSkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVJscChfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgZGF0YV9qc18yLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIDApO1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuZXhwb3J0cy5kZWNvZGVSbHAgPSBkZWNvZGVSbHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVJscCA9IHZvaWQgMDtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCgoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5mdW5jdGlvbiBlbmNvZGVSbHAob2JqZWN0KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGNvbnN0IHYgb2YgX2VuY29kZShvYmplY3QpKSB7XG4gICAgICAgIHJlc3VsdCArPSBuaWJibGVzW3YgPj4gNF07XG4gICAgICAgIHJlc3VsdCArPSBuaWJibGVzW3YgJiAweGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5lbmNvZGVSbHAgPSBlbmNvZGVSbHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUV0aGVyID0gZXhwb3J0cy5mb3JtYXRFdGhlciA9IGV4cG9ydHMucGFyc2VVbml0cyA9IGV4cG9ydHMuZm9ybWF0VW5pdHMgPSB2b2lkIDA7XG4vKipcbiAqICBNb3N0IGludGVyYWN0aW9ucyB3aXRoIEV0aGVyZXVtIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzLCB3aGljaCB1c2VcbiAqICB0aGUgc21hbGxlc3QgbWFnbml0dWRlIHVuaXQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbWFnaW5lIGRlYWxpbmcgd2l0aCBkb2xsYXJzIGFuZCBjZW50cy4gU2luY2UgZG9sbGFyc1xuICogIGFyZSBkaXZpc2libGUsIG5vbi1pbnRlZ2VyIHZhbHVlcyBhcmUgcG9zc2libGUsIHN1Y2ggYXMgYGAkMTAuNzdgYC5cbiAqICBCeSB1c2luZyB0aGUgc21hbGxlc3QgaW5kaXZpc2libGUgdW5pdCAoaS5lLiBjZW50cyksIHRoZSB2YWx1ZSBjYW5cbiAqICBiZSBrZXB0IGFzIHRoZSBpbnRlZ2VyIGBgMTA3N2BgLlxuICpcbiAqICBXaGVuIHJlY2VpdmluZyBkZWNpbWFsIGlucHV0IGZyb20gdGhlIHVzZXIgKGFzIGEgZGVjaW1hbCBzdHJpbmcpLFxuICogIHRoZSB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYW5kIHdoZW4gc2hvd2luZyBhIHVzZXJcbiAqICBhIHZhbHVlLCB0aGUgaW50ZWdlciB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogIFRoaXMgY3JlYXRlcyBhIGNsZWFyIGRpc3RpbmN0aW9uLCBiZXR3ZWVuIHZhbHVlcyB0byBiZSB1c2VkIGJ5IGNvZGVcbiAqICAoaW50ZWdlcnMpIGFuZCB2YWx1ZXMgdXNlZCBmb3IgZGlzcGxheSBsb2dpYyB0byB1c2VycyAoZGVjaW1hbHMpLlxuICpcbiAqICBUaGUgbmF0aXZlIHVuaXQgaW4gRXRoZXJldW0sIC8vZXRoZXIvLyBpcyBkaXZpc2libGUgdG8gMTggZGVjaW1hbCBwbGFjZXMsXG4gKiAgd2hlcmUgZWFjaCBpbmRpdmlkdWFsIHVuaXQgaXMgY2FsbGVkIGEgLy93ZWkvLy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpVbml0IENvbnZlcnNpb24gIFthYm91dC11bml0c11cbiAqL1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBmaXhlZG51bWJlcl9qc18xID0gcmVxdWlyZShcIi4vZml4ZWRudW1iZXIuanNcIik7XG5jb25zdCBtYXRoc19qc18xID0gcmVxdWlyZShcIi4vbWF0aHMuanNcIik7XG5jb25zdCBuYW1lcyA9IFtcbiAgICBcIndlaVwiLFxuICAgIFwia3dlaVwiLFxuICAgIFwibXdlaVwiLFxuICAgIFwiZ3dlaVwiLFxuICAgIFwic3phYm9cIixcbiAgICBcImZpbm5leVwiLFxuICAgIFwiZXRoZXJcIixcbl07XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLywgYXNzdW1pbmcgJSV1bml0JSUgZGVjaW1hbFxuICogIHBsYWNlcy4gVGhlICUldW5pdCUlIG1heSBiZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9yIHRoZSBuYW1lIG9mXG4gKiAgYSB1bml0IChlLmcuIGBgXCJnd2VpXCJgYCBmb3IgOSBkZWNpbWFsIHBsYWNlcykuXG4gKlxuICovXG5mdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAoMCwgbWF0aHNfanNfMS5nZXROdW1iZXIpKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkbnVtYmVyX2pzXzEuRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuZXhwb3J0cy5mb3JtYXRVbml0cyA9IGZvcm1hdFVuaXRzO1xuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5mdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAoMCwgbWF0aHNfanNfMS5nZXROdW1iZXIpKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkbnVtYmVyX2pzXzEuRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbmV4cG9ydHMucGFyc2VVbml0cyA9IHBhcnNlVW5pdHM7XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLyB1c2luZyAxOCBkZWNpbWFsIHBsYWNlcy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuZXhwb3J0cy5mb3JtYXRFdGhlciA9IGZvcm1hdEV0aGVyO1xuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRXRoZXIoZXRoZXIpIHtcbiAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xufVxuZXhwb3J0cy5wYXJzZUV0aGVyID0gcGFyc2VFdGhlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IHZvaWQgMDtcbi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9ICgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5mdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pIHtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydE5vcm1hbGl6ZSkoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGkgPCBzdHIubGVuZ3RoICYmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApLCBcImludmFsaWQgc3Vycm9nYXRlIHBhaXJcIiwgXCJzdHJcIiwgc3RyKTtcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKGMgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0cy50b1V0ZjhCeXRlcyA9IHRvVXRmOEJ5dGVzO1xuO1xuLy9leHBvcnQgXG5mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRlZCBieSB0aGUgVVRGLTggZGF0YSAlJWJ5dGVzJSUuXG4gKlxuICogIFdoZW4gJSVvbkVycm9yJSUgZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCBpcyBjYWxsZWQgb24gVVRGLThcbiAqICBlcnJvcnMgYWxsb3dpbmcgcmVjb3ZlcnkgdXNpbmcgdGhlIFtbVXRmOEVycm9yRnVuY11dIEFQSS5cbiAqICAoZGVmYXVsdDogW2Vycm9yXShVdGY4RXJyb3JGdW5jcykpXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG5leHBvcnRzLnRvVXRmOFN0cmluZyA9IHRvVXRmOFN0cmluZztcbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0pIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG5leHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSB0b1V0ZjhDb2RlUG9pbnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZFY0ID0gdm9pZCAwO1xuLyoqXG4gKiAgRXhwbGFpbiBVVUlEIGFuZCBsaW5rIHRvIFJGQyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpVVUlEICBbYWJvdXQtdXVpZF1cbiAqL1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdGhlIHZlcnNpb24gNCBbW2xpbmstdXVpZF1dIGZvciB0aGUgJSVyYW5kb21CeXRlcyUlLlxuICpcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuICovXG5mdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXMpIHtcbiAgICBjb25zdCBieXRlcyA9ICgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGRhdGFfanNfMS5oZXhsaWZ5KShieXRlcyk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbmV4cG9ydHMudXVpZFY0ID0gdXVpZFY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVdhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzUgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxuICogIFtbU2lnbmVyXV0gdGhhdCBvcGVyYXRlcyB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xuICogIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBhbmQgc2ltcGxpZmllcyBsb2FkaW5nIGEgdmFyaWV0eVxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxuICpcbiAqICBUaGlzIGNsYXNzIG1heSBiZSBvZiB1c2UgZm9yIHRob3NlIGF0dGVtcHRpbmcgdG8gaW1wbGVtZW50XG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cbiAqL1xuY2xhc3MgQmFzZVdhbGxldCBleHRlbmRzIGluZGV4X2pzXzMuQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgd2FsbGV0IGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAjc2lnbmluZ0tleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBCYXNlV2FsbGV0IGZvciAlJXByaXZhdGVLZXklJSwgb3B0aW9uYWxseVxuICAgICAqICBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvdmlkZXIlJSBpcyBub3Qgc3BlY2lmaWVkLCBvbmx5IG9mZmxpbmUgbWV0aG9kcyBjYW5cbiAgICAgKiAgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5LCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KShwcml2YXRlS2V5ICYmIHR5cGVvZiAocHJpdmF0ZUtleS5zaWduKSA9PT0gXCJmdW5jdGlvblwiLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB0aGlzLiNzaWduaW5nS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbmRleF9qc180LmNvbXB1dGVBZGRyZXNzKSh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICAvLyBTdG9yZSBwcml2YXRlIHZhbHVlcyBiZWhpbmQgZ2V0dGVycyB0byByZWR1Y2UgdmlzaWJpbGl0eVxuICAgIC8vIGluIGNvbnNvbGUubG9nXG4gICAgLyoqXG4gICAgICogIFRoZSBbW1NpZ25pbmdLZXldXSB1c2VkIGZvciBzaWduaW5nIHBheWxvYWRzLlxuICAgICAqL1xuICAgIGdldCBzaWduaW5nS2V5KCkgeyByZXR1cm4gdGhpcy4jc2lnbmluZ0tleTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkgZm9yIHRoaXMgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnByaXZhdGVLZXk7IH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VXYWxsZXQodGhpcy4jc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBhbnkgQWRkcmVzc2FibGUgb3IgRU5TIG5hbWUgd2l0aCBhbiBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20gfSA9IGF3YWl0ICgwLCBpbmRleF9qc181LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICB0bzogKHR4LnRvID8gKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKHR4LnRvLCB0aGlzLnByb3ZpZGVyKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBmcm9tOiAodHguZnJvbSA/ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKSh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKSA6IHVuZGVmaW5lZClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0byAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50byA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgodHguZnJvbSkpID09PSB0aGlzLmFkZHJlc3MsIFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCB0eC5mcm9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBidHggPSBpbmRleF9qc180LlRyYW5zYWN0aW9uLmZyb20odHgpO1xuICAgICAgICBidHguc2lnbmF0dXJlID0gdGhpcy5zaWduaW5nS2V5LnNpZ24oYnR4LnVuc2lnbmVkSGFzaCk7XG4gICAgICAgIHJldHVybiBidHguc2VyaWFsaXplZDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduTWVzc2FnZVN5bmMobWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBBZGQgYSBzZWNpYWxpemVkIHNpZ25UeCBhbmQgc2lnblR5cGVkIHN5bmMgdGhhdCBlbmZvcmNlc1xuICAgIC8vIGFsbCBwYXJhbWV0ZXJzIGFyZSBrbm93bj9cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2lnbmF0dXJlIGZvciAlJW1lc3NhZ2UlJSBzaWduZWQgd2l0aCB0aGlzIHdhbGxldC5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZVN5bmMobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnNpZ24oKDAsIGluZGV4X2pzXzIuaGFzaE1lc3NhZ2UpKG1lc3NhZ2UpKS5zZXJpYWxpemVkO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgaW5kZXhfanNfMi5UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHNob3VsZCB1c2UgcmVzb2x2ZU5hbWU7IGFkZHJlc3NlcyBkb24ndFxuICAgICAgICAgICAgLy8gICAgICAgIG5lZWQgYSBwcm92aWRlclxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KSh0aGlzLnByb3ZpZGVyICE9IG51bGwsIFwiY2Fubm90IHJlc29sdmUgRU5TIG5hbWVzIHdpdGhvdXQgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBuYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGFkZHJlc3MgIT0gbnVsbCwgXCJ1bmNvbmZpZ3VyZWQgRU5TIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnNpZ24oaW5kZXhfanNfMi5UeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpLnNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlV2FsbGV0ID0gQmFzZVdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2Utd2FsbGV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5IRE5vZGVWb2lkV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVXYWxsZXQgPSBleHBvcnRzLmRlZmF1bHRQYXRoID0gdm9pZCAwO1xuLyoqXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkhEIFdhbGxldHMgIFtoZC13YWxsZXRzXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBsYW5nX2VuX2pzXzEgPSByZXF1aXJlKFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIik7XG5jb25zdCBiYXNlX3dhbGxldF9qc18xID0gcmVxdWlyZShcIi4vYmFzZS13YWxsZXQuanNcIik7XG5jb25zdCBtbmVtb25pY19qc18xID0gcmVxdWlyZShcIi4vbW5lbW9uaWMuanNcIik7XG5jb25zdCBqc29uX2tleXN0b3JlX2pzXzEgPSByZXF1aXJlKFwiLi9qc29uLWtleXN0b3JlLmpzXCIpO1xuLyoqXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxuICovXG5leHBvcnRzLmRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG4vLyBcIkJpdGNvaW4gc2VlZFwiXG5jb25zdCBNYXN0ZXJTZWNyZXQgPSBuZXcgVWludDhBcnJheShbNjYsIDEwNSwgMTE2LCA5OSwgMTExLCAxMDUsIDExMCwgMzIsIDExNSwgMTAxLCAxMDEsIDEwMF0pO1xuY29uc3QgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xuY29uc3QgTiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtcbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBOaWJibGVzW3ZhbHVlICUgMTZdICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSA9IE1hdGgudHJ1bmModmFsdWUgLyAxNik7XG4gICAgfVxuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoICogMikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVuY29kZUJhc2U1OENoZWNrKF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKF92YWx1ZSk7XG4gICAgY29uc3QgY2hlY2sgPSAoMCwgaW5kZXhfanNfNC5kYXRhU2xpY2UpKCgwLCBpbmRleF9qc18xLnNoYTI1NikoKDAsIGluZGV4X2pzXzEuc2hhMjU2KSh2YWx1ZSkpLCAwLCA0KTtcbiAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc180LmNvbmNhdCkoW3ZhbHVlLCBjaGVja10pO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5lbmNvZGVCYXNlNTgpKGJ5dGVzKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gc2VyX0koaW5kZXgsIGNoYWluQ29kZSwgcHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDM3KTtcbiAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKHByaXZhdGVLZXkgIT0gbnVsbCwgXCJjYW5ub3QgZGVyaXZlIGNoaWxkIG9mIG5ldXRlcmVkIG5vZGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRlcml2ZUNoaWxkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG4gICAgICAgIGRhdGEuc2V0KCgwLCBpbmRleF9qc180LmdldEJ5dGVzKShwcml2YXRlS2V5KSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuICAgICAgICBkYXRhLnNldCgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykocHVibGljS2V5KSk7XG4gICAgfVxuICAgIC8vIERhdGEgKz0gc2VyXzMyKGkpXG4gICAgZm9yIChsZXQgaSA9IDI0OyBpID49IDA7IGkgLT0gOCkge1xuICAgICAgICBkYXRhWzMzICsgKGkgPj4gMyldID0gKChpbmRleCA+PiAoMjQgLSBpKSkgJiAweGZmKTtcbiAgICB9XG4gICAgY29uc3QgSSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMS5jb21wdXRlSG1hYykoXCJzaGE1MTJcIiwgY2hhaW5Db2RlLCBkYXRhKSk7XG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZVBhdGgobm9kZSwgcGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoY29tcG9uZW50cy5sZW5ndGggPiAwLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShub2RlLmRlcHRoID09PSAwLCBgY2Fubm90IGRlcml2ZSByb290IHBhdGggKGkuZS4gcGF0aCBzdGFydGluZyB3aXRoIFwibS9cIikgZm9yIGEgbm9kZSBhdCBub24temVybyBkZXB0aCAke25vZGUuZGVwdGh9YCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgICAgICBjb21wb25lbnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBub2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBwYXRoIGluZGV4XCIsIGBwYXRoWyR7aX1dYCwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kZXJpdmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEFuICoqSEROb2RlV2FsbGV0KiogaXMgYSBbW1NpZ25lcl1dIGJhY2tlZCBieSB0aGUgcHJpdmF0ZSBrZXkgZGVyaXZlZFxuICogIGZyb20gYW4gSEQgTm9kZSB1c2luZyB0aGUgW1tsaW5rLWJpcC0zMl1dIHN0YW50YXJkLlxuICpcbiAqICBBbiBIRCBOb2RlIGZvcm1zIGEgaGllcmFyY2hhbCBzdHJ1Y3R1cmUgd2l0aCBlYWNoIEhEIE5vZGUgaGF2aW5nIGFcbiAqICBwcml2YXRlIGtleSBhbmQgdGhlIGFiaWxpdHkgdG8gZGVyaXZlIGNoaWxkIEhEIE5vZGVzLCBkZWZpbmVkIGJ5XG4gKiAgYSBwYXRoIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIGVhY2ggY2hpbGQuXG4gKi9cbmNsYXNzIEhETm9kZVdhbGxldCBleHRlbmRzIGJhc2Vfd2FsbGV0X2pzXzEuQmFzZVdhbGxldCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbW5lbW9uaWMgdXNlZCB0byBjcmVhdGUgdGhpcyBIRCBOb2RlLCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiAgU291cmNlcyBzdWNoIGFzIGV4dGVuZGVkIGtleXMgZG8gbm90IGVuY29kZSB0aGUgbW5lbW9uaWMsIGluXG4gICAgICogIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIG1uZW1vbmljO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGUgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVuY29kZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBzaWduaW5nS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIG1uZW1vbmljLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlV2FsbGV0XCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHB1YmxpY0tleTogc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5IH0pO1xuICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9ICgwLCBpbmRleF9qc180LmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEucmlwZW1kMTYwKSgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKHRoaXMucHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCwgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBtbmVtb25pYyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHRoaXMuc2lnbmluZ0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5tbmVtb25pYywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjYWNjb3VudCgpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubW5lbW9uaWM7XG4gICAgICAgIGlmICh0aGlzLnBhdGggJiYgbSAmJiBtLndvcmRsaXN0LmxvY2FsZSA9PT0gXCJlblwiICYmIG0ucGFzc3dvcmQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogXCJlblwiLFxuICAgICAgICAgICAgICAgIGVudHJvcHk6IG0uZW50cm9weVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xuICAgICAqICB1cGRhdGVzIGFzIHRoZSBlbmNyeXB0aW9uIHByb2Nlc3MgcHJvZ3Jlc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvbikodGhpcy4jYWNjb3VudCgpLCBwYXNzd29yZCwgeyBwcm9ncmVzc0NhbGxiYWNrIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXBlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZW5jcnlwdCkgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsXG4gICAgICogIGl0IGlzIGNvbXBsZXRlLCB3aGljaCBtYXkgYmUgYSBub24tdHJpdmlhbCBkdXJhdGlvbi5cbiAgICAgKi9cbiAgICBlbmNyeXB0U3luYyhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uU3luYykodGhpcy4jYWNjb3VudCgpLCBwYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHByaXZgYCBhbmQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgcmVjb25zdHJ1Y3QgdGhpcyBIRCBOb2RlIHRvIGRlcml2ZSBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcbiAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW50aW1lbnQgaXMgdGhhdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcbiAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KSh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjaygoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcbiAgICAgICAgICAgIFwiMHgwNDg4QURFNFwiLCB6cGFkKHRoaXMuZGVwdGgsIDEpLCB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcIjB4MDBcIiwgdGhpcy5wcml2YXRlS2V5XSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV1dGVyZWQgSEQgTm9kZSwgd2hpY2ggcmVtb3ZlcyB0aGUgcHJpdmF0ZSBkZXRhaWxzXG4gICAgICogIG9mIGFuIEhEIE5vZGUuXG4gICAgICpcbiAgICAgKiAgQSBuZXV0ZXJlZCBub2RlIGhhcyBubyBwcml2YXRlIGtleSwgYnV0IGNhbiBiZSB1c2VkIHRvIGRlcml2ZVxuICAgICAqICBjaGlsZCBhZGRyZXNzZXMgYW5kIG90aGVyIHB1YmxpYyBkYXRhIGFib3V0IHRoZSBIRCBOb2RlLlxuICAgICAqL1xuICAgIG5ldXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBraSA9IG5ldyBpbmRleF9qc18xLlNpZ25pbmdLZXkoKDAsIGluZGV4X2pzXzQudG9CZUhleCkoKCgwLCBpbmRleF9qc180LnRvQmlnSW50KShJTCkgKyBCaWdJbnQodGhpcy5wcml2YXRlS2V5KSkgJSBOLCAzMikpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIGtpLCB0aGlzLmZpbmdlcnByaW50LCAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5tbmVtb25pYywgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEhETm9kZSBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgI2Zyb21TZWVkKF9zZWVkLCBtbmVtb25pYykge1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNCeXRlc0xpa2UpKF9zZWVkKSwgXCJpbnZhbGlkIHNlZWRcIiwgXCJzZWVkXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShfc2VlZCwgXCJzZWVkXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IEkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEuY29tcHV0ZUhtYWMpKFwic2hhNTEyXCIsIE1hc3RlclNlY3JldCwgc2VlZCkpO1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IGluZGV4X2pzXzEuU2lnbmluZ0tleSgoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJLnNsaWNlKDAsIDMyKSkpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHNpZ25pbmdLZXksIFwiMHgwMDAwMDAwMFwiLCAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXG4gICAgICogIG9yIGZ1bGwgSEQgTm9kZSAoW1tIRE5vZGVXYWxsZXQpIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzQudG9CZUFycmF5KSgoMCwgaW5kZXhfanNfNC5kZWNvZGVCYXNlNTgpKGV4dGVuZGVkS2V5KSk7IC8vIEBUT0RPOiByZWRhY3RcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShieXRlcy5zbGljZSg1LCA5KSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoOSwgMTMpKS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoMCwgNCkpKSB7XG4gICAgICAgICAgICAvLyBQdWJsaWMgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YjIxZVwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTg3Y2ZcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgKDAsIGluZGV4X2pzXzMuY29tcHV0ZUFkZHJlc3MpKHB1YmxpY0tleSksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgbnVsbCwgaW5kZXgsIGRlcHRoLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgaW5kZXhfanNfMS5TaWduaW5nS2V5KGtleS5zbGljZSgxKSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gbW5lbW9uaWNfanNfMS5NbmVtb25pYy5mcm9tRW50cm9weSgoMCwgaW5kZXhfanNfMS5yYW5kb21CeXRlcykoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgbW5lbW9uaWMgJSVwaHJhc2UlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCB3b3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLmRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IG1uZW1vbmljX2pzXzEuTW5lbW9uaWMuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKG1uZW1vbmljLmNvbXB1dGVTZWVkKCksIG1uZW1vbmljKS5kZXJpdmVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhbiBIRCBOb2RlIGZyb20gYSAlJXNlZWQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChzZWVkLCBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkhETm9kZVdhbGxldCA9IEhETm9kZVdhbGxldDtcbi8qKlxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAqXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XG4gKiAgW251ZXRlcmluZ10oSEROb2RlV2FsbGV0LW5ldXRlcikgYSBbW0hETm9kZVdhbGxldF1dLlxuICovXG5jbGFzcyBIRE5vZGVWb2lkV2FsbGV0IGV4dGVuZHMgaW5kZXhfanNfMi5Wb2lkU2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaW5nZXJwcmludC5cbiAgICAgKlxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXG4gICAgICogIGJ1dCBkZXZlbG9wZXJzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBkZWFsIHdpdGggY29sbGlzaW9ucyBhcyBpdFxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJlbnQgbm9kZSBmaW5nZXJwcmludC5cbiAgICAgKi9cbiAgICBwYXJlbnRGaW5nZXJwcmludDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluY29kZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYSBwdWJsaWMga2V5IHVzZWRcbiAgICAgKiAgdG8gZGVyaXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGNoYWluQ29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRlcml2YXRpb24gcGF0aCBvZiB0aGlzIHdhbGxldC5cbiAgICAgKlxuICAgICAqICBTaW5jZSBleHRlbmRlZCBrZXlzIGRvIG5vdCBwcm92aWRlciBmdWxsIHBhdGggZGV0YWlscywgdGhpc1xuICAgICAqICBtYXkgYmUgYGBudWxsYGAsIGlmIGluc3RhbnRpYXRlZCBmcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3RcbiAgICAgKiAgZW5vY2RlIGl0LlxuICAgICAqL1xuICAgIHBhdGg7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGlsZCBpbmRleCBvZiB0aGlzIHdhbGxldC4gVmFsdWVzIG92ZXIgYGAyICpcXCogMzFgYCBpbmRpY2F0ZVxuICAgICAqICB0aGUgbm9kZSBpcyBoYXJkZW5lZC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRlcHRoIG9mIHRoaXMgd2FsbGV0LCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgICAgKiAgaW4gaXRzIHBhdGguXG4gICAgICovXG4gICAgZGVwdGg7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGFkZHJlc3MsIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihhZGRyZXNzLCBwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlVm9pZFdhbGxldFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gKDAsIGluZGV4X2pzXzQuZGF0YVNsaWNlKSgoMCwgaW5kZXhfanNfMS5yaXBlbWQxNjApKCgwLCBpbmRleF9qc18xLnNoYTI1NikocHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwdWJsaWNLZXksIGZpbmdlcnByaW50LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIGtleSB3aWxsIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYHhwdWJgYCBhbmQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgcmVjb25zdHJ1Y3QgdGhpcyBuZXV0ZXJlZCBrZXkgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbiBhZGRyZXNzZXMuXG4gICAgICovXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcbiAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW50aW1lbnQgaXMgdGhhdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcbiAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KSh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjaygoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxuICAgICAgICAgICAgenBhZCh0aGlzLmRlcHRoLCAxKSxcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgS2kgPSBpbmRleF9qc18xLlNpZ25pbmdLZXkuYWRkUG9pbnRzKElMLCB0aGlzLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMy5jb21wdXRlQWRkcmVzcykoS2kpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCBhZGRyZXNzLCBLaSwgdGhpcy5maW5nZXJwcmludCwgKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG59XG5leHBvcnRzLkhETm9kZVZvaWRXYWxsZXQgPSBIRE5vZGVWb2lkV2FsbGV0O1xuLypcbmV4cG9ydCBjbGFzcyBIRE5vZGVXYWxsZXRNYW5hZ2VyIHtcbiAgICAjcm9vdDogSEROb2RlV2FsbGV0O1xuXG4gICAgY29uc3RydWN0b3IocGhyYXNlOiBzdHJpbmcsIHBhc3N3b3JkPzogbnVsbCB8IHN0cmluZywgcGF0aD86IG51bGwgfCBzdHJpbmcsIGxvY2FsZT86IG51bGwgfCBXb3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkgeyBwYXNzd29yZCA9IFwiXCI7IH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkgeyBwYXRoID0gXCJtLzQ0Jy82MCcvMCcvMFwiOyB9XG4gICAgICAgIGlmIChsb2NhbGUgPT0gbnVsbCkgeyBsb2NhbGUgPSBMYW5nRW4ud29yZGxpc3QoKTsgfVxuICAgICAgICB0aGlzLiNyb290ID0gSEROb2RlV2FsbGV0LmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgbG9jYWxlKTtcbiAgICB9XG5cbiAgICBnZXRTaWduZXIoaW5kZXg/OiBudW1iZXIpOiBIRE5vZGVXYWxsZXQge1xuICAgICAgICByZXR1cm4gdGhpcy4jcm9vdC5kZXJpdmVDaGlsZCgoaW5kZXggPT0gbnVsbCkgPyAwOiBpbmRleCk7XG4gICAgfVxufVxuKi9cbi8qKlxuICogIFJldHVybnMgdGhlIFtbbGluay1iaXAtMzJdXSBwYXRoIGZvciB0aGUgYWNjb3VudCBhdCAlJWluZGV4JSUuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTGVkZ2VyLlxuICpcbiAqICBUaGVyZSBpcyBhbHNvIGFuIFthbHRlcm5hdGUgcGF0dGVybl0oZ2V0SW5kZXhlZEFjY291bnRQYXRoKSB1c2VkIGJ5XG4gKiAgc29tZSBzb2Z0d2FyZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSAoMCwgaW5kZXhfanNfNC5nZXROdW1iZXIpKF9pbmRleCwgXCJpbmRleFwiKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYDtcbn1cbmV4cG9ydHMuZ2V0QWNjb3VudFBhdGggPSBnZXRBY2NvdW50UGF0aDtcbi8qKlxuICogIFJldHVybnMgdGhlIHBhdGggdXNpbmcgYW4gYWx0ZXJuYXRpdmUgcGF0dGVybiBmb3IgZGVyaXZpbmcgYWNjb3VudHMsXG4gKiAgYXQgJSVpbmRleCUlLlxuICpcbiAqICBUaGlzIGRlcml2YXRpb24gcGF0aCB1c2VzIHRoZSAvL2luZGV4Ly8gY29tcG9uZW50IHJhdGhlciB0aGFuIHRoZVxuICogIC8vYWNjb3VudC8vIGNvbXBvbmVudCB0byBkZXJpdmUgc2VxdWVudGlhbCBhY2NvdW50cy5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBNZXRhTWFzay5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5kZXhlZEFjY291bnRQYXRoKF9pbmRleCkge1xuICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XG59XG5leHBvcnRzLmdldEluZGV4ZWRBY2NvdW50UGF0aCA9IGdldEluZGV4ZWRBY2NvdW50UGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkd2FsbGV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgV2hlbiBpbnRlcmFjdGluZyB3aXRoIEV0aGVyZXVtLCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIGEgcHJpdmF0ZVxuICogIGtleSBhdXRoZW50aWNhdGUgYWN0aW9ucyBieSBzaWduaW5nIGEgcGF5bG9hZC5cbiAqXG4gKiAgV2FsbGV0cyBhcmUgdGhlIHNpbXBsZXN0IHdheSB0byBleHBvc2UgdGhlIGNvbmNlcHQgb2YgYW5cbiAqICAvL0V4dGVybmFsbHkgT3duZXIgQWNjb3VudC8vIChFT0EpIGFzIGl0IHdyYXBzIGEgcHJpdmF0ZSBrZXlcbiAqICBhbmQgc3VwcG9ydHMgaGlnaC1sZXZlbCBtZXRob2RzIHRvIHNpZ24gY29tbW9uIHR5cGVzIG9mIGludGVyYWN0aW9uXG4gKiAgYW5kIHNlbmQgdHJhbnNhY3Rpb25zLlxuICpcbiAqICBUaGUgY2xhc3MgbW9zdCBkZXZlbG9wZXJzIHdpbGwgd2FudCB0byB1c2UgaXMgW1tXYWxsZXRdXSwgd2hpY2hcbiAqICBjYW4gbG9hZCBhIHByaXZhdGUga2V5IGRpcmVjdGx5IG9yIGZyb20gYW55IGNvbW1vbiB3YWxsZXQgZm9ybWF0LlxuICpcbiAqICBUaGUgW1tIRE5vZGVXYWxsZXRdXSBjYW4gYmUgdXNlZCB3aGVuIGl0IGlzIG5lY2Vzc2FyeSB0byBhY2Nlc3NcbiAqICBsb3ctbGV2ZWwgZGV0YWlscyBvZiBob3cgYW4gSEQgd2FsbGV0cyBhcmUgZGVyaXZlZCwgZXhwb3J0ZWRcbiAqICBvciBpbXBvcnRlZC5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvd2FsbGV0OldhbGxldHMgIFthYm91dC13YWxsZXRzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldCA9IGV4cG9ydHMuTW5lbW9uaWMgPSBleHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuaXNLZXlzdG9yZUpzb24gPSBleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5pc0Nyb3dkc2FsZUpzb24gPSBleHBvcnRzLkhETm9kZVZvaWRXYWxsZXQgPSBleHBvcnRzLkhETm9kZVdhbGxldCA9IGV4cG9ydHMuZ2V0SW5kZXhlZEFjY291bnRQYXRoID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBhdGggPSBleHBvcnRzLkJhc2VXYWxsZXQgPSB2b2lkIDA7XG52YXIgYmFzZV93YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2Utd2FsbGV0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVdhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV93YWxsZXRfanNfMS5CYXNlV2FsbGV0OyB9IH0pO1xudmFyIGhkd2FsbGV0X2pzXzEgPSByZXF1aXJlKFwiLi9oZHdhbGxldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZHdhbGxldF9qc18xLmRlZmF1bHRQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuZ2V0QWNjb3VudFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbmRleGVkQWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuZ2V0SW5kZXhlZEFjY291bnRQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEROb2RlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhETm9kZVZvaWRXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuSEROb2RlVm9pZFdhbGxldDsgfSB9KTtcbnZhciBqc29uX2Nyb3dkc2FsZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1jcm93ZHNhbGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Nyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fY3Jvd2RzYWxlX2pzXzEuaXNDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdENyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fY3Jvd2RzYWxlX2pzXzEuZGVjcnlwdENyb3dkc2FsZUpzb247IH0gfSk7XG52YXIganNvbl9rZXlzdG9yZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1rZXlzdG9yZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzS2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuaXNLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVKc29uU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNyeXB0S2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG52YXIgbW5lbW9uaWNfanNfMSA9IHJlcXVpcmUoXCIuL21uZW1vbmljLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW5lbW9uaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1uZW1vbmljX2pzXzEuTW5lbW9uaWM7IH0gfSk7XG52YXIgd2FsbGV0X2pzXzEgPSByZXF1aXJlKFwiLi93YWxsZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhbGxldF9qc18xLldhbGxldDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNyeXB0Q3Jvd2RzYWxlSnNvbiA9IGV4cG9ydHMuaXNDcm93ZHNhbGVKc29uID0gdm9pZCAwO1xuY29uc3QgYWVzX2pzXzEgPSByZXF1aXJlKFwiYWVzLWpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBDcm93ZHNhbGUgd2FsbGV0LlxuICovXG5mdW5jdGlvbiBpc0Nyb3dkc2FsZUpzb24oanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBpZiAoZGF0YS5lbmNzZWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNDcm93ZHNhbGVKc29uID0gaXNDcm93ZHNhbGVKc29uO1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxuLyoqXG4gKiAgQmVmb3JlIEV0aGVyZXVtIGxhdW5jaGVkLCBpdCB3YXMgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhIHdhbGxldFxuICogIGZvcm1hdCBmb3IgYmFja2VycyB0byB1c2UsIHdoaWNoIHdvdWxkIGJlIHVzZWQgdG8gcmVjZWl2ZSBldGhlclxuICogIGFzIGEgcmV3YXJkIGZvciBjb250cmlidXRpbmcgdG8gdGhlIHByb2plY3QuXG4gKlxuICogIFRoZSBbW2xpbmstY3Jvd2RzYWxlXV0gZm9ybWF0IGlzIG5vdyBvYnNvbGV0ZSwgYnV0IGl0IGlzIHN0aWxsXG4gKiAgdXNlZnVsIHRvIHN1cHBvcnQgYW5kIHRoZSBhZGRpdGlvbmFsIGNvZGUgaXMgZmFpcmx5IHRyaXZpYWwgYXNcbiAqICBhbGwgdGhlIHByaW1pdGl2ZXMgcmVxdWlyZWQgYXJlIHVzZWQgdGhyb3VnaCBjb3JlIHBvcnRpb25zIG9mXG4gKiAgdGhlIGxpYnJhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIF9wYXNzd29yZCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIHV0aWxzX2pzXzEuZ2V0UGFzc3dvcmQpKF9wYXNzd29yZCk7XG4gICAgLy8gRXRoZXJldW0gQWRkcmVzc1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImV0aGFkZHI6c3RyaW5nIVwiKSk7XG4gICAgLy8gRW5jcnlwdGVkIFNlZWRcbiAgICBjb25zdCBlbmNzZWVkID0gKDAsIHV0aWxzX2pzXzEubG9vc2VBcnJheWlmeSkoKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJlbmNzZWVkOnN0cmluZyFcIikpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShlbmNzZWVkICYmIChlbmNzZWVkLmxlbmd0aCAlIDE2KSA9PT0gMCwgXCJpbnZhbGlkIGVuY3NlZWRcIiwgXCJqc29uXCIsIGpzb24pO1xuICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMi5wYmtkZjIpKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsIFwic2hhMjU2XCIpKS5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBlbmNyeXB0ZWRTZWVkID0gZW5jc2VlZC5zbGljZSgxNik7XG4gICAgLy8gRGVjcnlwdCB0aGUgc2VlZFxuICAgIGNvbnN0IGFlc0NiYyA9IG5ldyBhZXNfanNfMS5DQkMoa2V5LCBpdik7XG4gICAgY29uc3Qgc2VlZCA9ICgwLCBhZXNfanNfMS5wa2NzN1N0cmlwKSgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoYWVzQ2JjLmRlY3J5cHQoZW5jcnlwdGVkU2VlZCkpKTtcbiAgICAvLyBUaGlzIHdhbGxldCBmb3JtYXQgaXMgd2VpcmQuLi4gQ29udmVydCB0aGUgYmluYXJ5IGVuY29kZWQgaGV4IHRvIGEgc3RyaW5nLlxuICAgIGxldCBzZWVkSGV4ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VlZEhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlZWRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4geyBhZGRyZXNzLCBwcml2YXRlS2V5OiAoMCwgaW5kZXhfanNfMy5pZCkoc2VlZEhleCkgfTtcbn1cbmV4cG9ydHMuZGVjcnlwdENyb3dkc2FsZUpzb24gPSBkZWNyeXB0Q3Jvd2RzYWxlSnNvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tY3Jvd2RzYWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgVGhlIEpTT04gV2FsbGV0IGZvcm1hdHMgYWxsb3cgYSBzaW1wbGUgd2F5IHRvIHN0b3JlIHRoZSBwcml2YXRlXG4gKiAga2V5cyBuZWVkZWQgaW4gRXRoZXJldW0gYWxvbmcgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uIGFuZCBhbGxvd3NcbiAqICBmb3IgZXh0ZW5zaWJsZSBmb3JtcyBvZiBlbmNyeXB0aW9uLlxuICpcbiAqICBUaGVzZSB1dGlsaXRpZXMgZmFjaWxpdGF0ZSBkZWNyeXB0aW5nIGFuZCBlbmNyeXB0aW5nIHRoZSBtb3N0IGNvbW1vblxuICogIEpTT04gV2FsbGV0IGZvcm1hdHMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvblN5bmMgPSBleHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb24gPSBleHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5pc0tleXN0b3JlSnNvbiA9IHZvaWQgMDtcbmNvbnN0IGFlc19qc18xID0gcmVxdWlyZShcImFlcy1qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL192ZXJzaW9uLmpzXCIpO1xuY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gS2V5c3RvcmUgV2FsbGV0LlxuICovXG5mdW5jdGlvbiBpc0tleXN0b3JlSnNvbihqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAoKGRhdGEudmVyc2lvbiAhPSBudWxsKSA/IHBhcnNlSW50KGRhdGEudmVyc2lvbikgOiAwKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0tleXN0b3JlSnNvbiA9IGlzS2V5c3RvcmVKc29uO1xuZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBjaXBoZXIgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5jaXBoZXI6c3RyaW5nXCIpO1xuICAgIGlmIChjaXBoZXIgPT09IFwiYWVzLTEyOC1jdHJcIikge1xuICAgICAgICBjb25zdCBpdiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnBhcmFtcy5pdjpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgYWVzQ3RyID0gbmV3IGFlc19qc18xLkNUUihrZXksIGl2KTtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmhleGxpZnkpKGFlc0N0ci5kZWNyeXB0KGNpcGhlcnRleHQpKTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZGVjcnlwdFwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRBY2NvdW50KGRhdGEsIF9rZXkpIHtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoX2tleSk7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgY29uc3QgY29tcHV0ZWRNQUMgPSAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc180LmNvbmNhdCkoW2tleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpKS5zdWJzdHJpbmcoMik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGNvbXB1dGVkTUFDID09PSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5tYWM6c3RyaW5nIVwiKS50b0xvd2VyQ2FzZSgpLCBcImluY29ycmVjdCBwYXNzd29yZFwiLCBcInBhc3N3b3JkXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBkZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMy5jb21wdXRlQWRkcmVzcykocHJpdmF0ZUtleSk7XG4gICAgaWYgKGRhdGEuYWRkcmVzcykge1xuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFjaGVjay5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGNoZWNrID0gXCIweFwiICsgY2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKGNoZWNrKSA9PT0gYWRkcmVzcywgXCJrZXlzdG9yZSBhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJhZGRyZXNzXCIsIGRhdGEuYWRkcmVzcyk7XG4gICAgfVxuICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3MsIHByaXZhdGVLZXkgfTtcbiAgICAvLyBWZXJzaW9uIDAuMSB4LWV0aGVycyBtZXRhZGF0YSBtdXN0IGNvbnRhaW4gYW4gZW5jcnlwdGVkIG1uZW1vbmljIHBocmFzZVxuICAgIGNvbnN0IHZlcnNpb24gPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcIngtZXRoZXJzLnZlcnNpb246c3RyaW5nXCIpO1xuICAgIGlmICh2ZXJzaW9uID09PSBcIjAuMVwiKSB7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDaXBoZXJ0ZXh0OmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJ4LWV0aGVycy5tbmVtb25pY0NvdW50ZXI6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IGFlc19qc18xLkNUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XG4gICAgICAgIGFjY291bnQubW5lbW9uaWMgPSB7XG4gICAgICAgICAgICBwYXRoOiAoKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJ4LWV0aGVycy5wYXRoOnN0cmluZ1wiKSB8fCBkZWZhdWx0UGF0aCksXG4gICAgICAgICAgICBsb2NhbGU6ICgoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcIngtZXRoZXJzLmxvY2FsZTpzdHJpbmdcIikgfHwgXCJlblwiKSxcbiAgICAgICAgICAgIGVudHJvcHk6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKCgwLCBpbmRleF9qc180LmdldEJ5dGVzKShtbmVtb25pY0Flc0N0ci5kZWNyeXB0KG1uZW1vbmljQ2lwaGVydGV4dCkpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudDtcbn1cbmZ1bmN0aW9uIGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSkge1xuICAgIGNvbnN0IGtkZiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZjpzdHJpbmdcIik7XG4gICAgaWYgKGtkZiAmJiB0eXBlb2YgKGtkZikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInNjcnlwdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnNhbHQ6ZGF0YSFcIik7XG4gICAgICAgICAgICBjb25zdCBOID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLm46aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucjppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgcCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5wOmludCFcIik7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgTiBpcyBhIHBvd2VyIG9mIDJcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShOID4gMCAmJiAoTiAmIChOIC0gMSkpID09PSAwLCBcImludmFsaWQga2RmLk5cIiwgXCJrZGYuTlwiLCBOKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShyID4gMCAmJiBwID4gMCwgXCJpbnZhbGlkIGtkZlwiLCBcImtkZlwiLCBrZGYpO1xuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuZGtsZW46aW50IVwiKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGZsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgc2FsdCwgTiwgciwgcCwgZGtMZW46IDY0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHByZiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5wcmY6c3RyaW5nIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHByZi5zcGxpdChcIi1cIikucG9wKCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoYWxnb3JpdGhtID09PSBcInNoYTI1NlwiIHx8IGFsZ29yaXRobSA9PT0gXCJzaGE1MTJcIiwgXCJpbnZhbGlkIGtkZi5wZGZcIiwgXCJrZGYucGRmXCIsIHByZik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5jOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5ka2xlblwiLCBka0xlbik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInBia2RmMlwiLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiLCBcImtkZlwiLCBrZGYpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWNjb3VudCBkZXRhaWxzIGZvciB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgJSVqc29uJSVcbiAqICB1c2luZyAlJXBhc3N3b3JkJSUuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShkZWNyeXB0S2V5c3RvcmVKc29uKVxuICogIGluc3RlYWQsIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWRcbiAqICBhcyB0byB0aGUgZGVjcnlwdGlvbiBzdGF0dXMuXG4gKlxuICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWwgZGVjcnlwdGlvblxuICogIGlzIGNvbXBsZXRlLCB3aGljaCBjYW4gdGFrZSBxdWl0ZSBzb21lIHRpbWUsIGRlcGVuZGluZyBvbiB0aGUgd2FsbGV0XG4gKiAgcGFyYW10ZXJzIGFuZCBwbGF0Zm9ybS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgX3Bhc3N3b3JkKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgdXRpbHNfanNfMS5nZXRQYXNzd29yZCkoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xuICAgIGlmIChwYXJhbXMubmFtZSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICBjb25zdCB7IHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc18yLnBia2RmMikocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc18yLnNjcnlwdFN5bmMpKHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbik7XG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbn1cbmV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvblN5bmMgPSBkZWNyeXB0S2V5c3RvcmVKc29uU3luYztcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byB0aGUgZGVjcnlwdGVkIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlIHVzaW5nIHRoZVxuICogICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgSWYgcHJvdmlkZWQsICUlcHJvZ3Jlc3MlJSB3aWxsIGJlIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nIHRoZVxuICogIGRlY3JweXRpb24gdG8gcHJvdmlkZSBmZWVkYmFjaywgYW5kIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiAgYGBmYWxzZWBgIHdpbGwgaGFsdCBkZWNyeXB0aW9uLlxuICpcbiAqICBUaGUgJSVwcm9ncmVzc0NhbGxiYWNrJSUgd2lsbCAqKmFsd2F5cyoqIHJlY2VpdmUgYGAwYGAgYmVmb3JlXG4gKiAgZGVjcnlwdGlvbiBiZWdpbnMgYW5kIGBgMWBgIHdoZW4gY29tcGxldGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgX3Bhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIHV0aWxzX2pzXzEuZ2V0UGFzc3dvcmQpKF9wYXNzd29yZCk7XG4gICAgY29uc3QgcGFyYW1zID0gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKTtcbiAgICBpZiAocGFyYW1zLm5hbWUgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBwcm9ncmVzcygwKTtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGluZGV4X2pzXzIucGJrZGYyKShwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnNjcnlwdCkocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcyk7XG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbn1cbmV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvbiA9IGRlY3J5cHRLZXlzdG9yZUpzb247XG5mdW5jdGlvbiBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjay9nZW5lcmF0ZSB0aGUgc2FsdFxuICAgIGNvbnN0IHNhbHQgPSAob3B0aW9ucy5zYWx0ICE9IG51bGwpID8gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKG9wdGlvbnMuc2FsdCwgXCJvcHRpb25zLnNhbHRcIikgOiAoMCwgaW5kZXhfanNfMi5yYW5kb21CeXRlcykoMzIpO1xuICAgIC8vIE92ZXJyaWRlIHRoZSBzY3J5cHQgcGFzc3dvcmQtYmFzZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVyc1xuICAgIGxldCBOID0gKDEgPDwgMTcpLCByID0gOCwgcCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5OKSB7XG4gICAgICAgICAgICBOID0gb3B0aW9ucy5zY3J5cHQuTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucikge1xuICAgICAgICAgICAgciA9IG9wdGlvbnMuc2NyeXB0LnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnApIHtcbiAgICAgICAgICAgIHAgPSBvcHRpb25zLnNjcnlwdC5wO1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKE4pID09PSBcIm51bWJlclwiICYmIE4gPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKE4pICYmIChCaWdJbnQoTikgJiBCaWdJbnQoTiAtIDEpKSA9PT0gQmlnSW50KDApLCBcImludmFsaWQgc2NyeXB0IE4gcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5OXCIsIE4pO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHIpID09PSBcIm51bWJlclwiICYmIHIgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHIpLCBcImludmFsaWQgc2NyeXB0IHIgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5yXCIsIHIpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh0eXBlb2YgKHApID09PSBcIm51bWJlclwiICYmIHAgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHApLCBcImludmFsaWQgc2NyeXB0IHAgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5wXCIsIHApO1xuICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIGRrTGVuOiAzMiwgc2FsdCwgTiwgciwgcCB9O1xufVxuZnVuY3Rpb24gX2VuY3J5cHRLZXlzdG9yZShrZXksIGtkZiwgYWNjb3VudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoYWNjb3VudC5wcml2YXRlS2V5LCBcInByaXZhdGVLZXlcIik7XG4gICAgLy8gT3ZlcnJpZGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yXG4gICAgY29uc3QgaXYgPSAob3B0aW9ucy5pdiAhPSBudWxsKSA/ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShvcHRpb25zLml2LCBcIm9wdGlvbnMuaXZcIikgOiAoMCwgaW5kZXhfanNfMi5yYW5kb21CeXRlcykoMTYpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpdi5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy5pdiBsZW5ndGhcIiwgXCJvcHRpb25zLml2XCIsIG9wdGlvbnMuaXYpO1xuICAgIC8vIE92ZXJyaWRlIHRoZSB1dWlkXG4gICAgY29uc3QgdXVpZFJhbmRvbSA9IChvcHRpb25zLnV1aWQgIT0gbnVsbCkgPyAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykob3B0aW9ucy51dWlkLCBcIm9wdGlvbnMudXVpZFwiKSA6ICgwLCBpbmRleF9qc18yLnJhbmRvbUJ5dGVzKSgxNik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHV1aWRSYW5kb20ubGVuZ3RoID09PSAxNiwgXCJpbnZhbGlkIG9wdGlvbnMudXVpZCBsZW5ndGhcIiwgXCJvcHRpb25zLnV1aWRcIiwgb3B0aW9ucy5pdik7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgd2FsbGV0IChhcyBwZXIgV2ViMyBzZWNyZXQgc3RvcmFnZSlcbiAgICAvLyAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuICAgIC8vIC0gMzIgYnl0ZXMgICBBRVMga2V5IHRvIGVuY3J5cHQgbW5lbW9uaWMgd2l0aCAocmVxdWlyZWQgaGVyZSB0byBiZSBFdGhlcnMgV2FsbGV0KVxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBrZXkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xuICAgIC8vIEVuY3J5cHQgdGhlIHByaXZhdGUga2V5XG4gICAgY29uc3QgYWVzQ3RyID0gbmV3IGFlc19qc18xLkNUUihkZXJpdmVkS2V5LCBpdik7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShhZXNDdHIuZW5jcnlwdChwcml2YXRlS2V5KSk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLCB1c2VkIHRvIGNoZWNrIHRoZSBwYXNzd29yZFxuICAgIGNvbnN0IG1hYyA9ICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoKDAsIGluZGV4X2pzXzQuY29uY2F0KShbbWFjUHJlZml4LCBjaXBoZXJ0ZXh0XSkpO1xuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb25cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGlkOiAoMCwgaW5kZXhfanNfNC51dWlkVjQpKHV1aWRSYW5kb20pLFxuICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICBDcnlwdG86IHtcbiAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgaXY6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGl2KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lwaGVydGV4dDogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoY2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAga2RmOiBcInNjcnlwdFwiLFxuICAgICAgICAgICAga2RmcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc2FsdDogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoa2RmLnNhbHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgICAgICBuOiBrZGYuTixcbiAgICAgICAgICAgICAgICBka2xlbjogMzIsXG4gICAgICAgICAgICAgICAgcDoga2RmLnAsXG4gICAgICAgICAgICAgICAgcjoga2RmLnJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYWM6IG1hYy5zdWJzdHJpbmcoMilcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgd2UgaGF2ZSBhIG1uZW1vbmljLCBlbmNyeXB0IGl0IGludG8gdGhlIEpTT04gd2FsbGV0XG4gICAgaWYgKGFjY291bnQubW5lbW9uaWMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gKG9wdGlvbnMuY2xpZW50ICE9IG51bGwpID8gb3B0aW9ucy5jbGllbnQgOiBgZXRoZXJzLyR7X3ZlcnNpb25fanNfMS52ZXJzaW9ufWA7XG4gICAgICAgIGNvbnN0IHBhdGggPSBhY2NvdW50Lm1uZW1vbmljLnBhdGggfHwgZGVmYXVsdFBhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IGFjY291bnQubW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgY29uc3QgZW50cm9weSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShhY2NvdW50Lm1uZW1vbmljLmVudHJvcHksIFwiYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5XCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gKDAsIGluZGV4X2pzXzIucmFuZG9tQnl0ZXMpKDE2KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuQ1RSKG1uZW1vbmljS2V5LCBtbmVtb25pY0l2KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKG1uZW1vbmljQWVzQ3RyLmVuY3J5cHQoZW50cm9weSkpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSAobm93LmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS56cGFkKShub3cuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuenBhZCkobm93LmdldFVUQ0RhdGUoKSwgMikgKyBcIlRcIiArXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS56cGFkKShub3cuZ2V0VVRDSG91cnMoKSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS56cGFkKShub3cuZ2V0VVRDTWludXRlcygpLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLnpwYWQpKG5vdy5nZXRVVENTZWNvbmRzKCksIDIpICsgXCIuMFpcIik7XG4gICAgICAgIGNvbnN0IGdldGhGaWxlbmFtZSA9IChcIlVUQy0tXCIgKyB0aW1lc3RhbXAgKyBcIi0tXCIgKyBkYXRhLmFkZHJlc3MpO1xuICAgICAgICBkYXRhW1wieC1ldGhlcnNcIl0gPSB7XG4gICAgICAgICAgICBjbGllbnQsIGdldGhGaWxlbmFtZSwgcGF0aCwgbG9jYWxlLFxuICAgICAgICAgICAgbW5lbW9uaWNDb3VudGVyOiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKG1uZW1vbmljQ2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgdmVyc2lvbjogXCIwLjFcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWQgd2l0aFxuICogICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkLiBBbnkgcHJvdmlkZWQgW1tQcm9ncmVzc0NhbGxiYWNrXV0gaXMgaWdub3JkLlxuICovXG5mdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBwYXNzd29yZEJ5dGVzID0gKDAsIHV0aWxzX2pzXzEuZ2V0UGFzc3dvcmQpKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc18yLnNjcnlwdFN5bmMpKHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCk7XG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZW5jcnlwdEtleXN0b3JlSnNvblN5bmM7XG4vKipcbiAqICBSZXNvbHZlZCB0byB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgZm9yICUlYWNjb3VudCUlIGVuY3J5cHRlZFxuICogIHdpdGggJSVwYXNzd29yZCUlLlxuICpcbiAqICBUaGUgJSVvcHRpb25zJSUgY2FuIGJlIHVzZWQgdG8gdHVuZSB0aGUgcGFzc3dvcmQtYmFzZWQga2V5XG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xuICogIHVzZWQgYW5kIHByb3ZpZGUgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byByZWNlaXZlIHBlcmlvZGljIHVwZGF0ZXNcbiAqICBvbiB0aGUgY29tcGxldGlvbiBzdGF0dXMuLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uKGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSAoMCwgdXRpbHNfanNfMS5nZXRQYXNzd29yZCkocGFzc3dvcmQpO1xuICAgIGNvbnN0IGtkZiA9IGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucyk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgKDAsIGluZGV4X2pzXzIuc2NyeXB0KShwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQsIG9wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb24gPSBlbmNyeXB0S2V5c3RvcmVKc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1rZXlzdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW5lbW9uaWMgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBsYW5nX2VuX2pzXzEgPSByZXF1aXJlKFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIik7XG4vLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBNU0IgYml0cyBzZXRcbmZ1bmN0aW9uIGdldFVwcGVyTWFzayhiaXRzKSB7XG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpIDw8ICg4IC0gYml0cykgJiAweGZmO1xufVxuLy8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTFNCIGJpdHMgc2V0XG5mdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cykge1xuICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSAmIDB4ZmY7XG59XG5mdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnROb3JtYWxpemUpKFwiTkZLRFwiKTtcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSB3b3JkbGlzdC5zcGxpdChtbmVtb25pYyk7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKCh3b3Jkcy5sZW5ndGggJSAzKSA9PT0gMCAmJiB3b3Jkcy5sZW5ndGggPj0gMTIgJiYgd29yZHMubGVuZ3RoIDw9IDI0LCBcImludmFsaWQgbW5lbW9uaWMgbGVuZ3RoXCIsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgY29uc3QgZW50cm9weSA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCgxMSAqIHdvcmRzLmxlbmd0aCAvIDgpKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3Jkc1tpXS5ub3JtYWxpemUoXCJORktEXCIpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAsIGBpbnZhbGlkIG1uZW1vbmljIHdvcmQgYXQgaW5kZXggJHtpfWAsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IDExOyBiaXQrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgKDEgPDwgKDEwIC0gYml0KSkpIHtcbiAgICAgICAgICAgICAgICBlbnRyb3B5W29mZnNldCA+PiAzXSB8PSAoMSA8PCAoNyAtIChvZmZzZXQgJSA4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW50cm9weUJpdHMgPSAzMiAqIHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gd29yZHMubGVuZ3RoIC8gMztcbiAgICBjb25zdCBjaGVja3N1bU1hc2sgPSBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKGVudHJvcHkuc2xpY2UoMCwgZW50cm9weUJpdHMgLyA4KSkpWzBdICYgY2hlY2tzdW1NYXNrO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShjaGVja3N1bSA9PT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzayksIFwiaW52YWxpZCBtbmVtb25pYyBjaGVja3N1bVwiLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xufVxuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKGVudHJvcHkubGVuZ3RoICUgNCkgPT09IDAgJiYgZW50cm9weS5sZW5ndGggPj0gMTYgJiYgZW50cm9weS5sZW5ndGggPD0gMzIsIFwiaW52YWxpZCBlbnRyb3B5IHNpemVcIiwgXCJlbnRyb3B5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHdvcmRsaXN0ID0gbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpO1xuICAgIH1cbiAgICBjb25zdCBpbmRpY2VzID0gWzBdO1xuICAgIGxldCByZW1haW5pbmdCaXRzID0gMTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENvbnN1bWUgdGhlIHdob2xlIGJ5dGUgKHdpdGggc3RpbGwgbW9yZSB0byBnbylcbiAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPiA4KSB7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IDg7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgICAgIC8vIFRoaXMgYnl0ZSB3aWxsIGNvbXBsZXRlIGFuIDExLWJpdCBpbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSByZW1haW5pbmdCaXRzO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV0gPj4gKDggLSByZW1haW5pbmdCaXRzKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHdvcmRcbiAgICAgICAgICAgIGluZGljZXMucHVzaChlbnRyb3B5W2ldICYgZ2V0TG93ZXJNYXNrKDggLSByZW1haW5pbmdCaXRzKSk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgY2hlY2tzdW0gYml0c1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICBjb25zdCBjaGVja3N1bSA9IHBhcnNlSW50KCgwLCBpbmRleF9qc18xLnNoYTI1NikoZW50cm9weSkuc3Vic3RyaW5nKDIsIDQpLCAxNikgJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSBjaGVja3N1bUJpdHM7XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKChpbmRleCkgPT4gd29yZGxpc3QuZ2V0V29yZChpbmRleCkpKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuLyoqXG4gKiAgQSAqKk1uZW1vbmljKiogd3JhcHMgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gY29tcHV0ZSBbW2xpbmstYmlwLTM5XV1cbiAqICBzZWVkcyBhbmQgY29udmVydCBiZXR3ZWVuIHBocmFzZXMgYW5kIGVudHJvcHkuXG4gKi9cbmNsYXNzIE1uZW1vbmljIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1uZW1vbmljIHBocmFzZSBvZiAxMiwgMTUsIDE4LCAyMSBvciAyNCB3b3Jkcy5cbiAgICAgKlxuICAgICAqICBVc2UgdGhlIFtbd29yZGxpc3RdXSBgYHNwbGl0YGAgbWV0aG9kIHRvIGdldCB0aGUgaW5kaXZpZHVhbCB3b3Jkcy5cbiAgICAgKi9cbiAgICBwaHJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXNzd29yZCB1c2VkIGZvciB0aGlzIG1uZW1vbmljLiBJZiBubyBwYXNzd29yZCBpcyB1c2VkIHRoaXNcbiAgICAgKiAgaXMgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgYXMgcGVyIHRoZSBzcGVjaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIHBhc3N3b3JkO1xuICAgIC8qKlxuICAgICAqICBUaGUgd29yZGxpc3QgZm9yIHRoaXMgbW5lbW9uaWMuXG4gICAgICovXG4gICAgd29yZGxpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmRlcmx5aW5nIGVudHJvcHkgd2hpY2ggdGhlIG1uZW1vbmljIGVuY29kZXMuXG4gICAgICovXG4gICAgZW50cm9weTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBsYW5nX2VuX2pzXzEuTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0UHJpdmF0ZSkoZ3VhcmQsIF9ndWFyZCwgXCJNbmVtb25pY1wiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCwgZW50cm9weSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNlZWQgZm9yIHRoZSBtbmVtb25pYy5cbiAgICAgKi9cbiAgICBjb21wdXRlU2VlZCgpIHtcbiAgICAgICAgY29uc3Qgc2FsdCA9ICgwLCBpbmRleF9qc18yLnRvVXRmOEJ5dGVzKShcIm1uZW1vbmljXCIgKyB0aGlzLnBhc3N3b3JkLCBcIk5GS0RcIik7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5wYmtkZjIpKCgwLCBpbmRleF9qc18yLnRvVXRmOEJ5dGVzKSh0aGlzLnBocmFzZSwgXCJORktEXCIpLCBzYWx0LCAyMDQ4LCA2NCwgXCJzaGE1MTJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IE1uZW1vbmljIGZvciB0aGUgJSVwaHJhc2UlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNlOyB0aHJvd3MgaWYgaW52YWxpZFxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgICAgIHBocmFzZSA9IGVudHJvcHlUb01uZW1vbmljKCgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShlbnRyb3B5KSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqTW5lbW9uaWMqKiBmcm9tIHRoZSAlJWVudHJvcHklJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVudHJvcHkoX2VudHJvcHksIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XG4gICAgICAgIGNvbnN0IHBocmFzZSA9IGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNbmVtb25pYyhfZ3VhcmQsICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGVudHJvcHkpLCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwaHJhc2UgZm9yICUlbW5lbW9uaWMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW50cm9weVRvUGhyYXNlKF9lbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XG4gICAgICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRyb3B5IGZvciAlJXBocmFzZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBwaHJhc2VUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICByZXR1cm4gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVwaHJhc2UlJSBpcyBhIHZhbGlkIFtbbGluay1iaXAtMzldXSBwaHJhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjaGVja3MgYWxsIHRoZSBwcm92aWRlZCB3b3JkcyBiZWxvbmcgdG8gdGhlICUld29yZGxpc3QlJSxcbiAgICAgKiAgdGhhdCB0aGUgbGVuZ3RoIGlzIHZhbGlkIGFuZCB0aGUgY2hlY2tzdW0gaXMgY29ycmVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE1uZW1vbmljKHBocmFzZSwgd29yZGxpc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTW5lbW9uaWMgPSBNbmVtb25pYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uZW1vbmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zcGVsdW5rID0gZXhwb3J0cy5nZXRQYXNzd29yZCA9IGV4cG9ydHMuenBhZCA9IGV4cG9ydHMubG9vc2VBcnJheWlmeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZykge1xuICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09IFwic3RyaW5nXCIgJiYgIWhleFN0cmluZy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgaGV4U3RyaW5nID0gXCIweFwiICsgaGV4U3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShoZXhTdHJpbmcpO1xufVxuZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gbG9vc2VBcnJheWlmeTtcbmZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuenBhZCA9IHpwYWQ7XG5mdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGlmICh0eXBlb2YgKHBhc3N3b3JkKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvVXRmOEJ5dGVzKShwYXNzd29yZCwgXCJORktDXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShwYXNzd29yZCk7XG59XG5leHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5mdW5jdGlvbiBzcGVsdW5rKG9iamVjdCwgX3BhdGgpIHtcbiAgICBjb25zdCBtYXRjaCA9IF9wYXRoLm1hdGNoKC9eKFthLXowLTkkXy4tXSopKDooW2Etel0rKSk/KCEpPyQvaSk7XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKG1hdGNoICE9IG51bGwsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBfcGF0aCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IHR5cGUgPSBtYXRjaFszXTtcbiAgICBjb25zdCByZXFkID0gKG1hdGNoWzRdID09PSBcIiFcIik7XG4gICAgbGV0IGN1ciA9IG9iamVjdDtcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcuJykpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgaWYgKCFjb21wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBjdXJbcGFyc2VJbnQoY29tcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGN1cltrZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoIXJlcWQgfHwgY3VyICE9IG51bGwsIFwibWlzc2luZyByZXF1aXJlZCB2YWx1ZVwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKHR5cGUgJiYgY3VyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIgJiYgY3VyLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGN1cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOS5dKiQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlQXJyYXlpZnkoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdHlwZW9mIChjdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYHdyb25nIHR5cGUgZm91bmQgZm9yICR7dHlwZX0gYCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xufVxuZXhwb3J0cy5zcGVsdW5rID0gc3BlbHVuaztcbi8qXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93KG9iamVjdDogYW55LCBwYXRoOiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcbiAgICBsZXQgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpKSB7XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgbGV0IG1hdGNoaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcbiAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDaGlsZCA9IGN1cnJlbnRDaGlsZFtrZXldO1xuICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hpbmdDaGlsZCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDaGlsZDtcbn1cblxuLy8gXCJwYXRoL3RvL3NvbWV0aGluZzp0eXBlIVwiXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93UmVxdWlyZWQoZGF0YTogYW55LCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbHVlID0gZm9sbG93KGRhdGEsIHBhdGgpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBgZGF0YTokeyBwYXRoIH1gLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn1cbiovXG4vLyBTZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlczogQnl0ZXNMaWtlKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuXG4gICAgLy8gU2VjdGlvbjogNC4xLjM6XG4gICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxuICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuXG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE0LCAxOCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYmFzZV93YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2Utd2FsbGV0LmpzXCIpO1xuY29uc3QgaGR3YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2hkd2FsbGV0LmpzXCIpO1xuY29uc3QganNvbl9jcm93ZHNhbGVfanNfMSA9IHJlcXVpcmUoXCIuL2pzb24tY3Jvd2RzYWxlLmpzXCIpO1xuY29uc3QganNvbl9rZXlzdG9yZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1rZXlzdG9yZS5qc1wiKTtcbmNvbnN0IG1uZW1vbmljX2pzXzEgPSByZXF1aXJlKFwiLi9tbmVtb25pYy5qc1wiKTtcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XG59XG4vKipcbiAqICBBICoqV2FsbGV0KiogbWFuYWdlcyBhIHNpbmdsZSBwcml2YXRlIGtleSB3aGljaCBpcyB1c2VkIHRvIHNpZ25cbiAqICB0cmFuc2FjdGlvbnMsIG1lc3NhZ2VzIGFuZCBvdGhlciBjb21tb24gcGF5bG9hZHMuXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBkZXZlbG9wZXJzXG4gKiAgdGhhdCB3aXNoIHRvIHVzZSBhIHByaXZhdGUga2V5IGRpcmVjdGx5LCBhcyBpdCBjYW4gY3JlYXRlXG4gKiAgaW5zdGFuY2VzIGZyb20gYSBsYXJnZSB2YXJpZXR5IG9mIGNvbW1vbiBzb3VyY2VzLCBpbmNsdWRpbmdcbiAqICByYXcgcHJpdmF0ZSBrZXksIFtbbGluay1iaXAtMzldXSBtbmVtb25pY3MgYW5kIGVuY3J5cHRlIEpTT05cbiAqICB3YWxsZXRzLlxuICovXG5jbGFzcyBXYWxsZXQgZXh0ZW5kcyBiYXNlX3dhbGxldF9qc18xLkJhc2VXYWxsZXQge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgd2FsbGV0IGZvciB0aGUgcHJpdmF0ZSAlJWtleSUlLCBvcHRpb25hbGx5IGNvbm5lY3RlZFxuICAgICAqICB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiICYmICFrZXkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBrZXkgPSBcIjB4XCIgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSA/IG5ldyBpbmRleF9qc18xLlNpZ25pbmdLZXkoa2V5KSA6IGtleTtcbiAgICAgICAgc3VwZXIoc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXG4gICAgICovXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uKShhY2NvdW50LCBwYXNzd29yZCwgeyBwcm9ncmVzc0NhbGxiYWNrIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXBlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZW5jcnlwdCkgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsXG4gICAgICogIGl0IGlzIGNvbXBsZXRlLCB3aGljaCBtYXkgYmUgYSBub24tdHJpdmlhbCBkdXJhdGlvbi5cbiAgICAgKi9cbiAgICBlbmNyeXB0U3luYyhwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICByZXR1cm4gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uU3luYykoYWNjb3VudCwgcGFzc3dvcmQpO1xuICAgIH1cbiAgICBzdGF0aWMgI2Zyb21BY2NvdW50KGFjY291bnQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGFjY291bnQsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGlmIChcIm1uZW1vbmljXCIgaW4gYWNjb3VudCAmJiBhY2NvdW50Lm1uZW1vbmljICYmIGFjY291bnQubW5lbW9uaWMubG9jYWxlID09PSBcImVuXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gbW5lbW9uaWNfanNfMS5NbmVtb25pYy5mcm9tRW50cm9weShhY2NvdW50Lm1uZW1vbmljLmVudHJvcHkpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gaGR3YWxsZXRfanNfMS5IRE5vZGVXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBhY2NvdW50Lm1uZW1vbmljLnBhdGgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MgJiYgd2FsbGV0LnByaXZhdGVLZXkgPT09IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IEpTT04gbWlzbWF0Y2ggYWRkcmVzcy9wcml2YXRlS2V5ICE9IG1uZW1vbmljOyBmYWxsYmFjayBvbnRvIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MsIFwiYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIsIFwianNvblwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgKGFzeW5jaHJvbm91c2x5KSBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSVcbiAgICAgKiAgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzcyUlIGlzIHByb3ZpZGVkLCBpdCBpcyBjYWxsZWQgcGVyaW9kaWNhbGx5IGR1cmluZ1xuICAgICAqICBkZWNyeXB0aW9uIHNvIHRoYXQgYW55IFVJIGNhbiBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRW5jcnlwdGVkSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xuICAgICAgICBpZiAoKDAsIGpzb25fa2V5c3RvcmVfanNfMS5pc0tleXN0b3JlSnNvbikoanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBhd2FpdCAoMCwganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb24pKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGpzb25fY3Jvd2RzYWxlX2pzXzEuaXNDcm93ZHNhbGVKc29uKShqc29uKSkge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50ID0gKDAsIGpzb25fY3Jvd2RzYWxlX2pzXzEuZGVjcnlwdENyb3dkc2FsZUpzb24pKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIFtbZnJvbUVuY3J5cHRlZEpzb25dXSBtZXRob2QgaXMgcHJlZmVycmVkLCBhcyB0aGlzIG1ldGhvZFxuICAgICAqICB3aWxsIGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgZHVyaW5nIGRlY3J5cHRpb24sIHdoaWNoIG1heSB0YWtlXG4gICAgICogIHNvbWUgdGltZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24sIHBhc3N3b3JkKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCgwLCBqc29uX2tleXN0b3JlX2pzXzEuaXNLZXlzdG9yZUpzb24pKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5kZWNyeXB0S2V5c3RvcmVKc29uU3luYykoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBqc29uX2Nyb3dkc2FsZV9qc18xLmlzQ3Jvd2RzYWxlSnNvbikoanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSAoMCwganNvbl9jcm93ZHNhbGVfanNfMS5kZWNyeXB0Q3Jvd2RzYWxlSnNvbikoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gW1tIRE5vZGVXYWxsZXRdXSB1c2luZyB0aGUgYXZhaWxhYmxlXG4gICAgICogIFtjcnlwdG9ncmFwaGljIHJhbmRvbSBzb3VyY2VdKHJhbmRvbUJ5dGVzKS5cbiAgICAgKlxuICAgICAqICBJZiB0aGVyZSBpcyBubyBjcnl0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gaGR3YWxsZXRfanNfMS5IRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIFtbSEROb2RlV2FsbGV0XV0gZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVCaXRzID0gdm9pZCAwO1xuY29uc3QgQmFzZTY0ID0gXCIpIUAjJCVeJiooQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGVCaXRzKHdpZHRoLCBkYXRhKSB7XG4gICAgY29uc3QgbWF4VmFsdWUgPSAoMSA8PCB3aWR0aCkgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBhY2N1bSA9IDAsIGJpdHMgPSAwLCBmbG9vZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEFjY3VtdWxhdGUgNiBiaXRzIG9mIGRhdGFcbiAgICAgICAgYWNjdW0gPSAoKGFjY3VtIDw8IDYpIHwgQmFzZTY0LmluZGV4T2YoZGF0YVtpXSkpO1xuICAgICAgICBiaXRzICs9IDY7XG4gICAgICAgIC8vIFdoaWxlIHdlIGhhdmUgZW5vdWdoIGZvciBhIHdvcmQuLi5cbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gd2lkdGgpIHtcbiAgICAgICAgICAgIC8vIC4uLnJlYWQgdGhlIHdvcmRcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGFjY3VtID4+IChiaXRzIC0gd2lkdGgpKTtcbiAgICAgICAgICAgIGFjY3VtICY9ICgxIDw8IChiaXRzIC0gd2lkdGgpKSAtIDE7XG4gICAgICAgICAgICBiaXRzIC09IHdpZHRoO1xuICAgICAgICAgICAgLy8gQSB2YWx1ZSBvZiAwIGluZGljYXRlcyB3ZSBleGNlZWRlZCBtYXhWYWx1ZSwgaXRcbiAgICAgICAgICAgIC8vIGZsb29kcyBvdmVyIGludG8gdGhlIG5leHQgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZsb29kICs9IG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgKyBmbG9vZCk7XG4gICAgICAgICAgICAgICAgZmxvb2QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZUJpdHMgPSBkZWNvZGVCaXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0LXJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlT3dsID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgc3Vic0NocnMgPSBcIiAhIyQlJicoKSorLC0uLzw9Pj9AW11eX2B7fH1+XCI7XG5jb25zdCBXb3JkID0gL15bYS16XSokL2k7XG5mdW5jdGlvbiB1bmZvbGQod29yZHMsIHNlcCkge1xuICAgIGxldCBpbml0aWFsID0gOTc7XG4gICAgcmV0dXJuIHdvcmRzLnJlZHVjZSgoYWNjdW0sIHdvcmQpID0+IHtcbiAgICAgICAgaWYgKHdvcmQgPT09IHNlcCkge1xuICAgICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmQubWF0Y2goV29yZCkpIHtcbiAgICAgICAgICAgIGFjY3VtLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbml0aWFsKSArIHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbCA9IDk3O1xuICAgICAgICAgICAgYWNjdW0ucHVzaCh3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgW10pO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGRhdGEsIHN1YnMpIHtcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyB3aXRoIHRoZWlyIGV4cGFuZGVkIGZvcm1cbiAgICBmb3IgKGxldCBpID0gc3Vic0NocnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoc3Vic0NocnNbaV0pLmpvaW4oc3Vicy5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgMikpO1xuICAgIH1cbiAgICAvLyBHZXQgYWxsIHRsZSBjbHVtcHM7IGVhY2ggc3VmZml4LCBmaXJzdC1pbmNyZW1lbnQgYW5kIHNlY29uZC1pbmNyZW1lbnRcbiAgICBjb25zdCBjbHVtcHMgPSBbXTtcbiAgICBjb25zdCBsZWZ0b3ZlciA9IGRhdGEucmVwbGFjZSgvKDp8KFswLTldKXwoW0EtWl1bYS16XSopKS9nLCAoYWxsLCBpdGVtLCBzZW1pLCB3b3JkKSA9PiB7XG4gICAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQoc2VtaSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY2x1bXBzLnB1c2goXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2x1bXBzLnB1c2goaXRlbS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobGVmdG92ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsZWZ0b3ZlcnM6ICR7SlNPTi5zdHJpbmdpZnkobGVmdG92ZXIpfWApO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIHJldHVybiB1bmZvbGQodW5mb2xkKGNsdW1wcywgXCI7XCIpLCBcIjpcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZU93bChkYXRhKSB7XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGRhdGFbMF0gPT09IFwiMFwiLCBcInVuc3VwcG9ydGVkIGF1d2wgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZShkYXRhLnN1YnN0cmluZygxICsgMiAqIHN1YnNDaHJzLmxlbmd0aCksIGRhdGEuc3Vic3RyaW5nKDEsIDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSk7XG59XG5leHBvcnRzLmRlY29kZU93bCA9IGRlY29kZU93bDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1vd2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZU93bEEgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYml0X3JlYWRlcl9qc18xID0gcmVxdWlyZShcIi4vYml0LXJlYWRlci5qc1wiKTtcbmNvbnN0IGRlY29kZV9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZS1vd2wuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGVPd2xBKGRhdGEsIGFjY2VudHMpIHtcbiAgICBsZXQgd29yZHMgPSAoMCwgZGVjb2RlX293bF9qc18xLmRlY29kZU93bCkoZGF0YSkuam9pbihcIixcIik7XG4gICAgLy8gSW5qZWN0IHRoZSBhY2NlbnRzXG4gICAgYWNjZW50cy5zcGxpdCgvLC9nKS5mb3JFYWNoKChhY2NlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBhY2NlbnQubWF0Y2goL14oW2Etel0qKShbMC05XSspKFswLTldKSguKikkLyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCAhPT0gbnVsbCwgXCJpbnRlcm5hbCBlcnJvciBwYXJzaW5nIGFjY2VudHNcIiwgXCJhY2NlbnRzXCIsIGFjY2VudHMpO1xuICAgICAgICBsZXQgcG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gKDAsIGJpdF9yZWFkZXJfanNfMS5kZWNvZGVCaXRzKShwYXJzZUludChtYXRjaFszXSksIG1hdGNoWzRdKTtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFske21hdGNoWzFdfV0pYCwgXCJnXCIpO1xuICAgICAgICB3b3JkcyA9IHdvcmRzLnJlcGxhY2UocmVnZXgsIChhbGwsIGxldHRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtID0gLS1wb3NpdGlvbnNbcG9zT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChyZW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxldHRlci5jaGFyQ29kZUF0KDApLCBjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgcG9zT2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZHMuc3BsaXQoXCIsXCIpO1xufVxuZXhwb3J0cy5kZWNvZGVPd2xBID0gZGVjb2RlT3dsQTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1vd2xhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLldvcmRsaXN0T3dsQSA9IGV4cG9ydHMuV29yZGxpc3RPd2wgPSBleHBvcnRzLkxhbmdFbiA9IGV4cG9ydHMuV29yZGxpc3QgPSB2b2lkIDA7XG4vKipcbiAqICBBIFdvcmRsaXN0IGlzIGEgc2V0IG9mIDIwNDggd29yZHMgdXNlZCB0byBlbmNvZGUgcHJpdmF0ZSBrZXlzXG4gKiAgKG9yIG90aGVyIGJpbmFyeSBkYXRhKSB0aGF0IGlzIGVhc2llciBmb3IgaHVtYW5zIHRvIHdyaXRlIGRvd24sXG4gKiAgdHJhbnNjcmliZSBhbmQgZGljdGF0ZS5cbiAqXG4gKiAgVGhlIFtbbGluay1iaXAtMzldXSBzdGFuZGFyZCBpbmNsdWRlcyBzZXZlcmFsIGNoZWNrc3VtIGJpdHMsXG4gKiAgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBtbmVtb25pYyBwaHJhc2UuXG4gKlxuICogIEEgbW5lbW9uaWMgcGhyYXNlIG1heSBiZSAxMiwgMTUsIDE4LCAyMSBvciAyNCB3b3JkcyBsb25nLiBGb3JcbiAqICBtb3N0IHB1cnBvc2VzIDEyIHdvcmQgbW5lbW9uaWNzIHNob3VsZCBiZSB1c2VkLCBhcyBpbmNsdWRpbmdcbiAqICBhZGRpdGlvbmFsIHdvcmRzIGluY3JlYXNlcyB0aGUgZGlmZmljdWx0eSBhbmQgcG90ZW50aWFsIGZvclxuICogIG1pc3Rha2VzIGFuZCBkb2VzIG5vdCBvZmZlciBhbnkgZWZmZWN0aXZlIGltcHJvdmVtZW50IG9uIHNlY3VyaXR5LlxuICpcbiAqICBUaGVyZSBhcmUgYSB2YXJpZXR5IG9mIFtbbGluay1iaXAzOS13b3JkbGlzdHNdXSBmb3IgZGlmZmVyZW50XG4gKiAgbGFuZ3VhZ2VzLCBidXQgZm9yIG1heGltYWwgY29tcGF0aWJpbGl0eSwgdGhlXG4gKiAgW0VuZ2xpc2ggV29yZGxpc3RdKExhbmdFbikgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3dvcmRsaXN0czpXb3JkbGlzdHMgW2Fib3V0LXdvcmRsaXN0c11cbiAqL1xudmFyIHdvcmRsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkbGlzdF9qc18xLldvcmRsaXN0OyB9IH0pO1xudmFyIGxhbmdfZW5fanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctZW4uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYW5nRW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfZW5fanNfMS5MYW5nRW47IH0gfSk7XG52YXIgd29yZGxpc3Rfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2wuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdE93bFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2w7IH0gfSk7XG52YXIgd29yZGxpc3Rfb3dsYV9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsYS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsQVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3Rfb3dsYV9qc18xLldvcmRsaXN0T3dsQTsgfSB9KTtcbnZhciB3b3JkbGlzdHNfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRsaXN0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3RzX2pzXzEud29yZGxpc3RzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdDeiA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBpdGF0a2FzdGNlbmFvdm8kdGFvdWxlcmFla2kmY2hvcip0ZWNpJWVuYmFsb2RhZWxhZGV0JyFDaG49MERpIyVFJV4xUmVzYTJSZXNlM0NlVCcjMEVqS29ob2wwUHUpJTBBJnNEdWwjRWtkbylLZSlUaSNVbHwzfWFPZ2FuJTBGYWx0SSRAdFBpLCVUbWFUcm9ub20wTGFzTHtpI09sMFRvYnVzNFlsOkIjfTxDaWxDdWwjRCFfR2UpR3JIbm9LdGVyaWVMYV5MeyNMa29uTG9uLUx2YW5MemFNYnVzTmtvbSFSW3JSe1JtYW5Sb2tvUnZhVGVyI1RvaFZsJlphbCNaaWxpI1p1IzNEJlJhblNlXlN0aWVUb25aaW4jWm1vY1opazNDeWtsRF1GdC1LaW55TGFuJU9nLGZPXWdUdmFab24yQWhvYnl0QXQqL0UvYUVkdStFc2tJayFJeiZPa3xPdWQgVWQyQi1CckRsLkR+SCEoSmtvdEp8Szx5c0xlJFI+Uic/VGFVYl9VLyFVXlUrVXIhWGVyMkFediNBbWJvLEFuI0F0ckVwKUlrZSlLb0xvaE9uek9za2V2VW57I1VzaW4jWl5aeTJCbC5Cbnx9KUQgX0QjRCdhRntKYXIoS3Y/TGRva0x2YU5eTmtyUnphVGlrVm9sWm9sYTNEK3RMLlQnIzBVa290OlBhcnRSZXYmM0RyRHUrSi9KbkxhTGVyTGtlbUxuP04uTm4oTicjTnRydW1OejxTdG9waXNUIzJBbHVwYUFwYF1BciBhQSlFL3QhRW1pZUkvb3RJcnVyZ0xgTGVbTHViIE1fTXUsT2JvdE8vb2xPZFtPKyxPbT1PcCBPcm9bT3ZSYXBvdFJsIFJ0UnVwVGl2KFVkLlV0biFWIVZpbCNWKFlbWSQhWXQgMEJ1K0dhcmUpSF8mSGxhTmtvdFJrdXNTdGVyJlRhJVRydXNaaW4+WigyTyYyS29saXZVdiE0SXRfTigwRG4oS2UpS3JQb3QwQWt+QWxJa1Jrb3QyS2xpJGE6TC1vUmVbVF9UdW0xRSwxQiFhfScjQ2liX0ZpYyBGbGElS2xLcntNb2tyIVByZXNlUmJ5UyNULXRpdjNLb2Isekt0fE9eUF1tU2tTcCtqVmBdVm8vMkFoYU91aG9VaG9waXMxRXMwQnJvQnl0LUNAdH11dCBEbmVzSCtkSG9eSCxKZW1Kbj9LbGBLb2xhS3Q8S3VtQHRMYXJMZXZhTC5NYU0ubnRNbHV2IE0nTnV0IFBgUGlzUGxuIFBvc3VkUHInb2RQdSQgUmF6IFIoUnRTYWhTbCdTdCEtU3VkU3kpVGF6VC1Ua35VZiFVdG4hVm96JVpgdVpuIVo8JTJBaG8pQWtBbSFpa0F2PkF6ZURvbE9ibihPZ2VyaWVPemRTbihUIFooMkJAfSdub0QtSGFIJyNTIFNub1QoME9qP09yPjJOYW0gOjlPXWdPbm9taWUwRWt0cm9uSXBzYTBBaWxJc2VPJVAhaWUySXpvXk8vYU9wZWpPczJFakVuJUs8KUt5bW8wSWtlKTBGPGllME9sdSUxRWt1JUt1cnplUGVkP1BdemVQPHRULGt0OkMjSmYjS3VsKU4haWtOKXppZVJtYWNpZVY8IFpvKzNEZSwlSntvbk4jM0FsI0d1LG50TG96b2ZMdHJOYW4lTilYYSUwT3JkMUFuX0lydE90aWxhMk5kU2Y8VFtsVCNUb24yQWslRXMjT24pMkthck5rJTNaaSM6TGVqZVJhbnQzTntpI09dZzNMb3QuMkF6dSxFanQyTGVtTGZpJGFUaSMyQWZBbW9mb25BbnUrRXBJbE9nT3RlcyMyTWE6RD9EckxhTEAjTltOb3Bpc1JmYVJwdSZWLG4zQmsoSiNsSm5vSnRtYW5LKXJMbWFNIW9tUj5SJlNdWmt5M1N0PGlrMkFkJyNBc2l2a3lBdmFFZCFFbk9edj5PaE91cChUIVViLlUvbykwQXRPKVl6MElzT2ppdm9PdXQwQmwuQm9qfURpbnlEbCFEbm8pRHxKbihLZWpMaW4jTCNMdWJNbytOIFtObywlUmFsUl5SaXpvbnRSa29SbGl2PlJtb25Sbi5Sb3Nrb3BSJHZvU3BvXlN0LlQnKFVbVWZVcCFVcyNWPDJBZFtBbj9BdihBel5CbytrRC5EXUQoTi1PYiNPbWFeT3RPdV5PekBTdCNVYihZeiEyQkAoQn5EW0tvdE1yUyBhU3RvKTBPemQyQm4oRCxudEdpZSZNJlN0ZXJpazoyWWwjM05lZDJPJjBVemUwVW4gYTBGLSVGbGElS2Fzb092YSVTcC0lVGVybntWYWxpXlZlJDxaZXIlM09uaWU6Qmxrb30pSG9eS21pK0soTCc+TilyUm1hcmtSb1NhblNub1QjVjxaeWszRGluPkQrRG4hX0hsYW5Lb3RMQEwgb01uKE5vbVA/U3tlclYgWmQ+WmVybzNOYWtOZHlOby9TayxTdG8pVHJuP1p2YTNFbnwxR3VydDVSKTpCYXJ7Ql9CaW57fSZEe0RpZF1IYW5KYWtKdSlLYW9LdHVzTGFtIGFMaG90eUxpYnJMbihNZSxNa29saXZNJk5pW2xOb2VOdDxQYWwuUF9hUCBvbGFQI1ArUG8pUHJQdSRhUHlbLFJhbV9Sb3QjUnRvblNhVGFdZ1RlZCxVJVV6YVZhK2NaYWojWmUpWml2KDJFa29saXZFc2kwRGx1YkBNcFJhbWkjM05vMkEla0FkaXZvQW1BcG90QXNpI0F1bkVjRW5bRXAhRXN+SWRJbWFJcyZPYiprTyNuT3BhT3ViVWInJlVzIVV6aygwRW5JdCFPdHIwSWhhT3QwQWw/QmVyPkIjQmxpaGFCeWxhQypySD1KQD5Lb3NLdGVqbExhcHNMZV5MaXplTG9NYW5kb01lKU1pa01uIWFNbyxNcGFzTXVuIGFOIU4lcHROZD9OPk5mZXNlTmdyZXNOLk5rdXJzTilrdE56ZXJ2YVBhbj5QaWVQflByJyNSYl9SLXQ8Um1pZF1Sb3B0ZXZScHVzUnUmUnl0b1J6e1MhPlN0I1RfVCspVCpsVWshVXBfJlVzLVV6XVZib2paYVo8b2gyQWI/QS9Bai5BbHxBc29waXNBdiFhRWQgRWpjYXJFc1tFdmUpSWt7SXRpa0l6ZUthdj5NZStjTWl2b09jYW5Pa09uaSNPcCBPdXBhT3YjVC1VaGBdVXA/VXQoVmluI1kvK1lwKVkkYWxZdDJEbGFuI0ZySm4oS2xhTGFqXkxpL0wjTG9te0x0dSxOYVBvZGl2dVJ0Uno8VGlsMEFsIGFBc2luI0UkPDJOb11nU18uVGEsVD9UI1QnPlZgXTpCLGQ8fSluRG4oSWtLb20+TV9hTXBhTicjUz9Tb1N0dSxUaW4jVi4zQiNDa2R5REBEbj9EJyNEdi5HQF5HaWVHLCVIJUhrKEh+S3R2YXJOby9vZE50aWwjUEAjUGlkXVRgXVQ+VG1vVG9rcnVoVmhhcnRWIGElVm9ib2szQix9b3QjRG9qZWREc2soSCcuSmF2PkwtTXsjTmllTiNObyt1bVN0b3BgVC5UfDVCaSRhRGl2b2RHaSNHb3BlZEthbCBhS3tNY3xQIWFQdS9SZFNvc1RyVV5sVWhVI1VzayFWPjNUaXYoMUNlciZDaWZlck1wU2tTdCwlMEklMlJhUmkjUy46RGFtRF1HaSRySGFnb25Key1KIF9KPCBhS2FrSyc/S3JfYUxbTC5MfEx2P01pbiNOZCtOa29SbihTYWtyU2tvdFNvcHUkVD9UcmkjVHVyIGFaYW4+Wml2b1psIFp1ciMyTG9bMH1hbmlrRCBhJUQnLkxhc2FMKm5OdG9sI1RsYVRvXlRyWmUsM0csJUh+SHUrSy5Lcm9mb25MQD5MaW17ckwoTWkjTmMnJk5pW3JOb217TnVsKFMjU3RyWHwyQWQoSGFIJy5Pa1MhVXYgMUkvT2hlbTBCaWxDbihEXyNEbCBbSHlsYUtyb0wtdWxhTUB0I05hci9hTm9rbE4kcnVtTnR8Tnp1blNhelNreXRTdFRpdmElVDwjVHkjVS9hVWRyKFphaSNaLVpvbDJBbTxBdkA+S2V2VHZvbGFae1p1dCgwVCBfMURyY0ZdbkwhTWllTj9Te1RhJVpldW1aaSNudDNTbGl2PjBEYTpCKnIhfXl0IURhJURieXQtRGhvekRvYnJvRHBpc0hsYXNIbiFIb2RpK0gsZCBJdiBhSmVkbipKaSRvSm09S11uIEtvbj5Lcm0gTGV2b01heiFNbHV2IE5vbXtyT2tvT3Bha08kcm9QYCFQZXZub1BsbiBQflBvcytkUHIob1JvZCBSdWJ5UnkvXVNgIFMtIVMrcG9TdCFUb2xpa1ZALVZyL1Z6ZDx5WnYhM0JlfSFDa3lEYStrb0RiIUR1aEdhJUh7SG9eSkBKcHJ2ZUtsaWRMaWIoTWlsKE1vY08vbylPbiNQb2tvalIoUnZTbXlzbFMqbGBUdjxVcm9uVi5adnlrKzNDbylKYWtLYW1LZHlLbEt0ZSxrVHJvNUMraEhhdj9NLiVSYVItUyBfU24oVXplVmlueVZvKVpkLDVEYUQrR3tUIFRuKFRyaWUzTWZhOjBBbEFydiBBdmFEaXZFY0VobiFFam09RXogYUhham9bSWxuP0phc24gSi10S11wIExhJEwtTGlbTG9oYUx1Xk5vc09oISBPai1PdXRSYXo+UiZSdVtSeXNTYWhTbHVoYVMpciFVdlZhelZpbiBWb2RWeWsrWXYhX1o8MEFzRWxFbiBIbGAgSG8pSCwmSXR+MEJvakJ5dH1vZENpeiBFYnIhRXNsIUV2emQhRXp2YUhgJUhvZCBKe0ppbnVkS2F6SypwIExpdkx1I01sI09sbihQYFBpc1BsPVA8UHUkIFB5ayFSYXojUypkIFN0dXBTdW5Ub2tUdWRWYWhhVmUpVm9sIVYsJXRaJmsxSSZTYWpkMUxhc05pc2tvUmFeUm96IFJ5ei0yQXBFbj9MaSNOb091emwgT3Z5UmFzYVJlc1JzLVJ1aFVwYW50VXIjVXMgMEVqbi5JenwwQWtFKylFeiBMYC5MKnYhTHV2YVlsMEVoZHkxQWt8QXMtRSwlSSVJbChJc3xPLE96P1JhdmR1Um90aTFCIGFsfWUkckdpZUw/TG9qVF8wQV59fkkjSXZvTGF2YUxlcCBMbiBMJyBOJ2FPW09sIFBhK2NUQFQsaGFUdV5UeS9Wb2ogMEVwbCBJc2tPcFJoIVJsKFJva1J1YnlWPDFBfkFyRXNMaXZuIE8lMUlkMURvWzp9IV9DaUB0RCovSDwtS3RMYW5eTD5MaXZvTHVbTWYrdE1scy1OQCNOaSNOJk58TiR2b050b2YrUHJpI1JrZSlSb2RpZVIpUnUjUnlbU2UjU2l2IGFTdF8jVEB0VHJvJlYqa1puZWh0WipyLTNDI0RhZ29nSnMtS11Mb3Rvbk5hbClOZHItTnplUmlza29wUm9TdHIoVGFyXlQ/VHJvK2pWbi5YZXNvM0FuaSRhSGFKYXY/SytLbmlrTC5MbihMdWwjTnplKVBlKVMhX1N0bytUZXYmVm4/VidhcjJBJW4pQWshQW1AQW5lKUEkaSNBdCBBdmlkXUF6RS9FbUBvRW4pRXNFdGl2b0V2X0l2IU4gTm9PL2FPZC5PbVtPdXRVa1luMkJhdiBCeXR9b2RDIEN0aXY+RCFEJW4gRGVwcyFEaCtkRGl2IERrbGBEbWFuIERuaWtEb1tEcG8sRCx6RCQhYUR2b2REemltRXppZUhhbiNIbnV0I0gnPEhyb21hSHliSW4pSmkkI0ptPUtheiBLK3NLb2pLcm9rS3UpS3luTGVkbmVMaWItTGt+TG9oYUx5bm9tTWFsdU1pfk1sI01vY00kYU15cyt0TmUvIU48I051cihQYCFQX1Bpcy1QbGEvUHJvcyBQcyFQdWRSYCVSJVJvZFJ1L2FSeXZTYCBTZWRTaWxhU2tva1NsYW4+UypkIFNwb2x1Uyl2YVN1ZC1TeXBUYWhUI25UK3NrVG9tLVQsdmFUdXBhVHZvLFUjelV0b1V6ZHJvVmFoYVZpZGxhVmxha1ZvelZyL1YkIVZ5a1Z6ZGUvWmQsdlplbS1abiEtWjxadiEyQWN8QWg8eUFrdGkjQStzQW90PkFwPC1Bc2VBdl5JbmNpcEtub09idWQgTyVudG9PZGVqT2Zlc2VPaCxPai10T11tIE9taStPbmlrIU9wYE9yb2tPc1tPdG9uT3V0LU92YXpTI3YjU3RAVWRrKFV0Vi1Wb2g8eTBBbj5Pdm9kVHJ1aDBBY3R2bzBCZXIpfURsS2F2PktsLktyK0x0TXBhTmNQQFNhU2luI1N0LlR8VHkjM1JhbWleU2tUXzo6Qy19b3REaWElRG4/RG9uRnRHYnlLZSlLJy5NQG9NcCovTmRlUmEvUiBhUycmU3RyVG8rJFphbiVaaWRdM0FnfEFrJUNlcHREYWt0PEZlckB0Rit4Sm5va0tsYW1hSzxkS3J1dEt0PFB1KSVWaXplVm1hVm9sdmVyWmVydmEzU2t8WmlrbzVCb3RpI0Rva21ASCcjSytLb2tvTWFue29QJ29kUHUvYVJlanNTb2xTdGwuVG1pJHJUb3BlZFR1bl5VYkAjVS9vVXBVLFYuVm4/WmI8Wi9vZFpkIVplem4hWmhvZCVaaW4jWmplemRaI3paXWhhWm1hclpwYFpydS9ac2FoWnRva1p1bVp2b2Q1QnJpI31gXUthdj9Lb3BpczNCYUJvbCd9bChEXVBgXVQuWig6RGkkYUghS29NPk1pemQhTW8pTiAjUmRpbiNTYW4jVF8gWltaQD8wT3IwSHwxQixuI0Nlc2VEYF1EaW1AdERdSG4hSm09S2UsSylLdW5eS3ZvamVNQG9Ob1J2aXNTYCBTaG8sU2tva1NsIVN0LFN1dlN5cCFUW1QuVGshVH5UcnYhVmVyWiZtMk9eUn4wRm9uTG4/UiNSb3QtUnVwVHVhJTFBZmFuZHJBbGlza29BbnpAQXV0RXB0aWtJY2FMYFtMQD9Mb0x1ek9bTyNuT3JvUmlwKVJ6VXAuVihWciYwQWJpI0FkaWRdQW4uQSRBdm4oRWR8RXA+RXZhRXouSWJJJkl6bj9Pbk91cC1Pdm9VL1VoYVVuJVVwI1phMEEsZ2RFKSZJbCR2b0wqdmFPZ1JgUmtSdCNVdC1Zc2wwQWRBaGFPYjBCbyl9YUQnI0tvbFAjVHZhVWJvalVjIFVkJVVobGFzVWxgVW0sa1VwLHZhVXNlZFV0b2tVdmlzezBBbCcmQXMgX0lzTGF2T2QtT2pAPk9sdU9uejxPcm4oT3UkYVIvYVUkIDFBbl5BekQlTmFOPk92biFQQFN0VWIxQW4/QXIoYUF0aSNBdltFaG5vRXojT2RvbGFPK2tPcGFPcm5vT3VwIVJhL1Jlc1JoflJvbVJ1JlVkJlVwbj9Wb2xZazBCai10QnRyb3B5fWFyRChLbm9OZCFOPVJpayFhUicuMEFoQWwkdm9FdHJBdFtBei1JcytJdC1PYm9eT2RpZF1PciNSYWIyS2F2I0tvdE4tTic+UCFQayhSJyhTX1QoOkIrdCNCdStIKm5KZW1ub0pmdW5KZ2FKIEpuKEt0aSNNaCtNcG9uTmN8Tj5Oa2VyUGUpVkAuWiFfM31uaSNIZHlLdXQuTGVmb25Nbm8pTmRAJU5pJGFOPFBdKVAmUHJ2ZVJhcGllUm1vcyNYdGlsM31vU2tvcGlzVHUrazFBZCtjQW4uMEFwI0VzayFVa290VXBhMEVsMUErKVBpbiNQb2xSem9VaGFVK2MyQWQ/QWt0PEFtcEFzYUF2ZXJ6YUVmIEUkRXo8SGF2LkhsLk8vdU9qP09zI091W1AlUCBfUGsoVWI+VS9sIFVobD9Vc1YhMkR5SH5IKE5kLFJpJGFSJmpaZW1za28wQXJvaE9yW1JkKFJ6MkdyS2V2OjBPaChPemVSIVIqcy1SdXNZdCcmMEhvVGl2KDBJdiAzUmAgMUVkbiFJJCBNPTBBeiFfTGlkbiBMb24gT3R2IFJvaiAwSSVJKU92IDBZdmBdMEF2IElmPG1hSWt+MUFkfkwhbiBMeX5PdXQhUmF2IDFBbkF6IDBFZH5JbHxNcnQgTmBuIE49T3VkIFRsIVRyfjBBaHxLIUx1bSBPfk9wQD5SKnMgMUFsIE9sbiBPeicjM0QsdiBFbEVuLkwuTiE6R29uTC9hTCpuTmFOXmxOaWwjUmFuUmhhbnlSfDFFbGt1SG9kME92YTBEcm9HZSklSiVMYmwqZEx7cmhMIF9MbW9jTHJ5W05rJ1Jhbl5SemVTXyNTa3J6ZVNuP1Nwb2R1UylUZXIuVmVyIzNCLCV9ckRlb2gsRC5EK0xhTj9Te1RhbCBhWmVaICMwRXpkMExgVXMwQWojQWtBcz5Fdm9IayhJdk4nI091cCExVWN8VWswRGFEaXYoRG96JmtEJHZvSkBza3lKJkpza29MYW50TFtMIExub1NrJyNaaWRdWicmMFJhdm8xQWI+QSV0QWhBKUJhfW8ra0ghU3R2YVR1KzBBZCBUKnAgVHVwMElwNEJhdiBCciF9fEQhRCxGb3QgSCtkIUh+SG9kIEgsZCBIdWIgSmFzbiBKe0ptPUtdcCBLb24hTC0hTWF6IU1leiBNaXp7TXlzK3ROZS8hTmlrIU51dCBQYCFQbCEgUCx2IFB1JCBSYXogUiduIVJ2IVNsJyBTb2tvUyl2IFN1flN5cCFUYXMgVGVzIVRyISBWaX5Wb2whVnJoX1pkb2IgWm4hMEFkdUJ1ZCB9b3AgRDxEdS9EeS8hRSR1cEgrZGVtS2F6THlrIU5pa09yLVAqLFRhaFQtOjo5OTNMb2Zvbjo6QnIhQnlkK3R9fERhcm1vRHVzIEYqayFIbHQgSG9kIEgsXkh5fkohPkp7SmkkIEsrcCFLKnAgTGVwIE1leiBNb3QhTXlzK3ROZS8hTmlrIVBsISBQb2ogUHMhUmF6IFMpdiBTdX5UYWogVGVtbiBUa35Vam09VmFsIFZlK3RWaW4gVm9sIVZydCFadm9uIDBBdiBSdXN1VWR8WXQtMUErI0FybWFBdG4oSXZvT2IgUm9qVmloWW1gXTBMQC5NYW5NLlB0IVpgdVpkb2xhMkF0IEx0fkx1Ym8jT3QnIFJ1WzBNYU1uPzBFbW4gMExhbSFPdW0hUiEjVW1hdiMwQXRvRWgjT1tPbU8kT3p2eWswQXB8QXJBdC1JamVJentPY24gT2RyIVJ6bC5VdHwwQWtBbChBbUAhT3Z1MEIseiBUYXYgVWItVWZhKzBMb2QgT21hbCBSYXZhUiggUnVkI1J2dTFBXkFuIENgXU4gKE5vT3YmWS9sIFphdigxSS9hUiEgMEInLkJyMEVkfkVua3VFc19hT25SIVVrJ29kWWtcIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDI1ZjQ0NTU1ZjRhZjI1YjUxYTcxMTEzNmUxYzdkNmU1MGNlOWY4OTE3ZDM5ZDZiMWYwNzZiMmJiNGQyZmFjMWFcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWN6XV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdDeiBleHRlbmRzIHdvcmRsaXN0X293bF9qc18xLldvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ3plY2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVXNpbmcgdGhlIGNvbnN0cnVjdG9yIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSwgaW5zdGVhZCB1c2UgdGhlXG4gICAgICogIFtbd29yZGxpc3RdXSBzaW5nbGV0b24gbWV0aG9kLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImN6XCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0N6YGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdDeigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdDeiA9IExhbmdDejtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctY3ouanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdFbiA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBlcmxlb25hbG9yZW5zZWluY2VyZWdlc3RpY2l0U3RhbnZldGVhcmN0c3NpI2NoMkF0aGNrJnRuZUxsMEFuZCNJbC55TGVPdXRPPVN8UyViL3JhQFN1cmRVJzBDZVtDaWR8Q291bnRDdSdIaWU9SWRPdSwtUXVpKlJvW1RUXVQlVCpbVHUkMEFwdERELXREKltKdSxNLlVsdFY8KVZpKTBSb2ItMEZhaXJGJWRSYWlkMEEoRUVudFJlZTBFYWQwTVJScCV0UyFfcm1CdW1Db2hvbEVydEkmTExleUxvd01vLE99UGhhUmVhZHlTb1QgV2F5czBBPnVyQXooZ09uZ091bnRVJ2QwQWx5LENoJUNpfEcgRyFHcnlJbSRLIU5vdW4pTnUkT2AgU3cgVCZuYVRpcXVlWGlldHlZMUFydE9sb2d5UGU/UCFQcm89UmlsMUNoQ3QtRWFFbmFHdWVNTWVkTSVNeU91bmRSPCtSZSxSaT1Sb3dUVGVmYUBUaSxUdyVrMEtQZUBTYXVsdFNldFNpLFN1bWVUaG1hMEghPk9tVGF7VCZkVC51ZGVUcmFAMEN0XUQuR3UsTnRUaCVUb1R1bW4wRXJhK09jYWRvT2lkMEFrZUEqQXlFc29tZUZ1bEt3P2QwSXM6QnlDaGVsJUMjRCtHTDwpTGMjeX5NYm9vTjxhTm4gUlJlbHlSZ2EoUipsU2VTLVNrZXRUdCEzQV5BbkF1dHlDYXUnQ29tZUVmRiVlRyhIYT1IKGRMaWU9TG93THROXk5lZi4vVHJheVR0IFR3ZSZZI2QzQ3ljIURLZU5kT2xvZ3lSZFJgVHQgX3tBZGVBbWVBbmtldEEsRWFrRVtJbmRPb2RPW29tT3UnVWVVclVzaF9yZEF0RHlJbE1iTmVOdXNPa08sUmQgUihnUnJvd1NzVHRvbVVuKVhZX3tldEEoQW5kQVtBPUVhZEVlemVJe0lkK0llZklnaHRJbmdJc2tPY2NvbGlPayZPbnplT29tT2AgT3duVXNoMkJiIURkeUQrdEZmJG9JbGRMYkxrTCF0TmQhTmsgUmQmUmcgUixTUyhlW1N5VHQgWSBaejpCYmErQihCIUN0dXNHZUtlfkxtTSBhTXBOTiROKWxOZHlObiNOb2VOdmFzTnkjUGFiIVAuJFB0YShSUmIjUmRSZ29ScGV0UnJ5UnRTZVNoUyhvLyFTdSRUVCRvZ1ReVGVnJXlUdCFVZ2h0VSdVdF1WZTNJbChnTCB5TXxOc3VzTnR1cnlSZSRSdGEoX2lyQWxrQW1wXUFuK0Fvc0FwdCBBcitBJ0F0RWFwRXtFZSdFZkVycnlFLEl7JkllZklsZEltfXlPaSlPbydSIy1VeyFVbmtVcm4wRz9ObmFtI1JjIVRpeiZUeVZpbF9pbUFwQXJpZnlBd0F5RTxFcmtFdiBJe0l8SWZmSW1iSW4tSXBPe09nTydPYE91ZE93blViVW1wVSwgVXReX15BLEMjdXREZUZmZWVJbEluTCFATCVMdW1uTWIoZU1lTWYldE0tTW0jTXA8eU5jIHROZHVATmZpcm1OZypbTn1ATnNpZCBOdHJvbE52KClPa09sUHAgUHlSJFJlUm5SKkAvVHQjVV5VbnRyeVVwIVVyJ1VzKFYgWW8+X3tBZCFBZnRBbUF9QXNoQXQgQXdsQXp5RWFtRWQuRWVrRXdJe2V0SW1lSXNwSXQtT3BPW091Xk93ZFVjaSRVZWxVaSdVbWIhVW5eVXNoWVksJDJCZUx0dSpQUGJvP2RSaW91c1JyfFJ0YShSPVNoXS9vbVRlM0MhOkRNYStNcE4pTmcgUihnU2hVZ2h0IFduWTNBbEJhPkJyaXNDYWRlQ2VtYiBDaWRlQ2woZUMlYT5DKmEnRXJGJidGKGVGeUcqZUxheUxpdiBNPGRNaSdOaSROdGksTnlQP3RQJmRQb3MuUGBQdXR5Umk9U2NyaWJlUyB0U2lnblNrU3BhaXIvcm95VGFpbFRlQFZlbG9wVmkpVm8+M0FncmFtQWxBbSNkQXJ5Q2VFJ2xFdEZmIEcuJEduLnlMZW1tYU5uIE5vc2F1clJlQFJ0U2FnKmVTY292IFNlYSdTaFNtaVtTJWQgU3BsYXkvPClWIHRWaWRlViUpWnp5NUN0JUN1bXxHfkxwaChNYShOYT5Oa2V5TiVPclNlVWIhVmVfZnRBZyNBbWFBLC1Bd0VhbUVbSWZ0SWxsSW5rSXBJPU9wVW1ZMkNrTWJOZVIoZy9UXlR5MUFyZjFOYW0tOkcgRyFSbHlSblJgU2lseS9TeTFIb09sb2d5T25vbXkwR2VJdFVjYT4xRiV0MEcxR2h0VGggMkJvd0QgRUByLUVnPHRFbXxFcGg8dEV2YXQlST5TZTBCP2tCb2R5QnJhKUVyK090XVBsb3lQb3cgUHR5MEFiIUFAREQhW0QlJ0VteUVyZ3lGJSlHYStHKGVIPClKb3lMaSxPdWdoUi1oUm9sbFN1KlQgVGkqVHJ5VmVsb3BlMUlzb2RlMFUkVWlwMEFBJ09kZU9zXVIlVXB0MENhcGVTYXlTJilUYT4wRXJuJEgtczFJZCYpSWxPa2VPbD0xQUBBbXAhQ2VbQ2g8K0MuZUNsdWRlQ3UnRWN1PkVyY2knSGF1LEhpYi5JIUksSXRPdC1QPGRQZUBQaSpQbGEoUG8nUCpbVCZkVHJhMEVFYnJvdzpCci1DZUN1bHR5RGVJbnRJYH5MJ01lTWlseU1vdXNOTmN5TnRhc3lSbVNoXVRUJFRoIFRpZ3VlVWx0ViUuZTNBdHUqQnJ1P3lEICRFRWRFbE1hIU4pL2l2JFReViBXM0IgQ3RdRWxkR3UqTGVMbUx0IE4kTmROZU5nIE5pc2hSZVJtUixTYyRTaFRUfVtYX2dBbWVBc2hBdEF2JUVlSWdodElwT2F0T3tPJU93IFVpZFVzaFlfbUN1c0dJbExkfm93T2RPdFIpUmUsUit0UmtSdHV9UnVtUnc/ZFNzaWwvIFVuZFhfZ2khQW1lRXF1fEVzaEkmZEluK09nT250TyxPd25PeiZVLjJFbE5ObnlSbmEpUnlUdSo6RCt0SW5MYXh5fiB5TWVQUmErUmJhK1JkJlJsLVJtfFNTcFRlVGggVStaZTNOICROaXVzTipOdCFOdShlL3UqMk8sMEFudEZ0R2chTmcgUmFmZmVSbFZlX2RBbilBKkFbSWRlSW1wJ09iZU9vbU9yeU89T3dVZV90RGRlW0xkT2RPJ1JpbGxhU3BlbFNzaXBWIG5Xbl9iQSlBKEFudEFwZUFbQXYueUVhdEUmSWRJZWZJdE9jIHlPdXBPd1VudF9yZEVbSWRlSWx0SXQ/TjNNOkIuSXJMZk1tIE0sIE5kUHB5UmIlUmRSc2hSPSxUVmVXa1o/ZDNBZEFsYEFydEF2eUQraG9nSWdodH5vTG1ldExwTlJvM0RkJkdofk50UFJlLyV5NUJieUNrZXlMZExlTGlkYXl+b3dNZU5leU9kUGVSblJyJVInU3AuJC9UZWxVclYgNUJHZU08TWIhTSVOZCpkTmdyeU50UmQhUnJ5UnRTYjxkM0JyaWQ6MUVPbjBFYUVudGlmeUxlMk4lZTRMTGVnJEx9WzBBK0l0YT5NJidNdX1QYUBQbydQcm89UHVsJzBDaENsdWRlQ29tZUMqYSdEZXhELWE+RG8lRHUscnlGPHRGbC10RiVtSGEhSCAuSXRpJEplQEp1cnlNYT5OIE5vY3xQdXRRdWlyeVM8ZVNlQFNpZGVTcGkqLyRsVGFAVCBlLFRvVmUsVi5lVm9sPTNPbjBMPGRPbGE+U3VlMEVtMU9yeTpDa2V0R3U/Ulp6M0Fsb3VzQW5zfnlXZWw5QkluS2VVcn15WTVEK0kpTXBOZyFOaSVOay86Tmc/b28zRW5FcFRedXBZM0NrRER9eU5kTmdkb21Tc1RUXiZUZVR0JldpNEVlSWZlT3tPdzpCQmVsQiVEZCBEeUtlTXBOZ3VhK1B0b3BSK1QgVChVZ2hVbmRyeVZhV1duV3N1LlkgWnkzQWQgQWZBcm5BPUN0dSpGdEdHJEcmZElzdSpNI05kTmdgTnNPcD9kU3MjVHQgVmVsM0FyQiB0eUJyP3lDJidGZUZ0R2h0S2VNYk0uTmtPblF1aWQvVHQhVmVaP2Q1QWRBbkIsIEMkQ2tHLU5lbHlOZ09wVHQgeVVkVW4rVmVZJDVDa3lHZ2ErTWIgTj9OXlh1cnkzUi1zOkNoKGVERy1HfXRJZElsSW5KJUtlTW0kTk5hK05kYT5OZ29Oc11OdSRQIVJiIVJeUmcoUihlUmtldFJyaWErU2tTcy8gVF5UIGkkVGhUcml4VHQgWGltdW1aZTNBZG93QW5Bc3UqQXRDaDwtRCREaWFMb2R5THRNYiBNJXlOdF1OdVJjeVIrUi5ScnlTaFNzYStUJFRob2QzRGQhRG5pZ2h0TGt+XU0tTmROaW11bU4lTnU+UmFjIVJyJVMgeVNzL2FrZVhYZWRYdHUqNUJpIURlbERpZnlNTXxOLiVOa2V5TiwgTmBPblIkUmVSbihnU3F1Lm9UaCBUXVQlVW50YShVJ1ZlVmllNUNoRmYoTGVMdGlwbHlTYyFTZXVtU2hyb29tUy0vVHUkM1NlbGYvIHlUaDpJPU1lUGsoUnJvdy95VF1UdSozQXJDa0VkR2F0aT1HIUBJYCBQaGV3Uj0vVFR3JWtVdHIkViBXc1h0M0NlR2h0NUIhSSdNKGVlT2QhUm0kUmBTZVRhYiFUZVRoKGdUaSlWZWxXNUMhP01iIFInVDpLMEV5SmVATGkrU2N1KlMgPVRhKFZpb3VzMEN1ckU8VG9iIDBPcjFGRiBGaSlUJjJMMUF5MERJPVltcC0wSXQwQ2VFSSNMKGVMeTFFbkVyYUluXVBvJ1RdMUFuK0IuQ2g/ZEQgRCg/eUc8SXxJZygkUGg8MFRyLWgwSCAwVGRvJVQgVHB1dFRzaWRlMEFsRW5FcjBOTiAwWWcmMC8gME99OkN0RGQhR2VJckxhKUxtTmRhTmVsTi1OYCBQIFJhZGVSfFJrUnJvdFJ0eVNzVF5UaFRpfFRyb2xUdCBuVSdWZVltfDNBKUFudXRBckFzPHRMLTxOTiR0eU5jaWxPcCFQcCBSZmVAUm0uUnMjVDJPfU90b1JhJ1lzLSQwQW5vQ24tQ3R1KkUpR0dlI35Mb3ROa099IFBlL29sVF5aemFfKUF9dEEsLUE+QXlFYSdFZCtVe1VnVW4rMkVtRXRJbnRMP0xlTGkpTmROeU9sUHVsP1J0XVMuXVNzaWIhL1RhdG9UdCB5ViB0eVdkIFcgX0BpKUFpJ0VkLXRFZiBFcGEqRXN8RXR0eUV2fEkpSWRlSW0/eUludEklLnlJcyNJdmE+SXplT2IhbU8pW09kdSlPZi5PZ3JhbU9qZUBPbW8+T29mT3AgdHlPc3AgTz5AT3VkT3ZpZGUyQmwtRGQoZ35McEwnTXBrKE5eUGlsUHB5Ul5hJ1IueVJwbydSJ1NoVFp6ITNSYW1pZDo5OUFsLnlBbnR1bUFydCBFLF1Je0l0SXpPPjpCYi5DY28jQ2VDa0Q/RGlvSWxJbkknfnlNcE5eTmRvbU4rUGlkUmVUZVRoIFYmV1olM0FkeUFsQXMjQmVsQnVpbGRDJGxDZWk9Q2lwZUMlZEN5YyFEdSlGIUBGJW1GdSdHXUcqdEd1bD9KZUBMYXhMZWEnTGllZkx5TWEoTWVtYiBNKGRNbz1OZCBOZXdOdE9wJlBhaXJQZWF0UGxhKVAldFF1aSpTY3VlU2VtYiFTaSxTb3VyKVNwIydTdWx0VGkqVCphdFR1cm5Vbl1WZSRWaWV3Vz9kMllgbTBCQmIjQ2VDaERlRCtGIUdodEdpZE5nT3RQcCFTa1R1JFYkViA1QWRBLEJvdEJ1LENrZXRNPClPZk9raWVPbVNlVGE+VWdoVW5kVT5ZJDVCYiBEZUdMZU5Od2F5UiQ6RERkIUR9W0ZlSWxMYWRMbSNMI0x0THU+TWVNcCFOZFRpc2Z5VG9zaGlVKVVzYStWZVkxQSFBbkEqQXR0IEV9SGVtZUhvb2xJJilJWyVzT3JwXU91dFJhcFJlJlJpcHRSdWIxQUFyXkFzI0F0QyNkQyp0Q3RdQ3VyLnlFZEVrR218TGVAfk0oP05pJU4nTnQmKVJpZXNSdmkpU3NdVHQhVHVwViZfZG93QWZ0QWxsb3dBKkVkRWxsRXJpZmZJZWxkSWZ0SX1JcEl2IE97T2VPb3RPcE9ydE91bGQgTz1SaW1wUnVnVWZmIVkwQmwoZ0NrRGVFK0dodEduTHxMa355THYgTWlsP01wIU4pTmdSJi8gVHVhPlhaZTFBPkV0XklJbGxJbklydFVsbDBBYkFtRWVwRW5kIEkpSWRlSWdodEltT2c8T3RPd1VzaDBBbGxBcnRJIU9rZU9vYDBBe0FrZUFwSWZmT3cwQXBDYyBDaSRDa0RhRnRMP0xkaSBMaWRMdXRdTD1NZSNlTmdPblJyeVJ0VWxVbmRVcFVyKVVgMEEpQSpBdGkkQXduRWFrRWNpJEVlZEVsbEVuZEggZUkpSWQgSWtlSW5Jci5MLk9pbE9ucyVPI09ydE90UmF5UmVhZFIoZ1kwVWEqVWVlemVVaXIqbF9iIUFkaXVtQWZmQStBaXJzQW1wQW5kQXJ0QT5BeUVha0VlbEVtRXBFKm9Je0lsbEluZ097T21hXk99T29sT3J5Tz1SYT5neVJlZXRSaWtlUiNnUnVnZyFVZHxVZmZVbWIhWSEwQmplQEJtLkJ3YXlDKVtDaERkJkZmIEc/RyssSXRNbSBOTm55Tid0UCBQcGx5UCptZVJlUmZhKVIrUnByaSdScm91bmRSPXlTcGVAL2EoMUFsbG93QW1wQXBBcm1FP0VldElmdEltSW5nSXReT3JkMU1ib2xNcHRvbVJ1cC9lbTpCIUNrIUdJbEx8TGtOa1BlUit0U2svZVR0b29YaTNBXkFtfk5OPHRObmlzTnRSbS9YdF9ua0F0RW1lRW5FJXlFKkV5SW5nSXNPdWdodFJlZVJpPVJvd1VtYlVuZCAwQ2tldERlRyBMdE1iIE1lTnlQUmVkU3N1ZVQhNUEsQmFjY29EYXlEZGwgRUdlYCBJIXRLJk1hdG9NJXJvd05lTmd1ZU5pZ2h0T2xPYFBQLVBwIVJeUm5hZG9SdG9pJ1NzVCRVcmksVz9kVyBXbllfe0FkZUFmZi1BZy1BKEFuc2YgQXBBc2hBPWxBeUVhdEVlRW5kSSRJYmVJe0lnZyBJbUlwT3BoeU91YiFVe1VlVWx5VW1wZXRVLFVgWTJCZUl0XU1iIU5hTn1sUmtleVJuUnQhMUVsPUVudHlJKUluSSxPMVBlUC0kOjVMeTVCKmxsYTBBYiFBd2EqQyFDb3YgRCBEb0ZhaXJGb2xkSGFwcHlJZiVtSXF1ZUl0SXYgJ0tub3duTG97VGlsVXN1JFZlaWwxRGE+R3JhZGVIb2xkT25QIFNldDFCPEdlMEErRUVkRWZ1bEUhW1UkMElsLnk6Qzx0Q3V1bUd1ZUxpZEwheUw9Tk5pc2hQJVJpb3VzL1VsdDNILSFMPXROZCVOdHUqTnVlUmJSaWZ5UnNdUnlTJ2xUIDwzQWIhQnI8dENpb3VzQ3QleURlb0V3fmErTnRhK09sKFJ0dSRSdXNTYVMuU3UkVCRWaWQ1QyRJKUlkTGM8b0x1bWVUZVlhKzpHZUcjSXRMa35MbnV0TnRSZmEqUm1ScmklU2hTcC9lVCBWZVkzQWxgQXAjQXJBJ2xBYCBCRGQoZ0VrJmRJcmRMY29tZS9UXyFBdEVhdEVlbEVuRSpJcElzcCAwRGVEYEZlTGR+Tk5kb3dOZU5nTmtObiBOdCBSZVNkb21TZVNoVH1bNUxmTTxOZCBPZE9sUmRSa1JsZFJyeVJgX3BFe0UsIUksST5Pbmc6OlJkM0Fyfm93OVVVbmdVYDozQnJhUm85TmVPXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHgzYzhhY2MxZTdiMDhkOGU3NmY5ZmRhMDE1ZWY0OGRjOGM3MTBhNzNjYjdlMGY3N2IyYzE4YTliNWE3YWRkZTYwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1lbl1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nRW4gZXh0ZW5kcyB3b3JkbGlzdF9vd2xfanNfMS5Xb3JkbGlzdE93bCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nRW5dXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJlblwiLCB3b3JkcywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFbmBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nRW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nRW4gPSBMYW5nRW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nRXMgPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xhX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2xhLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBhcmVydG9pb3RhZG9ub2FSdGVpcnJvZW5hTm9uYUxzb2xvY29pbGlhcmFsYW9ycmVuYWRhQ2hvTiRuMEE+RG9tLEVqYUkhI09nYSZPJ09yI1Jhem9SKlVlPVU8MEFiIEFkZW1AQ2U8Q35FaSlFbGdhRW4jRXB0IEkmTCAgTmVPZyFPPFRpdm9Ub1RyaXpUdSBVZCpVISZVcyAwSWMjTWl0Kk9wdCBPcidVYWBVbCMwUmVvMEVjdCBJY35JbiBJcm0gMElsSXQgT25AT3MjT3QgUmVnIFIkVWFVJlU/YVVqYTBPZ29PciswUmVTbCAwRWRfekUnVXMpMUFjW25BbWJfQXJtYUJhQnVtQ2FsZGVEZWFFZ19FaiBFciVFJUY/IUdhR28mbklhJkksI0l2JE1hTWVqYU1pYiBUIFRlemFUaXZvVG9UdVtVbSdaIDBBYmxlQW4pQXBvXUFyZ29BcyBCIEJpI0UnSWdvSXMlZE9yUCBvUGwkMHxvQ0AnQ11EIEQsRW1AR3U9SWw9SW1vSXNPdCBULGFUaWd1b1Rvam9VYWxVbCBVbmMkQWQqRWpvTzFBZyBBWyNFdGkjSW9MaWMgTyZPcilPeW9SLGQhUm9iIFVlcyVVKzFBJkFgQXJCaXQrQm9sQnVzI3xpdm9Db0QhRD9dRHVvRWFJJkllc00uaS1lc09tYVBhUC5SZWc9Um96UnVnYVRlVGlzJTBBQSZBbCNDLDxFZ3VyIEVvRTxySSwjST1Jc3QqTm9PbWIrUCFvVD9dVCtUdSNVbSpVbiMwQWpvQXF1ZUFyRW4jRW9JPkxlJU9tb1JhIVJvelVuMERhekQkR2VMYU0sI1MsKVReMEFsQW5jZUErRUVsXWBFYEVzdHJ1ekkuSTwyRXJVe1UnMEFmW25Bck8pVWMgVWZfVWw6QmFCXnxlSEBJbGVKIExhbnovYy5MZGVNYnVOPk5kLW9SYig+Um5pelIrU2N1XVMjblN1W1RhbF1UIUBUKlR1JVVsWiAzQmVCaWQvPVMgU29TdEAzfG9Fbk5nbzJBbj5PcXVlVXNhMkFCaWBCb0NhQ2lgRGFEZWdhSW4vLyFvTHNhTWIte2ROaSNOfXNhaVJkZVJyIFNxdWVUZVRpblZle1phbDJBdm9Bem9FY2hhRXZlSWw9SW4+SXNhT2NhT21hT25jZU8pVWphVXM+VSMyQ2VvQ2xlRSdFeUZhbntGLkhvSXRfTCNSYnVqKGwoK1NjIFRhY2FaLjpCYWw9QmV6YUJpYEJbQ2FvRGF2IUQsYUVyRmVJe0ltYW5KYUouTExhbSBMYyRMJkxpe2RMbGVMbS9eTHZvTWFNYiRNZWw9TWknTXB9YyFOZD9OZWwtZ3UrTmljLSNOLS5PYmFPc1BhelBpJW5QbylQdCBQdWNoKChiLlJjZWxSZSVSZyhpJ1JuZVJwZSVSK1IlU2FTPlMhb1NwYVMjclReY2VUX1V7bFVzYVpvM0JvbF1EIUQrTGQvZWJfTG88THVdTSwjTml6LXQrUmMoJlJleihvUnIgUil6YVNwZWRUKzJBY2FsQWxlPkFtcHVBbmNdQXBhQXJdST5JcylJdm9PcXVlT3phVWxlJVVwIDBDbC5FZ29FPUVuRXIjRltHICtNLT5OZU4lUF9zUj5SdWVdU25lVGFVe2QyQW1eQW5BK0FzZUF2ZUksKUltYUluaWNhMkJfQ2N+fGknQ2lgQ29EaWdvRG9GX0chSGUpSmluSm9ML2NoL2VnJExnIExpbi9sIExtb0x1bWBNYmEpTSFNaXtNbyZNcHItZGVOZWp9Zy1vYyFOc2VqfXQgUGFQaShhei5SYmElUmNob1ImblIuKHIhUyFTbW9zUyUyQW5lb0F0IUUgRWMhRWkmRW1hSWFJbSxJcCVJc2lzT21vT25pY2FPcXVlJVUmVXoyQWQrQXIjQXQrQm9Ccip8IGFFbD1FbiNFcntFcyVFdmFJZCBMZWJyL3AvI01iX01wbCpOLWUlTyVQLlB1bCggUiQ8UjxSdmFUaXM6TS16KFImVD8zQiFCP0Nhe0MqRG9GLHNhRmluKkogTGZpbkxnYSZMaSNNXi08TiVsUF4pUmVjaG9SKyVTYXl1J1Nlb1NmP2VTbnUmU3RpJ1N2JFRhbGxlVCwhVXszQUFiPUFkZW1hQW1hbilBYEFyJEJ1am9DdCBFbilFJUV6RmljP0cnTGVtL3UqTiFvUmVjI1JpZypTPlNlJ1NmW3pWYVZpJzVCbGVDZUxeTWluZ31OIFJhJlJtKlI8U1NpczJBZy5PZ2EyfGFEYUU9RSdMY2VPUXVlUiBSZXoobzowQSdSJDBIIE9VYSZyMEFkSWN+SWZpYyRJI3JVYyAxRWMjSWNhejNFRW1wPTFFZmFuKUVnKkVtLCNFdiBJcHNlSSlJeCpPZyRVZCowQnUmSXQqT2N+UGEpUGUnUGxlb1Bfc2EwQSdDIGdvfHVmZUNARW1pZ29FK0ZhJkYhbW9HYSdJZ20vYWNlT3JtZVJlJlNheW9TLCBUIW9UciBWYXNlViQxT2NhMFVpcG8wSXpvMENhXUMsYUNvbCBDcmliKkN1JkVuY0BGIWFGdSF6b1Bhe1Blam9QQFBvc2FQdW1hUXVpVCBUZVRpPVR1ZmEwQXBhRXInSWMtQDFBZCpBbHUgRW4jSXQgMUFjI0FtLENlPEN1c2FFbiNJZypJbCRJc3QqSSNQISNQbGljIFAuIVRfbW86QnJpY2FCdV18YXtDP0MjckVgSi9kLz1MPEx0IE1hTT9ATW88UmEuUm1hY2kob2xSc2FTZVRpZ2FVYFZeWDNCciFvfC9pek9SaShvelJ0P1J2XlN0aW4zQWJsZUFuemFBckJbQ2N+fGFEZW9FYl9FbEVbRXMlR3VbSiBKb0wvZSlMQGxMdCtOTmMtZypOaSNSbWEyQT5BdSVFY2hhT3JPJVUqVWpvVV4yQkBDYUdhJUcuTCRMbGUjTiZSbSgrUnR1bih6IFNhVG8yQWNhPEFnP0FuamFBc2VBdWRlRSpFJ0VzYUlvSSNVJTJFZ29FbilFcnphR2FNIE5jfk5kKGcuUkBTP1Rib2xUdSs6Q2VdRmFzSSVKb0wvIWkvPU1iLSBOY2h9Zy08UmFqZVJ6YVNvbGlgU3QgVG9WP2FuM01lPU0qTk4hfSROKVJhbiRSLClSbSxTIzNHYW4pTWBzJFIgUm8yQWNpIE9ib09yQDJMTGZvTG88THBlTSgmUj8oW1RhVGVvWiAyQXtBZmk+QSdBc2FBdGlzQXZlSWUlSWw9SXBlSXNJI088clVhVWU8VW1vVXBvMkFuKUFwb0FyZEBFcltJYUknSS5JPEl0IFtTYSdTdCA6QiFCP0JsIEMhfGFEL2wgTWFjKGlgWlphYDNCP11CW3xvTGEmTCRNYnIoKlJtYSdSb2VSdiozRT1FcitHYSZHaSxlSm9NJ1MjckA1Q2k+RyBHdSFhSmFNYl9OZ31eTnIoKG1pZygnU3Q/WW81RT5FbGdhRXIlRTxFdm9Je0lyTWEnTWUmTT9kZU19ZCpSYWNhblIjOjFPJzBFYWxJb21hTz0yTGVzaS91VWFsNEVnYWxVc34wQWcsQW5JdCBQIFAhJFAuIVB1bDwwQ2FwYXpEaWNlRXIpRmllbEZebWVHLCRJYyRNLDxNdW5lTmEjU2VjI1MlbilUIWVzVGltb1R1KlV0P1ZpISczQUlzT25AMEwvbyk6QmFsaUIuTS5SYWJlUmRpblJbVV1abWluM0ZlUmluZ2EzTmUpNVJgZChvYmFWLFlhNUVyZ2FFdmVzRXpHYSZyR29HdWUpSWMkTj5OZ2wtJE50IFBpdCFSIFMjViw/WmcgOjdMbzVBXTpCJEMkQ1tEb0QrbkcgI0dyaW1hR3VgST5NIU1pYE1wIC0tY2gtZ29zJU56YVBpelJnb1J2YVN0aW1hVGFUZXhUKlVfbFYgWm8zQWxDY358ZUMjckVyR35HdW1iX0phJ05ndS0jTmFPbk9wICZTflRhbFRbVmVZLHszQiElZEIrQ15EIURpIEVuem9HYUchb01hTWkpTS5NcCROY2VOJk5lLWdvKU59dCFgUXVpJlNvUyVUIWFUJFQrMkFnYUFtYUFuI0F2ZUVnIEVuIEV2IE9yIE92IVV2QDJCb0N+Q29DdVtHaWNhRytNYnJpek19amFUZTV8YUMqRyBKfS1lc1BhU3QrVG9aOkNlJXxvRCFhRF9EdStFc3QrRkBHQEdvSXpMe2RMZSVMbC9vTWFNYm9NdXROPk4mTmVqIE5nLWlxdWlOaiBOfTxOJU5hYFBhUXVpbihSPlJlKGY/UmcsUmkmUm1vbFIrblIpc1J6b1NhU2MgYVNpdm9UIFQhQFRpelRyaXpYaW1vWV5aXmNhM3xhRGFsXUQkRHVdSj9dSl5MLC8uTV5pLV5Oc2FqZU4pTnVSY2EmUixndWVSaSNTUy5UYVQhVG8mVCtaY10zRSZFbEVtYitHL0xhZytMaXQgTGwuTX0tIX1pbX11I09wZVIgU2FTIUBTP1Ntb1RhZFRvNXw/YUN+RGFEZT1Ib0ogTGRlTCFMaSdNLCNNaS0gYy1lZC1qLSNOb1JhZChkIVJlJ1IqUitScyglbFNjYVN0ciBUaXZvViFWP1pvNXxvRCBFYmxlRV1FcilFc3RbR19KIUwvZSVMJU4mTmVjKGFsUm9TY3U9U2VvU2dvU2ljYVM9OkMgQ35EIElwZVJhbmooaXpSciBTYWxUYWxUaXZvVHVbbFVzZWFWYWxWZVZpe2QzQyRDdCBHIEdvYyRHK09uUnYkVG9VdCtWIFYhYTN8b0RvRWJdRSNOZXpOb1RpJlZlbDVCbGV6YXxlTWluKGkobSgpVGFUaWNAVmEjVmVdViQ1QmVDYUNsZW9EPz1Eb0VbRXZlRXpMb00hb1RyQDpTaXMwRTxJc3BvSmUjUighb1MhdiBULCFWJDBBQTxFYSdILCVIb0lvUmVUYXZvVHViX1VsI1VwIFVyciowSSBJb0lzZWEwUykwRW5zYUVyJUljJFJlYyEwUm8xRG9SME8xQUVhe0ZhI0l2b0xhTW9PclZpJjBCbGlnbzBEYVphMUE+Q35FW0luIE9uIVQgVGljYVVlcyMxQWN+QSZyQWxCaSVDYUQsRWphR2EnR0BHdWw9SSwpSWcsSWxdT1F1ZXMlVWdhMEFkQEN1K0V6J09UWzBPJ1JvMUVqYVU9MUkmSWdlJzBFbikwTyc6QyNEX0VsXUdpYEdvSXNKIG9MYWJyLz5MZSVMaSZMbS9vbS9wIE5OYWxOaT5OdCEtdWU9UGFQZWxQP11RdWUpUiBSY2VsKGVkUipSb1JwYSZScXVlUltmb1IpUyBTZW9TflNvUyVUYVQkVHJAVXNhVSVWb1lhPDNBI25DYSZDIWF8b0RhbEQqRyBJbmVMIEx7J0xlL2lnK0xsZWpvTG9MdWMtLXMgTi5Pbk9yUGknUXVlJ1IoY2goZCFSZXooZj9SaT5SbChtaTxSK1JzLmFTYVNjYVNpbW9TJWBUYT1UK2xlb1padWAzQyB8LkVFZFtFcmBFemFKYW0vIExvI01pLCVOfSNyTnotYU9qb1AoYSVTIFNjaWBTb1MlVC5aY2EyQWNhQW5BJUF5YUF6YUVpI0UnT21vVW1hVVtsMkJfQ29EIUQkRW1hRXNARSVMLExpY2kvPUx2b01he01lPU1vTXAtIVJjflIlbFNhe1NlIVNpYmxlUylULGNAVCtabzJBJkU+ekVndW4lRW0kRW5zYUU8RXYkSW1vSW5jaXBlSXN+SXYgT2FPYiBPY2U8T2R1YyNPZXphT2ZlPHJPZ1ttYU9sZU9tZXNhT24jT3AkT3hpbW9VZWJhMkJsaT58IW9EXkViPUVyJUVzI0xnLypMbS5McG9MPE0tI05hbE5vUGFQPyhlOjk5RWQgRWphRW0gRXIhRTxJZSNJbWljYUluY2VJdCA6QmEnQkBCb0N+RGljYWxJek1hTXAtY2h9Z29QYXpQaSZQI1Nnb1NwYVRvWW9aYVouM0FjY35BbGl7ZEJhJ0JvKUNhIUNlJXxhem9Db2chQ19vQyNDdXI8REQuJkR1YypGbGVqb0ZebWFGW25GdWckR2E9RypHXUdfPEgsSSdJckovYSNMZXZvTGlldmVMbGUnTG9qTSBNZWQkTX0+ck5kKk4lUCAjUGV0KlBvPFB0P1NTY2EpU2lgU3BlI1MjU3VtLFQqb1ReJ1RbI1VuKlZlc1ZpcyVZWiAzQ29FZ29FbntFc2dvRmFHaSZHXk5jLk4uT1F1ZXphU2FUbW9Ub1pvNUJsZUNlQ2kgRCBEZW9EP11Fckppem9Kb00hb01wIU5OPk57UGFQIW9TYVNjYVN0K1QgNUJpQl5Eb0V7RypJJkluL2UlTG9NYm9NXlB0dVtUYVRpYDpCYSZCIUIkQmxlQyBHYXpHWyZMLyZMIW9MKkxtLkwuTHMvI0x1ZEx2IE1iLWN+TmRpLWUgTmdfTml7ZE59I1BvUXVlUmRpbigpblN0X1RhblVgWG9mLjNDY35Db0NfI0MlREd1KklzTD1MdmFNYWBNP2wtZC08ck5hbE5eUCAgUEBRdWkoUmllUm0uUnYqUywlU35UYVQsJVYhb1hvWCMzRFtFcyVFKUc9RydMYWIvYiBMLGMkTF1NYm89TSRSLGFTKW1hVCRUdSA1Ql9DJEQkTExhcC97Jkxle2RMaSZMdCBMdWN+TWJyLWRlfWkmTm8rTnJpc2FQYVBsIFBeKVImUnBfcygpb1MpblRhJzVBdmVCKkNlPEReRWdbRT1FJ0VyKUZyKkplI0wlbk0gUCEgUGwqUC4hUF9tb1JSPlJlJ1JnKlMjVD86QmE+QmlxdWVCXUJ1Q29DI0pvTCBMPkwsI0xsLy5NYSdNYl5OZ31xdWVQYVBlKVBAUC5RdT9sKGRlUmUoaWYoamUlUm90UitSJVR1YWplVStaYVouM0F0K3xvQ11DbmljYUphJkohSmkmTC9lZm8nTWFNXk1wPU5hek5kIU4hTmlzTjxPcmkoYXBpKD5SbWknUm51cigrclNpc1NvK1N0aWdvVCFhWCNaM0IkQnUrbkVtcG9FbntFcltFPEdfSiEvZGVNYl9NaSZNfSVPUGk+UG9SKC5UYW5UIWVUdT1aYTVBbF1CPz1DIENpJ0RvRy8mTSBOfSNQIFBlUXVlUmF4UiFvUm0sJVJuZW9Sb1JwZSZSX1I8UnR1Z2FTUz5TIVhpPjJBYmFqb0FjI3JBIUFmaT5BZ29BamVBbW9BbmNlQSNBdW1hQXogRWJvbEVndWFFaW4lRW5FcCBFc0lidUlnb0lwYUlzKUl1bmZvT2Zlb09tcGFPbj5PcGFPKU96b1U+VWUnVWZhMkIhQEJvRXIjTWJhTV5OZWxOaWMoYmluKGlzbW9SJ1ReOjBJYyA5QyFhMEJbbDBJe2RJckl2ITxPVCBBM0JhJ0JlRywpTmEwQXJVICQwSWxPcEAxQTpDYUMkQ3VgRyBHb0lgSj9sL2VMaSZMbGVMXkx2dV1NcCpvUihpIFIuU28zQ2knQyNySGljdT1JbilKZXpMLyFvTG96Ti1jIU5kLWUnTmcgTipOJU51c1JSYSdSYm9SZGVSZWQoaig8UnQhM0FBamVCciBDJEN0aW1hRGFEZW9EciRFam9Fcm5lc0deTExsLWFnX059ZSZPbGluUmFsUmdvUnR1ZFNeU3AhYVMlVGFtaWBVJlZhelYhb1YqVm81TGNhbkx1bSxMdiFSYXpUIFRvWjVFPUxnIDo6OkMhVGUzR3VhTSgnU285RG9HYUd1cjpGKn1qYVBhI1J6YTkzTigrNU1vUiZcIjtcbmNvbnN0IGFjY2VudHMgPSBcImFlaW91NzY5NUBAQlpXV2F2d1VKa09AWS1LbikpWUVHcSNFQE8pY0lAI1prTUh2JGUqKSlNISEpRCoqJEdXIW9LbSpBY29oXmsmSXQtcGleU1lXKSRebiFHKWJPIVdremFtKGpTI1gpT2cqXmxeUlchYlEjUXlnQktYZnpFKSlodGkhUW0pQ25nJSVjKW1KaUkqSEpXYm1ZbmlDTHdOZFl5WSVXS09eYm5UJFB1R09yIUl2SHUmRyhHS2J0QnVoaVcmIWVPQFhNZW9ZUWVDYSMhTXJUSkNxIU9XJkNIRyhXQ2NXJSUpJHJmckllZ3UkKXchRylKR21XV3cpTW5EJVNYWFdJVF5MV0FadVZXQl5XKWVUTF54JiRXR0hXKG5LV0VNQSkjJEYkeCRXYWVrcXMsbjc3MTUpVypITS0kV0FjQ2l1KGEpKVZDWilHRyUoKkNXV2RXJSREIVVDTyRNXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHhmNzRmYjcwOTJhZWFjZGZiZjg5NTk1NTdkZTIyMDk4ZGE1MTIyMDdmYjlmMTA5Y2I1MjY5OTQ5MzhjZjQwMzAwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1lc11dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nRXMgZXh0ZW5kcyB3b3JkbGlzdF9vd2xhX2pzXzEuV29yZGxpc3RPd2xBIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgU3BhbmlzaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdFc11dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVzXCIsIHdvcmRzLCBhY2NlbnRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0VzYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdFcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdFcyA9IExhbmdFcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdGciA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bGFfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bGEuanNcIik7XG5jb25zdCB3b3JkcyA9IFwiMGVycmVsZW9udGl0ZXVyaW51ZWlyaWV0IGNlZ2VhbnNlYWxpIG1lZGVuZWwgcSllbmlsdXhhdXMgY2gwQWlzfUFuZCREaXF1IEVgI09sKk9yZCBPdSVyT3kgUmFzaWZSZXV2IFJpLFJvZyBSdXB0U18tU29sdVMnQFVzaWZZc3M9MEFAbStBam91QXIrbkNhYl1DZXAsQ2xhbSBDb2xhQENyb35lQ3V9RXJiZUhhdEhlLElkdV1JIE9tcCZRdSAqUiR5P1RlJ1RpZlQpbDBFcCZFcXVhdEhlc2lmSmVjJWZKdWcgTWV0dCFNKiBPcCxPciBPdWMqUmVzPFJvaXRVbCZWIGJlMFIgUiRlZjBGYWkhRmVjLEZpfmVGIXtGdWJdMEFjIEVuYyBJI0ksUmFmIFJlYWIjUnU/MUQgR3VgI0w+TWFiI1MvLTBPdSxVcywxQXJtIENoaW0rRXImR2ViIUcpSV8gST9udExlZyBMaWEuTG91IEx1bSBPJ2QqUGFnYVRlczxWZW8jMEEmJ0JpZ3VCIUVuYWcgRXJ0dT9JZCRJcj1PcmMgTydPdmliI1BoaWIrUCMnVXMvdDBBbHk8QXBobyFBcn4rQXRvbStDK25FLyVyRyNHb2lzPEd1I3tJbT1OZXggTiQtTilsT2QoT209K09ueT9Pcm09VF9bVGlkbyZYK3sxQWl9RXJpJWZMLypPbG9nK1BhIWBQZV1Qb3IsUHV5IDBVYXJpdW1VZWR1YzBCaXQhQnVzJkRlJ0RvaTxHX3RMZXF1KE1hdHUhTWU/bnRNb2khTXUhUF8sUmF+IFJpdiBSb31TX2ljVCArbFRpYyMwUGVjdFBoPSZQKiBTfHRTIHYqUyt0JlNvYz5TJyBUaWNvdFQhVHUtMEVsPk8/Uml1bVJvLVRhXlRfJWZUKiBUcmFwIDBCYShlQiAuRGEtRGliI0cnIFJvIVRvbVtUcnV+ZTBBXUFuYyBBcmktRW4qRXI8RXVnI0lhJidJQEkkSX1PKGVPdSBSYDFJPUlvPzpELkZvdSBHYS5HKXQmSWduYUBML2MgTGMkTGUoZUxpc2EuTWIoTmNhaSFOZGEuTmwrKU5uPmVOcXU+UmI+UmBSJFJeUnJhLlNzKFMlJFRhYCNUZXxULCtVZHI+VmFyZCAzTGV0Jkw+TG8mTmVmaS1SLXxSZyBSbChlUm11ZGFTYS1Tb2dbVGFgVXIhM0IgJEN5YyNEdSNKb3VML0woZylMbGFyZE5haSFPbG9nK09wcytPdHlwZVNjdWl0UyRTdG8naVR1P1phciEyQWZhcmRBZylBbn4qRXNzL3RJbmQgT25kT3F1IE91cyQyQmFyZEIoZUkhSX1MaUBOYiROZCpOaGUnTmlmPk51c1JkdSFSW1QmVWMjVWV7VWcrVWwkVXF1KFVyPFVzc28jVSVeWGUnMkFufmVBcz5BdmVFYmlzRX5lRXV2YS5JY29dSWdhQElsbC90SW9+ZUleT351IU9kIE9ueiBPdXM8T3llJ1U/VXNeVXQ9VXkvdDJGZiNJc3MkTCMlblJlfFIoUyUgVCggVG8qVmFiI1ZldCY6Qi8kQihlQ2hldCZEZXxEIUZlKGVJbGxvdUlzcyRMY3VdTGVwKExpYiFMbSBMb21uK0x2YWkhTWFyYUBNIGFNaSRNcGFnW049TmV0JE4kTiVbTnVsYXJQYWIjUG9yPVByaS1Qc3UjUCxQdX5lUmFiKGVSYiRlUmVzfVJpYm91Um5hLlJvdCZSIXxSdCRTY2FAUz5TXlNzdSFVfVUlJFY9PlYgW1ZpYXIzRGAjSW50dSFMZXMmTGx1I05kcj5OcycgTnRyPVJjI1JlYnI9Umk8Um4gUnZlfFN9MkFncihBaTxBIydBbWIhQW4tQXBpdCFBcmIkQXM8J0F0JEF1c3MkQXYqIEVtaTxFbmAjRXF1PkVyfiBFdj1JX0lmZiFJZ24kSW0gZUlvdExvcnUhT2NvbGF0T2lzKk88Tyl0JlJvP1UmMEdhIUdvZ1tNXyxOZW1hTnRyIFJjdV1SIFJeVCBbVG95X1RyJFZgMkEqJEE/J0FxdSBBczxBdj5JX3RJZ24gSW1hdEl2YS5PfmVPbmEuT3BvciYyQj10QnJhQ2FzPENvJSBEIERpZj5GZiFHbiBIZXNpJElmZiBJbmMgTCBlTGlicmlMbChlTG1hLEwkZWxNYmF0TWVkK01tL0BNcGFjdE5jIHROZHVpIU5mPk4uXU5ubyxOcyRbTnRhY3ROdmV4ZVBhKFArUmFgUmJlfFJkYS5Sbml+ZVJwdXNSIWN0UiYuU21pXlN0dT9UJFVAVXB1IVVyYS5VJnxVdnIqWW8mMkFiZUEoJkF2YSZBeSRFYXR1IUVkaSxFP3tFdX1FdmV0JkliXUkgSXN0PUksZU9pIU9xdSBPdGEjVWNpPVVlbFlwLDJCaV5FYGwqSWxdZUlzKGVJdiFMbSggTCV2IE11XVBpQFJhJWZSPCczQW51IUMjTChkIU5pXjpJZ24gTT5OZyBOPCdVcGgoM0JhdHQhQmksQm9yZCBCcmlkIEJ1dC90Qz0gQ2VtYiFDaCogQ2lkIENsYXIgQ29yIENyaSFDdXBdRGEjRHVjJWZFczxGX3NpZkZpXUZyYXkgR2FnIEdpdnIgR2x1JXJHcmFmIEpldW4gTGktTG9nIE0vZCBNZScgTW9sKk5pfiBOb3UgTiZsI051ZCBQYXJ0UF99UGhhfVBsYWMgUG99Ui9nIFJvYiBTYXN0IVMtbiZTIHRTaWduIFNvYmUqU3MoIFN0cj5UYX4gVGVzLFRvJyBUIXM8Vi9jIFZfKlYoIFZvKjNBYiNBbG9nKUFtL3RDLEZmICBHICBHaXQ9R1tMdSBNL35lTSh1IE94eUBSZWMlZlJpZyBTY3UsU3BvfVNzaXAgU3QvLVYgJXJWaX01Q2kjQyYnRz9JZ3RNYShlTWljaSNNcCxOYSYnTmokTm4gUGFtKGVSdG8qUnUhU2EuU2UnU3M+VGElJFUvPlViI1UtJ1UsWV8yQWckQXAgRXN9SWJiXU9pdHUhMlAgK1AjeGVSYWIjUmMqM05hcyVlOjBMb3UqMEFyLEhhcnBlSGVsI0xhKiBMaXA8TG8hTHU8TyNPbm9tK09yLU91LFJhfVJlbSBSaXZhKFJvdVU/VSF1YDBJZj5VcXUgMUZhYyBGZWMlZkZpZytGb3J0RnJheSBGdXNpJDBBbGl9QXIgMkVjLDFBYm9yIEFyZypFY3RyJEVnL3RFcGgvdEV2ZUlnaWIjSSVzP08uVWNpZCBVZCAwQj1dQmVsbCpCcnkkRXJ8QElzc2kkTV8gTyUkT3V2bypQIGUnUGxveSBQb3IsUHJpPFVsc2kkMENhZHIgQ2ggZUNsYXZlQ29+ZURpZ3UgRG9zfURyb2l0RHVpIUVyZytGLy1GIG0gRm91KkdhZyBHKEdsb2IgSWc/SmFtYiBKZXVMZXYgTmVtaU51eWV7Uml+KlJvYmEuU2VpZ1tUYXN9VF9kIVQ+VG8nIFRyYXYgVW0gIFZhaCpWaWFiI1ZveSBaeT8wTCtuMEFpc3MqQXJnW0F0L3RBdSNJYyArSUBtK0kgSWxvZylJW0lzb0BJdGFwaGVPXlJldXZlUm91diBVaXMvdDBVICFVaXBlMElnIE9zaSRSZSdVcCUkMEM9PlBhZCRQZS1QK2cjUG8qUHJpdFF1aXYgU2F5IFNfLVMrdVNvciBUaT9Ub21hY1RyYUAwQWcgZUFdQW5+ZUElXkUoZCFFbmRvKkVyW2xIL29sSGleSG4rSXIgT2ZmIE9pI09ubi90TydkKlIvLlJvaXRVQDBQaG9yKzBBbHUgQXNpJEVudGFgSUBuLUksT2x1JWZPcXUgMUFjdEFnICBBdWMgQ2VsXUNpdC90Q2x1c2lmQ3U8RWN1LEVtcCNFcmMgSD0gSG9yLEkubi1JXUlzLE8lXlBlZD5QbG9yIFBvfVByaW0gUXVpc1Rfc2lmVHJhaSFVbCw6QiNCdSN7Q2V0JkNpI0N0dSFJYmwqTGFpPE1le01gI1ItJ1JmZWx1UihlUm91fmVTYyggVD1UaWcpVWMkVSVmVmUnVm9yaTNCcmkjQyRkIEQgIEwoTT9NJ05kbypPZD1SbSBSby1SdmUnUyV2PVVgI1V0IVZyPjNBc2NvQ2VdQyVmRGUjR3UhTGF0dSFMZXRhLkw+ZUwjdWxMbSBMb3VMdHIgTi9jIE4qTyNSP1NzdSFYIDJBKiBBbT9Bc15BdCYnRXxFfmVFJ0V4aSRPYyRPIVVjdHUgVWlAVXZpPTJMK05kICtOZ2liI050YShlUmMgUmcgJFJtdV1SdHVbU3NpI1VkIVVnIGVVYF1VbHUhVXJtaTJBZ2kjQWk8QW5+KkFwcCBBeWUnRWdhJkUoIEVsJEVtKkVbcytFIUlhYiNJYyUkSXNzJEl2byNPaWRPbWEuT250PU90LFVpdDJHaSVmSSZSZSdSK3tSJWZTaSRUJzpHbiBMYXgrTCArTWJhZCBSLyVyUmQrblJuKlJyaWcpWmVsI1okM0FudExhJVtMdSNOZGFyP04gPU4rTm91TiVsT2xvZytPP3QhUi9pdW1SP1N0KWxZfTNCPkNdUmFmZVYhMkEtQWl2ZUlzfU9iZU9pIU9yK3syTGZlJ00/TmZdUi5SYCNVZHIkVWZmIVVsb3RVcGAjVXJtL2RVdCYyQWQpbEFmZmklQShlQW5kQXBwKEF0dWl0QXYqRW5hdElmZnUhSWxdSW1wIE9nbiBPbmQgT3QmT3VwZVVnIFUlIFV5IGUyRXBhcmRFcnI+SUBJbXx2ZUl0YSFTdGElZjNNbmFzJlJvc3RhdDpCaXR1QENobypMJk1lfE5nYXJOW3QkUmljb3RSbSQrUnAkU2FyZDNMaXVtTWF0bz9SYmVSaXNzJFJtKGVSJFNpLFUhezNCIG4gQm91TGFyL3RTdG9pIVYgNU1hcmRNbWEuTW8uW05bJ05vciBOJntSQFJpeiRSbG8uUm0kZVJyaWIjVSN7VXM8NUJsb3RJI3tNYShNYiNNaUBNbydSXTNEcm8/bEcrW01bUG5vPDoyWWwjMk5vciBVL2U0TGljaSZMdXNpJDBBLkJpYiBJLE1fPE1vYmkjTXVhYiNQYWN0UCBpPVBsb3IgUG99UHJpbSBQdSwwQ2FybiBDX2QrQ2lAbnRDbCggQ29sbyFEZXggRGktRHVjJWZFZGl0RXAlZUV4YWN0RihpRmxpZyBGb3JtIEZ1c2kkRyAgSD0gSGliIEplYyxKdSFOby1udE9jdV1PbmQgU2NyaSFTZWMmU2lnW1NvbGkmU3AqIFMlbmN0U3VsLFRhY3RUXzxUaT9UcmlnKVR1aSVmVSUjVmFzaSRWXyxWaSxWb3F1IDNPbmleUmFkPlJlZWxSaSwwT10yT2khUmVzPDpHdWFySWxsKk1iZU52PlJkKFVnIFVbVmVsb3QzVGFiI1QkVWRpVVtzPDlJbmQhTn4gTmddVWUnVWlzc2lmVXJuPVZpPVl8WWV7NUJpXUdlP250TmlvclAkUmlzJlMlLVRle1ZfaSM6WWFrN00kb09zXjpCZWxCaT1CbycgQyAgQ3RvPEd1W0lbSXN9SSUgTWJlfE1lbCNNcGVOLSdOZ2EuTixbUChSLidSP1VyPlZhYm9WbyozQ3R1IUc9RyBHdT9Tc2l2ZVR0IVY+WGleWmFyZDNBczxCICBCIUNfLUNvcltFLkV2IUdhdHUhR28sRylNIE1pJk0kYUBNcGlATmVhaSFOZ290T24tfFF1aUBTPmVTLFRoaXVtVGkuVHRvcj1WISc1R2leSW50YShJcypNYnJpY1QgK1UgVXJkVXQhVXZlWT01QitDaUBDcmElZkUnR3ViIUlzL3RNPmVOYWkhTmRpUiRULFgpezpDaChlR2FzKEdfdGFHaV5JZyFJbGwkSW4lX0lyK0lzJEpvciBMYXggTGVmaS1MaGUnTGktTCN0Jk1tb3V0aE5kYSxOaWFiI05xdS90TiZ8TilsUmF0aCRSYiFSfi9kUmRpUmklP1JeJ1JyJFImXVNjb3QmU3NpZlQgK2xUPmVUcmFeVWRpIVVzc2FAVXZlWGltPTNDaC90QyRudURhYCNEZWMoRGksRHU8SWwjJ0wvLkxvZCtNYiFNb2khTmFjIE4gTmgqTnMkLk50b3JSYyFkaVJpJlIjU3NhZyBTdSFUPVRlbyFUaG9AVD5VYiMzQXVdQ3JvYmVFdCZHbiRHciBMK3VMbGkkTWleTi1OID1OaW09Tm9yIE51JlJhYyNSb2ksU3NpI1gmNUJpI0QgW0VsI3tOZGk9TmkmJ05uYStOb3QkZU5zdCFOdGFnW051P250USknUi18UnN1IVIlIFRlJ1RpZlV+ZVVmI1VsKFVzcyRVdCRVdi90NUwlcCNOaSUkUmFgI1JlW1JtdSFTYyNTZXVtU2ljK25UYSUkVCBUKWwzUmlhQFIlbCNTLGVUaGleOkdlJ1BwZVJxdW9pc1JyIFRhJSRUaSRUdSFVZnJhLlUlXlZpITNCdSN7Q3RhckZhcyZHYSUkR2xpZyBHb2M+SS5SdmV7VHRveSBVciRlVXRyJFZldTNDaGVDa2VsVHJhJlZlfDVCI0NpZkN0J1tJci0nSTx0Jk1hQE1iIXtNbSBSbWElZlRhYiNUaWY+VG9pIVVycipVdmV8VmEmJ1ZlbWIhVmktNUEuQW5jIEkhSXNpYiNNIG9QJT1RKVRyaSVmOjBFKkplYyVmTGlnIFNjJ1MgdiBTdGFjI1RfKlQnIDBDYXNpJEN1cCBFL1RvYiFUcm95IFR1cF1VbGFpITBFJ09yL3QxRl99RmljPkZyKjBJdmUxU2V8U2BsJDJGYWMlZkl2PjBCcmEuRXR0ITBDdCl7RHVdRSF7SXJpXjFBI0FeRXIgSW5pJFBvcnR1blByaW0gVCBUaV4xQS57QW4uQmkmRCRuIEVgI0cvZUcpYElmaS1OZT9udFEpVCswQ2BdTW88U2F0dSEwQXIrMFJhZy9ScyRUYFRyYWcgVnJhLjBBJSQxWUBZLlsxT1s6SXNpYiNMYS1MbWEhc0xvJ0BMcCBOYX5lTmRhTmdvbChOaXF1IE5bfE5vcmFtYU50PSRQYXllUD5QbyxQeXJ1c1JhZG94ZVItbCNSZXM8UmZ1bSBSXVJvI1JyYShSPG0gUnRhZyBSdSFSdl8qU3NpJFMmXlQgW2xUK24tVHIkVmBsJFZvaX1ZIFlzYS4zSWdbSW50IUxhLkxpYy9MI0xvdTxMdX5lTmR1I05ldHIgTmliI05zaWZOJytQaSZQbHVtUmRyaXhSZm9yIFJpb0BSbXUsUnAjeGVSc2BSJlMgVGEjVGl0VHIqVXAjMkFyYSRPYitPXk90JFJhPFlzaV4wQW5vQ3QnPUUtRXIhRXV2IUxvJk4tfFBldCZRdSBSb2cpU2MoZVN0JFZvLFhlbFp6YTJBY2FyZEFmJGRBaXMqQW4gQV5Bc3RyJEEmfEUnIEV4dXNJYS5PbWJPbmcgVStVbWEuMkNoZXQmRXMrRSZJbiZJcj5Jc3MkSXYhTGFpIUxpYz5MI25MeWckZU1tYUBNcD5OY3QpbE5kICBOZXlSJV5TaSUkUzxkIFN0dSFUYWcgVGV8VGkkVS1VbGEoVW0kVXJwIVVzcyhVdm8qMkEqK0ElXkVjK3tFZGkhRWZpeGVFbHVARW5vbUU8bi1FJngmRXZvKkltaSVmSW4tSXMkSXYgT2IjP08tZCBPZGkuT2YkZE9nIXNPK09qZSxPbG9nKU8/biBPcCFPc3AgZU8mZyBPKXM8T3YgYmVVQG4tVVt8MFl+bzwxQmxpY0MgJEl9THBlTHNhck5haTxOaSVmUGl0IVJpZj5aeiMzUmFtaUA6OTlBc2FyRSFsI0VzJSRJZXR1QEl0LE8lX3Q6QyhlQyQsRCt7RyRkKElAJ0lzKExfJXJMbCQuTWFzfVBpQFNhLlRpc31WYWcgVihZJG4gM0FjJWZBZypBbGl9QW5pbSBDZXZvKkNpLENsYW0gQ29sLENydSxDdV1DeWNdRGlnIERvdSxGYWkhRiN4ZUZvcm0gRnJhKEZ1Lkc9K25HaSRHbGEuR3VsPkksIEplLEpvdSBMYSVmTGV2IEwrZk1hcl5NZUBNaTxNJCxNcGwqTXUgTmFyZE5mb3J0TmlmXU4kYyBOdHIgTnZvaVBsPlBvcixQcmk8UCUjUXUoUyB2ZVMoZXtTb3VkIVNwZWN0UyxTdWx0YXRUYWJsKlRfKlRpY3UjVG9tYiBUcmFjIFVuaSRVc3MqVi9+ZVZpdiFWb2wmVnVsc2lmM0NoZXM8RGV8RSdHaUBHb11OYyBQb3MsU2liI1NeVClsVj1WPmU1Q2hle00vLU1wIU4tTmQoU2V8Uz5UYSVmVG9yVHUjVS5VYCNVI3xVJVtZfD81Qi9CaXNDaGVFbCNHKXtJbiBJczx8UyBTJV4zVGg/OkJdQm8sQiFDb35lRmFyaUdlczxJcypMYUBMaXZlTCRMdSBNZWRpTmMlJE5nbD5SY2FzP1JkKGVUJyBVZyFudVVtJFUsVXZhLlYvdFYkbiAxQWxwZWxBbmRhI0VdYXRFbmFyaW9FcHQhSGVtYUlfLUluZCBPIVJ1JW5VbHAsMUFuLUNhYiNDaCBDb3UgQyEsRGElZkR1aSFJZ1snSm8nTGVjJWZNYShlTWJdTV8tTSg9TmEmJ05zaWIjTiZuLVBhciBRKW4tUmUoUi5udFIre1JydSFSdW1SdmktU2E/VipWcmEuWHR1cCMzRCA9RWMjRWcgRmZdRyNHbj1MXy1MaWNpdW1NcCNOYyBlTmlzdCFQaCRSb3BTbWleVHUgMUkgM0NpPUMjRGl1bUlnW3tMZGF0TGVgTGl0dUBMdWIjTWIhTT9gTW5vXU5ATi4nTlt0Jk5vIVJjPlIlclMrVCU8VWMre1VkdSFVZmYjVSN2IFVwYXBlVXItVSVyIFV2XyowQWMre0ElPUVjaT1IIGVJcj0zQWIjQSUkRXJudW1JbXVsdXNJcHVdUmljdFVkK3tVcGUnWWxpcyYwQmxpP0JzdHJhdEIlbEJ2XypDLXNDIUZmaXhlR2cgIEl2ZSdMZmEmUCBiZVBwbD5SZmEtUmljYSZSP24gUnByaTxSc3x0UnYrU3BlY3QzTGxhYmVNYm8jTWV0citOYXA8TnRheGVTJj86QmFjQmw+QyUjSWxdTF90TGlzbS9MJG4gTWJvJ01pfU5naWIjUGlzUXUoIFJkIFJpZlIlW1M8VGFtaVRvdWEuVXBlVSF8WCAzTW8oTXBvIWxOYWAjTmQhTmUnTipOc2kkUm0oIFJbUnJpYiNUKGVYJjJFP0VvcitFcmFwK09yYXgwQmlhRUBNaUBSZWxpIVJvKlNzdVQvZVQhVHViIDVCb2dnL0wgL3RNYSZOaV5OW3xQJHk/Un5lUmQhUm5hQFJwYCNSIW50UjxSdClUZW1VfiBVcm5hLlVzfVgoZTJBYyUkQWZpY0FnaV5BaCpBKEFufiBBdmFgRWYjRW1wIEVzb3JFdWBJYS5JYnVuPUljbyxJbG9nK0lvbXBoZUlwXUl0JyBJdmk9T21iJGVPbmNPcGljPU91cGV8MkkjTGlwZU11bCZOW2xSYihlVGUnVG95IFl8M01wL1BoJFBpXlIvOjBVZXNeOVRpP1RyYXMkMUFuaT9JZj5JJEleSXRhaSFJdiBzM0FuaXVtQmEoVGljL3QwQS5JW1VlbFUhMEkjT3ArOkNhcj9DYyhHYWIkZEcpSWxsL3RJbmMhSXM8fExhYiNMaTxMbCRMdmVNcGkhTmAjUGUnUj5TZXtTcz1TJjNDJidEZXQmR2V0PUhpY3UjSW5hcmRMby1OZCFkaU4gIE5nIE5pP3tOdG91PFJkdSFSKFJuKlJyb3VSfVJ0dVN0JFQgL1R1cyZYL3RYIDNBZHVjQW5AQ3RvaSFELy5EZW9HW3QmRyknTGEoTGxhLk5haWchT2wkUCBlUmU/bnRSdHVvPFJ1c1NhLlNlJ1NpJFNee1MpbFQ9VGVzPFRpY28jVHIoZVZhLVZpcGEhNUNhJSRHdSBJI0lzKEl0dSFMYWAjTGMvTCVnIEx1P1JhLVImeFQgVWxvKllhLlllbCM6RyQ6M04kOkNodDozQiFOaXRoUyY5T2xvZytcIjtcbmNvbnN0IGFjY2VudHMgPSBcImU3NjkzJilVKm8mKVJ5XikqKVcpKSkpI1heKSkpKUBAKSNXZiltJSkjISkpQUcpJklJQVFJSUlCSUlISk5BZ0JJSUxJREpHbykpKUhJUUlJSUlBKElHZ0pISChCSUl4WCMpT3UpQCpJQUFQSUlJSkhRSikmUUlRUFlJKEhZQVFDJSkhKSlRSEpKQCkjKV5mKl5BWENKKSkkJUNQKSklJm0pdSlAZV5BI0cjKSlXQCEoSUtLJSEoSSUpKU9AUUEpKUBHRyNlKSkpKVdISklXaCkpbXlASUlCVF4pISlIQVlHRVRISSopKSFRblVERykpKW5Cb0tBQypId3lRaCkpJCYpRyYpVUdPKUcpKSkoQlgjdioqKSVPLGU3Njg2KUkpKUApJilnZE1QKCkpKXVkKXAjTCkpSV5GSUhZZFdHKSlEQERGVilRQSlvJU15VGglKilaKSUpbihYQU5jXlIpWVNcIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDUxZGViN2FlMDA5MTQ5ZGM2MWE2YmQxOGE5MThlYjdhYzc4ZDI3NzU3MjZjNjhlNTk4YjkyZDAwMjUxOWIwNDVcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWZyXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdGciBleHRlbmRzIHdvcmRsaXN0X293bGFfanNfMS5Xb3JkbGlzdE93bEEge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBGcmVuY2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nRnJdXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJmclwiLCB3b3JkcywgYWNjZW50cywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdGcmBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nRnIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nRnIgPSBMYW5nRnI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWZyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nSXQgPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bC5qc1wiKTtcbmNvbnN0IHdvcmRzID0gXCIwdG9yZWEgbm9pY2EhaW9zb3JvbG90YWxlcmF0ZWxhbmVuYSVvaWFkb2VuY290aXZvbWFpIHQgY2ElYTBBXUJhZ2wnQmluI0UuSXMoT2xpIVJhc2lfUm9nIzBDYWRlIUNbJEN1cyNFIDxIaWwsSUBRdWFSZVJpbD5Sb2JhK1UgMEFnJ0RlYntEb21lRWd1I0VyaSFJcGVPdHQmVWwmMUZhYmksRmV8RmlzKEYtbiBPcmlzYE8oUn4kMEF2ZUVuLkVfLEdhbmMnSSFJdCZPbmlzbW9SPipSdW1lIFV6em80QWJhcmRhQSBCYXQpQmVyI0JvQnVtZUNlQ29sPkV8PEZhR2ViLUlhbi5JYmlJbVsgTGFnI0xlZylMaWVfTG9AL0x1c2lfTWUkT2dlJFBhfVBlc3QhVGEsPVRlciRUJWMnVCl2ZVVuJFZlbypaJjBBbGdhYEFuaStBIT1Ce0JyI0ViYUVyfkVecytJXU1hcyhNW2RhTWlyJk1vbntPIVAnUGxpJlUsIDBBfXJAQWctZmVBbGlzK0FyY2g/QXQtQ2FDZWwvQ28tRCZEIWFFbCpHZSpHb2wmR3VzIElgTmVnJk5pZCNOb051bmMnT25pbW9UJWlwb1ppMUF0PkVydHUtT2RlUGFyaSFQZV4gUG9nZydQKUBQdW4gUmksMUFifkFjaGlkZUFnb3MrQWxkfkFuYydBdHUtQXp6b0JpdClDaGl2J0R7RW5pLEdbIEdpPEd1IElhTW9uP05lc2VSZWQjUmluZ2FSb3MgU1s+U29UZWYlZVppbCowQ2l1fENvbCBFcHNpRXR0PkZhbCBJJE8vUGlyI1ApU2FnZydTZVNvbHUgU3VyQFRhVFt1IFQlZVQtfDBBdj5FaXNtb09tPk8kVGVzYVRpdiZUb3IkVHJ7VHVhLDBTaWwnU3RyP1RpcytUbyRtb1R1biQwQW56I0UhVltpIVZpKFZvbGdlITNJbzxPIFppbW9adXIpOkJlLEN9JENpJENvRGVzc2FEaS8rR24jSStMXTxMQExlPUwvK0x6YSRNYmkkTmRpIVJhb25kYVJiYSlSfVJ7JFJsdW1lUm9jXVNpbD5TKFRvcytUdHUgVSxWYVZvc2EzQ11GZmFMZydMdmFOZGFOZV8sTmlnJE56aT1SZVJsaT1UYTNCaStDaURvPEZpQEdhTGFuYz9NYm9Ob10qTypnb1BlZGVQb2wmUmJhbi5SLVNdfFNlcyBTJG4kU29uLlN0dXJpWnphcikyQW5AQXQrMkxse05pZj5SQFNdVGFuPlReJFp6byoyQWNjJ0FkaXBvQWBBbn1BdnUtRS5sL0V2ZXxFenphSWdsP0lsL24uSW5kJk9jXSpPQE9uemk9VWwqVSQyQmJvPENhRGkkRmZvPElvTGJvTyRSKjxSLXN9UygvUys6RGV8RHVdTGFgKUxdKkxlc3NlTGliKUxtb0xvcj9NYnVzYU1lLStNJT9NbWkkTW8vTXBhLE5hcGFOZGUvTmVOaSROb3xOXj1QYWNlUGVsKlB7KlBvZ2kpUHBlKVAtUHN1L1JhcGFjZVJ9c3NhUkBSaXNgUm92YT1SIXxSIGxpPVNhY2MnU30rU2VyYFNvUyg8Uy5sKlN1YSxUYXMrVGU9VC1tZVUgVmlsKjNEaWJpLEQtK0ZhKkxlYiFMbHVsJk5hTm88Ti5zaW1vUmFtflJjJlIgUnVtZVJ2ZWwqU28/U3BvVG8yRS9JYSlJY31JZWRlIUltZS1JPUlydXJnb0krci0wQW9DbGlzbW9GciZHJExpbmQpT3wqUn1SKXNpVHI+VCtkaSRVZmZvVmV0K1ZpLDJBc3M+SW5+TykyQ11EYXJARCVlRSFuLkckbWVMbCZMbSNMbyFMcG8oTF52I0x6YU1hTWUrTWBuQE1vQE1wdS5yTXU8TmNpKE5kdXIhTmZlcmBOZ2VsJk5pdWdlTjxzKE5vc2NlIU5zdW1vTl5udW9OdmVnJFBlciBQJzxQcD9Qcn5wb1JhenphUmRhK1IlI1JuJWVSb2wvUnBvUiFAUnM/Ui5zZVNtPlMrbi5UdHUtViMyQS4hQXZhdCtFI0VkZSFFbW8oRXNjaStFK0ljZSBJPSxJc2lJdD5PY2VPPX1PcysrVWM/LFVzfTJDaSFDdSpHaSRMbCNQby9SIyFSKCFSX1NjaSRTIGRlOkRvSSRMYCtNZXJpJE5pZS9OJChOeiZUI1Zhbl5WdmUpM0J1fENbbidDaShDbGkkQ29sKkMhIEQlI0ZpbntGb3JtZUckTGVnJkxmaSRMaXInTCtNW3phTm90I050KVBvc3tSYXBhK1JpdiZSb2dhU2NyaXxTZXIgU2lkZXInU3VtZSFUZXJzaV9WbyAzQW1ldClDZW1iIUVkKUZlKEZmdShHZXJpIUdpKyxMdXYnTmFtPk49bnppUGluIFAqYFBvKlJhZCZSZVJvfFJ1cG9TYWcnU2MhIFNmJlNnZSpTcG9zIFMrbnphU3VgJFRvVmEkVmVsIFZpZGUhVm9yIzVCKjxDWy5HYT0sR2BMY2VNI01bfk1pbiZOQCpOb1JtaSFUZVQgIVZ1IFp6aT0yQWdvVWlAMkJiJ0JpdCZDYSxOYU9tb1BsJWVSYXR1KTowQSQwQ2VzKENvTGlzc2lPJG0/MEUtSV0vSSxJIHI/VWMmMkVtb24/TGlPaXNtb1JlZyc0QWJvciNBcmdpIUVnYW4uRW5jI0V8RXYmRj5JfU1vU2FVKDBBbiNCLGBFcyhJKU9eX096JzxQaXI+VSowRGVtPkR1KUVyZz9GYXNpTy59VHImWmlgMUFeLkkqZ29JKGQnT30sUHUhMFUjITBBcidCYUJvKEVkZUVtaStJZ2UhTWV0Pk9lT3NpX1Jhbi4wQWdvJEFtZUFuaW1lQXVkaSFDYUVtcCdFcmN7SWJ7SWdbLklzLiFJIE9mYWdvT3J0I08oUGFuKFAhcyhTW3phU29UZShUaW0mVG9uP1QpKFVsdCYwSWw+Tj5SdXNdVG8wQ2xpZGVvUm9wYTBBKElkW3phSXQjT2x1IFZpdmE6QmJyfkNjW2RhQ2hpKUxdTWlnbD9OYSxOZmEtTmdvTitzYFJlUmZhbC9SaSQoUmBdU2M/UyAoU3VsKlQlJlRvVm8qKDNCYiFDby9EZUcjTHBhTHQpTW1pPU5kZSFOb21lJFJtWyBSKVJeLFNzdS1TXl9UK1VAM0FiYUR1Yz9GYUd1ciNMb05hbnphTmVzdC1OaSFPIVN9LFM+VW1lMkFdPEFtW11FYm9FbWBPcmlAVVsuVW8pMkI+Q2FjYz9DbyhEZXIjR2wnTGErTGMqIUxnbyFOZFsuTmV0Pk4/Tis9UmJ7UmNoZXQrUmVzK1JtflI9J1JvUi56emFSeiZTZiNTKDJBfXMoQT1Bc3NpJEEubCpFY2NldCtFPStFc11JZ29PbGxpJE9uZGVVZ2EsVXQrMkNpLytDcz9HZ1suTG1pPExfTWFuLk1lfE1vKE5lTnonPE9dUmJvUmdvPFJvIVNvVGksOkJiPyRGZmVMYS5vTGxpPUxvcHBvTWJlKU1gUmFuej9SYm9Sb2ZhJFJ6bzxTQHxTb2wnU3RyPlQgVWQnWmVib1p6ZWwvM0NvTGFePUwoTWVsKk1tI05lTnshTj0nTm9ecG9SZ28yRXBhckBJYWNjJ0lzYTBBbCpMZGFOZXApT2MmT2llbCpPciRPdmVSI1JvPFQrK1VkaXonVXIjVXMgMk9idSpVXjwxT21vMEJiYUxmTXtNbW88TmYnTj1WZXIkMkFjaSxBQEFmPkFtbW9BbmRlQXR0JkFfKEF6P0V9RWdnZUlmbzxJZydJbnphT3QrVXBwbzJBZGFnJEEnQW4gQXJkJkZvSWQmOjowRXJuIzBPPTBFbnQ+SWxsJ08qUmFSPlJvZ2UkMkllPE5hKU5vciM0QSFMZShMb2c+THVkZSEwQmFsKkJldnUgQm9jXUJ1IE1hPE1lcihNb2wjUGFjXVBlIFBpZWdvUG9yIFApbiswQWwmQXJjJkF0Xl9DYW4gQ1tkJ0NoaSRDaXNpX0NsdShDb250KUMpYydDdWJvRGFnaTxEP0RvLEVke0ZhdF5GaWwmRmxpfEdhZ2cnR2VnJEcsc2VHb3JARylzKE5lc11PQCFPbHRyJk9uZCNTYSRTZXxTaWVtZVNvbm4/U3VsaT1UYXMjVGUpVG89XVR1e1VtaWRpIVZhbGlAVmVjZVZ7MUVyYm8sTm90Pk8uc2lQfjFJZGVMYW5kYU9uPlJpZyNSb3ImME9sI08gcG9UZXI+VGl0dSBUciVlMEFsP0VyJjo6OkJiKUJpcmluIEN9Q2VyI0NyaWBDdT1EQHZlR29NcG9OY2V0K04ucj1SQChSZ2FSaW5nZVN0LVRbemFUaSRUdHVnYVZhZz1WbykzR2EsR2dlKU1ib04uenphTnphTzxQIVNpX1NzI1MgVC4tLFZhVmlnIzNCZSlEb0V2e0wvTWF0dS1NaXQmTXBpQE5lJk5ndWFRdWlAUmFSflN9VGVUaWcnViFhNUNhbmRhRGVHfk1iJk5kLU5nZV9RdWFjZVJbem9Ub1Qucj81Q2VDaWQjTWF9TWkkKE5nb1BvUHBvKlNpbmdhUyhUIDpDYWIpQ2NoaT1DZSlDaW4jRGFgRz5HbD9HPC5HKUlvbH5MYWZlZGVMZy1ATGluLihMc2EkTCBMdW1vIU5hTmM/TkByL05naSZOaWZlcyBOPSlOb3YtTnNhcmRhTl5kZU51YnInUHBhUiM9UmNpIVJldCtSbW9Sc3VwJ1NjaGUtU3NhP1NeJFRlLXMoVHI+L1QgPFR1KVp1cn0zQW5kKUN9bj5DZT0uRGVzaW1vRGl0JkdhTGFzc2FMaXNMb2Q/TmluZ2VOb04oL1JjdXInUltkYVIqU2NoaSRTZVNzZSFTICpUYWwqVG9AVC4hM0Fnb2wmQ2FDZWwnQ2hlLEMpYm9Eb2wqRSxHbCchTGEkTGkuTW9zYU5lLSxOaU5vIVJpJFJebCpTY2UvU3NpdmFTIFN1ciZUZXp6YVRpZyZULVQubi40RW1vbj4wRGVsKkRpZn5EdSpHYSRHJ0xlTG9zKE5hcy4pTl1OZGk9TmUrcidOaSxObyAkTig8TnQjTnZpKFJhUmRlIVJzJSNTdClUaXYjVG9zZWdhVCBWW3phVmltWyBaem81Q31Db3NhRmZhR2hlfEc9J0xhfExpPGwqTF5wKk1tP04gT3ZlIVJhLFNhU10qU35UZV8sVG86QmFiYm9GK05vbWV0KVJjaShSJWVSciNTY2UhU3RyJlR1LSxVdH5WaWdsJzNCdSpzYUMpc2lHYV5fR296J01tZSRPZmkrUmV8Ul9Tc3UkVHR1JFV0LSxWZVYpdD4zQ2NoP05mYVRpQDVCaSxDaV9Eb01lTWk9UmQ+UmAsUnZlZ2VzZVN0LSRUJlRpej9UdHVyJFZlbC81QyxvTC9NZSlPX1RyaSFWby9aPyw6U2kwQmVkaSFCbGlnb0VsaXNdTCdPKlNvLCAwQ2FzJzxDaCdDaWRbLkNvciEhQ3VsdCZSYVVsIzBJZXIkT3ImMUZlcitGcmkhRnVzYyMwR2V8R2lOdSQ0QW5kZXNlRmF8SSNJdmFPZy1tYFQhMEFnZydCZWw+Qi1FZ2FJc3MnPDBEbyhFIUljZU5pXylPIV8sVGExRXIjSW4nPFBvcyAxQV0qQWZvRGk8RWNjaGkkRWYlZUZhJEdhbj5JZ2k8SXp6b24uTWFNZWdnJ05hXl9PKmcnUltAUmliaSxUW3M/VH5aYStabzBBIUN1ciZNb3NpUGVkYSxQaS5TYVNpZCZUYV0qVGUwSS5SZVRhZ28kVGltb1RvYiExQSxFc3RJJElwYSlPY3tVbnF1ZVZpJjNJbzpDY2hlfENlQ2lmPkRlbC9EKTxFc2VHYUdpPUxhenppPUxlcyZMbGlATG9MdWRlTkApTjxsKk8qTz16em9Qcn5SYWJvL1JjZWwvUmUhUmdvKlJpUmwjUm8vUl4hUnZbemFSej8sU3NpX1N0JX1UYWN9VG8qZz9UdHVtZVZvPDNDYyNEYWwmRG89LEdnJ0xvKE4mTmQlZU5pKC9ObnUgTm9tYi1OcyZOIC9QZVBpK1JiZTxSXXIoUkBuI1Jmb3ImUmdhbWU9UidAUm1lcyhSJFJwLHMoUnN1YShSdHVnJ1J2YShTIyFTaXMrU29TXmZlKVRhKlRePFR1L24uWnpvM0FjZSFBbitBdF4kQ2NpJENvenphRWdhRXQtRmZlKUc/YEdvbCdHKUxhTGlmZSlMKi9MbytNcGFuLk5lK049Tm8qT2dnP09tYm9SYW1pZGVSZXQ+UmkuUm9saXNpVG88Wno+MkFjZWJvQW4mQXNgQSskRT1yJzJDaGV6emFEZSkoRGlzbW9Fcz9HZ2kmTFsrTGlnbyRMbCVlTG1vbmkuTHBldCtMKEx0KT1MdmUhTSVlTW9AKU4uUG8qKFJmaUBSbyhScG8tUiFSKytTYVNpXl9Tc2VzKFN0dWwjVGFzcydUZSEyQW56b0Fzc2lBdH5FY2x1KEVkfkVmaXMoRWdpI0VsaWVfRW1lIUUkdCZFcGFyI0VzW3phRS5zIEV2YWwoSWBJbmNpcGVJdiNPYixgT2N1LU9kdXIhT2Z1bW9PZ2V8T2x1bmdhT21lc3NhTyRtZU9wb3MrTylnYU8uKE92YVVkWy5VZz1VcnswSWNoZTFCYmw+RH5HaWwjRyRMY2VMe0xzYW4uTnQmUGF6em9QaWwvUm86OTlBZClBbF1zYUFzaUUhL08rOkNdbCBEQHBwJ0R+LER1biNGZn5HYXp6b0cnPEckTWFyKU1pbmdvTW9OZGFnJ04gbCZQI1BpPVBwIShTYXR1LVNjaGkjU1suU3NlZz1TdCFsKlRhVnZlZHUgM0EsQ2VwaSFDaW4gQ2x1K0NvbmR7Q3VwZSlEZHtEaW1lIUdhbCNHaXN0KUdvL0chcyhMYXonPE0mTW8gTj1QbH5QcmltZSFQdXQmU2FTaWRbLlNwb24oUyt1KVRlVGk9VG9yflReZn5Wb2MjM0Fzc3VuIEJhZGkhQmVsLEIhenpvQ2FyfkNdQ2V2ZSFDJWwjQ29yQEMhZHUgRD4qRHVyIUZhcyZGLHMoRm9yYEZ1ZydHJkdldHQjR2hlbCpMYXNzI0xldiNNYTwhTWJhbHpvTWVkJ01vcmNoJ05hc2NpK059KU5mb3J6b04kX05vbSNOc2F2e04gY11OdW5jP052W2khUGFyI1BldHUgUGllJFBvcnQmUCFzYVB1bGkhU2ErU2NoJ1NlcnZhU2liaSxTb1NwZXxTIClTdWx0I1NfbCBUYXJAVGVnJFRtPlQpX1VuJzxWYVZlcihWaW5jaStWb2wgWm9gNUJhQm90PkJ1cyBDYz9Db0RhZ2cnRGUhRHshR3tMbCdNYW50Pk1wZSFOeidTb2wmU3BvVGFuLlRvbkBUdS9WZXNjJzVCaXp6b0JyfkdhTGxpJE1pPE1vKShPKlBlU3MmU3Q+OkIjQmJpJkJvdCNHb2BMYXMoTGRhdHUtTGdlbWBMaXYmTG1vPExvPEx0Jkx1IExfUGUhUGlAUG9ye1JhY2UkUn1zbW9SIFMoKFRlbGxpLlRpLVRvbCpUdXIkVmE9VidaaSMwQWRpZ2wnQWx6b0FuYyNBci1BdC4hQXYmRW5kJklyY2kmTG9jYyNPY2NpI1JpbiZSdWZmbzxVZmYmMEFiKShBZFt6YUEvQW1iaSZBbmRhKkFwby9BcihBLm4mQXYjRWwgRW4+RXR0KUhlZGFIaWU9SWFycGFJW3phSW5kZSFJcHBvSSlwcG9JXypMZXImT2RlbC9PbHB7T21wYXIgT25mb3IgT3ByaSFPcitPcyg8T3p6ZXNlUmliYVJvbGwmUnVebidVZGVyP1VsICFVby9VKVVzJjBFYml0Jk9nYW4mMEN9dHUtQ29uQERhJEdnJy9HPWwjRyFnI0d1e0xjaSNMZXReX0wvTHZhZ2cnTWFmbylNYnImTWVNaW4jTXAhTihOXiFQb2wgUXVbemFSYStSYiNSZSRSJ1JwWy5SLWdsJ1J2aSFTXj1Uby9UXmA9MEFjZSpBbGQmQW0jQXJ6byhBdCUjRS1JZGFJbCNJbmdlT2MjT2RlciZPZ29PbF4hT3J6I1JhfFJ1dHQjVWdne1VtJlUoMEFiZWwqQXJiI09uZmkmT3JiJ1Jhc3MjVWFyQDFCaSpDXW1lRXItRy9HJCFMW3onTC9iYU1ibypNcGF0Pk11bCNOZm9uP05nbypOaXN0KU5vTi5zaU51KGlkZVBhcidTYFMgLFR1IzJJdCtPZ2F0dS1PdmUkMEFycntFbW9yI0VuXiBFLWxASWx6b09udCZPdHQjVXNzIzBFbGxpIUVydiNPQDBCYmFsem9CcidDXXIoQz8sRGEsRmZpfEckTGQjTFs8TGlATC96em9Mb0x1YmksTHZbLk1hdD5NYE5kYU5lfE5uaWZlKVBpIVBwZShQLVJnZSFScGFzKFJyaShSKFIuZ2cnUl9sI1NwaSlTK1ReLDBBZGFBbC9BcmdlIUEgL0F2WyBBenpvL0VjaWVFZGkhRWc8IUUvdHUtRS1uemFFcyghRXR0LSxFenojSWFJZ28qKElsbCNJJChJLSxMW2RpQE9yXl9PKFJhbmdhUmVjJlJvbiNSdXp6b1VuXiQwVWlsKjBBZCUmTyBsIzFBYmksQWNdQWZmYUFnbiZBbXAjQW50J0FybnUgQXNlLUF0dSBFKkVwcGFFcnpvSSx8SWBJcnBlSXZhLEl6em8oT24jT3I+UmFwcG9SZWcjUmlkdSpSb3p6JlJ1fFVjYyZVZm9VcFtAMEJbdClDXShEbyFHZ2Vye0dvTCskT24mUGVyYm9QcG9yIFJnZWwjUilnI1NzdXIpVHUtMEFnJkVkZXNlRWdsJ0VsJkVudSBFej9JbHVwcG9JcytJenplLU9sK1VvdCY6QmFjXUJ1bCNDY2kmQ2l0dXIkTGVMaXNgJE1wbzxObmkkUmFSZGlfUmcjUmlmZmFScCZSK3J1Z2FTIFR0PlZlcj1Wby8rWnphM0NhQ24+TGVmbyRNZS1yJ01wb011IE5APE5lKU5zJzxOK10qTyFgUm1lUi16em9SemV8U2lTc2VyI1N0I1QpVCA/M0YmR2VsL01iKU4gUD5Qb2ctZm9SYWdnJ1JvVGFuJ1RvKlR1YmFuLlonWnpvPDVDYyZMLHImTCBNYm8vTW9OZm9Oc2lsL1BheidQbypnP1BwYVJiYVJuJlIpPFIgLVN9JFNzaSFTK3R1LVRhJDJBYm9jXUFjaGVhQWZpL0FnZWQ/QWxjJ0Ftb24gQW5ze0FwYSRBciFBcypdQXR0I0F2ZUVjYz9FbW9sJ0VzcG8qSWJ1IEljaGVdSWZvZ2wnSWwqSW5jZWFJb0lzLnp6YUl0dXIjSXZlbC9PbWJhTyRPcHBvT3wvT3YmVWNjIzJCYXR1LUZmI0xpcGEkTXVsIE5pcz9SYiZSY2hpJFRhVGUvOjBJYyMwQ2VsKkNpKCEwSSFJXl8xRmFGJScwVWEsNElzc2VUaW0jMEEkSSxPcmlzbW8wQ2k8fEdlIUdoZSFzZUldciRJZiUjSSgkSStyJ1RlMFZvMFVwYTFBZ2EkR1t6YUxvMEFuemFBIEN7SWckKlUtJzBFbnNpLElsaXp6b09wPzpDYW4uQ2NpbiNHYWJvbkBHbGkjTGFuZ2FMZ29MPkwsdCtMbykoTHV0JkxfL01wYStOZyZOeyhOb04rZ2cnTnZlLVBvIVJhJFJjI1I/bi5TfTNEZXQrRG92YUR1IEdlKyxJXSpMYylMaT1MbHUgTG9jZU4jTmRlbW0/TiBSYWNlUmJhLFJnb2c9UmlmflJvUnJ1fVJ0fixTY35Tc2lsKlMrLFRlLSRUcmk9VHVzIDNBbmRhbi5CLW4uQ1tkYUNoaW5nb0NpPW56YURpbSZHaWw/RzwgR28hTGVMLyRNaW5pTmN7IU8vUGUtUmdvL1JvKmdvUnUsbiBTXShTJzxTcG9Tc3UgU3UtVGFUZWwqVF5gVmFuZGFWaUBaaSY1Q2VHYUxhXixMZSFMcGVSYWdpPDVMfSQ6Ojo6TXBvZz1OPVBwI1QuLVZvci0zRmkpTGFuLkxvTnplKVJiaSQzQmV8Tl1SXTxUIDVML1Q+NUNjaGUpRm8qTHVQcGFcIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDVjMTM2MmQ4OGZkNGNmNjE0YTk2ZjMyMzQ5NDFkMjlmN2QzN2MwOGM1MjkyZmRlMDNiZjYyYzJkYjZmZjc2MjBcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWl0XV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdJdCBleHRlbmRzIHdvcmRsaXN0X293bF9qc18xLldvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgSXRhbGlhbiBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdJdF1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcIml0XCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0l0YGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdJdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdJdCA9IExhbmdJdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdKYSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB3b3JkbGlzdF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3QuanNcIik7XG5jb25zdCBkYXRhID0gW1xuICAgIC8vIDQta2FuYSB3b3Jkc1xuICAgIFwiQVFSQVNSQUdCQUdVQUlSQUhCQWdoQVVSQWRCQWRjQW5vQU1FQUZCQUZDQktGQlFSQlNGQkNYQkNEQkNIQkdGQkVRQnBCQnBRQklrQkhOQmVPQmdGQlZDQmhCQmhOQm1PQm1SQmlIQmlGQlVGQlpEQnZGQnNYQmtGQmxjQmpZQndEQk1CQlRCQlRSQldCQldYWGFRWGFSWFFXWFNSWENGWFlCWHBIWE9RWEhSWGhSWHVSWG1YWGJSWGxYWHdEWFRSWHJDWFdRWFdHYUJXYUtjYVlnYXNGYWRRYWxtYU1CYWNBS2FSS0tCS0tYS0tqS1FSS0RSS0NZS0NSS0lES2VWS0hjS2xYS2pIS3JZTkFITkJXTmFSTktjTklCTklPTm1YTnNYTmRYTm5CTk1CTlJCTnJYTldETldNTkZPUUFCUUFIUUJyUVhCUVhGUWFSUUtYUUtEUUtPUUtGUU5CUU5EUVFnUUNYUUNEUUdCUUdEUUdkUVlYUXBCUXBRUXBIUUxYUUh1UWdCUWhCUWhDUXVGUW1YUWlEUVVGUVpEUXNGUWRSUWtIUWJSUWxPUWxtUVBEUWpEUXdYUU1CUU1EUWNGUVRCUVRIUXJERFhRRE5GREdCREdRREdSRHBGRGhGRG1YRFpYRGJSRE1ZRFJkRFRSRHJYU0FoU0JDU0JyU0dRU0VRU0hCU1ZSU2hZU2hrU3lRU3VGU2lCU2RjU29FU29jU2xtU01CU0ZCU0ZLU0ZOU0ZkU0ZjQ0J5Q2FSQ0tjQ1NCQ1NSQ0NyQ0diQ0VIQ1lYQ3BCQ3BRQ0lCQ0lIQ2VOQ2dCQ2dGQ1ZFQ1ZjQ21rQ213Q1pYQ1pGQ2RSQ2xPQ2xtQ2xGQ2pEQ2pkQ25YQ3dCQ3dYQ2NSQ0ZRQ0ZqR1hoR05oR0RFR0RNR0NER0NIR0lGR2dCR1ZYR1ZFR1ZSR21YR3NYR2RZR29TR2JSR25YR3dYR3dER1dSR0ZOR0ZMR0ZPR0ZkR0ZrRUFCRUJERUJGRVhPRWFCRUtTRU5CRU5ERVlYRUlnRUlrRWdCRWdRRWdIRWhGRXVkRXVGRWlCRWlIRWlGRVpERXZCRXNYRXNGRWRYRWRSRWtGRWJCRWJSRWxGRVBDRWZrRUZOWUFFWUFoWUJOWVFkWURYWVNSWUNFWVlvWWdRWWdSWXVSWW1DWVpUWWRCWWJFWWxYWWpRWVJiWVdScEtYcFFvcFFucFNGcENYcElCcElTcGhOcGRCcGRScGJScGNacEZCcEZOcEZEcEZvcEZyTEFETEJ1TFhRTFhjTGFGTENYTEVoTHBCTHBGTEhYTGVWTGhJTGRITGRSTG9ETGJSTHJYSUFCSUJRSUJDSUJzSUJvSUJNSUJSSVhhSWFSSUtZSUtSSU5CSU51SUNESUdCSUlESUlrSWdSSXhGSXlRSWlISWRSSWJZSWJSSWxISXdSSU1ZSWNSSVJWSVRSSUZCSUZOSUZRT0FCT0FGT0JRT2FGT05CT05NT1FGT1NGT0NET0dCT0VRT3BCT0xYT0lCT0lGT2dRT2dGT3lRT3ljT21YT3NYT2RJT2tIT01FT01rT1dXSEJOSFhOSFhXSE5YSER1SERSSFN1SFNSSEhvSGhrSG1SSGRSSGtRSGxjSGxSSHdCSFdjZ0FFZ0FnZ0FrZ0JOZ0JRZ0JFZ1hPZ1ljZ0xYZ0hqZ3lRZ2lCZ3NGZ2RhZ01ZZ1dTZ0ZRZ0ZFVkJUVlhFVktCVktOVktEVktZVktSVk5CVk5ZVkRCVkR4VlNCVlNSVkNqVkdOVkxYVklGVmhCVmhjVnNYVmRSVmJSVmxSaEJZaEtZaERZaEdTaHhXaG1OaGRhaGRraGJSaGpvaE1YaFRSeEFYeFhTeEtCeE5CeEVReGVOeGVReGhYeHNGeGRieGxIeGpjeEZCeEZOeEZReEZPeEZveU5ZeVlveWJjeU1ZdUJRdUJSdUJydURNdUNvdUhCdWRRdWtrdW9CdWxWdU1YdUZFbUNZbUNSbXBSbWVEbWlNbWpkbVRGbUZRaUFEaUJPaWFSaUtSaU5CaU5SaVNGaUdraUdGaUVSaXBSaUxGaUlGaWhZaWJIaWpCaWpFaU1YaVdCaUZCaUZDVUJRVVhGVWFSVU5EVU5jVU5SVU5GVURCVVNIVUNEVUdCVUdGVUVxVUxOVUxvVUlSVWVFVWVZVWdCVWhGVXVSVWlGVXNYVWRGVWtIVWJCVWpTVWpZVXdYVU1EVWNIVVJkVVRCVXJCVXJYVXJRWkFGWlhaWmFSWktGWk5CWlFGWkNYWkdCWllkWnBCWkxEWklGWkhYWkhOWmVRWlZSWlZGWm1YWmlCWnZGWmRGWmtGWmJIWmJGWndYWmNDWmNSWlJCdkJRdkJHdkJMdkJXdkNvdk1Zc0FGc0JEc2FSc0tGc05Gc0Ryc1NIc1NGc0NYc0NSc0VCc0VIc0Vmc3BCc0xCc0xEc0lnc0lSc2VHc2JSc0ZCc0ZRc0ZTZE5CZFNSZENWZEdIZFlEZEhjZFZiZHlTZHVEZHNYZGxSZHdYZFdZZFdjZFdSa0JNa1hPa2FSa05Ja05Ga1NGa0NGa1lCa3BSa2VOa2dCa2hWa21Ya3NGa2xWa01Ca1dEa0ZOb0JOb2FRb2FGb05Cb05Yb05hb05Fb1NSb0Vyb1lYb1lDb1lib3BSb3BGb21Yb2prb3dYb3JGYkJFYkVJYmRCYmpZbGFSbERFbE1YbEZEaktqalNSakdCallCallranBSakxYaklCak9GamVWamJSandCblhRblNIbnBGbkxYbklObk1CblRSd1hCd1hOd1hZd05Gd1FGd1NCd0dGd0xYd0xEd2VOd2dCd3VId2pEd25YTUJYTXBGTUlCTWVOTVRIY2FRY05CY0RIY1NGY0NYY3BCY0xYY0xEY2dGY3VGY25YY3dYY2NEY1RRY3JGVFFFclhOckNIcnBGcmdGcmJGclRIckZjV05ZV05iV0VIV01YV1RSXCIsXG4gICAgLy8gNS1rYW5hIHdvcmRzXG4gICAgXCJBQkdIQUJJSkFFQVZBWUpRQUxaSkFJYVJBSE5YQUhkY0FIYlJBWkpNQVpKUkFaVFJBZFZKQWtsbUFiY05BamRSQU1uUkFNV1lBV3BSQVdnUkFGZ0JBRmhCQUZkY0JOSkJCTkpEQlFLQkJRaGNCUWxtQkRFSkJZSmtCWUpUQnBOQkJwSkZCSUpCQklKREJJY0FCT0tYQk9FSkJPVkpCT2lKQk9aSkJlcEJCZUxYQmVJRkJlZ0JCZ0dKQlZKWEJ1b2NCaUpSQlVKUUJsWFZCbElUQndORkJNWVZCY3FYQlRsbUJXTkZCV2lKQlduUkJGR0hCRndYWEtHSlhOSkJYTlpKWERUVFhTSFNYU1ZSWFNsSFhDSkRYR1FKWEVoWFhZUUpYWWJSWE9mWFhlTmNYVkpGWGhRSlhoRUpYZFRSWGpkWFhNaEJYY1FUWFJHQlhURUJYVG5RWEZDWFhGT0ZYRmdGYUJhRmFCTkphQkNKYUJwQmFCd1hhTkpLYU5KRGFRSUJhRHBSYUVQRGFITUZhbURKYWxFSmFNWkphRmFGYUZOQmFGUUphRkxEYUZWSEtCQ1lLQkVCS0JIREtYYUZLWEdkS1hFSktYcEhLWElCS1haREtYd1hLS3dMS05hY0tOWUpLTkpvS05XY0tER2RLRFRSS0NoWEtHYVJLR2hCS0diUktFQlRLRWFSS0VQVEtMTURLTFdSS09IREtWSmNLZEJjS2xJQktsT1BLRlNCS0ZFUEtGcEZOQk5KTkpCUU5CR0hOQkVQTkJIWE5CZ0ZOQlZYTkJaRE5Cc1hOQndYTk5hUk5OSkROTkpFTk5Ka05EQ0pORFZETkdKUk5KaUROWkpOTnNDSk5KRk5ORlNCTkZDWE5GRVBORkxYTkZJRlFKQkZRQ2FSUUpFUVFMSkRRTEpGUUlhUlFPcVhRSGFGUUhIUVFWSlhRVkpEUWhOSlFtRUlRWkpGUXNKWFFKckZRV2JSREpBQkRCWUpEWE5GRFhDWERYTFhEWFpERFhzSkRRcVhEU0pGREpDWERFUGtERXFYRFltUURwU0pET0NrRE9HUURIRUlEVkpERHVEdURXRUJESkZnU0JORFNCU0ZTQkdIU0JJQlNCVFFTS1ZZU0pRTlNKUWlTSkNYU0VxWFNKWVZTSWlKU09NWVNIQUhTSGFRU2VDRlNlcFFTZWdCU0hkSFNIckZTaFNKU0p1SFNKVUZTa05SU3JTclNXRUJTRmFIU0pGUVNGQ1hTRkdEU0ZZWFNGT0RTRmdCU0ZWWFNGaEJTRnhGU0ZrRlNGYkJTRk1GQ0FEZENKWEJDWGFGQ1hLRkNYTkZDWENYQ1hHQkNYRUpDWFlCQ1hMRENYSUJDWE9QQ1hIWENYZ0JDWGhCQ1hpQkNYbERDWGNIQ0pOQkNKTkZDRENKQ0RHQkNEVlhDRGhCQ0RpRENESmRDQ21OQ3BKRkNJYVJDT3FYQ0hDSENIWkpDVmlKQ3VDdUNtZGRDSmlGQ2ROQkNkSGhDbEVKQ25VSkNyZVNDV2xnQ1dUUkNGQkZDRk5CQ0ZZQkNGVkZDRmhGQ0ZkU0NGVEJDRldER0JOQkdCUUZHSkJDR0JFcUdCcEJHQmdRR05CRUdOSllHTmtPR05KUkdEVUZHSnBRR0hhQkdKZU5HSmVFR1ZCbEdWS2pHaUpER3ZKSEdzVkpHa0VCR01JSkdXak5HRkJGR0ZDWEdGR0JHRllYR0ZwQkdGTUZFQVNKRUFXcEVKTkZFQ0pWRUlYU0VJUUpFT3FYRU9jRkVlTmNFSEVKRUhsRkVKZ0ZFaGxtRW1ESkVtWkpFaU1CRVVxWEVvU1JFUEJGRVBYRkVQS0ZFUFNGRVBFRkVQcEZFUExYRVBJQkVKUGRFUGNGRVBUQkVKblhFcWxIRU1wUkVGQ1hFRk9ERUZjRllBU0pZSkFGWUJhQllCVlhZWHBGWURoQllDSkJZSkdGWVliUlllTmNZSmVWWWlJSllaSmNZdkpnWXZKUllKc1hZc0pGWU1ZTVlyZVZwQk5IcEJFSnBCd1hwUXhGcFlFSnBlTkRwSmVEcGVTRnBlQ0hwSFVKcEhiQnBIY0hwbVVKcGlpSnBVSnJwc0p1cGxJVHBGYUJwRlFxcEZHQnBGRWZwRllCcEZwQnBGTEpwRklEcEZnQnBGVlhwRnlRcEZ1RnBGbEZwRmpEcEZuWHBGd1hwSkZNcEZUQkxYQ0pMWEVGTFhoRkxYVUpMWGJGTGFsbUxOSkJMU0pRTENMQ0xHSkJMTERKTEhhRkxlTkZMZVNITGVDWExlcEZMaGFSTFpzSkxzSkRMc0pyTG9jYUxsTGxMTWRiTEZOQkxGU0JMRkVITEZrRklCQkZJQlhGSUJhUUlCS1hJQlNGSUJwSElCTFhJQmdCSUJoQklCdUhJQm1YSUJpRklCWlhJQnZGSUJiRklCalFJQndYSUJXRklLVFJJUVVKSURHRklDalFJWVNSSUlOWElKZUNJVmFSSW1Fa0laSkZJdkpSSXNKWElkQ0pJSm9SSWJCUUlqWUJJY3FYSVRGVklyZVZJRktGSUZTRklGQ0pJRkdGSUZMRElGSUJJSkZPSUZnQklGVlhJSkZoSUZ4RklGbVhJRmRISUZiQklKRnJJSkZXT0JHQk9RZlhPT0tqT1VxWE9mWEJPcVhFT2NxWE9SVkpPRklCT0ZsREhCSU9IWGlGSE5UUkhDSlhISWFSSEhKREhIRUpIVmJSSFpKWUhiSUJIUnNKSFJrREhXbG1nQktGZ0JTQmdCQ0RnQkdIZ0JwQmdCSUJnQlZKZ0J1QmdCdkZnS0RUZ1FWWGdEVUpnR1NKZ09xWGdtVU1nWklKZ1RVSmdXSUVnRkJGZ0ZOQmdGREpnRlNGZ0ZHQmdGWVhnSkZPZ0ZnUWdGVlhnRmhCZ0ZiSGdKRldWSkFCVlFLY1ZEZ0ZWT2ZYVmVERlZoYVJWbUdkVmlKWVZNYVJWRk5IaEJORGhCQ1hoQkVxaEJwRmhCTFhoTkpCaFNKUmhlVlhoaEtFaHhsbWhaSUpoZEJRaGtJSmhiTU5oTVVKaE1aSnhOSmd4UVVKeERFa3hEZEZ4U0pSeHBsbXhlU0J4ZUNYeGVHRnhlWVh4ZXBReGVnQnhXVmN4RkVReEZMWHhGSUJ4RmdCeEZ4RHhGWnR4RmRjeEZiQnhGd1h5REpYeURsY3VBU0p1REpwdURJQnVDcEp1R1NKdUlKRnVlRUZ1WklKdXNKWHVkV0V1b0lCdVdHSnVGQmN1RktFdUZORnVGUUZ1RkRKdUZHSnVGVkp1RlV0dUZkSHVGVEJtQllKbU5KWW1RaGttTEpEbUxKb21JZFhtaUpZbXZKUm1zSlJta2xtbU1CeW1NdUNtY2xtbWNuUWlKQUJpSkJOaUpCRGlCU0ZpQkNKaUJFRmlCWUJpQnBGaUJMWGlCVEhpSk5jaURFZmlDWkppRUNKaUpFcWlPa0hpSEtGaWVORGlISlFpZVFjaWVESGllU0ZpZUNYaWVHRmllRUZpZUlIaWVnRmloVUppeE5vaW9OWGlGYUJpRktGaUZORGlGRVBpRllYaXRGT2l0RkhpRmdCaUZWRWlGbVhpRml0aUZiQmlGTUZpRnJGVUNYUVVJb1FVSUpjVUhRSlVlQ0VVSHdYVVVKRFVVcVhVZFdjVWNxWFVyblFVRk5EVUZTSFVGQ0ZVRkVmVUZMWFV0Rk9aQlhPWlhTQlpYcEZaWFZYWkVRSlpFSmtacERKWk9xWFplTkhaZUNEWlVxWFpGQlFaRkVIWkZMWHZCQUZ2QktGdkJDWHZCRVB2QnBIdkJJRHZCZ0Z2QnVIdlFOSnZGTkZ2RkdCdkZJQnZKRmNzWENEc1hMWHNYc1hzWGxGc1hjSHNRcVhzSlFGc0VxWHNlSUZzRkVIc0ZqRGRCeE9kTnBSZE5KUmRFSmJkcEpSZGhaSmRuU0pkcmpOZEZOSmRGUUhkRmhOa05KRGtZYVJrSE5Sa0hTUmtWYlJrdU1Sa2pTSmtjcURvU0pGb0VpSm9ZWkpvT2ZYb2hFQm9NR1FvY3FYYkJBRmJCWEZiQmFGYkJORGJCR0JiQkxYYkJUQmJCV0RiR0pZYklKSGJGUXFiRnBRbERnUWxPckZsVkpSakdFQmpaSlJuWHZKblhiQm5FZkhuT1BEbmdKUm54ZlhuVUpXd1hFSndOcEp3RHBCd0VmWHdyRUJNRENKTURHSE1ESUpNTEpEY1FHRGNRcEhjcVhjY3FORmNxQ1hjRkNKUkJTQlJCR0JSQkVKUkJwUVRCTkZUQlFKVEJwQlRCVlhURkFCVEZTQlRGQ0ZURkdCVEZNRHJYQ0pyWExEckROSnJFZkhyRlFKckZpdFdOamRXTlRSXCIsXG4gICAgLy8gNi1rYW5hIHdvcmRzXG4gICAgXCJBS0xKTUFOT1BGQVNOSklBRUpXWEFZSk5SQUlJYlJBSWNkYUFlRWZEQWdpZFJBZGpOWUFNWUVKQU1JYlJBRk5KQkFGcEpGQkJJSllCRFpKRkJTaUpoQkdkRUJCRUpmWEJFSnFYQkVKV1JCcGFVSkJMWHJYQklZSk1CT2NmWEJlRWZGQmVzdFhCak5KUkJjREpPQkZFcVhYTnZKUlhETUJoWENKTllYT0FXcFhPTkpXWEhERUJYZUlhUlhoWUpEWFpKU0pYTURKT1hjQVNKWEZWSlhhQlFxWGFCWkpGYXNYZFFhRlNKUWFGRWZYYUZwSkhhRk9xWEtCTlNSS1h2SkJLUUpoWEtFSlFKS0VKR0ZLSU5KQktJSmpOS2dKTlNLVkVsbUtWaEVCS2lKR0ZLbEJnSktqblVKS3dzSllLTUZJSktGTkpES0ZJSkZLRk9mWE5KQlNGTkpCQ1hOQnBKRk5KQnZRTkpCTUJOSkxKWE5KT3FYTkplQ1hOSmVHRk5kc0pDTmJUS0ZOd1hVSlFORkVQUURpSmNRRE1TSlFTRnBCUUdNUUpRSmVPY1F5Q0pFUVVKRUJRSkZCclFGRUpxRFhESkZESlhwQkRKWElNREdpSmhESUpHUkRKZVljREhyREpEVlhnRkRrQVdwRGtJZ1JEakRFcURNdkpSREpGTkZESkZJQlNLY2xtU0pRT0ZTSlFWSFNKUWpEU0pHSkJTSkdKRlNFQ0pvU0hFSnFTSkhUQlNKVkpEU1ZpSllTWkpOQlNKc0pEU0ZTSkZTRkVmWFNKRkxYQ0JVSlZDSlhTQkNKWHBCQ1hWSlhDSlhzWENKWGRGQ0pOSkhDTElKZ0NIaUpGQ1ZOSk1DaENKaENVSEVKQ3NKVFJDSmRZY0NvUUpDQ0ZFZlhDRklKZ0NGVUp4Q0ZzdEZHSkJhUUdKQklER1FKcVhHWUpOUkdKSEtGR2VRcURHSEVKRkdKZUxYR0hJaUpHSGRCbEdVSkVCR2tJSlRHRlFQREdKRkVxRUFHZWdFSklKQkVKVkpYRWhRSlRFaUpOY0VKWkpGRUpvRXFFakRFcUVQRHNYRVBHSkJFUE9xWEVQZVFGRWZEaURFSmZFRkVmZXBRRWZNaUpFcVhOQkVxRElERXFlU0ZFcVZKWEVNdkpSWVhOSkRZWEVKSFlLVkpjWVlKRUJZSmVFY1lKVXFYWUZwSkZZRnN0WHBBWkpNcEJTSkZwTkJORnBlUVBEcEhMSkRwSElKRnBIZ0pGcGVpdEZwSFpKRnBKRkFEcEZTSkZwSkZDSnBGT3FYcEZpdEJwSkZaSkxYSUpGTElKZ1JMVk5KV0xWSEpNTHdOcEpMRkdKQkxGTEpETEZPcVhMSkZVSklCREpYSUJHSkJJSkJZUUlKQklCSUJPcVhJQmNxRElFR0pGSUxOSlRJSUpFQklPaUpoSUplTkJJSmVJQkloaUpJSVdvVFJJSkZBSElKRnBCSUpGdUhJRlV0RklKRlRIT1NCWUpPRWNxWE9IRUpxT3ZCcEZPa1ZKck9iQlZKT25jcURPY05Ka0hoTkpSSHVISnVIZE1oQmdCVXFYZ0JzSlhnT05KQmdITkpEZ0hISlFnSmVpdGdIc0pYZ0p5TmFneURKQmdaSkRyZ3NWSlFna0VKTmdralNKZ0pGQUhnRkNKRGdGWnRNVkpYTkZWWFFmWFZKWERKVlhvUUpWUVZKUVZERWZYVkR2SkhWRXFORlZlUWZYVkhwSkZWSHhmWFZWSlNSVlZtYVJWbElKT2hDWFZKaEhqWWtoeENKVmhXVlVKaFdpSmN4Qk5KSXhlRXFEeGZYQkZ4Y0ZFUHhGU0pGeEZZSlh5QkRRSnlkYVVKeUZPUER1WUNKWXVMdkpSdUhMSlh1WkpMRHVGT1BEdUZaSkh1RmNxWG1LSEpkbUNRSmNtT3NWSmlKQUdGaXRMQ0ZpZU9mWGllc3RYaVpKTUVpa05KUWlyWHpGaUZRcVhpRklKRmlGWkpGaUZ2dEZVSHBKRlV0ZUljVXRlT2NVVkNKa1VoZEhjVWJFSkVVSnFYUVVNTkpoVVJqWWtVRml0RlpER0pIWkpJeERaSlZKWFpKRkRKWkpGcFF2Qk5KQnZCU0pGdkp4QnJzZVFxRHNWRlZKZEZMSkRrRUpOQmttTkpZa0ZMSkRvUUpPUG9Hc0pSb0VBSEJvRUpmRmJCUXFEYkJaSkhiRlZKWGxGSUpCallJclhqZWl0Y2pqQ0VCaldNTkJ3WFFmWHdYT2FGd0RzSlh3Q0pUUndyQ1pKTUROSlFjRERKRmNxRE9QUllpSkZUQnNKWFRRSUpCVEZFZlhURkxKRHJYRUpGckVKWE1yRlpKRldFSmRFV1lUbG1cIixcbiAgICAvLyA3LWthbmEgd29yZHNcbiAgICBcIkFCQ0RFRkFDTkpUUkFNQkRKZEFjTkpWWEJMTkpFQlhTSWRXUlhFck5Ka1hZREpNQlhaSkNKYVhNTkphWUtLVkpLY0tERUpxWEtEY05KaEtWSnJOWUtiZ0pWWEtGVkpTQk5CWUJ3RE5KZVFmWE5KZUVxWE5oR0pXRU5KRmlKUlFsSUpiRVFKZlh4RFFxWGNmWFFGTkRFSlFGd1hVSkRZY25VSkRKSUJnUURJVUpUUkRKRkVxRFNKUVNKRlNKUUlKRlNPUGVadFNKRlpKSENKWFFmWENUREVxRkdKQlNKRkdKQk9mWEdKQmNxWEdKSE5KREdKUkxpSkVKZlhFcUVKRkVKUEVGcEJFSllKQlpKRllCd1hVSllpSk1FQllKWkp5VFlUT05KWHBRTUZYRnBlR0lEZHBKRnN0WHBKRmNQRExCVlNKUkxIUUpxWExKRlpKRklKQk5KRElKQlVxWElCa0ZESklKRUpQVElZSkdXUklKZVFQRElKZUVmSElKRnNKWE9xR0RTRkhYRUpxWGdKQ3NKQ2dHUUpxWGdkUVlKRWdGTUZOQmdKRmNxRFZKd1hVSlZKRlpKY2hJZ0pDQ3hPRUpxWHhPd1hVSnlESkJWUnVzY2lzY2lKQmlKQmllVXRxWGlKRkRKa2lGc0pYUVVHRVpKY1VKRnNKWFp0WElyWFpEWkpEclpKRk5KRFpKRnN0WHZKRlFxWHZKRkNKRXNKWFFKcWtoa05HQmJESmRUUmJZSk1FQmxEd1hVSk1FRmlKRmNmWE5KRFJjTkpXTVRCTEpYQ1wiLFxuICAgIC8vIDgta2FuYSB3b3Jkc1xuICAgIFwiQnJhRlV0SEJGU0pGZGJOQkxKWFZKUW9ZSk5FQlNKQkVKZkhTSkh3WFVKQ0pkQVpKTUdqYUZWSlhFSlBOSkJsRUpmRmlKRnBGYkZFSnFJSkJWSkNySUJkSGlKaE9QRkNodkpWSlpKTkpXeEdGTklGTHVlSUJRSnFVSEVKZlVGc3RPWkpEcmxYRUFTSlJsWFZKWFNGd1ZKTkpXRFwiLFxuICAgIC8vIDkta2FuYSB3b3Jkc1xuICAgIFwiUUpFSk5OSkRRSkVKSUJTRlFKRUp4ZWdCUUpFSmZIRVBTSkJtWEVKRlNKQ0RFSnFYTFhOSkZRcVhJY1FzRk5KRklGRUpxWFVKZ0ZzSlhJSkJVSkVKZkhORnZKeEVxWE5KblhVSkZRcURcIixcbiAgICAvLyAxMC1rYW5hIHdvcmRzXG4gICAgXCJJSkJFSnFYWkpcIlxuXTtcbi8vIE1hcHMgZWFjaCBjaGFyYWN0ZXIgaW50byBpdHMga2FuYSB2YWx1ZSAodGhlIGluZGV4KVxuY29uc3QgbWFwcGluZyA9IFwifn5BekJ+WH5hfktOflF+RH5TfkN+R35Ffll+cH5Mfkl+T35lSH5nflZ+aHh5dW1pfn5Vfn5afn52fn5zfn5ka29ibFBqZm5xd01jUlRyfld+fn5Gfn5+fn5KdFwiO1xubGV0IF93b3JkbGlzdCA9IG51bGw7XG5mdW5jdGlvbiBoZXgod29yZCkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykod29yZCkpO1xufVxuY29uc3QgS2lZb0t1ID0gXCIweGUzODE4ZGUzODI4NGUzODE4ZlwiO1xuY29uc3QgS3lvS3UgPSBcIjB4ZTM4MThkZTM4MjgzZTM4MThmXCI7XG5mdW5jdGlvbiB0b1N0cmluZyhkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xufVxuZnVuY3Rpb24gbG9hZFdvcmRzKCkge1xuICAgIGlmIChfd29yZGxpc3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdDtcbiAgICB9XG4gICAgY29uc3Qgd29yZGxpc3QgPSBbXTtcbiAgICAvLyBUcmFuc2Zvcm1zIGZvciBub3JtYWxpemluZyAoc29ydCBpcyBhIG5vdCBxdWl0ZSBVVEYtOClcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB7fTtcbiAgICAvLyBEZWxldGUgdGhlIGRpYWNyaXRpYyBtYXJrc1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDE1NF0pXSA9IGZhbHNlO1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDE1M10pXSA9IGZhbHNlO1xuICAgIC8vIFNvbWUgc2ltcGxlIHRyYW5zZm9ybXMgdGhhdCBzb3J0IG91dCBtb3N0IG9mIHRoZSBvcmRlclxuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDEzM10pXSA9IHRvU3RyaW5nKFsyMjcsIDEzMCwgMTM0XSk7XG4gICAgdHJhbnNmb3JtW3RvU3RyaW5nKFsyMjcsIDEyOSwgMTYzXSldID0gdG9TdHJpbmcoWzIyNywgMTI5LCAxNjRdKTtcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxMzFdKV0gPSB0b1N0cmluZyhbMjI3LCAxMzAsIDEzMl0pO1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMzAsIDEzNV0pXSA9IHRvU3RyaW5nKFsyMjcsIDEzMCwgMTM2XSk7XG4gICAgLy8gTm9ybWFsaXplIHdvcmRzIHVzaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICBmdW5jdGlvbiBub3JtYWxpemUod29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga2FuYSA9IHdvcmRbaV07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0cmFuc2Zvcm1ba2FuYV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGthbmEgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0ga2FuYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBTb3J0IGhvdyB0aGUgSmFwYW5lc2UgbGlzdCBpcyBzb3J0ZWRcbiAgICBmdW5jdGlvbiBzb3J0SmFwYW5lc2UoYSwgYikge1xuICAgICAgICBhID0gbm9ybWFsaXplKGEpO1xuICAgICAgICBiID0gbm9ybWFsaXplKGIpO1xuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBMb2FkIGFsbCB0aGUgd29yZHNcbiAgICBmb3IgKGxldCBsZW5ndGggPSAzOyBsZW5ndGggPD0gOTsgbGVuZ3RoKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGRhdGFbbGVuZ3RoIC0gM107XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGQubGVuZ3RoOyBvZmZzZXQgKz0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IG1hcHBpbmcuaW5kZXhPZihkW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICB3b3JkLnB1c2goMjI3KTtcbiAgICAgICAgICAgICAgICB3b3JkLnB1c2goKGsgJiAweDQwKSA/IDEzMCA6IDEyOSk7XG4gICAgICAgICAgICAgICAgd29yZC5wdXNoKChrICYgMHgzZikgKyAxMjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZGxpc3QucHVzaCh0b1N0cmluZyh3b3JkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd29yZGxpc3Quc29ydChzb3J0SmFwYW5lc2UpO1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiBreW9rdSBhbmQga2l5b2t1IGFyZSBmbGlwcGVkIGluIG5vZGUgKCEhKS5cbiAgICAvLyBUaGUgb3JkZXIgU0hPVUxEIGJlOlxuICAgIC8vICAgLSBreW9rdVxuICAgIC8vICAgLSBraXlva3VcbiAgICAvLyBUaGlzIHNob3VsZCBpZ25vcmUgXCJpZlwiLCBidXQgdGhhdCBkb2Vzbid0IHdvcmsgaGVyZT8/XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGhleCh3b3JkbGlzdFs0NDJdKSA9PT0gS2lZb0t1ICYmIGhleCh3b3JkbGlzdFs0NDNdKSA9PT0gS3lvS3UpIHtcbiAgICAgICAgY29uc3QgdG1wID0gd29yZGxpc3RbNDQyXTtcbiAgICAgICAgd29yZGxpc3RbNDQyXSA9IHdvcmRsaXN0WzQ0M107XG4gICAgICAgIHdvcmRsaXN0WzQ0M10gPSB0bXA7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18xLmlkKSh3b3JkbGlzdC5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGNoZWNrc3VtICE9PSBcIjB4Y2IzNmIwOWU2YmFhOTM1Nzg3ZmQ3NjJjZTY1ZTgwYjBjNmE4ZGFiZGZiYzNhN2Y4NmFjMGUyYzRmZDExMTYwMFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBqYSAoSmFwYW5lc2UpIEZBSUxFRFwiKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBfd29yZGxpc3QgPSB3b3JkbGlzdDtcbiAgICByZXR1cm4gd29yZGxpc3Q7XG59XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1qYV1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nSmEgZXh0ZW5kcyB3b3JkbGlzdF9qc18xLldvcmRsaXN0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgSmFwYW5lc2UgbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nSmFdXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJqYVwiKTsgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBsb2FkV29yZHMoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb2FkV29yZHMoKS5pbmRleE9mKHdvcmQpO1xuICAgIH1cbiAgICBzcGxpdChwaHJhc2UpIHtcbiAgICAgICAgLy9sb2dnZXIuYXNzZXJ0Tm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBwaHJhc2Uuc3BsaXQoLyg/OlxcdTMwMDB8ICkrL2cpO1xuICAgIH1cbiAgICBqb2luKHdvcmRzKSB7XG4gICAgICAgIHJldHVybiB3b3Jkcy5qb2luKFwiXFx1MzAwMFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdKYWBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nSmEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nSmEgPSBMYW5nSmE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWphLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nS28gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuY29uc3QgZGF0YSA9IFtcbiAgICBcIk9ZQWFcIixcbiAgICBcIkFUQVpvQVRCbDNBVENUckFUQ2w4QVREbG9BVEdnM0FUSFQ4QVRKVDhBVEpsM0FUTGx2QVRMbjRBVE1UOEFUTVg4QVRNYm9BVE1nb0FUb0xiQVRvTVRBVHJIZ0FUdkhuQVQzQW5BVDNKYkFUM01UQVQ4RGJBVDhKVEFUOExtQVQ4TVlBVDhNYkFUI0xuQVVIVDhBVUhadkFVSlhyQVVKWDhBVUxuckFYSm52QVhMVW9BWExndkFYTW42QVhSZzNBWHJNYkFYM0pUQVgzUWJBWUxuM0FaTGd2QVpyU1VBWnZBY0FaOEFhQVo4QWJBWjhBbkFaOEhuQVo4TGdBWjhNWUFaOE1nQVo4T25BYUFib0FhRFRyQWFGVHJBYUpUckFhSmJvQWFMVm9BYU1YdkFhT2w4QWFTZW9BYkFVb0FiQWc4QWJBbDRBYkduckFiTVQ4QWJNWHJBYk1uNEFiUWI4QWJTVjhBYnZSbEFiOEFVQWI4QW5BYjhIZ0FiOEpUQWI4TlRBYjhSYkFjR2JvQWNMbnZBY01UOEFjTVg4QWNTVG9BY3JBYUFjckZuQWM4QWJBYzhNZ0FmR2dyQWZIYm9BZkpudkFmTFY4QWZMa29BZk1UOEFmTW5vQWZRYjhBZlNjckFmU2dyQWdBWjhBZ0ZsM0FnR1g4QWdIWnZBZ0hnckFnSlhvQWdKWDhBZ0pib0FnTFpvQWdMbjRBZ09YOEFnb0FUQWdvQW5BZ29DVUFnb0pnQWdvTFhBZ29NWUFnb1NlQWdyRFVBZ3JKVEFockZuQWhyTGpBaHJRZ0FqQWdvQWpKbnJBa01YOEFrT25vQWxDVHZBbENWOEFsQ2x2QWxGZzRBbEZsNkFsRm4zQWxvU25BbHJBWEFsckFmQWxyRlVBbHJGYkFsckdnQWxyT1hBbHZLbkFsdk1UQWwzQWJBbDNNbkFuQVRyQW5BY3JBbkNaM0FuQ2w4QW5EZzhBbkZib0FuRmwzQW5IWDRBbkhickFuSGdyQW5JbDNBbkpndkFuTFhvQW5MWDRBbkxickFuTGdyQW5MaHJBbk1Yb0FuTWdyQW5PbjNBblNickFuU2VvQW52TG5BbjNPbkNUR2d2Q1RTbHZDVHZBVUNUdktuQ1R2TlRDVDNDWkNUM0dVQ1QzTVRDVDhIbkNVQ1pyQ1VMZjhDVUxudkNVM0huQ1UzSlVDWTZOVUNiRGI4Q2JGWm9DYkxuckNib09UQ2JvU2NDYnJGbkNidkxuQ2I4QWdDYjhIZ0NiJExuQ2tMZm9DbEJuM0Nsb0RVRFRIVDhEVExsM0RUU1U4RFRyQWFEVHJMWERUckxqRFRyT1lEVHJPZ0RUdkZYRFR2Rm5EVDNIVURUM0xmRFVDVDlEVURUNERVRlZvRFVGVjhEVUZrb0RVR2dyRFVKbnJEVUxsOERVTVQ4RFVNWHJEVU1YNERVTWc4RFVPVW9EVU9ndkRVT2c4RFVTVG9EVVNaOERiRFhvRGJEZ29EYkdUOERiSm4zRGJMZzNEYkxuNERiTVhyRGJNZzhEYk9Ub0Rib0pYR1RDbHZHVERUOEdURlpyR1RMVm9HVExsdkdUTGwzR1RNZzhHVE9UdkdUU2xyR1RvQ1VHVHJEZ0dUckpZR1RyU2NHVHRMbkdUdkFuR1R2UWdHVUNackdVRFR2R1VGWm9HVUhYckdVTG52R1VNVDhHVW9NZ0dYb0xuR1hyTVhHWHJNbkdYdkZuR1lMbnZHWk9udkdadk9uR1o4TGFHWjhMbUdiQWwzR2JEWXZHYkRsckdiSFgzR2JKbDRHYkxWOEdiTG4zR2JNbjRHYm9KVEdib1JmR2J2RlVHYjNHVUdiNEpuR2dEWDNHZ0ZsJEdnSmxyR2dMWDZHZ0xab0dnTGY4R2dPWG9HZ3JBZ0dnckpYR2dyTVlHZ3JTY0dndkFUR2d2T1lHbkFnb0duSmd2R25MWm9HbkxnM0duTG5yR25RbjhHblNickduck1nSFRDbHZIVERUb0hURlQzSFRRVDhIVG9KVEhUb0pnSFRyRFVIVHJNbkhUdkZZSFR2UmZIVDhNbkhUOFNVSFVBWjhIVUJiNEhVRFR2SFVvTVlIWEZsNkhYSlg2SFhRbHJIWHJBVUhYck1uSFhyU2JIWHZGWUhYdktYSFgzTGpIWDNNZUhZdlFsSFpyU2NIWnZEYkhiQWNySGJGVDNIYkZsM0hiSlQ4SGJMVHJIYk1UOEhiTVhySGJNYnJIYlFiOEhiU1gzSGJvRGJIYm9KVEhickZVSGJySGdIYnJKVEhiOEpUSGI4TW5IYjhRZ0hnQWxySGdEVDNIZ0dnckhnSGdySGdKVHJIZ0pUOEhnTFhASGdMbnJIZ01UOEhnTVg4SGdNYm9IZ09uckhnUVRvSGdSZzNIZ29IZ0hnckNiSGdyRm5IZ3JMVkhndkFjSGd2QWZIbkFsb0huQ1RySG5DbnZIbkdUckhuR1o4SG5HbnZIbkpUOEhuTGY4SG5Ma3ZIbk1nOEhuUlRySVR2RlVJVHZGbkpUQVhySlRDVjhKVEZUM0pURlQ4SlRGbjRKVEdndkpUSFQ4SlRKVDhKVEpYdkpUSmwzSlRKbnZKVExYNEpUTGY4SlRMaHZKVE1UOEpUTVhySlRNbnJKVE9ickpUUVQ4SlRTbHZKVDhEVUpUOEZrSlQ4TVRKVDhPWEpUOE9nSlQ4UVVKVDhSZkpVSFpvSlhGVDRKWEZsckpYR1o4SlhHbnJKWExWOEpYTGd2SlhNWG9KWE1YM0pYTmJvSlhQbHZKWG9KVEpYb0xrSlhyQVhKWHJIVUpYckpnSlh2SlRKWHZPbkpYNEtuSllBbDNKWUpUOEpZTGh2SllRVG9KWXJRWEpZNk5VSmJBbDNKYkNackpiRGxvSmJHVDhKYkdnckpiSlh2SmJKYm9KYkxmOEpiTGhySmJMbDNKYk1udkpiUmc4SmJTWjhKYm9EYkpickNaSmJyU1VKYjNLbkpiOExuSmZSbjhKZ0FYckpnQ1pySmdEVHJKZ0dackpnR1o4SmdIVG9KZ0pUOEpnSlhvSmdKZ3ZKZ0xYNEpnTFozSmdMWjhKZ0xuNEpnTWdySmdNbjRKZ09ndkpnUFg2SmdSbnZKZ1NUb0pnb0NaSmdvSmJKZ29NWUpnckpYSmdySmdKZ3JMakpnNk1USmxDbjNKbEdndkpsSmw4Smw0QW5KbDhGbkpsOEhnSm5BVG9KbkFUckpuQWJ2Sm5EVW9KbkduckpuSlhySm5KWHZKbkxodkpuTG5ySm5MbnZKbk1Ub0puTVQ4Sm5NWHZKbk1YM0puTWc4Sm5NbHJKbk1uNEpuT1g4Sm5TVDRKblNYM0pub0FnSm5vQW5Kbm9KVEpub09iSm5yQWJKbnJBa0puckhuSm5ySlRKbnJKWUpuck9ZSm5yU2NKbnZDVUpudkZhSm52SmdKbnZKbkpudk9ZSm52UVVKbnZSVUpuM0ZuSm4zSlRLbkZsM0tuTFQ2TFREbHZMVE1ub0xUT24zTFRSbDNMVFNiNExUU2xyTFRvQW5MVG9KZ0xUckFVTFRyQWNMVHJDVUxUckhnTFRyTWdMVDNKbkxVTG5yTFVNWDhMVW9KZ0xWQVRyTFZEVHJMVkxiOExWb0pnTFY4TWdMVjhSVExYRGczTFhGbHJMWHJDbkxYckxYTFgzR1RMWDRHZ0xYNE9ZTFpBWHJMWkFjckxaQWdyTFpBaHJMWkRYeUxaRGxyTFpGYnJMWkZsM0xaSlg2TFpKWDhMWkxjOExaTG5yTFpTVThMWm9KVExab0puTFpyQWdMWnJBbkxackpZTFpyTFVMWnJNZ0xaclNrTFp2QW5MWnZHVUxadkplTFp2T1RMWjNGWkxaNEpYTFo4U1RMWjhTY0xhQVQzTGFBbDNMYUhUOExhSlRyTGFKVDhMYUpYckxhSmd2TGFKbDRMYUxWb0xhTVhyTGFNWHZMYU1YOExiQ2x2TGJGVG9MYkhsckxiSm40TGJMWjNMYkxodkxiTVhyTGJNbm9MYnZTVUxjTG5yTGM4SG5MYzhNVExkck1uTGVBZ29MZU9ndkxlT24zTGZBbDNMZkxudkxmTWwzTGZPWDhMZjhBbkxmOEpYTGY4TFhMZ0pUckxnSlhyTGdKbDhMZ01YOExnUlpyTGhDVG9MaHJBYkxockZVTGhySlhMaHZKWUxqSFRyTGpIWDRMakpYOExqTGhyTGpTWDNMalNaNExrRlg0TGtHWjhMa0dndkxrSlRyTGtNWG9Ma1NUb0xrU1U4TGtTWjhMa29PWUxsM0ZmTGwzTWdMbUFackxtQ2JyTG1HZ3JMbUhib0xtSm5vTG1KbjNMbUxmb0xtTGhyTG1TVG9MbkFYNkxuQWI2TG5DWjNMbkNiM0xuRFR2TG5EYjhMbkZsM0xuR25yTG5IWnZMbkhndkxuSVR2TG5KVDhMbkpYOExuSmx2TG5MZjhMbkxnNkxuTGh2TG5Mbm9Mbk1YckxuTWc4TG5RbHZMblNickxuckFnTG5yQW5MbnJEYkxuckZrTG5ySmRMbnJNVUxuck9ZTG5yU1RMbnZBbkxudkRVTG52SGdMbnZPWUxudk9uTG4zR2dMbjREVUxuNEpUTG40Sm5NVEFab01UQWxvTVREYjhNVEZUOE1USm5vTVRKbnJNVExack1UTGhyTVRMa3ZNVE1YOE1UUlRyTVRvQVRNVHJEbk1Uck9uTVQzSm5NVDRNbk1UOEZVTVQ4RmFNVDhGbE1UOEdUTVQ4R2JNVDhHbk1UOEhuTVQ4SlRNVDhKYk1UOE9UTVVDbDhNVUpUck1VSlU4TVVNWDhNVVJUck1VU1RvTVhBWDZNWEFiNk1YQ1pvTVhGWHJNWEhYck1YTGd2TVhPZ29NWHJBVU1YckFuTVhySGdNWHJKWU1YckpuTVhyTVRNWHJNZ01Yck9ZTVhyU1pNWHJTZ01YdkRVTVh2T1RNWDNKZ01YM09UTVg0Sm5NWDhEYk1YOEZuTVg4SGJNWDhIZ01YOEhuTVg4TGJNWDhNbk1YOE9uTVlBYjhNWUdib01ZSFR2TVlIWDRNWUxUck1ZTG52TVlNVG9NWU9ndk1ZUmczTVlTVHJNYkFUb01iQVhyTWJBbDNNYkFuOE1iR1o4TWJKVDhNYkpYck1iTVh2TWJNWDhNYk1ub01ick1VTWI4QWZNYjhGYk1iOEZrTWNKWG9NZUxuck1nRmwzTWdHVHZNZ0dYb01nR2dyTWdHbnJNZ0hUOE1nSFpyTWdKbm9NZ0xuck1nTG52TWdNVDhNZ1FVb01nckhuTWd2QW5NZzhIZ01nOEpZTWc4TGZNbG9Kbk1sOEFUTWw4QVhNbDhKWU1uQVRvTW5BVDRNbkFaOE1uQWwzTW5BbDRNbkNsOE1uSFQ4TW5IZzhNbkpub01uTFpvTW5MaHJNbk1Yb01uTVgzTW5NbnJNbk9ndk1uckZiTW5yRmZNbnJGbk1uck5UTW52SlhOVE1sOE9UQ1QzT1RGVjhPVEZuM09USFp2T1RKWHJPVE9sM09UM0FUT1QzSlVPVDNMWk9UM0xlT1QzTWJPVDhBVE9UOEFiT1Q4QWdPVDhNYk9VQ1h2T1VNWDNPWEhYdk9YTGwzT1hyTVVPWHZEYk9YNk5VT1g4SmJPWUZab09ZTGJyT1lMa29PWU1nOE9ZU1gzT2JIVHJPYkhUNE9iSmdyT2JMaHJPYk1YM09iT1g4T2I4Rm5PZUFsck9lSlQ4T2VKWHJPZUpuck9lTFRvT2VNYjhPZ0pYb09nTFhvT2dNbnJPZ09Yck9nT2xvT2dvQWdPZ29KYk9nb01ZT2dvU1RPZzhBYk9qTFg0T2pNbm9PalNWOE9uTFZvT25yQWdPbjNEVVBYUWxyUFh2RlhQYnZGVFBkQVQzUGxGbjNQbnZGYlFUTG40UVRvQWdRVG9NVFFVTFY4UVVSZzhRVW9KblFYQ1h2UWJGYnJRYjhBYVFiOEFjUWI4RmJRYjhNWVFiOFNjUWVBbHJRZUxoclFqQW4zUWxGWG9RbG9KZ1Fsb1NuUlRMbnZSVHJHVVJUckpUUlVKWnJSVW9KbFJVclFuUlpyTG1SWnJNblJaclNuUlo4QVRSWjhKYlJaOFNjUmJNVDhSYlNUM1JmR1pyUmZNWDhSZk1nclJmU1pyUm5BYnJSbkdUOFJudkpnUm52TGZSbnZNVFJuOEFhU1RDbHZTVEpnclNUT1hyU1RSZzNTVFJudlNUb0FjU1RvQWZTVG9BblNUb0huU1RvTGpTVG9NVFNUckFhU1RyRVVTVDNCWVNUOEFnU1Q4TG1TVUFadlNVQWdyU1VEVDRTVURUOFNVR2d2U1VKWG9TVUpYdlNVTFRyU1U4SlRTVThMalNWOEFuU1Y4SmdTWEZUb1NYTGY4U1l2QW5TWnJEVVNack1VU1pyTW5TWjhIZ1NaOEpUU1o4SmdTWjhNWVNaOFFVU2FRVW9TYkNUM1NiSFRvU2JRWXZTYlNsNFNib0puU2J2RmJTYjhIYlNiOEpnU2I4T1RTY0daclNjSGdyU2NKVHZTY01UOFNjU1RvU2NvSGJTY3JNVFNjdkFuU2VBWnJTZUFjclNlSGJvU2VKVW9TZUxoclNlTVQ4U2VNWHJTZTZKZ1NnSFRyU2tKbm9Ta0xudlNrOENVU2xGbDNTbHJTblNsOEduU21BYm9TbUdUOFNtSlU4XCIsXG4gICAgXCJBVExuRGxBVHJBWm9BVHJKWDRBVHJNVDhBVHJNWDRBVHJSVHJBVHZEbDhBVHZKVW9BVHZNbDhBVDNBVG9BVDNNWDhBVDhDVDNBVDhEVDhBVDhIWnJBVDhIZ29BVUFnRm5BVUNURm5BWG9NWDhBWHJBVDhBWHJHZ3ZBWHJKWHZBWHJPZ29BWHZMbDNBWnZBZ29BWnZGYnJBWnZKWG9BWnZKbDhBWnZKbjNBWnZNWDhBWnZTYnJBWjhGWm9BWjhMWjhBWjhNVThBWjhPVHZBWjhTVjhBWjhTWDNBYkFnRlpBYm9Kbm9BYnZHYm9BYjhBVHJBYjhBWm9BYjhBZ3JBYjhBbDRBYjhEYjhBYjhKbm9BYjhMWDRBYjhMWnJBYjhMaHJBYjhNVDhBYjhPVW9BYjhRYjhBYjhTVDhBY3JBVW9BY3JBYzhBY3JDWjNBY3JGVDNBY3JGWnJBY3JKbDRBY3JKbjNBY3JNWDNBY3JPVHZBYzhBWjhBYzhNVDhBZkFjSlhBZ29GbjRBZ29HZ3ZBZ29HbnJBZ29MYzhBZ29NWG9BZ3JMbnJBa3JTWjhBbEZYQ1RBbG9IYm9BbHJIYnJBbHJMaHJBbHJMa29BbDNDWnJBbDNMVW9BbDNMWnJBbnJBbDRBbnJNVDhBbjNIVDRCVDNJVG9CWDRNbnZCYiFMbiRDVEdYTW5DVG9MWjRDVHJIVDhDVDNKVHJDVDNSWnJDVCNHVHZDVTZHZ3ZDVThEYjhDVThHWnJDVThIVDhDYm9MbDNDYnJHZ3JDYnJNVThDYjhEVDNDYjhHbnJDYjhMWDRDYjhNVDhDYjhPYnJDZ3JHZ3ZDZ3JLWDRDbDhGWm9EVHJBYnZEVHJEYm9EVHJHVDZEVHJKZ3JEVHJNWDNEVHJSWnJEVHJSZzhEVHZBVnZEVHZGWm9EVDNEVDhEVDNMbjNEVDRIWnJEVDRNVDhEVDhBbHJEVDhNVDhEVUFrR2JEVURiSm5EWUxuUWxEYkRVT1lEYk1UQW5EYk1YU25EYm9BVDNEYm9GbjREYm9MbnZEajZKVHJHVENnRlRHVEdnRm5HVEpUTW5HVExuUGxHVG9KVDhHVHJDVDNHVHJMVm9HVHJMbnZHVHJNWDNHVHJNYm9HVHZLbDNHWkNsRm5HWnJEVDNHWjhEVHJHWjhGWjhHWjhNWHZHWjhPbjhHWjhTVDNHYkNuUVhHYk1iRm5HYm9GYm9HYm9KZzNHYm9NWG9HYjNKVHZHYjNKYm9HYjNNbjZHYjNRYjhHZ0RYTGpHZ01uQVVHZ3JEbG9HZ3JIWDRHZ3JTVG9HZ3ZBWHJHZ3ZBWnZHZ3ZGYnJHZ3ZMbDNHZ3ZNbnZHbkRuTFhHbnJBVHJHbnJNYm9HbnVMbDNIVEFUTW5IVEFnQ25IVENUQ1RIVHJHVHZIVHJIVHZIVHJKWDhIVHJMbDhIVHJNVDhIVHJNZ29IVHJPVHJIVHVPbjNIVHZBWnJIVHZEVHZIVHZHYm9IVHZKVThIVHZMbDNIVHZNWHJIVHZRYjRIVDRHVDZIVDRKVDhIVDRKYiNIVDhBbDNIVDhHWnJIVDhHZ3JIVDhIWDRIVDhKYjhIVDhKbm9IVDhMVHJIVDhMZ3ZIVDhTVG9IVDhTVjhIVW9KVW9IVW9KWDhIVW9MbnJIWHJMWm9IWHZBbDNIWDNMbnJIWDRGa3ZIWDRMaHJIWDRNWG9IWDRPbm9IWnJBWjhIWnJEYjhIWnJHWjhIWnJKbnJIWnZHWjhIWnZMbnZIWjhKbnZIWjhMaHJIYkNYSmxIYk1UQW5IYm9KbDRIYnBMbDNIYnJKWDhIYnJMbnJIYnJNbnZIYnZSWXJIZ29TVHJIZ3JGVjhIZ3JHWjhIZ3JKWG9IZ3JSbnZIZ3ZCYiFIZ3ZHVHJIZ3ZIWDRIZ3ZIbiFIZ3ZMVHJIZ3ZTVThIbkRuTGJIbkZiSmJIbnZEbjhIbjZHZ3ZIbiFCVHZKVENUTG5KVFFnRm5KVHJBbnZKVHJMWDRKVHJPVW9KVHZGbjNKVHZMbnJKVHZOVG9KVDNBZ29KVDNKbjRKVDNMaHZKVDNPYnJKVDhBY3JKVDhBbDNKVDhKVDhKVDhKbm9KVDhMWDRKVDhMbnJKVDhNWDNKVDhSZzNKVDhTYzhKVW9CVHZKVThBVG9KVThHWjhKVThHZ3ZKVThKVHJKVThKWHJKVThKbnJKVThMbnZKVThTY3ZKWEhuSmxKWHJHZ3ZKWHJKVThKWHJMaHJKWHJNVDhKWHJNWHJKWHJRVW9KWHZDVHZKWHZHWjhKWHZHZ3JKWHZRVDhKWDhBYjhKWDhEVDhKWDhHWjhKWDhIWnZKWDhMbnJKWDhNVDhKWDhNWG9KWDhNbnZKWDhTVDNKWUduQ1RKYkFrR2JKYkNUQW5KYkxUQWNKYm9EVDNKYm9MYjZKYnJBbnZKYnJDbjNKYnJEbDhKYnJHYm9KYnJJWm9KYnJKbnZKYnJNbnZKYnJRYjRKYjhSWnJKZUFiQW5KZ0puRmJKZ1NjQW5KZ3JBVHJKZ3ZIWjhKZ3ZNbjRKbEpsRmJKbExpUVhKbExqT25KbFJiT2xKbHZOWG9KbHZSbDNKbDRBY3JKbDhBVW9KbDhNbnJKbkZuTWxKbkhnR2JKbm9EVDhKbm9GVjhKbm9HZ3ZKbm9JVDhKbm9RVG9Kbm9SZzNKbnJDWjNKbnJHZ3JKbnJIVHZKbnJMZjhKbnJPWDhKbnZBVDNKbnZGWm9KbnZHVDhKbnZKbDRKbnZNVDhKbnZNWDhKbnZPWHJKbnZQWDZKbnZTWDNKbnZTWnJKbjNNVDhKbjNNWDhKbjNSVHJMVEFUS25MVEpuTFRMVE1YS25MVFJUUWxMVG9HYjhMVHJBWjhMVHJDWjhMVHJEYjhMVHJIVDhMVDNQWDZMVDRGWm9MVCRDVHZMVCRHZ3JMVXZIWDNMVm9BVHJMVm9BZ29MVm9KYm9MVm9NWDNMVm9SZzNMVjhDWjNMVjhGWm9MVjhHVHZMWHJEWG9MWHJGYnJMWHZBZ3ZMWHZGbHJMWHZMbDNMWHZSbjZMWDRNYjhMWDhHVDhMWUNYTW5MWXJNbnJMWm9TVHZMWnJBWnZMWnJBbG9MWnJGVG9MWnJKWHZMWnJKYm9MWnJKbDRMWnJMbnJMWnJNVDhMWnJPZ3ZMWnJSbnZMWnJTVDRMWnZNWDhMWnZTbHZMWjhBZ29MWjhDVDNMWjhKVDhMWjhMVjhMWjhMWm9MWjhMZzhMWjhTVjhMWjhTYnJMWiRIVDhMWiRNbjRMYTZDVHZMYkZiTW5MYlJZRlRMYlNuRlpMYm9KVDhMYnJBVDlMYnJHYjNMYnJRYjhMY3JKWDhMY3JNWHJMZXJIVHZMZXJKYnJMZXJOYm9MZ3JEYjhMZ3JHWjhMZ3JIVHJMZ3JNWHJMZ3JTVThMZ3ZKVHJMZ3ZMbDNMZzZMbDNMaHJMbnJMaHJNVDhMaHZBbDRMaUxuUVhMa29BZ3JMa29KVDhMa29KbjRMbHJTVThMbDNGWm9MbDNIVHJMbDNKWDhMbDNKbm9MbDNMVG9MbUxlRmJMbkRVRmJMbkxWQW5MbnJBVHJMbnJBWm9MbnJBYjhMbnJBbHJMbnJHZ3ZMbnJKVThMbnJMWnJMbnJMaHJMbnJNYjhMbnJPWHJMbnJTWjhMbnZBYjRMbnZEVHJMbnZEbDhMbnZIVHJMbnZIYnJMbnZKVDhMbnZKVThMbnZKYnJMbnZMaHZMbnZNWDhMbnZNYjhMbnZObm9MbnZTVThMbjNBbDNMbjRGWm9MbjRHVDZMbjRKZ3ZMbjRMaHJMbjRNVDhMbjRTVG9NVG9DWnJNVG9KWDhNVG9MWDRNVG9MZjhNVG9SZzNNVHJFbG9NVHZHYjZNVDNCVHJNVDNMYjZNVDhBY3JNVDhBZ3JNVDhHWnJNVDhKbm9NVDhMbnJNVDhNWDNNVU9VQW5NWEFiRm5NWG9BbG9NWG9KWDhNWG9MZjhNWG9MbDhNWHJBYjhNWHJEVHZNWHJHVDhNWHJHZ3JNWHJIVHJNWHJMZjhNWHJNVThNWHJPWHZNWHJRYjhNWHZHVDhNWHZIVHJNWHZMVm9NWDNBWDNNWDNKbjNNWDNMaHJNWDNNWDNNWDRBbHJNWDRPYm9NWDhHVHZNWDhHWnJNWDhHZ3JNWDhKVDhNWDhKWDhNWDhMaHJNWDhNVDhNWURVRmJNWU1nRGJNYkduRmZNYnZMWDRNYnZMbDNNYjhNYjhNYjhTVDRNZ0dYQ25NZzhBVHJNZzhBZ29NZzhDWnJNZzhEVHJNZzhEYm9NZzhIVHJNZzhKZ3JNZzhMVDhNbG9KWG9NbDhBaHJNbDhKVDhNbkxnQVVNbm9KWHJNbm9MWDRNbm9MaHJNbm9NVDhNbnJBbDRNbnJEYjhNbnJPVHZNbnJPZ3ZNbnJRYjhNbnJTVThNbnZHZ3JNbnZIWjhNbjNNVG9NbjREVHJNbjRMVHJNbjRNZzhObkJYQW5PVEZURm5PVG9BVG9PVHJHZ3ZPVHJKWDhPVDNKWG9PVDZNVHJPVDhHZ3JPVDhIVHBPVDhNVG9PVW9IVDhPVW9KVDhPVW9MbjNPWHJBZ29PWHJEZzhPWHJNVDhPWHZTVG9PWDZDVHZPWDhDWnJPWDhPZ3JPYjZIZ3ZPYjhBVG9PYjhNVDhPY3ZMWjhPZ3ZBbHJPZ3ZIVHZPZ3ZKVHJPZ3ZKbnJPZ3ZMWnJPZ3ZMbjRPZ3ZNVDhPZ3ZSVHJPZzhBWm9PZzhEYnZPbnJPWG9PbnZKbjRPbnZMaHZPbnZSVHJPbjNHZ29PbjNKbnZPbjZKYnZPbjhPVHJQVEdZRlRQYkJuRm5QYkduRG5QZ0RZUVRQbHJBbnZQbHJFVHZQbHJMbnZQbHJNWHZQbHZGWDRRVE1UQW5RVHJKVThRWUNuSmxRWUpsUWxRYkdUUWJRYjhKbnJRYjhMWm9RYjhMbnZRYjhNVDhRYjhNbDhRYjhTVDRRbG9BbDRRbG9IWnZRbG9KWDhRbG9NbjhRbkpaT2xSVHJBWnZSVHJEVHJSVHZKbjRSVHZMaHZSVDRKYjhSWnJBWnJSWjhBa3JSWjhKVThSWjhMVjhSWjhMbnZSYkpsUVhSZzNHYm9SZzNNbnZSZzhBWjhSZzhKYm9SZzhKbDRSbkxUQ2JSbnZGbDNSbnZRYjhTVG9BbDRTVG9DWnJTVG9GWm9TVG9IWHJTVG9KVThTVG9KZ3ZTVG9KbDRTVG9MaHJTVG9NWDNTVHJBbHZTVHJDVDlTVHJDZ3JTVHJHZ3JTVHJIWHJTVHJIYm9TVHJKbm9TVHJOYm9TVHZMbnJTVDRBWm9TVDhBYjhTVDhKVDhTVW9KbjNTVTZIWiNTVTZKVHZTVThEYjhTVThIYm9TVThMZ3JTVjhKVDhTWnJBY3JTWnJBbDNTWnJKVDhTWnJKbnZTWnJNVDhTWnZMVW9TWjRGWm9TWjhKbm9TWjhSWnJTY29MbnJTY29NVDhTY29NWDhTY3JBVDRTY3JBWjhTY3JMWjhTY3JMa3ZTY3ZEYjhTY3ZMZjhTY3ZOVG9TZ3JGWnJTaHZLbnJTbG9IVW9TbG9MbnJTbHJNWG9TbDhIZ3JTbXJKVW9TbjNCWDZcIixcbiAgICBcIkFURmxPbjNBVExnckRZQVQ0TVRBbkFUOExUTW5BWUpuUlRyQWJHZ0puckFiTFY4TG5BYnZOVEFuQWVGYkxnM0FnT1lNWG9BbFFiRmJvQW5EYm9BZkFuSmdvSlRCVG9EZ0FuQlVKYkFsM0Jib0RVQW5DVERsdkxuQ1RGVHJTbkNZb1FUTG5EVHdBYkFuRFVEVHJTbkRVSGdIZ3JEWDhMWEZuRGJKWEFjckVUdkxUTG5HVEZUUWJyR1RNbkdUb0dUM0RVRmJHVUpsUFgzR2JRZzhMbkdib0piRm5HYjNHZ0FZR2dBZzhTY0dnTWJBWHJHZ3ZBYkFuR25KVExudkdudkFURmdIVERUNkFUSFRyRGxKbkhZTG5NbjhIWnJTYkpUSFo4TFRGbkhiRlRKVW9IZ1NlTVQ4SGdyTGpBbkhndkFiQW5IbEZVckRsSG5EZ3ZBbkhuSFRGVDNIblFUR25ySlRBYU1YdkpUR2JDbjNKVE9nckFuSlh2QVhNbkpiTWc4U25KYk1uUmczSmI4TFRNbkpuQWwzT25KbkdZclFsSm5KbFFZM0xURGxDbjNMVEpqTGczTFRMZ3ZGWExUTWczR1RMVjhIVU9nTFhGWkxnM0xYTlhyTW5MWDhRWEZuTFg5QWxNWUxZTFhQWHJMWkFiSlU4TFpEVUpVOExaTVhyU25MWiRBZ0ZuTGFQWHJEVUxiRllyTW5MYk1uOExYTGJvSmdKZ0xlRmJMZzNMZ0xaclNuTGdPWUFnb0xoclJuSmxMa0NUclNuTGtPbkxockxuRlglQVlMbkZab0pYTG5IVHZKYkxuTGxvQWJNVEFUTGY4TVRIZ0puM01UTVhyQVhNVDNNVEZuTVVJVHZGbk1YRlglQVlNWE1YdkZiTVhyRlREYk1ZQWNNWDNNYkxmOFNuTWI4SmJGbk1nTVhyTVRNZ3ZBWEZuTWd2R2dDbU1uQWxvU25NbkZuSlRyT1h2TVhTbk9YOEhUTW5PYkpUOFNjT2JMWkZsM09iTVhDWm9QVExnclFYUFVGbm9RWFBVM1JYSmxQWDNSa1FYUGJySlhRbFBsckpiRm5RVUFockRiUVhHbkNYdlFZTG5IbHZRYkxmTG52UlRPZ3ZKYlJYSllyUWxSWUxuclFsUmJMbnJRbFJsRlQ4SmxSbEZuclFYU1RDbENuM1NUSFRyQW5TVExaUWxyU1RNbkdUclNUb0hnR2JTVHJHVERuU1R2R1hDblNUM0hnRmJTVTNIWEFYU2JBbkpuM1NiRlQ4TG5TY0xmTG52XCIsXG4gICAgXCJBVDNKZ0pYOEFUOEZab1NuQVQ4SmdGVjhBVDhMaHJEYkFaOEpUOERiQWI4R2dMaHJBYjhTa0xudkFlOE1UOFNuQWxNWUpYTFZBbDNHWURUdkFsM0xmTG52QlVEVHZMbDNDVE9uM0hUckNUM0RVR2dyQ1U4TVQ4QWJDYkZUckpVb0NnckRiOE1URFRMVjhKWDhEVExuTFhRbERUOExaclNuRFVRYjhGWjhEVVNUNEpudkRiOFNjT1VvRGo2R2JKbDRHVExmQ1lNbEdUb0FYdkZuR2JvQVh2TG5HZ0FjckpuM0dndkZuU1RvR25MZjhKbnZHbiNIVERUb0hUTG5GWEpsSFR2QVRGVG9IVHZIVERUb0hUdk1UQWdvSFQzU1RDbHZIVDRBbEZsNkhUOEhURFRvSFVvRGdKVHJIVW9TY01YM0hiUlpyTVhvSGJvSmc4TFRIZ0RiOEpUckhnTVRvTGY4SGd2TG5Mbm9IbkhuM0hUNEhuNk1ndkFuSlRKVThTY3ZKVDNBYVFUOEpUOEhUckFuSlhyUmc4QW5KYkFsb01Yb0pickFURlRvSmJ2TW5vU25KZ0RiNkdndkpnRGI4TVhvSmdTWDNKVThKZ3VBVEZUb0psUFlMblFsSmxRa0RuTGJKbFFsRllKbEpsOExmOE9USm5DVEZuTGJKbkxUSFhNbkpuTFhHWENuSm5vRmZSZzNKbnJNWVJnM0puM0hnRmwzS1Q4RGc4TG5MVFJsRm5QVExUdlBiTGJ2TFZvU2JyQ1pMWE1ZNkhUM0xYTlU3RGxyTFhOWERUQVRMWDhEWDhMbkxaRGI4SlU4TFpNbm9MaHJMWlNUb0pVOExackxhTG5yTFp2Sm4zU25MWjhMaHJTbkxhSm5vTVQ4TGJGbHJIVHZMYnJGVExuckxidkFUTGx2TGI2T1RGbjNMY0xuSlpPbExlQVQ2TW40TGVKVDNPYnJMZzZMWEZsckxockpnOExuTGh2RGxQWDRMaHZMZkxudkxqNkpURlQzTG5GYnJNWG9MblFsdUNUdkxuclFYQ1k2TG52TGZMbnZMbnZNZ0xudkxudlNlTGY4TVRNYnJKbjNNVDNKZ1NUM01UOEFuQVRyTVQ4TFVMbnJNVU1Ub0Nack1VU2N2TGY4TVhvRFQ4U25NWDZBVEZUb01YOEFYTVQ4TVg4RmtNVDhNWDhIVHJEVU1YOFNjb1NuTVlKVDZDVHZNZ0Fjck1Yb01nOFNUb0FmTWx2QVhMZzNNbkZsM0Fudk9UM0FuRmwzT1VvQVRIVDhPVTNSbkxYck9Yck9YclNuT2JQYnZGbjZPZzhIZ3JTbk9nOE9YOERiUFR2QWdvSmdQVTNSWUxuclBYckRuSlpyUGI4Q1RHZ3ZQbHJMVERsdlBsdkZVSm5vUVV2RlhyUWxRZU1ub0FsM1FsclFsclNuUlRGVHJKVW9TVERsTGlMWFNURmc2SFQzU1RKZ29NbjRTVHJGVEpUclNUckxaRmwzU1Q0Rm5NWG9TVXJEbEhVb1NjdkhUdlNuU2ZMa3ZNWG9cIixcbiAgICBcIkFVb0Fjck1Yb0FaOEhib0FnOEFiT2c2QVRGZ0FnOEFsb01Yb0FsM0FUOEpUckFsOE1YOE1Yb0NUM1NUb0pVOENsOERiOE1Yb0RUOEhnckFUckRib09UOE1Yb0dUT1RyQVRNbkdUOExockFaOEdudkZuR25RWEhUb0dndkFjckhUdkFYdkxsM0hickFab01Yb0hnQmxGWExnM0hnTW5GWHJTbkhnclNiOEpVb0huNkhUOExndklUdkFUckpVb0pVb0xaclJudkpVOEhUOEpiOEpYdkZYOFFUOEpYdkxUb0pUckpZclFuR25RWEpnckpub0FUckpub0pVOFNjdkpudk1udk1Yb0xUQ1RMZ3JKWExUSmxSVHZRbExiUm5KbFFZdkxick1iOExudkxidkZuM1Jub0xkQ1ZTVEdackxlU1R2R1hDbkxnM01ub0xuM01Ub0xsckVUdk1UOFNUb0FsM01ickRVNkdUdk1iOExYNExoclBsckxYR1hDblNUb0xmOFJnM1NUckRiOExUclNUdkxUSFhNblNiM1JZTG5NblNnT2c2QVRGZ1wiLFxuICAgIFwiSFVEbEduclFYckpUckhnTG5yQWNKWU1iOERVTGM4TFR2RmdHbkNrM01nOEpiQW5MWDRRWXZGWUhuTVhyUlVvSm5HbnZGblJsdkZUSmxRbm9TVHJCWEhYckxZU1VKZ0xmb01UOFNlOERUckhiRGJcIixcbiAgICBcIkFiRGw4U1RvSlU4QW4zUmJBYjhTVDhEVVNUckduckFnb0xiRlU2RGI4TFRyTWc4QWFIVDhKYjhPYkRsOFNUb0pVOFBiM1JsdkZZb0psXCJcbl07XG5jb25zdCBjb2RlcyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkhQCMkJV4mKlwiO1xuZnVuY3Rpb24gZ2V0SGFuZ3VsKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PSA0MCkge1xuICAgICAgICBjb2RlID0gY29kZSArIDE2OCAtIDQwO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID49IDE5KSB7XG4gICAgICAgIGNvZGUgPSBjb2RlICsgOTcgLSAxOTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoWzIyNSwgKGNvZGUgPj4gNikgKyAxMzIsIChjb2RlICYgMHgzZikgKyAxMjhdKSk7XG59XG5sZXQgX3dvcmRsaXN0ID0gbnVsbDtcbmZ1bmN0aW9uIGxvYWRXb3JkcygpIHtcbiAgICBpZiAoX3dvcmRsaXN0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdDtcbiAgICB9XG4gICAgY29uc3Qgd29yZGxpc3QgPSBbXTtcbiAgICBkYXRhLmZvckVhY2goKGRhdGEsIGxlbmd0aCkgPT4ge1xuICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB3b3JkID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB3b3JkICs9IGdldEhhbmd1bChjb2Rlcy5pbmRleE9mKGRhdGFbaSArIGpdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JkbGlzdC5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgd29yZGxpc3Quc29ydCgpO1xuICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZGxpc3Quam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChjaGVja3N1bSAhPT0gXCIweGY5ZWRkZWFjZTljNWQzZGE5YzkzY2Y3ZDNjZDM4ZjZhMTNlZDNhZmZiOTMzMjU5YWU4NjU3MTRlOGEzYWU3MWFcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3Iga28gKEtvcmVhbikgRkFJTEVEXCIpO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIF93b3JkbGlzdCA9IHdvcmRsaXN0O1xuICAgIHJldHVybiB3b3JkbGlzdDtcbn1cbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWtvXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdLbyBleHRlbmRzIHdvcmRsaXN0X2pzXzEuV29yZGxpc3Qge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBLb3JlYW4gbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nS29dXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJrb1wiKTtcbiAgICB9XG4gICAgZ2V0V29yZChpbmRleCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGxvYWRXb3JkcygpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRXb3JkcygpLmluZGV4T2Yod29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nS29gYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0tvKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0tvID0gTGFuZ0tvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1rby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ1B0ID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2wuanNcIik7XG5jb25zdCB3b3JkcyA9IFwiMGFyYWQhb3RvdGVhbGlyZXJ0YWlucmFzb2VudCBob2FuZG9hUiNyaWFyZWhhIWFyb2VsZSdvcm9udWwwQWNhJUFpeG9BbCBBJXJEdXonRWxdRXIkSXNtb08kIFI8ZyhSZXZpIFJpZyBSdXAkUyokU29sdSRTdXI9VXRbMEFiI0FsbSBBbXAgQW5oIEEsRWkuRWwoIEVuIEVydm9Fc3MgRSRuYUhhLklkZXpJbWFJfSNJcnIgTGFtIExpdmVPbGhpZGFPbW9kIE9wbCBPcmQgVW1+IFVzPzBBcC5FZ2FFbnRfRXAkRXF1IEVyLSVFc2l2b0V1c0k8JUl0aXZvSmV0aXZvSnVuJE0nIE9yIFF1JydVYm9WKCxWb2cjMFJ9YXZlMEFzLkVyJ0V0aXZvSW4/SXZgIExpJEx1LSVSfS4wQWNoIEFyciBBcyYvRW5jaSBJbGl6IElvKUl0I08rUiEgUmVzJVJ1cCBVIGQgVWxdMk9gaCBVZCBVcy4xQW1lZGFBcm1lQXN0ciBBdjxjYUIoZ3VlQipvQ2F0K0RlQEVjcmltRWdyQEVyLkZhY2VGKmUlR3VtSGVpb0kgSWNhJUktIEluaCBJdmkgTW9mXk9jIFBpcyVUKCBUaXR1ZGVVYyogVWcgVW5vVXNpdm9WbzBBY2kgQT1yQVtsb0FzcyBCYXNCaS0lRWl4YUVuaXogST1JcyQsSXohZU9sP09uJCBPXyxPc3QrUCAgUGxpIFBvbGEwQWcrbWFBbGlzIEFycXVAQSRtQERhaW1lRWxFeG9HfiBJbSBKb09tJkBPdCNTaW8sVChpfFVpZCFlVW5jaSBab2wxQWc/QWxwIEFuaCNFZ29FbGk9RXJ0XkVzIEV0aSVJJExhdSxMaWNeT2lvT24uT3MpUi1kaXpSb3YgMFVlYygwQW1lQW5dQStDXkQtJUVARWogRW5pJEVzKUdpbG8sR29sYU1hUXVpdm9SYWkmUmViYSVSaXNjIFJvYj51bSBTLSZUKGkmVGlnb1ZvWz0wRiYuSWwjUCcgUz9TKiBTbyYvU3VuJFRyJjBBYyNBZHUrQWwvQVtmIEUgRW5kKEVyX0V1SW5nJ0lyP0l2b09se29SYWMgUmV2aT1SaXpVJlVtMERpJHJNLS5SPm8rVGlzbW9UfEBUdSAwQWxpIEFuJUFyQEVudCZFcyxJP0lzIFVsLDFJbGExQXIgRT1FaSVVbGVqbzpCIEJvc2FDJl11Q2ggYENAR2FnZW1JPG9JbCBJfWUpSXJfSXhpcylKfiBMZUBMaXphTHNhTiZOZHthTi9OJ05xdWUlUmEkUmIjUn1lcz4rYz5+L1NlI1MpbiVUYSlUZT1yVGlkYVRvbVR1YyBVbmlsXTNCKElqb0lyXklzZWJvbExkIWVMZXphTGdhTGlzYyBOZGkkTmcmYU56KFJpbWJhdVJsKmQ+X1NvdV9YaWdhWihfM0NvQ3U9RW4mRm9jJkZ1cmMgR3xuYUxoZSVNZXN0W01vJHJPbG9nQE9tYm9Pc2YoYVBvbCBSci0kU2NvaSRTbmUkU3BvU3NleCRUb2xhWiBfMkluZCNPY29PcXVlIDJBJEJhZ2VtQyNDZWpvQ2hlY11JY28uTF5MZXRpbUxdTG9NYntvTmRlTmVjb05pKVJifmg+ZD5lJlIrY11WKm9YZT8yQW5jb0FzYUF2ZXphRXVJZ2FJbC9JbmMgT2FPY2h1K09uemUgTyRVeG8yQ11EaXNtb0YgTGVSYWNvU2NhUyRaKmE6QjxhQmBvQmlkZUJvQnJpJENhdUNldF5DL3JfQ2lxdWVEYXN0X0RlI0ZleiZJYXF1ZUlwJ2FJeG8lSiNKdUxhZnJpb0xjfiBMZHthTGliciBMbTwlTG8pTV5NYmlzKU1pc2FNb21pbGFNcDxdTXVmbCBOYXZpJk5jYCBOZSlOZ3VydU4vJE5pdmUlTm9hTnMjTi5OdT1QYWMvUGBhUCogUG8uUHJpYy9QdD9QdXpSYWNvbFJifW9SZGUmUmVjPmltYiBSbntvUnBlJVJbJz4pelJ2Ji9TYWNvU2NhU2ViW1MlbG9Tfm9UIGEpVGl2IFVsZVVzP1UlbCBWJm9WKG5hM0JvbGFEaWxdR31dTGViciBMfiBOb3UrTixOJWlvUmMgUnIjUiUnb1J2ZWphVGltVl4yQWNvKUFse2FBbSNBcF5Bcm1lQXRpY2VBdmVFZmVFZ15FJ29FcXVlSWNvJUlmW0luYG9PYyYvT3YoVW1ib1UuVXZhMENhdHJpekNsfWVEIWVEWydhRW4lRzxhTS0kTiROej48ZD5jdWkkUnVyZ0BUIDJBW3phRV9JYyBPbmVVYmUyQT1BZydCYUBCKCRyQnIgQ15FbC9FbnRfRSxHdW1gb0liJ0lmYUlvJUwgTHthTGgoTGlkJ0xtZUBMfW9MdW5hTTw9TWIqIE0tLk1pdGl2YU1vdihNcGxleG9NdW1OY11OPXJOZWMuTmZ1LE5nYCBOaGVjKE5qdWcgTnN1bSdOdCskTnZpJU9wKCBQe29QaT9Qb1F1ZSVsUmFnZW1SZGkmUm5lKVJ9aD5wfCZSW2lvUiVqb1J1aj52b1NzLW9TJWxhVH1lJVVfVXZlVmlsWipdMkElK0F2b0VjaGVFPXJFbWVFckVzcG9JXkltKiZJb35vSXNlSXRpYyBPcylVYVV6e28yQjxvRWNhSWQjSm9MYXQrTG0qIExwIEx0dStNcHInTmgjUGk9UmF0aXZvUnImUnMgUiRTcCdTJSBUYG86TWFzY29UIDNCYSVyQmkuQm9jaGVCfmggQyZxdWVDaW0mQ2xpdmVDbyVDWy5EJkRpYyNEdXonRmVzYUZ1bSBHYG9HK3VHdXMuSXQjSXggTGEkckxlZyNMKmUgTH1nYU08ZGFNaXQnTW9saT1OdGlzKVAtI1BpbCBQb2lzUFtzc2FQdXIgUml2PittIFNhZmlvU2JvLlNjPCxTLS9TZmkjU2dhcyVTaWd1JlNsaXplU21hbSBTb3ZhU3Blc2FTKXF1ZVN2aSBUJmggVC0kclR9IFRyaSRVc2FWKFZpPVZvdCNaLWEzQWcrbWFBbGUkRGEpRnUsR2kuTGF0I0x1LSVNKnUnTmFzdEBOaHtvT2Nlc2VSZSRTY1spU2YgY2VTcCBvU3F1ZSVTc2lwIFMpbiVUP1Vybm9WKCxWaSxyVn5nIFooNUJyP0x8aT1NP00qI05hdGl2b056YD5tLSVScyZTYWdlbVVyI1UkcjJFbmFnZW1JYmxlT2cgQDJFbCBFbmRlRSRQbG9RdWVzPjwlVmk9LDoxTG9kJ08gT2xvZ0AwSWZpYyBJdCZVYyMxRWkkRXRpdiAzRS4xQWJ8IEVnKEVpJHJFbmNvRXY/SW0qIE9naSAwQiBnb0JvbCNCcn4vQnV0aT1FbmRhRXJnJ0lzLHJQYXRAUC0vUCojUG9sZyBQW2dvUHVyciBVbD8wQ2FpeGVDLSNDaC0lQ310X0RldXMgRG9zcyBGYWl4IEZlaSVGaW1HYWojRy0vR2xvYiBHb20jRyt4IEd1QEpvIExhLlF1PCRSYWl6IFJvbCNSdWcgU2Fpb1NlXlMqb1NvcCNUPCRUZSNUaWQhZVR8LlRyXlR+L1YoZyBWaSNWb2x2KFhhbWVYKCRYb2ZbWHUkMUlkKG1lMFVpcCAwRSRHdWk9UmEpVmFWaWxdMEI8aiBCYCRDYW1hQ29sYUNyaSlDdSlGKmdlRm9sIEZbZyBGdW0jR3JpbWFNJiVQPCRQYC9QaWdhUH1qYVBbaSlQdW0gUXUoZGFUYWNhVHthVGljIFRvZiNUW2xhVHU9VmF6aSAwQW5vbElxdWUpMEZ8aT5vcGV1MEFjdSBBcHwgQXNpdm9FbnR1JklkLSVPbHUnMUFnKG9BbCBBbSogQSRBdXMkQ2VzLENpLkNsYW0gRWN1LkVtcGxvSWInSWctJU9uKCBQPGQnUGAnUCcgUGw8IFBvcyRQW3MsUH5zIFQobm9UKiRUKyQ6QnJpYyBCfm8sQ2UpQ2kmRGFEaWdhSXhhTCBMKU1pbGkgTmQ8Z29OZiArTiRjaGVSZCNSYG9SKmg+b2Y+cD50dStUQFR8VnxpKVgqYVotZGEzQ2gjSWpvXkkrbiVMKm9NKipvTmRhTm9SPmkjUnJ1Z2VtUnYoUyVqIFQmVWQmM0Fwb0Jfc2VDIENoe29HdXIjTHthTC9MbWVMdHIgUm1lemFTZ15Tc3UrVGFWYGFYP1hvMkFjaWRlekFtKmdvQW5gYUVjaF5PK1V0dSBVeG8yQyZDKi9Gb2MgR29HdWUlSWNlTGcjTGhlJFJqIFJtaWc+bm9SJVNjb1NzYTJBZ2EpQWxkYUFuZ29Bc2NvQSVybm9FJ2FFbiVFLkllemFJLEl0dStPbl1Vc3RyIFUlJ2EyRydMPG9MaWdlbU5kIE5nb05pbFI/UmlvLFRlYm9sOkIgaSRCKmUlRG9JYSRJb2xhSXZvKUxlZ2FML0wqXUxvY11OaCBSYWdlbVJmb1JnJm9SaW1wb1JvdXA+K2ZhU29kdSRTJFRhVGlsL1ZlKVpgYTNMI0xlQExvTV5NKE1pPU4obyxOZ2l2YU5pJk5vbWFOX09sb2dpPj9SbSogUyxTJHIzTmFzKU5jPGFOZyNSYWY+Km8yQWNpJkljb3NlT2ImT3JpbywyRWxhSWFiYUxmZUxwZSBSZHUrUmplKVJfUyQsVHthVihuIDJBY2Vqb0FkdSZBZmklQWxdQW1wb0FuXkF0dWkkQXZlJEF4YUVnb0VsaCBFdmVJbG9JcyYvSS5AT3MsTyVzY29VZCNVbmhpPVUpMkFjaGVBK25pQXgqaW1FclsgSSBJbmMvSXMjTGFMbyxSdTpCaS5SbX1AUyVWKDNDLmVSZCBSZXNAU2kuM0EkQihuIEQrLkVuYU5vUGlzbW9Qbm9zZVBvJWNhNUplTG9mbyVNZW1OZXMkTnIjUm19JlNwZWQgNU18IzpUZTJFQE8sMk58I1JlamFVPGE0RSxIYVVkaT1VbSogVXN0ciAwQWdlbUVkQCRFbixFcnNpdm9Jbi0lSXQ/T3J0JlBhYyRQZWQnUGw8JVB8UHItc2FQdW5lVW5peiAwQWw/QXAkQXRpdm9DLSxDaCBDaWQnQ2x1J0NvbHxEZWNpLEQnZSREdSRyRWZpY2F6RXItJUY8dGlsRmVzLkYqaSRGbGFtIEZ8bSZGKyRyRygnSWJpPUljaSZJbWlnb0plLk9jLSVPPV9Pdj9PeFF1aWUkU2NyaSRTZSRTaXN0J1NwZSRyU3QmIFN+JFRhYyRUZWdyJlRpbSBUb2MjVHJpZ2FWYSxyVihub1ZpYyRWb2MgMEd1ciUyQW5pPG9Pbml6IFJlJlJpdCMwQ2FFbiRPbCNRdXtvMEFsaTxvOk57b05nXk4pUiBhYz5kaW1SX1NtaW1Ub1YmaVppZGEzSnVtOUFuKl1FbGheRz9JPm4mUnIgVmVtNUJhRGV1RG9jYUl6TGc/TC9SI1JpcylSb1MpOjpCIGVkYUJ8JkNbQyluJURyaWwvRyApR29hSmVNYihNLS5NKiBNcGVqb05jaGVQaWQgUCxSPGo+ez5ndStTPF1TdF9UKCZUaT1WPGRhVm91K1ZyP1g8JVooM0FsZCFlQltHI0ctZCBHaXMpSWdvSWxvIEl0dStNYlslTWVOaD9OdGlsXU9hU21hUyVUaXZvVFsnb1YgVmV6YVZpLjNCKCZCaT1EKCBHIEd7b01pLk1ve29NcD9OZGFOZSBOXWdlbVF1aWRlelMpZ2VtU3UrVHwmVl9YYVh7YTVDP0N1JHJKaXMpTWJvTmFOZ2VOdCtSZGVUI1QoQFVjdStVc2FVdiA1QXJDaWRlekNfTmUpU3RbVD9WYTpDYWNvQ2UlQ2gjQ2lvRHthRHIqXUduYSlHW3phSXxJc0w8ZF9MXUxvJUx1Y29NaWxvTW97b011JU5eTmNdTmRhJE5lcXVpbU4vLE5pdmBhTm9iciBOc2FOJXJOdXNlIFBlI1F1KiBSYz9SZXNpPmZpbVJnZW1SKi9SbWkpUm8kUnF1aXNlUltjb1IlbG9SdWpvU2NvJVNtfCtTc2FnZW1TdGlnIFRhZyZUKG5vVComVHUuWGlsIDNEJl1EaWRhRHVzYUdhZn1lSWdhTDxjQEwvck1iX018aSZOKm9Ob3NOc2FnZW1OdCZSZWMoUmd+L1NeU2NsIFNtb1NxdWkpU3RbVCFlVGVvX1QrZ2VtWChYaWM8bzNDX0cmXUdyIExhZ1tMLSBMaCBNI04oIE4vY2FOaXN0X058QE9sb1I8JVJ0aWxvU3R1ciA1Q2lkIWVEKG5vRH4gRWRhRXJJbi9JKUxkdStMZXphTC9MKmUlTHVzY29OKW5dUXVlYz48Z29SY2Vnb1I9bW9SLWFTYWljb1NxdWUlUy5kYVRgVGltVG9Ucml6NURhSSRMYSlMaChMLk5kaSZOaT1SJmg+Yy9TY34gU2V1U2ljJjpDaX0mRD9KYU1vX1IqPnIjU2MoVGl2YVR1W3phViZdVmVnIFZpbzNCbCphQn5vLEdhdGl2YUdvY2kgR3JpJFJ2byxUYVVyJlZhc2NhVm97bzNOIE4vVGlkZXpWYCA1Qlt6YUklSXZhTWUgTSomUmRlcyVSJSBUIFRpY2kgVHVybm9WYG9WaWwvVm81QmwjRGV6TSgmUGNpJlRyJ1ZlbTowQ2VjI0VkZWMoSmV0aXZvUmlnI1NjdV9TJXQrVChUdXIgMElkLSVJbyxPcnIoVWxpcylVcCMyRWc8JUVuc2l2YUVyLWRhSWMqYVVzYyMwSXZhNEFyQEVvLEggSXZ7YTBCX0VsZSVJcyxJdCcwRH4jRV8sVGVtMUNpfSZFcj9Pbi0lT3J0dW5vT3MkMUFyQmkuRGVtRComRjxhJEdhc21vR34vSS10JklnZW1JdW49TGFUbz14b1YmLzBDaWwgU15Tb1QtLjBJbWlzbW8wUyFAVH1vVHViX1ZpPTBFbF1VbCAxSWQgSWctIDpDYSRDaS0lQ28lQ3R1IEQgQERyKi9HIEdvZGVJbmBJciBJc2FnZW1MYXYrTGVzdCtMaGUpTGkkTG1eTHBpLk5jXk5gYU5mbGUkTnF1ZWNhTiluJlBhZ2Fpb1BgXlAnb1JhZio+Y2kmUmQmUmVkZVJ0aWRhU21vU3MjUyVsVGFtIFQtJVQqIFRfbm9VbF5VcyAzQ35pIEQmIERlc3RbREB0K0QrR15JJHImSXhlTGVMaWM8b05jYU5kdXIgTnthTl1zY29Ocz9OJVJjZWIoUmZlaSRSZ3VuKVJpJFJtaXQnUm4+cGxleG9Sc2k8PiVuY2VSdWNhU2MjU3F1aXNhUyxhVGlzYyAzQWRhQyNFZCFlR20tJExhc3QrTGgjTG8uTS0pTmNgTmd1aW1OXU5vJU4uT257b1BvY2FRdWUlUjxoPmVzUnVlKVNjIFMkbGFUPGdhVmUlMkFuKUFxdWUpQXQqYUViZXVVbWFnZW1VdmkmMUV1MERhRSdhRXRpc2FMZWdeTGljaSBMdS0lTHZpbC9NIE1iYU5kKCBOLkBQfm8sUilTc3UnU3QmVGVVcCBVLFZvIDJBQEFuY11BJEF4ZUVjZUVkP0VmZWkkRW1pIEVucyBFcCAgRXNpbF1FJXgkRXYtJ0V6IEltYSlJbmNlc2FJc21hSXYjT2NlcyxPZHUkT2ZlKU9pYmk9T2plJE9tZSVyT3BhZyBPc2FPJSRyT3Y/MkJsaWMgRGltTCBMbX0gTHN7YU5oJk4nUGlsb1JlemFYPzo5OUFkK0FudEBBciRBc2VFYnIgRWRhRWlqb0VuJUVyaT1JbX1vSW5hSW9zcXVlOkI8XkJpc2NvQ2ggQ2l9IERpJkkgSW5dSW9JdmFKXkwjTSZOZyhOaHUrUCF1K1BgUGlkZXpQb3NhUXVlJVJpZCFlUzwlU2N1bi9TZyBTcD9TJSdhU3VyIFRhejxhVG97YTNBbGV6YUFuaW0gQXYoQmFpeCBCYGRlQm9sIEMjQy0lQ2hlaW9DaWJvQ3xkIENydS5DdSBEZURpbSdEfWRhRHV6aWRhRW52aW9GKiBGbGV0J0ZvZyBGW3Njb0Z1Z2kgRyZAR2ltZUcrSW4jSSRySmVpLkxhdGl2b00/TS09TXwsTm92I1Agb1BgJ1BsZSRQb2wvUFtzYVB1ZGkgUXUoKFMtXVNmcmkgU2dhLlNpZCdTb2x2KFNwZWkkU3NhY2FTKW4lU3VtJ1QmL1QoVCcgVG9tXlQrLlZgIFZpLHJWb2wpM0FjL0NhR2lkZXpHb18sTSBOZ3VlU15TY29TfS81QiZvQ2hlPUReRGVpb0RvdkBFPXJMZSlNPG9OYyBTI1N7YVMkVGFUe29UKmFUfiBVY29VcGFYbzVCX0dpPUdvLEl2b01vUGVzdFtTLDpCfENpIENvbGFDdWQnRGlvRidhR2FHcl5JYl9MXkx7b0xnI0xpdmFMcGljIExzaWNdTC5Mdj9NYiBNdStpTiBOZn1hTmd1ZU5pZCFlUGEkUmQ+Zy0kUmplKVR1ciBVZCFlWG9mfWVafSYzQyBDfiBEYUQtJERpI0RvLER1JHJHbS0kR1s9R3VuPUl2YUxlJEx2YWdlbU08Jk0tJU4/Ti9yTnN1Jk50I1AgI1JlaT4qZz4rUnZvVGVtYl9UfDNHaWxvTGh1ZSlMaWN9ZU1ldHJATXBhdEBNfiBOJk5jKG9OZ34gTm9wc2VOJG5pPi1lUmlUdSM1Qig8b0IrQ3xfR19KYUxkYUxldHIgTCUnb01icmlvTmEpTmQgTmVnIE5oP05vUCtub1F1ZSVScidSJWlvU3NlZ29UYXF1ZVQociBWI1oqLzVBdml6IEJpZGFCbSgsQixsb0J0KydDYSlDZXMsQ29EZXMlRml4b0c/RygnSmVpJExmYSRNJ09yUChpfFBsaWMgUG9zJFByaW0nUmQqPmZpcylScFtzPlsmUnQnU3Anb1MlbiQ6QmBhQmxlJUJ1XkMvRyBgYUxoKExvTHZlek08L01ifGltTXBhTmctJU4kUCBQaW9jPmRpb1JlZj5qPit4YVR1YWdlbVVyKm9YYXRpdm9YaXMpM0F0ciZDKENpPUNsI0RpbyxJYUltIExlZn1lTGgjTXAob04tJU4sck4uUm0mUm5vUnItb1NlU291K1N0I1RvWHR1K1h1Z28zQStHYGFKb2xvTWJyIE1pZGV6TmdpPU4lJ29SYWdlbVR+IDVBbF1DXUwoIExpY2VNXk1pbC9OYE50dStQZSVSPmNpPVJuZWlvUnF1ZVJyIT4kUy5VY2FVcHthWCphMkFiJi9BY2VqIEFkdSRyQWZlZyBBamUkQW1hQW5jIEFwb0Fze29BdD9BdiBFKm9FbShFcGlkIEV2b0lhZ2VtSWJvSWNpY2xvSWQtJUlsb2dASW5kIWVJcGxvSXR1ciBJdW5mJk9jIE9tYmUpT3ZhVW5mb1VxdWUyQn4gQzxvRG9MaXBhUGlSYm9SbT5xdWVzYVRgIFR8aSY6N1YgM0JpZ28wSGFJZCFlSWZ8bWUzT2xvZ0BTb1RpZ2FVYnUwQT1JbmFVZnJ1JzpDKmFEaSBHIG8sST0sTGFMLSVMaWQhZUxvW3NOKWdlbVF1e29SPGQ+ZSlScihTY34gU2lsXVMsdStaIFppbzNBPUQgR2UuSWN+IEx7b0xoaWNlTHU9TmNlPXJOZGF2Jk4oIE50W1JiJlJkIWVSZT9SZ31oPm1gL1JuaXpScyBSJW4lU3BhU3RpPVR8aSYzQWR1JEFnZW1BaiBBdHUrQnI/RHthRHIgQEVsYUdhRy0lR2kgR3wgTCBlam9OY29OaGUpTmlsT2xlKVIhPnR1ZGVTaS5TJFRyJlZ7b1oqLzVBPXJBckcmTDwlTGVpYm9sTClnZW1MdW1vLE50IWU1TCRWdXpgYTo6RFt6Um9wZTNRdWVSZS5SaWZlM05nIDo6TmcjUnAgM0J1TD85TWIgT2xvZ0A1TWJpPVwiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4MjIxOTAwMDkyNmRmN2I1MGQ4YWEwYTNkNDk1ODI2Yjk4ODI4N2RmNDY1N2ZiZDEwMGU2ZmU1OTZjOGY3MzdhY1wiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktcHRdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ1B0IGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBQb3J0dWd1ZXNlIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ1B0XV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwicHRcIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nUHRgYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ1B0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ1B0ID0gTGFuZ1B0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1wdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ1poID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHdvcmRsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC5qc1wiKTtcbmNvbnN0IGRhdGEgPSBcIn1hRSM0QT1ZdiZjbyM0TiM2Rz1jSiZTTSM2NnwvWiM0dCZrbn40NiM0S340cSViOT1JUiM3bCxtQiM3V19YMipkbH1Vb343c31VZiZJdyM5YyZjd342TyZINiZ3eCZJRyV2NT1JUX44YSZQdiM0NyRQUiY1MCVLbyZRTSYzbCM1ZixEOSM0THwvSCZ0UTt2MH42bl1uTjxkaSxBTT1XNSVRTyZrYSZ1YSxoTV50bT16Vj1KQT13UiYrWF03UCZOQiM0SiM1THwvYltkQX10SjxEbyY2bSZ1MltVMSZLYi5ITSZtQz13MCZNVzxyWSxIcSM2TX1RRywxMyZ3UH1KcF1PdyV1ZSZLZzxIUDxEOX40a345VCZJMl9jNiQ5VCM5L1tDNX43T340YT1jcyZPNz1LSz1BbiZsOSQ2VSQ4QSZ1RCZRSXwvWSZiZ31VeCZGMiM2Yn1FMiZKTiZrVyZrcD1VLyZiYj1YbDxDan1rK341SiM2TCY1eiY5aX1iNCZGbyxobyhYMF9nM340TyRGeiZRRTxITj1Xd102LyVHRi1Wdz10aiYvRCZQTiM5Zz1ZT31jTCZPZiZQSX41SSZJcD12VT1JVyM5Rzswby13VX1zcyZRUjxCVCZSOT10ayRQWV9kaCZQcS15aF03VCxuai5YdT1FUCY3Nj1jSSZGcypYZ316NyRHYiYrST1ERixBRj1jQX1yTCM3aj1EeiYzeTxBYSQ1Mj1QUX1iMChpWSRGYX1vTCZ4ViM2VT1lYz1XWix4aCVSWTxkcCM5TiZGbCY0ND1XSCpBNz1zaCZUQiY4UD0wNzt1KyZQS311aH1KNSM3MilWLz14QyxBQiRrMCZmNjsxRXwrNT0xQiwzdl02biZ3UiViKyZ4eF03Zj1PbH1mbDsrRF53R103RTtuQjt1aF5JciZsNT1KTCxuUz1jZj1nNTt1NnwvUSRHYz1NSCVIZyM1ZCVNNl44Nj1VKyRHeixsLyxpcl41eSZCYSYvRi1JWSZGSSZiZSVJWiM3NyZQV19OdSRrRShZZiZOWF03WixKeSZGSihYbyZOeiMvZD15NyZNWDxBZ31aKztuRV1EdChpRyM0RD0xMyZQan40YyV2OCZabyVPTCYvWCM0VzxIUiZpZX42Sl8xTyhZMj15NT1BZCpjdl9lQiM2ayZQWDpCVSM3QTt1ayZGdCZGeF9kRD1VMjt2Qj1VNT00Rn0rTyZHTi5ISDo5cz1iMCVOVihqTyZJSD1KVH1aOT1WWjxBZixLeF40bSZ1SiVjNiw2cjs5bSMrTH1jZiVLaCZGM340SD12UH1idSxIenwrKywxd11udn1rNjt1dSRqdypLbCpXWCZ1TVt4NyZGclttNyROTyZRTl1odT1KTn1uUl44ZyMvaChwc3xLQzt2ZH14ej1WMH1wNiZGRCRHMSM3SzxiR180cH44ZyZjZjt1ND10bH0rayU1L31mejt1dzxjQT11MX1nVX1WTT1MSj1lWCYrTCZQciM0VX1wMjpuQywyS103SDpqRiY5eH11WCM5Tz1NQjxmen44WH41bSY0RCZrTiZ1NSVFLyhoNyhaRiZWRzxkZShxTXwvZS1XdD0zeChhKywvUl1mLyZORCRSbyZuVX0wZz1LQSVrSCZOSyRLZTxkU31jQiZJWH41ZyRUTl02bT1VdixJcyZQeT1FZiVLeiMrLyViaSYrQTxGNCRPRyY0QyZGTCM5Vjxaaz0ySV9lRSY2Y11udyZrcSRIR315KyZBOCRQM31PSD1YUF03MCVJUyhBSl9nSCVHWiZ0WSZBWj12Yn42eSYvcj1WST1XdjxaaT1mbD14ZiZlTH1jOH1PTD1NSj1nOCRGNz1ZVH05dT0wK154Q31KSCZuTF5OMH40VF1LMixDeSVPQyM2czt2RyhBQ154ZV5jRyZNRn1CciM5UDt3RC03aCRPLyZ4QX1Gbl5QQ102aV03RyY4ViRRczt2bChUQn43M340bDxtVyY2Vj0yeSZ1WSYrMylhUH1YRjtMUCZreCR3VT10Nzt1eTxGTiZseik3RT1PbypZKzt3SX05cX1sZTtKNiZSaSY0dCZRciM4Qj1jYiZ2Rz1KNXxRbChoNTxZeX40K31RRCxMeD13biVLLyZSSz1kTyZQdyxROT1jbyU0dTs5dX1nMEA2YV40SSViMD16b3wvYyZ0WD1kUT1PUyMrYj15el9BQiZ3QiZQbT1XOSRIUF9nUj02Mj1BTz10aT1oSSxvQSZqciZkSD10bSZiNiRQMih4OD16aTtuR343RjswNV0wbltJeCYzbX1yZz1YcD1jZCZ1el03dDs5Nz1jTjt2VjxqZiZGRiZGMT02USZJaypLayZQNCwyej1mUV03RCYzdSxIMD1kL31VdzxaTjw3Un1LdjswZiRINyxNRF03biRGMCM4OH45WiVkYT1ieTsrVCMvdT1WRiZmTyZrcl5rZjxBQl1zVSxJNSROZyZQejswaSZRRCZ2TT1ZbDpCTTtuSl94Sl1VNyZLZiYzMCwzZnxaOSpkQylqZV9qQSZRNCZLcCROSChZeiM2UyZJZCVJYj1LWCxBRD1LViVkUH10VyZQa14rRV9OaT1jcSwzUn1WWihTaT1iK31ydjswan1yWl11QSwvdyhTeCZKdiR3OSY0ZCZ3RSxOSiRHeT1KL11McyM3azxaUTxZLyZ1al1PdiRQTTt2MywyRiYrdTp1cD1PbiYzZSxKdjs5MD1KKyZRbV02cX1iSyMrZH44WShoMl1oQTs5OSZBUz1JL31xQiZkUX15Si1WTX1WbCZ1aSxpQiZHM3xEY103ZD1lUSVkWCVKQ18xTH40ZF5OUDt2SiYvMSlaSSM3Tl05WFtiUSZQTD0wTChVWixMbSZrYyZJUn1uNyhpUjxBUTxkZz0zMz12Tn1mdH1hdV03SSxCYT14OT1kUn42UiZUcT1YaSwzZCROciZCY31ESSZrdSZ2Zl1EbiwvRiZpRCxMbCZOdz0weSZJNz1Mcz0vQSZ0VT1RZX1VYSZ1ayYrRj1nND1naD1WaiMrMSZRbn1VeSo0NCM1RixQYyZSeipYbj1vaD01Vzswbl9OZihpRTxZNz12cj1adV1veiM1WiVtST1rTj1Cdl9KcChUMjt2dF9NbDxGUyZ1ST1MLyY2UF02NCRNN304NjxibyVRWChTSSVJWSZWSz1BbCZVeDt2djt1dCpFLyV1aDxaRXxPMyxNMih5Y115dT1XayZ0cDpFeH1ocixDbCZXRSkrWj04VX1JMl80USxoQV9zaT1pdz1PTT10TT15WiVJYT1VNzt3VH1iKzt1bz1aYX15UyE1eH1IRH1mYiM1T19kQTtOdiV1Qih5QjswMShTZn1Gazt2N31QdCM4djxtWiM3TCwvciZQbH40dyZmNT1QaCRGd19MRiY4bSxiTD15SiZCSH1wLypKbn10VX41UTt3QihoNl1EZl04cF4rQjtFNCZXYz1kKztFYSZidyQ4QyZGTixETT1ZZn1tUH41dz1mVCM2Vj1tQz1GaT1BVn1qQiZBTn1sV31hSCMvRClkWjtobDt2RX0vNyxDSjszMSZ3OCxoaiV1OV9Kcz1qSiY0TX44az1UTiZlQ31uTCZ1Yy13aSZsWH1kaj1Ndj1lMiM2dT1jciR1cSQ2R104V31KYjpubT1ZZzxiMyhVQTt2WCY2biZ4Rj1LVCxqQyxEZSZSOCZvWT1adiZvQl03Lz1aMiZPYX1iZixoaCg0aF50WiY3MiZOeDtEMiZ4TH41aH40MClaRyloKz1PSiZSQV1CdiR5Qj1PcT1kZixBUSVKbn1PSjsxMSwzeiZUbCZ0ajt2K15IdixEaChpZD1zK103TiZOMyk5UX44ZixTND11Vz13NCZ1WCxMWCYzZF1DSiZ5cCY4eDxiMl9kbyZsUD15LzxjeV9kRz1PaT03UihWSChsdF8xVCxJcV9BQTsxMl42VCVrNiM4S1tCMXtvTzxBVVtCdDsxYiQ5UyZQczw4VD1TdHtiWSxqQihacCY2MyZVdiQ5VixQTV02diZBZn16V1tiV19vcX1zbX1uQiZLcSZnQyZmZl9lcV8ybSY1RiZUSX1yZn1HZjtacl96OTtFUiZqa31pel9zbjxCTn4rbiZ2bz1WaSU5N3xaUj1XYyxXRSY2dF02eiU4NShseSM4ND1LWSk2bV81Lz1hWCxOM31UbSZoZSY2S110Ul9CMi1JMzt1LyZoVSZsSDxBUD1pQiZJQT1YTDsvNSZOaD13djxCSCM3OT12Uz16bDxBQT0wWF9SR31CdyY5cCROVyxBWCZrUF9McCYvWihUY11NdX1ocyM2SX01QiZjSTxicSZIOSM2bT1LOX12SChZMShZMCM0QiZ3NiwvOSZnRzxiRSwvTz16Yn1JNF9sODxCLzt3TCVRbzxIT1tNcT1YWH0wdiZCUCZGNChtR30waX1ubSxFQz05dXtJMyx4RyYvOT1KWSpESyZoUilCWD1FST1jeD1iL3s2a315WCVBKyZ3YX1YYj1sYTt3aV5sTDswdH1qbyZRYj14Zz1YQn1pTzxxb3tiUj1OViY4Zj1hMCZKeTswdj11SylISzt2TiM2aCZqQihoLyV1ZCZOSSV3WS5YNz1QdH1DdS11TCZHc19obCVtSCx0bV03OD1MYl5RMCM3WT0xdTxCdCYrUT1Db19SSCx3MzsxZX11eDxhVTt1aX1VMyZRNSVidF02MyZVUXwwbCZ1TH1PNyYzbyxBViZkbXxOaihYdCo1KyhVdSZIaChwNyhVRj1WUj1CcF5KbCZIZFtpeCk5Lz1JcV1DODw2N102Nn1tQiU2Zn1iYn1KSV04VCRIQX1kYj1ZTSZwYT0ySn10UyZZMD1QUyZ5ND1jWCQ2RSxoWCxYUCZuUjswNCxGUSZsMCZWbV9EdiM1WX44Wj1CaSVNQV02eD1KTzorcCxBeiY5cSxIan42L31TRD1LMTpFSn1uQTtRbyMvRV05UixJZSY2WCVXM102MSZ2ND14WF9NQz0wcTswNihYcT1mc31JR31Edj0wbH1vNyRpWjs5diZMSCZEUC03YSZPWSxTWixLeixDdiZkaD1meHxOaCxGL343cT1YRiZ3Kzs5biZHdzswaH1aNzw3TyZKSyhTNyZMUzxBRDxhYz13bzxEdCZ6dyU0Qj00diM4UDs5b342cCp2Vj1UbSxPciZJNj0xcX1uWT1QMD1ncSZCbCZVdSxDaCV5Yn1VWT16aH1kaH1ybChUNF94ayhZQSM4Uip4SCxJTn1Kbl03Vn1DNCZUeX1qM103cD1jTD0zaCZ3VyVRdjxaMz1mMCZSSSYrUyhpY196cX1vTiYvWT16MTtUZD1MVz0wZT1PSShWYywrYl5qdShVTDswcjpaYSU4dj1ScD16dyY1OCY3MyZ3S31xWF02eSY4RSlhMn1XUj13UF51ciZuUTxjSH1SZT1BcSZ3a31RMCYrcT1QUCxHY3wvZF5rNSxGd104WX1QZ11wMz1qdT1lZH1yNV95ZiZDc103eiQvRzxDbSZKcCY1NF8xR19nUF9MbH1KWjswdV1rOF83ayhTZ102NXs5aT1MTiZTeCZXSyxpVyZmRCZMa3s5YX1FbS05YyM4TiZpbz1zeV04ZCZuVCZJSyhseCM3LyRsVyhUZDxzOH40OSwzbzw3WT1NVyhUK19KciZXZCxpTH1DdD14aCY1Vjt2NCY4biVLeD1pRiZsMl8wQntCKyxJZihKMCxMdjt1OD1LeC12Qj1IQyZ2Uz1aNiZmVSZ2RV54SzszRD00aD1NUiM0NTpKdzswZH1pdz1MVX1JNT1JMF1nQippbSxLOX1HVSwxa180VSZUdD1WcyhpWCZsVShURiM3eSxaT31vQSZtNSM1UH1QTn1Vej1oTTxCMSZGQjxhRyxlNn43VDx0UChVUV9aVD13dSZGOClhUV1pTiwxcl9MbyYvZzpDRH04NHtKMV9LaSZOYSYzbiRqeiZGRT1kYzt1djt2YX1pbn1sbD1mdihoMSYzaH1mcD1DeX1CTSgrRX44bX1sbyV2Nz1oQyhUNiRjaj1CUT1CdyhEUiwyaj1LcyxOU3xGKzswMD1mVT03MH1NYihZVTsrRyZtNyZocj1TayVDb110KyhYNV9Kd30wcn1nQyhBUy1JUCZRSzxaMiM4USRXQ11XWH1UMiZwR19LYSxIQz1SNCYvTjtaKztjaChDNyxENCQzcF9NayZCMiQ4RD1uOSVLeSM1eihDVCZRSiM3Ql1EQ11nV31uZn41TTtJdyM4MH1UY18xRiM0Wi1hQ31IbD1waD1meiwvMz1hV31KTX1ubjtERzt2bX13biw0UH1UMzt3eCZSRyR1K316Sz0wYjsrSl9Fa3tyZTxhWj1BU315WSM1RF03cSxDcH14Tj1WUCoyQ31HWn1hR34rbV9Dcz1PWSM2cl02ZzxHU31MQyhVQj0zQT1Cb31KeTxjNH1JczsxUDxBR31PcDxaMX1sZH1uUz0xWix5TSY5NSY5OD1DSig0dDoyTCRIaz1ab31WYzsrSX1ucCZOMX05eT1pdn1DTyo3cD1qTClweF10Yl56aCZHUyZWbCV2Lzt2Uj0xND16SiY0OXwvZl1oRn1XRzswMz04UH1vLyZHZyZycDtEQixLdn1KaSZQYjthQV5sbCg0aiV5dH0rSyRIdCM0eSZoWV03WTxGMSxlTn1iRyhVaCU2Wl10NSVHNzsrRl9SRTtpdH10TD1MUyZEYT1YeChTKyg0Zj04Rz15SX1jSn1XUD0zNz1qU31wWH1oZClmcDxBOD1KdH4rbyRISj1NNn1pWD1nOX1DUz1kdj1DaihtUCVLZCx4cXwrOSZMRCg0Lz1YbSZRUD1MY31MWCZmTDsrSz1PcChsdT1Rcy5xQzorZSZMKz1KaiM4dztTTF03UyhiKyM0ST1jMSZuR19MZiZ1SDsrUilaVjxiViVCLyxURSYwSCZKcSZBaCVPRiZTcyhwMixXdiZJMz1XbH1WcTsxTCZsSiM5Yl8xSD04cj1iOD1KSChTWj1oRD1KMiM3VSwvVSMvWH42UCxGVTxlTD1qeCxtRz1oRz1DRSZQVT1TZShxWCZMWT1YNj15NCZ0ayZRUSZ0Zj00ZyZ4SX1XKyZtWj1EYyM3d31MZztEQTt3UV9LYihjSj1oUiV5WCZZYixod3tiWF80WDtFUDsxV18yTX1VYz1iNShZRixDTSZUcF5PSntERF02cz12Rj1Zb344cX1YSH1GdSVQNShTSj1RdDtNT11zODxGMyZCMyY4VChVbC1CUypkdyZkUjw4N30vOF02MiRQWl1MeDxBdX05UV03Yz1qYT1LUixHbyxVcyZ2Nihxa31wRyZHMj1ldl5HTSV3NCZINF03RiZkdl1KNn1Fdzo5dz1zai1aTH1ZbSQraChVdChVbX40bj1YcyhVNyVlRT1RY19KUjxDQSM2dDxGdnwvSSxJUyxFRzxGMihYeSQvbjxGYShoOX0rOV8ybyZONCM3WDxacXwrZl9EcD1kdCZuYSxDYT1OSilqWT04Qz1ZRz1zNiZRKzxET31EMz14QiZSMShsdztRbjxiRihDdXwvQn1IVj1TUyZuNywxMCZ1MF1EbSVBNl40UT1XUihURD1YbzxHSCxSaihsOCliUCZuLz1MTSZDRixGNSZtbD1QSjswaz1MRz10cSxSaCxENkA0aT0xcCYrOT1ZQyVlcl9NaDtuSTswcT1Gd104MD14cT1GTSRHdjt2NiZuYzt3SyVIMiZLajt2cyxBQT1ZUCw2Nn1iSShxUn41VT02cX40YiROaT1LNS5YMyRTbyZJdShwK104Rz1DZj1SWShUU19PMyhpSCY1Nz1mRT1EZ19EbyM5eiM3SDtGS3txZF8yayVKUn1lbiZnaF96ODtSeH05cDxjTl9OZSxETztMTl83b34vcD1ORj01WX1nTjxjZTxDMSxRRV1Xdj0zdTxCQ31HS115cX1EWSZ1L19oaj1JSShweiZyQyxqViYrWn11dD1OUTtDZy1TUl9aUywrbz11LztPeV9SS19RRihGeCZ4UH1XciZUQSxVaCZnMT15cntheFtWRiRQZyhZQjtPeD1WeTsrVyhTcH1YViVkZCYzMyhsL11sNCM0WX1PRT02Yz1idyhBNyY5dCV3ZCZOLyZtbyxKSCZRZSlmbT1Bb31mdT10SFwiO1xuY29uc3QgZGVsdGFEYXRhID0gXCJGQVpEQzZCQUxjTFpDQStHQkFSQ1c4d05DY0REWjhMVkZCT3FxRFVpb3UrTTQyVEZBeUVSWEZiN0VqaFArdm1CRnBGclVwZkRWMkY3ZUIrZUNsdENISkZXTEZDRUQrcFdUb2pFSUhGWGMzYUZuNEY2OHpxakV1S2lkUzFRQlZQREVoRTdOQTRtaE1GN29UaEQ0OW90M0ZndHpIRkNLMGFjVzF4OERIMUVtTG9JbHJXRkJMRSt5NStOQTNDeDY1d0pIVGFFWlZhSzFtV0FtUEd4Z1lDZHh3T2pUREl0L2ZhT0VoVGwxdnFOc0t0SkNPaEpXdWlvMmcwN0tMWkVRc0ZCVXBOdHdFQnlCZ3hGc2xGaGVGYmlFUHZpNjFtc0R2QXB4Q3pCNnJCQ3pveDdqb1lBNVVkRGMrQ2I0RlNnSWFicFhGQWozYmprbUZBeENaRSttRC9TRmYvMEVMZWNZQ3QzbkxveEM2V0VaZjJ0S0RCNG9adnJFbXFGa0trN0J3SUxBN2d0WUJwc1RxLy9ENGpEMEYwd0VCOXB5UTFCRDVCYTBvWUhESStzYkRGaHZySFhkREhmZ0ZFSUpMaTVyOHFlcmNORkJnRkxDNGJvNUVSSnRhbVdCREZ5NzNLQ0ViNk04VnBtRXQzMzB5Z0NUSzU4RUlJRmtZZ0Y4NGd0R0E5VXloM202OGlWckZiV0ZiY2JxaUNZSFo5SjFqZVJQYkw4eXN3aE1pRGJoRWhkTm9Td0ZiWnJMVDc0MEFCRXFnQ2tPOEoxQkxkMVZoS0tSNHNEMXlVbzB6K0ZGNTlNdmc3MUNGYnlFaGJIU0ZCS0VJS3lvUU5nUXBwcTlUMEtBcWVQdTBaRkdyWE9IZEtKcWtvVEZoWXZwRE55dXV6bnJOODR0aEpic0NvTzZDdTZYbHZudHZ5MFFZdUFFeFFFWXRUVUJmM0NvQ3F3Z0dGWjR1MUhKRnpEVndFeTNjamNwVjRRdnNQYUJDM3JDR3lDRjIzbzRLM3BwMmdiZXJHZ0ZFSkVIbzRuSElDdHlLSDJacXl4aE4wNUtCQkpJUWxLaC9PdWp2L0RIMzJWcmxxRmRJRkM3Rno5Q3Q0a2FxRk1FMFVFVExwcm5OOWtmeStrRm10UUJCMCs1Q0Z1ME45SWo4bC9WdkpEaDJvcTNoVDZFempUSEtGTjdaalp3b1RzQVo0RXhza282RnBhNldDK3NkdXo4anlyTHBlZ1R2MmgxRUJlWXBMcG0yY3pRVzBLb0NjUzBiQ1ZYQ211V0pEQmpOMW5RTkxkRjU4U0ZKMGg3aTNwQzNvRU9LeS9GakJrbEw3MFh2QkVFSVdwMnlaMDR4T2J6QVdEREpHN2YrRGJxQkVBN0x5aVI5NWo3TURWZERWaXoyUkU1dldsQk12NWU0K1ZmaFAzYVhOUGh2TFN5bmI5TzJ4NHVGQlYrM2pxdTZkNXBDRzI4L3NFVEJ5dm11LytJSjBMM3diNHJqOUROT0xCRjZYUElPRHI0TDE5VTlSUm9mQUc2Tnh5ZGk4QmtpOEJoR0piQkFKS3piSnhrWlNsRjlRMkN1OG9LcWdnQjloQkFyd0xMcUVCV0V0Rm93eThYSzhiRXl3OXNuVCtCZXlGazFaQ1NyZG1nZkV3RmVQVGdDakVMQkVuSWJqYUREUEptMzZyRzlwenRjRXpUOGRHazIzU0JoWEJCMUg0eitPV3plMG9vRnp6OHBEQllGdnA5ajl0dkZCeWY5eTRFRmRWbnowMjZDR1I1cU1yN2Z4TUhOOFVVZGx5SkF6bFRCRFJDMjhrK0w0RkI4MDc4bGp5RDkxdFVqMW9jblRzOHZkRWY3em5iem0rR0lqRVpub1pFNXJuTEw3MDBYYzd5SGZ6MDVuV3h5MDN2QkI5WUdIWU9XeGdNUUdCQ1IyNENWWU5FMWhwZkt4TjB6S25mSkRtbU1nTW1CV3FOYmpmU3lGQ0JXU0NHQ2dSOHlGWGlIeUVqK1Z0RDFGQjNGcEMxekkwa0ZiemlmaUtUTG05eXE1ekZtdXIrcThGSHFqb09CV3NCUGlEYm5DQzJFcnVuVjZjSjZUeWdYRllIWXA3TUtOOVJVbFNJUzgveEJBR1lMemVxVW5CRjRRYnNUdVVrVXFHczZDYWlEV0tXalFLOUVKa2pwa1RtTkNQWVhMXCI7XG5jb25zdCBfd29yZGxpc3QgPSB7XG4gICAgemhfY246IG51bGwsXG4gICAgemhfdHc6IG51bGxcbn07XG5jb25zdCBDaGVja3MgPSB7XG4gICAgemhfY246IFwiMHgxN2JjYzRkODU0N2U1YTcxMzVlMzY1ZDFhYjQ0M2FhYWU5NWU3NmQ4MjMwYzI3ODJjNjczMDVkNGYyMTQ5N2ExXCIsXG4gICAgemhfdHc6IFwiMHg1MWU3MjBlOTBjN2I4N2JlYzFkNzBlYjZlNzRhMjFhNDQ5YmQzZWM5YzAyMGIwMWQzYTQwZWQ5OTFiNjBjZTVkXCJcbn07XG5jb25zdCBjb2RlcyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuY29uc3Qgc3R5bGUgPSBcIn4hQCMkJV4mKl8tPVtde318OzosLigpPD4/XCI7XG5mdW5jdGlvbiBsb2FkV29yZHMobG9jYWxlKSB7XG4gICAgaWYgKF93b3JkbGlzdFtsb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdFtsb2NhbGVdO1xuICAgIH1cbiAgICBjb25zdCB3b3JkbGlzdCA9IFtdO1xuICAgIGxldCBkZWx0YU9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcbiAgICAgICAgY29uc3QgcyA9IHN0eWxlLmluZGV4T2YoZGF0YVtpICogM10pO1xuICAgICAgICBjb25zdCBieXRlcyA9IFtcbiAgICAgICAgICAgIDIyOCArIChzID4+IDIpLFxuICAgICAgICAgICAgMTI4ICsgY29kZXMuaW5kZXhPZihkYXRhW2kgKiAzICsgMV0pLFxuICAgICAgICAgICAgMTI4ICsgY29kZXMuaW5kZXhPZihkYXRhW2kgKiAzICsgMl0pLFxuICAgICAgICBdO1xuICAgICAgICBpZiAobG9jYWxlID09PSBcInpoX3R3XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IHMgJSA0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbW1vbjsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gY29kZXMuaW5kZXhPZihkZWx0YURhdGFbZGVsdGFPZmZzZXQrK10pICsgKChpID09IDApID8gMjI4IDogMTI4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3b3JkbGlzdC5wdXNoKCgwLCBpbmRleF9qc18yLnRvVXRmOFN0cmluZykobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKSk7XG4gICAgfVxuICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZGxpc3Quam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChjaGVja3N1bSAhPT0gQ2hlY2tzW2xvY2FsZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCSVAzOSBXb3JkbGlzdCBmb3IgJHtsb2NhbGV9IChDaGluZXNlKSBGQUlMRURgKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBfd29yZGxpc3RbbG9jYWxlXSA9IHdvcmRsaXN0O1xuICAgIHJldHVybiB3b3JkbGlzdDtcbn1cbmNvbnN0IHdvcmRsaXN0cyA9IHt9O1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS16aF9jbl1dIGFuZCBbW2xpbmstYmlwMzktemhfdHddXSBmb3JcbiAqICBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nWmggZXh0ZW5kcyB3b3JkbGlzdF9qc18xLldvcmRsaXN0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ2hpbmVzZSBsYW5ndWFnZSBXb3JkbGlzdCBmb3JcbiAgICAgKiAgdGhlICUlZGlhbGVjdCUlLCBlaXRoZXIgYGBcImNuXCJgYCBvciBgYFwidHdcImBgIGZvciBzaW1wbGlmaWVkXG4gICAgICogIG9yIHRyYWRpdGlvbmFsLCByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nWmhDbl1dIGFuZCBbW2xhbmdaaFR3XV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlhbGVjdCkgeyBzdXBlcihcInpoX1wiICsgZGlhbGVjdCk7IH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gbG9hZFdvcmRzKHRoaXMubG9jYWxlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb2FkV29yZHModGhpcy5sb2NhbGUpLmluZGV4T2Yod29yZCk7XG4gICAgfVxuICAgIHNwbGl0KHBocmFzZSkge1xuICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvKD86XFx1MzAwMHwgKSsvZywgXCJcIik7XG4gICAgICAgIHJldHVybiBwaHJhc2Uuc3BsaXQoXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nWmhgYCBmb3IgJSVkaWFsZWN0JSUsXG4gICAgICogIGNyZWF0aW5nIGl0IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogIFVzZSB0aGUgJSVkaWFsZWN0JSUgYGBcImNuXCJgYCBvciBgYFwidHdcImBgIGZvciBzaW1wbGlmaWVkIG9yXG4gICAgICogIHRyYWRpdGlvbmFsLCByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KGRpYWxlY3QpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0c1tkaWFsZWN0XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdHNbZGlhbGVjdF0gPSBuZXcgTGFuZ1poKGRpYWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdHNbZGlhbGVjdF07XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nWmggPSBMYW5nWmg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLXpoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gVXNlIHRoZSBlbmNvZGUtbGF0aW4uanMgc2NyaXB0IHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5XG4vLyBkYXRhIGZpbGVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoaXMgY2xhc3Ncbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29yZGxpc3RPd2wgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgZGVjb2RlX293bF9qc18xID0gcmVxdWlyZShcIi4vZGVjb2RlLW93bC5qc1wiKTtcbmNvbnN0IHdvcmRsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC5qc1wiKTtcbi8qKlxuICogIEFuIE9XTCBmb3JtYXQgV29yZGxpc3QgaXMgYW4gZW5jb2RpbmcgbWV0aG9kIHRoYXQgZXhwbG9pdHNcbiAqICB0aGUgZ2VuZXJhbCBsb2NhbGl0eSBvZiBhbHBoYWJldGljYWxseSBzb3J0ZWQgd29yZHMgdG9cbiAqICBhY2hpZXZlIGEgc2ltcGxlIGJ1dCBlZmZlY3RpdmUgbWVhbnMgb2YgY29tcHJlc3Npb24uXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgdG8gbW9zdCBkZXZlbG9wZXJzIGFzXG4gKiAgaXQgaXMgdXNlZCBtYWlubHkgaW50ZXJuYWxseSB0byBrZWVwIFdvcmRsaXN0cyBmb3IgbGFuZ3VhZ2VzXG4gKiAgYmFzZWQgb24gQVNDSUktNyBzbWFsbC5cbiAqXG4gKiAgSWYgbmVjZXNzYXJ5LCB0aGVyZSBhcmUgdG9vbHMgd2l0aGluIHRoZSBgYGdlbmVyYXRpb24vYGAgZm9sZGVyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqL1xuY2xhc3MgV29yZGxpc3RPd2wgZXh0ZW5kcyB3b3JkbGlzdF9qc18xLldvcmRsaXN0IHtcbiAgICAjZGF0YTtcbiAgICAjY2hlY2tzdW07XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgZm9yICUlbG9jYWxlJSUgdXNpbmcgdGhlIE9XTCAlJWRhdGElJVxuICAgICAqICBhbmQgdmFsaWRhdGVkIGFnYWluc3QgdGhlICUlY2hlY2tzdW0lJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRhdGEsIGNoZWNrc3VtKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLiNjaGVja3N1bSA9IGNoZWNrc3VtO1xuICAgICAgICB0aGlzLiN3b3JkcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgT1dMLWVuY29kZWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgX2RhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSBhbGwgdGhlIHdvcmRzIGZvciB0aGUgd29yZGxpc3QuXG4gICAgICovXG4gICAgX2RlY29kZVdvcmRzKCkge1xuICAgICAgICByZXR1cm4gKDAsIGRlY29kZV9vd2xfanNfMS5kZWNvZGVPd2wpKHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICAjd29yZHM7XG4gICAgI2xvYWRXb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3dvcmRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy5fZGVjb2RlV29yZHMoKTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18xLmlkKSh3b3Jkcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gdGhpcy4jY2hlY2tzdW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJJUDM5IFdvcmRsaXN0IGZvciAke3RoaXMubG9jYWxlfSBGQUlMRURgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiN3b3JkcyA9IHdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3b3JkcztcbiAgICB9XG4gICAgZ2V0V29yZChpbmRleCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuI2xvYWRXb3JkcygpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xvYWRXb3JkcygpLmluZGV4T2Yod29yZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xb3JkbGlzdE93bCA9IFdvcmRsaXN0T3dsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3Qtb3dsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bC5qc1wiKTtcbmNvbnN0IGRlY29kZV9vd2xhX2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGUtb3dsYS5qc1wiKTtcbi8qKlxuICogIEFuIE9XTC1BIGZvcm1hdCBXb3JkbGlzdCBleHRlbmRzIHRoZSBPV0wgZm9ybWF0IHRvIGFkZCBhblxuICogIG92ZXJsYXkgb250byBhbiBPV0wgZm9ybWF0IFdvcmRsaXN0IHRvIHN1cHBvcnQgZGlhY3JpdGljXG4gKiAgbWFya3MuXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgdG8gbW9zdCBkZXZlbG9wZXJzIGFzXG4gKiAgaXQgaXMgdXNlZCBtYWlubHkgaW50ZXJuYWxseSB0byBrZWVwIFdvcmRsaXN0cyBmb3IgbGFuZ3VhZ2VzXG4gKiAgYmFzZWQgb24gbGF0aW4tMSBzbWFsbC5cbiAqXG4gKiAgSWYgbmVjZXNzYXJ5LCB0aGVyZSBhcmUgdG9vbHMgd2l0aGluIHRoZSBgYGdlbmVyYXRpb24vYGAgZm9sZGVyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqL1xuY2xhc3MgV29yZGxpc3RPd2xBIGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgICNhY2NlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgZm9yICUlbG9jYWxlJSUgdXNpbmcgdGhlIE9XTEEgJSVkYXRhJSVcbiAgICAgKiAgYW5kICUlYWNjZW50JSUgZGF0YSBhbmQgdmFsaWRhdGVkIGFnYWluc3QgdGhlICUlY2hlY2tzdW0lJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRhdGEsIGFjY2VudCwgY2hlY2tzdW0pIHtcbiAgICAgICAgc3VwZXIobG9jYWxlLCBkYXRhLCBjaGVja3N1bSk7XG4gICAgICAgIHRoaXMuI2FjY2VudCA9IGFjY2VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBPV0xBLWVuY29kZWQgYWNjZW50IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IF9hY2NlbnQoKSB7IHJldHVybiB0aGlzLiNhY2NlbnQ7IH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIGFsbCB0aGUgd29yZHMgZm9yIHRoZSB3b3JkbGlzdC5cbiAgICAgKi9cbiAgICBfZGVjb2RlV29yZHMoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZGVjb2RlX293bGFfanNfMS5kZWNvZGVPd2xBKSh0aGlzLl9kYXRhLCB0aGlzLl9hY2NlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3RPd2xBID0gV29yZGxpc3RPd2xBO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3Qtb3dsYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29yZGxpc3QgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBsYW5ndWFnZS1zcGVjaWZpY1xuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuY2xhc3MgV29yZGxpc3Qge1xuICAgIGxvY2FsZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBNVVNUIGNhbGwgdGhpcyBpZiB0aGV5IHByb3ZpZGUgdGhlaXIgb3duIGNvbnN0cnVjdG9yLFxuICAgICAqICBwYXNzaW5nIGluIHRoZSBsb2NhbGUgc3RyaW5nIG9mIHRoZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqICBHZW5lcmFsbHkgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgV29yZGxpc3QsXG4gICAgICogIHNpbmNlIGVhY2ggbGFuZ3VhZ2Utc3BlY2lmaWMgV29yZGxpc3QgY3JlYXRlcyBhbiBpbnN0YW5jZSBhbmRcbiAgICAgKiAgdGhlcmUgaXMgbm8gc3RhdGUga2VwdCBpbnRlcm5hbGx5LCBzbyB0aGV5IGFyZSBzYWZlIHRvIHNoYXJlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGxvY2FsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIHNwbGl0aW5nICUlcGhyYXNlJSUgaW50byBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxuICAgICAqICB3aGl0ZS1zcGFjZSBhcyBkZWZpbmVkIGJ5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgKGkuZS4gYGAvXFxzKy9gYCkuXG4gICAgICovXG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBwaHJhc2UudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGVyIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUld29yZHMlJSBhcmUgam9pbmVkIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICAgICAqL1xuICAgIGpvaW4od29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3QgPSBXb3JkbGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53b3JkbGlzdHMgPSB2b2lkIDA7XG5jb25zdCBsYW5nX2N6X2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWN6LmpzXCIpO1xuY29uc3QgbGFuZ19lbl9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1lbi5qc1wiKTtcbmNvbnN0IGxhbmdfZXNfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctZXMuanNcIik7XG5jb25zdCBsYW5nX2ZyX2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWZyLmpzXCIpO1xuY29uc3QgbGFuZ19qYV9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1qYS5qc1wiKTtcbmNvbnN0IGxhbmdfa29fanNfMSA9IHJlcXVpcmUoXCIuL2xhbmcta28uanNcIik7XG5jb25zdCBsYW5nX2l0X2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWl0LmpzXCIpO1xuY29uc3QgbGFuZ19wdF9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1wdC5qc1wiKTtcbmNvbnN0IGxhbmdfemhfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctemguanNcIik7XG4vKipcbiAqICBUaGUgYXZhaWxhYmxlIFdvcmRsaXN0cyBieSB0aGVpclxuICogIFtJU08gNjM5LTEgTGFuZ3VhZ2UgQ29kZV0obGluay13aWtpLWlzbzYzOSkuXG4gKlxuICogICgqKmkuZS4qKiBbY3pdKExhbmdDeiksIFtlbl0oTGFuZ0VuKSwgW2VzXShMYW5nRXMpLCBbZnJdKExhbmdGciksXG4gKiAgW2phXShMYW5nSmEpLCBba29dKExhbmdLbyksIFtpdF0oTGFuZ0l0KSwgW3B0XShMYW5nUHQpLFxuICogIFt6aF9jbl0oTGFuZ1poKSwgW3poX3R3XShMYW5nWmgpKVxuICpcbiAqICBUaGUgZGlzdCBmaWxlcyAoaW4gdGhlIGBgL2Rpc3RgYCBmb2xkZXIpIGhhdmUgaGFkIGFsbCBsYW5ndWFnZXNcbiAqICBleGNlcHQgRW5nbGlzaCBzdHJpcHBlZCBvdXQsIHdoaWNoIHJlZHVjZXMgdGhlIGxpYnJhcnkgc2l6ZSBieVxuICogIGFib3V0IDgwa2IuIElmIHJlcXVpcmVkLCB0aGV5IGFyZSBhdmFpbGFibGUgYnkgaW1wb3J0aW5nIHRoZVxuICogIGluY2x1ZGVkIGBgd29yZGxpc3RzLWV4dHJhLm1pbi5qc2BgIGZpbGUuXG4gKi9cbmV4cG9ydHMud29yZGxpc3RzID0ge1xuICAgIGN6OiBsYW5nX2N6X2pzXzEuTGFuZ0N6LndvcmRsaXN0KCksXG4gICAgZW46IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKSxcbiAgICBlczogbGFuZ19lc19qc18xLkxhbmdFcy53b3JkbGlzdCgpLFxuICAgIGZyOiBsYW5nX2ZyX2pzXzEuTGFuZ0ZyLndvcmRsaXN0KCksXG4gICAgaXQ6IGxhbmdfaXRfanNfMS5MYW5nSXQud29yZGxpc3QoKSxcbiAgICBwdDogbGFuZ19wdF9qc18xLkxhbmdQdC53b3JkbGlzdCgpLFxuICAgIGphOiBsYW5nX2phX2pzXzEuTGFuZ0phLndvcmRsaXN0KCksXG4gICAga286IGxhbmdfa29fanNfMS5MYW5nS28ud29yZGxpc3QoKSxcbiAgICB6aF9jbjogbGFuZ196aF9qc18xLkxhbmdaaC53b3JkbGlzdChcImNuXCIpLFxuICAgIHpoX3R3OiBsYW5nX3poX2pzXzEuTGFuZ1poLndvcmRsaXN0KFwidHdcIiksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3RzLmpzLm1hcCIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=